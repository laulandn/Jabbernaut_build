/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZArray.cpp			-- the basic container class object******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZArray.h"#include	"MacZoop.h"#include	<stdlib.h>#if _USE_URANDOMLIB#include	"URandomLib.h"#endifstatic short	vCompareFunc( void* a, void* b, const long ref = 0 );static short	vScrambleFunc( void* a, void* b, const long ref = 0 );CLASSCONSTRUCTOR( ZArray );/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZArray::ZArray( unsigned long elementSize )	: ZComrade(){	classID = CLASS_ZArray;		blkSize = elementSize;	numElements = 0;	physicalBlks = kNumPhysicalBlockAlloc;		FailNIL( a = NewHandleClear( elementSize * physicalBlks ));}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZArray::ZArray( ZArray* copyThis )	: ZComrade(){	classID = CLASS_ZArray;	FailNILParam( copyThis );	a = NULL;	Copy( copyThis );}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZArray::~ZArray(){	if (a)		DisposeHandle( a );}/*--------------------------------***  operator[]  ***----------------------------------*//*	return or set a value at the given index using the usual array notation(only used to get and set, cannot be used for append, etc).WARNING: do not rely on the return value across calls that may move memory----------------------------------------------------------------------------------------*/void*	ZArray::operator[]( const long index ){	if ( index < 1 || index > numElements )		FailOSErr( kIndexOutOfRangeErr );			return ( *a + ( blkSize * ( index - 1 )));	}/*---------------------------------***  InsertItem  ***---------------------------------*//*access:			public	overrides:description: 	insert data into the arrayins: 			<item> pointer to whatever data you wish to store				<index> position at which to insert it (1..n)outs: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZArray::InsertItem( void* item, const long index ){	// insert the item into the array at position <index>. The value of <index> is one-based.	// This extends the array by one item.		InsertElement( index - 1 );	SetArrayItem( item, index );		SendMessage( msgArrayItemInserted, (void*) index );}/*---------------------------------***  AppendItem  ***---------------------------------*//*access:			public	overrides:description: 	append data to the end of the arrayins: 			<item> pointer to whatever data you wish to storeouts: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZArray::AppendItem( void* item ){	// adds the item to the end of the array. This grows it by one item.		InsertElement( numElements );	SetArrayItem( item, numElements );		SendMessage( msgArrayItemAdded, (void*) numElements );}/*--------------------------------***  SetArrayItem  ***--------------------------------*//*access:			public	overrides:description: 	set data (replace) item in the arrayins: 			<item> pointer to whatever data you wish to store				<index> position at which data is storedouts: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZArray::SetArrayItem( void* item, const long index ){	// sets the item into the array at <index>, which is one-based.		ASSERT( "Index out of range; ZArray::SetArrayItem",  index >= 0 && index <= numElements, index )				BlockMoveData(item, (*a + (blkSize * (index - 1))), blkSize);		SendMessage( msgArrayItemChanged, (void*) index );}/*--------------------------------***  GetArrayItem  ***--------------------------------*//*access:			public	overrides:description: 	return a copy of data stored in the arrayins: 			<item> pointer to storage buffer of sufficient size				<index> position from which data is copiedouts: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZArray::GetArrayItem( void* item, const long index ){	// gets the item at poition <index> in the array. Index is one-based.		ASSERT( "Index out of range; ZArray::GetArrayItem",  index >= 0 && index <= numElements, index )				BlockMoveData((*a + (blkSize * (index - 1))), item, blkSize);}/*-----------------------------***  ConcatenateArray  ***-------------------------------*//*access:			public	overrides:description: 	append a copy of the data in the array passed to this oneins: 			<anArray> append data from this arrayouts: 			nonenotes:			source array unaffected - any sort order is not preserved.----------------------------------------------------------------------------------------*/void	ZArray::ConcatenateArray( ZArray* anArray ){	long	appendedItems;	long	physExtent;		FailNILParam( anArray );		// check element sizes are compatible:		ASSERT( "Block sizes don't match; ZArray::ConcatentateArray", anArray->blkSize == blkSize, blkSize )		// is there anything to copy?		if (( appendedItems = anArray->CountItems()) > 0 )	{		// extend our handle to accommodate the additional stuff. Note that since we allocate		// in multiples of a physical block count, we need to take this into account when		// joining the arrays				physExtent = appendedItems + numElements;		physExtent += kNumPhysicalBlockAlloc - ( physExtent % kNumPhysicalBlockAlloc );				if ( physExtent > physicalBlks )		{			physicalBlks = physExtent;						SetHandleSize( a, physicalBlks * blkSize );			FailMemError();		}				Ptr p = *anArray->a;		Ptr	q = *a + ( numElements * blkSize );				BlockMoveData( p, q, appendedItems * blkSize );				numElements += appendedItems;	}}/*------------------------------------***  Copy  ***------------------------------------*//*access:			public	overrides:description: 	copy an array into this one, replacing any existing contentins: 			<anArray> copy data from this arrayouts: 			nonenotes:			may change datasize and element count of this array -				source array unaffected----------------------------------------------------------------------------------------*/void	ZArray::Copy( ZArray* anArray ){	FailNILParam( anArray );		if ( a )		DisposeHandle( a );		a = anArray->a;		FailOSErr( HandToHand( &a ));		numElements = anArray->numElements;	blkSize = anArray->blkSize;	physicalBlks = anArray->physicalBlks;}/*---------------------------------***  FindIndex  ***----------------------------------*//*access:			public	overrides:description: 	search for a data item in the arrayins: 			<item> pointer to data to locateouts: 			index position of the data in the array, or 0 (not found)notes:			performs a linear search - finds first occurrence----------------------------------------------------------------------------------------*/long	ZArray::FindIndex(void* item){	// performs a linear search and returns the index of the item, if found.		if ( numElements < 1 )		return 0;			long		i = 0;	Boolean		found = FALSE;		do	{		if (EqualMem(*a + ( blkSize * i ), item, blkSize))		{			found = TRUE;			break;		}	}	while( i++ < numElements );	return ( found? i + 1 : 0 );}/*--------------------------------***  DeleteItem  ***----------------------------------*//*access:			public	overrides:description: 	delete an item from the arrayins: 			<index> position of data to deleteouts: 			nonenotes:			items following deleted index will have a new index value----------------------------------------------------------------------------------------*/void	ZArray::DeleteItem( const long index ){	// deletes the item at position <index> (1-based). Items above are moved down one.		DeleteElement( index - 1 );		SendMessage( msgArrayItemDeleted, (void*) index );}/*---------------------------------***  DeleteAll  ***----------------------------------*//*access:			public	overrides:description: 	delete all data from the arrayins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::DeleteAll(){	numElements = 0;	physicalBlks = kNumPhysicalBlockAlloc;		SetHandleSize( a, blkSize * physicalBlks );		SendMessage( msgArrayAllDeleted, NULL );}/*----------------------------------***  MoveItem  ***----------------------------------*//*access:			public	overrides:description: 	move an item from one index to anotherins: 			<curIndex> the index at which the data item to move is found				<newIndex> the index to which the data item should be movedouts: 			nonenotes:			will cause renumbering of other items as needed----------------------------------------------------------------------------------------*/void	ZArray::MoveItem( const long curIndex, const long newIndex ){	// moves the item at <curIndex> to position <newIndex> (all 1-based), moving other items	// as needed to keep things in order.		ASSERT( "Bad index; ZArray::MoveItem", curIndex > 0 && curIndex <= numElements && newIndex > 0 && newIndex <= numElements, 0 )		void* temp = (void*) NewPtr( blkSize );		FailNIL(temp);		// copy the item we want to move to a temporary space		GetArrayItem( temp, curIndex);		// delete its current position, which will move stuff as needed		DeleteElement( curIndex - 1 );		// insert it into the new position, which moves other stuff as needed		InsertItem( temp, newIndex );		// get rid of the temporary space		DisposePtr((Ptr) temp);	SendMessage( msgArrayItemMoved, (void*) newIndex );}/*------------------------------------***  Swap  ***-----------------------------------*//*access:			public	overrides:description: 	exchange two data itemsins: 			<itema, itemb> index values of data items to exchangeouts: 			nonenotes:			no other items will be affected----------------------------------------------------------------------------------------*/void	ZArray::Swap( const long itema, const long itemb ){	// swaps items a and b.	ASSERT( "Bad index; ZArray::Swap", itema > 0 && itema <= numElements && itemb > 0 && itemb <= numElements, 0 )		// make some swap space		void* tempa = (void*) NewPtr( blkSize );	void* tempb = (void*) NewPtr( blkSize );	FailNIL(tempa);	FailNIL(tempb);		GetArrayItem( tempa, itema);	GetArrayItem( tempb, itemb);	SetArrayItem( tempa, itemb);	SetArrayItem( tempb, itema);		DisposePtr((Ptr) tempa);	DisposePtr((Ptr) tempb);		long	inf[2] = { itema, itemb };		SendMessage( msgArrayItemMoved, (void*) &inf );}/*---------------------------------***  CountItems  ***---------------------------------*//*access:			public	overrides:description: 	query the number of items storedins: 			noneouts: 			number of items in the arraynotes:			----------------------------------------------------------------------------------------*/long	ZArray::CountItems(){	return numElements;}/*----------------------------------***  DoForEach  ***---------------------------------*//*access:			public	overrides:description: 	pass each array element to a supplied function in turnins: 			<aProc> the function that will be called with each data item				<ref> this value is also passed to the function verbatimouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::DoForEach( IteratorProcPtr aProc, const long ref ){	if (aProc && (numElements > 0))	{		long	i = numElements;		void*	temp = (void*) NewPtr( blkSize );				FailNIL( temp );				while ( i )		{			GetArrayItem( temp, i);			(*aProc)(temp, ref);						// in case the proc changed the item, set it back						SetArrayItem( temp, i--);		}				DisposePtr((Ptr) temp);	}}/*------------------------------------***  Sort  ***------------------------------------*//*access:			public	overrides:description: 	sort the array into order based on the comparison function suppliedins: 			<compareProc> the function that will compare the data items passed to it				<ref> this value is also passed to the function verbatimouts: 			nonenotes:			The comparison function may compare any aspect of the data it likes, and				return 1, 0 or -1 to indicate the relative ordering. The sort algorithm				used here is a shellsort.----------------------------------------------------------------------------------------*/void	ZArray::Sort( register SortCmpProcPtr compareProc, register const long ref ){	register long	E,N,M,J,K,R;	register short	cp;		register void*	itema;	register void*	itemb;		// sanity check- there IS a comparison function, right?		FailOSErr((compareProc == NULL)? kUndefinedCompProcErr : noErr );		// allocate some temporary storage		FailNIL(itema = (void*) NewPtr( blkSize ));	FailNIL(itemb = (void*) NewPtr( blkSize ));		// initialise the control variables to the number of elements in the list		M = E = N = numElements;	N++;		// and... sort!		do	{		M >>= 1;	// divide by 2				if (M <= 0)			break;					K = E - M;		J = 1;				do		{			N = J;			do			{				R = N + M;				GetArrayItem( itema, N );						// get first item				GetArrayItem( itemb, R );						// get second item								cp = (*compareProc)( itema, itemb, ref );		// call the comparison function								if ( cp < 1 )									// no need to swap (a <= b)					break;									Swap( N, R );									// swap items in the array									N -= M;			}			while ( N > 0 );			J++;		}		while (J <= K);	}	while( M > 0 );		// all done, now release the temporary storage		DisposePtr((Ptr) itema);	DisposePtr((Ptr) itemb);}/*------------------------------------***  Sort  ***------------------------------------*//*access:			public	overrides:description: 	sort the array into order based on a callback functionins: 			noneouts: 			nonenotes:			this may be used if you are subclassing ZArray and override Compare.----------------------------------------------------------------------------------------*/void	ZArray::Sort(){	Sort( vCompareFunc, (long) this );}/*-----------------------------------***  QSort  ***------------------------------------*//*access:			public	overrides:description: 	sort the array into order based on the comparison function suppliedins: 			<compareProc> comparison functionouts: 			nonenotes:			this uses Std C qsort algorithm, which can be faster, but more limited				comparison function here means less flexible than above.----------------------------------------------------------------------------------------*/void	ZArray::QSort( QSortProcPtr compareProc ){#if __powerc	char	hs = HGetState( a );		HLock( a );			qsort( *a, numElements, blkSize, compareProc );		HSetState( a, hs );#else	Sort((SortCmpProcPtr) compareProc, 0 );	#endif}/*----------------------------------***  Compare  ***-----------------------------------*//*access:			public	overrides:description: 	compare two data items and decide what order they're inins: 			<itema, itemb> pointers ot data to compare				<ref> reference value passed inouts: 			0notes:			normally overridden to make use of Sort() method with no parameters----------------------------------------------------------------------------------------*/short	ZArray::Compare( void* itema, void* itemb, const long ref ){	return 0;}/*---------------------------------***  Randomise  ***----------------------------------*//*access:			public	overrides:description: 	randomise the order of items in the arrayins: 			noneouts: 			nonenotes:			operates by sorting items based on a random number.----------------------------------------------------------------------------------------*/void	ZArray::Randomise(){	Sort( vScrambleFunc, 0 );}/*-----------------------------***  InsertSortedItem  ***-------------------------------*//*access:			public	overrides:description: 	insert data into a sorted array in the correct positionins: 			<item> pointer to item data to insert				<compareProc> the comparison function used for sorting the data				<ref> value passed to comparison functionouts: 			index position at which item was insertednotes:			----------------------------------------------------------------------------------------*/long	ZArray::InsertSortedItem( void* item, SortCmpProcPtr compareProc, const long ref ){	FailNILParam( compareProc );		short	rel;	long	pos = BFindIndex( item, compareProc, ref );	void*	itemB;		// <pos> represents the NEAREST item, but we don't know if we need to insert	// before or after this item, so we need to do one more compare		if ( pos > 0 )	{		FailNIL( itemB = (void*) NewPtr( blkSize ));				GetArrayItem( itemB, pos );				rel = (*compareProc)( item, itemB, ref );				DisposePtr((Ptr) itemB );				if ( rel > 0 )			pos++;	}			if (( pos > numElements ) || ( pos == 0 ))	{		AppendItem( item );		pos = numElements;	}	else		InsertItem( item, pos );			return pos;}/*-----------------------------***  InsertSortedItem  ***-------------------------------*//*access:			public	overrides:description: 	insert data into a sorted array in the correct positionins: 			<item> pointer to item data to insert				<ref> value passed to comparison functionouts: 			index position at which item was insertednotes:			relies on a valid override to Compare()----------------------------------------------------------------------------------------*/long	ZArray::InsertSortedItem( void* item, const long ref ){	return InsertSortedItem( item, vCompareFunc, ref );}/*-------------------------------***  InsertElement  ***--------------------------------*//*access:			protected	overrides:description: 	make space for storing a new data itemins: 			<index> where to open up the spaceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::InsertElement( const long index ){	// grow the handle by one element, moving items above <index> up one. This also	// sets the numElements data member. Index is zero-based.		long	newSize;		// check that the index parameter is sensible		ASSERT( "Index out of range; ZArray::InsertElement",  index >= 0 && index <= numElements, index )		// grow the handle if the number of physical blocks is insufficient		newSize = ( numElements + 1 ) * blkSize;		if ( newSize > ( physicalBlks * blkSize ))	{		physicalBlks += kNumPhysicalBlockAlloc;				SetHandleSize( a, physicalBlks * blkSize );		FailOSErr(MemError());	}		// OK, the handle is now larger by one element- do we need to move any data around?		if (index < numElements)	{		// yes, subsequent entries move up by <blkSize> bytes				HLock( a );		BlockMoveData(	*a + (blkSize * index),						*a + (blkSize * (index + 1)),						blkSize * (numElements - index));		HUnlock( a );	}		// increment the count of elements		numElements++;}/*-------------------------------***  DeleteElement  ***--------------------------------*//*access:			protected	overrides:description: 	recover space from a single data itemins: 			<index> where to close up the spaceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::DeleteElement( const long index ){	// shrink the handle by one element, after moving entries above <index> down by one.	// <index> is zero-based.		// check that the index parameter is sensible		ASSERT( "Index out of range; ZArray::DeleteElement",  index >= 0 && index < numElements, index )				// one less element		numElements--;			// if the index is not the last item, move everything down to fill the space		if (index < numElements)	{		HLock( a );		BlockMoveData(	*a + (blkSize * (index + 1)),						*a + (blkSize * index),						blkSize * (numElements - index));		HUnlock( a );	}		// shrink the handle if we can remove a whole multiple of physical blocks		if (( physicalBlks - numElements ) > kNumPhysicalBlockAlloc )	{		physicalBlks = MAX( 0, physicalBlks - kNumPhysicalBlockAlloc );		SetHandleSize( a, blkSize * physicalBlks );	}}/*--------------------------------***  BFindIndex  ***----------------------------------*//*access:			public	overrides:description: 	find data in a sorted arrayins: 			<item> pointer to data to search for				<compareProc> the comparison function employed to determine sort order				<ref> value passed to comparison function verbatimouts: 			index position of located data, or 0 (not found)notes:			uses binary search to locate data very quickly as long as array is sorted----------------------------------------------------------------------------------------*/long	ZArray::BFindIndex( void* item, SortCmpProcPtr compareProc, const long ref ){	unsigned long	lowItem, highItem, midItem, pos = 1;	short			compare;	void*			itemB;		FailNILParam( compareProc );		lowItem = 1;	highItem = numElements;		// if the list is empty, we return item 1, since we can simply append the item.		if ( numElements < 1 )		pos = 0;	else	{		// make space for the item we are going to compare				FailNIL( itemB = (void*) NewPtr( blkSize ));				while ( lowItem <= highItem )		{			midItem = ( highItem + lowItem ) >> 1;						GetArrayItem( itemB, midItem );						// compare this item to the one we are looking for						compare = (*compareProc)( item, itemB, ref );						// if an exact match, then insert right here						if ( compare == 0 )				break;							// otherwise search half the list						if ( compare > 0 )				lowItem = midItem + 1;			else				highItem = midItem - 1;		}				DisposePtr((Ptr) itemB );		pos = MAX( midItem, 1 );	}		return pos;}long	ZArray::BFindIndex( void* item, const long ref ){	return BFindIndex( item, vCompareFunc, ref );}/*------------------------------***  ReadFromStream  ***--------------------------------*//*access:			public	overrides:description: 	recreate array from a streamins: 			<aStream> stream to read fromouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::ReadFromStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZComrade::ReadFromStream( aStream );		// read array data items from the stream. First item is block size, then count.		aStream->ReadLong((long*) &blkSize );	aStream->ReadLong((long*) &numElements );		// if num elements is not 0, read data into array's storage handle		if ( numElements > 0 )	{		if ( a )			DisposeHandle( a );				aStream->ReadHandle( &a );				// the number of phyical blocks needs to be adjusted to this size.		// We do not bother rounding this up to a whole multiple of		// the physical block count- it'll work anyway.				physicalBlks = GetHandleSize( a ) / blkSize;	}#endif}/*-------------------------------***  WriteToStream  ***--------------------------------*//*access:			public	overrides:description: 	write array to a streamins: 			<aStream> stream to write toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::WriteToStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZComrade::WriteToStream( aStream );		// write all the array items to the stream.		long	numItems;		numItems = CountItems();		// first two items in stream are block size and item count		aStream->WriteLong( blkSize );	aStream->WriteLong( numItems );		// ...followed by the data:		if ( numItems > 0 )		aStream->WriteHandle( a );#endif}/*------------------------------***  AppendToHandle  ***--------------------------------*//*access:			public	overrides:description: 	append array raw data to an existing handleins: 			<aHand> valid handle to append data toouts: 			nonenotes:			this is used for special purposes - not normally for app use.----------------------------------------------------------------------------------------*/void	ZArray::AppendToHandle( Handle aHand ){	FailNILParam( aHand );	FailOSErr( HandAndHand( a, aHand ));}/*----------------------------***  GetDebugInfoString  ***------------------------------*//*access:			public	overrides:description: 	return some basic info to the inspectorins: 			<s> string receives the data to displayouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::GetDebugInfoString( Str255 s ){	Str15 ss;		NumToString( numElements, s );	NumToString( blkSize, ss );	ConcatPStrings( s, "\p x " );	ConcatPStrings( s, ss );	ConcatPStrings( s, "\p bytes, (" );	NumToString( GetHandleSize( a ), ss );	ConcatPStrings( s, ss );	ConcatPStrings( s, "\p physical bytes)" );}/*-------------------------------***  ReportFields  ***--------------------------------*//*access:			public	overrides:description: 	return data member info to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZArray::ReportFields(){	ZComrade::ReportFields();		XSHOWFIELD( a, ft_Handle );	XSHOWFIELD( blkSize, ft_unsignedlong );	XSHOWFIELD( numElements, ft_unsignedlong );	XSHOWFIELD( physicalBlks, ft_unsignedlong );}#pragma mark -/*--------------------------------***  vCompareFunc  ***--------------------------------*//*access:			static global	overrides:description: 	reflex callback for when Sort() is usedins: 			<a, b> data passed				<ref> ref valueouts: 			nonenotes:			----------------------------------------------------------------------------------------*/static short	vCompareFunc( void* a, void* b, const long ref){	ZArray*		theArray = (ZArray*) ref;		if ( theArray )		return theArray->Compare( a, b, ref );		else		return 0;}/*-------------------------------***  vScrambleFunc  ***--------------------------------*//*access:			static global	overrides:description: 	comparison function used to implement Randomise()ins: 			<a, b> data passed				<ref> ref valueouts: 			nonenotes:			----------------------------------------------------------------------------------------*/static short	vScrambleFunc( void* a, void* b, const long ref ){#if _USE_URANDOMLIB	short 	r = PRNG.UShort7();#else	short	r = Random();#endif	return ( ABS( r ) % 3 ) - 1;}