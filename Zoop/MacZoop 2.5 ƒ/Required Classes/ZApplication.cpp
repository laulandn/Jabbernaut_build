/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZApplication.cpp	-- the application object******			© 1996, Graham Cox*****************************************************************************************************/#include	"MacZoop.h"#include	"ZEventHandler.h"#include	"ZWindow.h"#include	"ZUndoTask.h"#include	"ZChore.h"#include	"MZCustomViewFunctions.h"#ifdef		USER_DEFAULT_WINDOW_TYPE	#include	HEADER( USER_DEFAULT_WINDOW_TYPE )#endif#if PRINTING_ON	#include	<printing.h>	#include	"ZPrinter.h"#endif#include	<resources.h>#include	<StandardFile.h>#include	<Notification.h>#include	<dialogs.h>// required for MPW/Symantec:#if	!defined( __MWERKS__ )	QDGlobals	QDGLOBALS;#endif#ifndef NUMBER_OF_INITIAL_UNDO_LEVELS#define	NUMBER_OF_INITIAL_UNDO_LEVELS	1#endif// gApplication is the global application object. There is only one, naturally.ZApplication*	gApplication = NULL;// globals inited by this classZWindowManager*	gWindowManager = NULL;		// window manager objectZMenuBar*		gMenuBar = NULL;			// the main menubar objectOSType			gAppSignature;				// the application's signature, obtained from 'BNDL', etc.	tMacInfo		gMacInfo;					// common gestalt resultsRgnHandle		gUtilRgn = NULL;			// general purpose region, handy as temp variable. Do NOT dispose!ZPrefsFile*		gPrefsFile = NULL;			// NOT inited unless your application subclass does it!OSErr			gDragErr = noErr;			// Set if Drag/Drop produced an error// a set of useful colours, available as global RGBColor recordsconst RGBColor	gWhite 			= {  0xFFFF, 0xFFFF, 0xFFFF };	// white RGB colourconst RGBColor	gBlack 			= {  0x0000, 0x0000, 0x0000 };	// black RGB colourconst RGBColor	gVeryLightGray 	= {  0xEEEE, 0xEEEE, 0xEEEE };	// the lightest grayconst RGBColor	gLightGray 		= {  0xDDDD, 0xDDDD, 0xDDDD };	// light gray RGB colourconst RGBColor	gMediumGray 	= {  0xCCCC, 0xCCCC, 0xCCCC };	// medium light greyconst RGBColor	gMidGray 		= {  0x7F7F, 0x7F7F, 0x7F7F };	// middle gray RGB colourconst RGBColor	gDarkGray 		= {  0x5555, 0x5555, 0x5555 };	// dark gray RGB colourconst RGBColor	gRed			= {  0xFFFF, 0x0000, 0x0000 };	// solid red RGB colourconst RGBColor	gGreen			= {  0x0000, 0xFFFF, 0x0000 };	// solid green RGB colourconst RGBColor	gBlue			= {  0x0000, 0x0000, 0xFFFF };	// solid blue RGB colourconst RGBColor	gCyan			= {  0x0000, 0xFFFF, 0xFFFF };	// solid cyan RGB colourconst RGBColor	gMagenta		= {  0xFFFF, 0x0000, 0xFFFF };	// solid magenta RGB colourconst RGBColor	gYellow			= {  0xFFFF, 0xFFFF, 0x0000 };	// solid yellow RGB colourconst RGBColor	gDarkRed 		= {  0xCCCC, 0x0000, 0x1111 };	// dark redconst RGBColor	gDarkBlue 		= {  0x1111, 0x1111, 0x8888 };	// dark blueconst RGBColor 	gDarkGreen		= {  0x1111, 0x8888, 0x1111 };	// dark greenconst RGBColor	gFeintBlue		= {  0xCCCC, 0xCCCC, 0xFFFF };	// ruled line blueconst RGBColor	gGridColour 	= {  0x9999, 0x9999, 0xEEEE };	// drawing grid mauveconst RGBColor	gStraw 			= {  0xFFFF, 0xFFFF, 0xAAAA };	// a light yellow// platinum hilite colours - see also MacZoopGlobals.hconst RGBColor	gGrayFrameInactive		= { 0x8888, 0x8888, 0x8888 };const RGBColor	gGrayFacePressed		= { 0x6666, 0x6666, 0x6666 };const RGBColor	gGrayDarkShadow			= { 0x7777, 0x7777, 0x7777 };const RGBColor	gGrayLightShadow		= { 0x9999, 0x9999, 0x9999 };const RGBColor	gGrayDarkShadowPressed	= { 0x4444, 0x4444, 0x4444 };// static functions used by the application object#if _USE_NAVIGATION_SERVICESstatic pascal void	ZNavEventCallback( 	NavEventCallbackMessage cbMessage,										NavCBRecPtr	cbParams,										NavCallBackUserData	cbData );NavEventUPP		gNavEventHandler = NewNavEventUPP( ZNavEventCallback );#endifextern void		TimerTimer();extern short	gLastCursorID;#if TARGET_API_MAC_CARBON && MAC_OS_X	#include	<CarbonEvents.h>	EventLoopTimerUPP	gCarbonTimerUPP = NULL;	static pascal void MZCarbonTimerCallback( EventLoopTimerRef inTimer, void *inUserData );#endif// static registry of window creation functionsZClassRegistry*	ZApplication::sWindowClassRegistry = NULL;GrowZoneUPP		ZApplication::sGrowZone = NULL;// note: ZApplication is NEVER instantiated from a stream- to ensure this but keep// special cases out of the class registry, etc, we jig the construction function// to simply return gApplication.ZObject* 	CF_ZApplication(){	return gApplication;}extern ZObject* CF_ZObjectList();/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZApplication::ZApplication()	: ZCommander( NULL ){	long	features;	OSErr	theErr;		classID = CLASS_ZApplication;		FailNIL( gUtilRgn = NewRgn());	done = FALSE;	phase = kInitialising;	zEH = NULL;	itsPrinter = NULL;	splashVisible = FALSE;	separateRedo = FALSE;	msDepth = 0;	fFrontSleep = FRONTSLEEP;	fBackSleep = BACKSLEEP;	fChoreList = NULL;	fDefaultUndos = NUMBER_OF_INITIAL_UNDO_LEVELS;		appResRefNum = CurResFile();		// set initial filetypes list to a zero handle		FailNIL( itsFileTypes = (FTypeListHdl) NewHandleClear( sizeof( FTypeList ) - sizeof( OSType )));			shortageFund = NULL;	memIsShort = FALSE;	userHasSeenAlert = FALSE;		// check to see if we are running on a colour Mac		theErr = Gestalt( gestaltQuickdrawFeatures, &features );	gMacInfo.supportsColour = ((theErr == noErr) && (features & 1));		// check for the drag manager		theErr = Gestalt( gestaltDragMgrAttr, &features );	gMacInfo.hasDragManager = ((theErr == noErr) && (features & 1));		#if __powerc	if ( gMacInfo.hasDragManager )		gMacInfo.hasDragManager = ((long) NewDrag != kUnresolvedCFragSymbolAddress );	#endif		// check for a FPU		theErr = Gestalt( gestaltFPUType, &features );	gMacInfo.hasFPU = ((theErr == noErr) && ((features & 1) == 0));		// check for applescript		theErr = Gestalt( gestaltAppleEventsAttr, &features );	gMacInfo.hasAppleEvents = ((theErr == noErr) && (features & 1));		// check for QuickTimeª		theErr = Gestalt( gestaltQuickTimeVersion, &features );	gMacInfo.hasQuickTime = ((theErr == noErr) && (features > 0));	// check for ICM		theErr = Gestalt( gestaltCompressionMgr, &features );	gMacInfo.hasImgCompressionMgr = (theErr == noErr);	// check for appearance manager	#if APPEARANCE_MGR_AWARE || TARGET_API_MAC_CARBON	theErr = Gestalt( gestaltAppearanceAttr, &features );	gMacInfo.hasAppearanceMgr = (( theErr == noErr ) && ( features & 1 ));		#if __powerc	if ( gMacInfo.hasAppearanceMgr )		gMacInfo.hasAppearanceMgr = ((long)  CreateRootControl != kUnresolvedCFragSymbolAddress );	#endif		// further check the version- we require 1.1 or later...		if ( gMacInfo.hasAppearanceMgr )	{	    theErr = Gestalt( gestaltAppearanceVersion, &features );		    if ( theErr != noErr || features < 0x0110 )	        gMacInfo.hasAppearanceMgr = FALSE;	}#else	gMacInfo.hasAppearanceMgr = FALSE;#endif	// what is the system version?		theErr = Gestalt( gestaltSystemVersion, &features );	gMacInfo.systemVersion = LoWord( features );		// check for navigation services:		#if _USE_NAVIGATION_SERVICES || TARGET_API_MAC_CARBON	if ( gMacInfo.systemVersion >= 0x0755 )		gMacInfo.hasNavigationServices = NavServicesAvailable();	#else		gMacInfo.hasNavigationServices = FALSE;	#endif		// check for contextual menus:		if ( gMacInfo.systemVersion >= 0x0800 )		gMacInfo.hasContextualMenus = TRUE;	else		gMacInfo.hasContextualMenus = FALSE;			// check for 8.5+ Window Manager	#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON	theErr = Gestalt( gestaltWindowMgrAttr, &features );	gMacInfo.hasModernWindowMgr = (( theErr == noErr ) && ( features & 1 ) == 1 );	#if __powerc	if ( gMacInfo.hasModernWindowMgr )		gMacInfo.hasModernWindowMgr = ((long)  SetWindowProxyFSSpec != kUnresolvedCFragSymbolAddress );	#endif#else	gMacInfo.hasModernWindowMgr = FALSE;#endif			// check for Mac OS X. Carbon porting guide currently suggests:	#if TARGET_API_MAC_CARBON		theErr = Gestalt( gestaltMenuMgrAttr, &features );	if (( theErr == noErr ) && ( features & gestaltMenuMgrAquaLayoutMask ))	    gMacInfo.isRealMacOSX = TRUE;	else#endif	    gMacInfo.isRealMacOSX = FALSE;		// initialise the animating cursors, and set the	// animated watch cursor going.		AppCursorInit();	gApplication = this;	#if _MACZOOP_STREAMS	FailNIL( gClasses = new ZClassRegistry());#endif}/*--------------------------------***  DESTRUCTOR  ***---------------------------------*/ZApplication::~ZApplication(){	if ( gMenuBar )			FORGETOBJECT( gMenuBar );		if ( gClipboard )		FORGETOBJECT( gClipboard );		if ( gWindowManager )		FORGETOBJECT( gWindowManager );	#if __ZPREFSFILE__	if ( gPrefsFile )		FORGETOBJECT( gPrefsFile );#endif		if ( zEH )		FORGETOBJECT( zEH );			if ( fChoreList )	{		fChoreList->DisposeAll();		FORGETOBJECT( fChoreList );	}#if PRINTING_ON			if ( itsPrinter )		FORGETOBJECT( itsPrinter );#endif			if ( itsFileTypes )		DisposeHandle((Handle) itsFileTypes);		if ( shortageFund )		DisposeHandle( shortageFund );			DisposeRgn( gUtilRgn );	AppCursorFree();}/*--------------------------------***  InitMacZoop  ***---------------------------------*//*access:			public	overrides:description: 	initialise the basic application object and helpersins: 			<numMasterBlocks> number of master pointer blocks to initially createouts: 			nonenotes:----------------------------------------------------------------------------------------*/void		ZApplication::InitMacZoop( const short numMasterBlocks ){	if ( phase == kInitialising )	{		// init the mac toolbox, memory mangler etc.				RegisterClasses();		InitMacApplication( numMasterBlocks );		// create the memory shortage fund (not Mac OS X - growzone ignored there)				if ( ! gMacInfo.isRealMacOSX )		{			sGrowZone = NewGrowZoneUPP( GrowFunction );						FailNIL( shortageFund = NewHandle( kShortageFundSize ));			SetGrowZone( sGrowZone );		}		SetWatchCursor();				// make the helper objects				MakeHelpers();			// make the clipboard object				MakeClipboard();				// read any prefs that the user may have set up (default does nothing). A typical		// thing to do here is to simply instantiate a ZPrefsFile object and assign it to		// <gPrefsFile>. You may also want to open/read the file! (use of data or resource		// fork is up to you, so ZPrefsFile does not automatically perform the open step).		ReadPrefs();		ShowSplash();				// initialise menubar and make printer object				InitMenuBar();		MakePrinter();				// preload the navigation services if required, to make use of these faster later on.			#if _USE_NAVIGATION_SERVICES		if ( gMacInfo.hasNavigationServices )			FailOSErr( NavLoad());	#endif				// call user-function as last part of initialisation- default		// does nothing but can be overridden to do further set up.		StartUp();		// record depth of main screen		msDepth = GetMainScreenDepth();				// update the menubar- note that this is not drawn until StartUp completes,		// since we allow the programmer the flexibility to use StartUp to create & install		// dynamic menus, etc. if they want.		gMenuBar->UpdateMenuBar();			// the cursor is not reset here- we let the main event loop do that so that if		// events are initially available, the cursor keeps right on animating until		// the user gets a chance to do anything.	}}/*-----------------------------***  InitMacApplication  ***-----------------------------*//*access:			protected	overrides:description: 	initialise the Mac toolbox, also file types listins: 			<numMasterBlocks> number of master pointer blocks to initially createouts: 			nonenotes:			will exit app directly if CheckCanRun fails----------------------------------------------------------------------------------------*/void		ZApplication::InitMacApplication( const short numMasterBlocks ){	// chant the "Macintosh mantra"...	#if !TARGET_API_MAC_CARBON	InitGraf( &qd.thePort );	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs( NULL );#endif		InitCursor();	// clear out the event queue in case any stray clicks or keypresses are left there		FlushEvents( everyEvent, 0 );	// see if the program can run on this Mac- if not, we show an alert and exit straight away		if (! CheckCanRun())	{		StopCursorAnimation();		(void) Alert( kCantRunAlertID, NULL );		ExitToShell();	}		else	{		// give yourself enough memory. For a bigger app, you may need to call MoreMasters a few		// more times. The parameter to this method sets the number of times MoreMasters is		// called, defaulting to 8, which gives 8 x 64 = 512 handles.		#if ! TARGET_API_MAC_CARBON			MaxApplZone();				short n = numMasterBlocks;				while( n-- )			MoreMasters();	#endif					// if we want appearance, register the app (not required under Carbon):			#if APPEARANCE_MGR_AWARE && !TARGET_API_MAC_CARBON				if ( gMacInfo.hasAppearanceMgr )			FailOSErr( RegisterAppearanceClient());		#endif					// set up <gAppSignature>, either from BNDL resource, or from constant according		// to the user's project settings.			#if USE_SIGNATURE_FROM_BNDL				OSType**	bndlHand = (OSType**) GetResource( 'BNDL', 128 );				if ( bndlHand )		{			gAppSignature = **bndlHand;			ReleaseResource((Handle) bndlHand );						#if CHECK_FREF_RESOURCE_TYPES						// first look for an 'open' resource ID=128. If there is one, we use it in			// preference to the FREF's, since there is a slightly different meaning. An 'open'			// resource can be treated as a list of OSTypes if you ignore the first 8 bytes.						bndlHand = (OSType**) GetResource( 'open', 128 );						if ( bndlHand )			{				// we have an 'open' resource, so just copy the data (ignoring first 8 bytes)				// to the file types list. Warning: This technique does not check for duplicates,				// either in the resource or in the types list.								long	bc = GetHandleSize((Handle) bndlHand );								SetHandleSize((Handle) itsFileTypes, bc );				FailMemError();								BlockMoveData((Ptr) *bndlHand, (Ptr) *itsFileTypes, bc );				ReleaseResource((Handle) bndlHand );			}			else			{				// scan the 'FREF' resources and build the <itsFileTypes> list. We do NOT add				// types of 'APPL', 'cdev', 'INIT', or 'rdev'- if you want to display such				// files in the Open dialog, you have to call AddFileType() for these types directly.				// This is a feature to prevent weird behaviour in the typical case.								// how many 'FREF's do we have?								short	i, fc = Count1Resources( 'FREF' );								for( i = 1; i <= fc; i++ )				{					bndlHand = (OSType**) GetIndResource( 'FREF', i );									if ( bndlHand )					{						// check if this is one of our 'forbidden' types:												if ( **bndlHand != 'APPL'	&&							 **bndlHand != 'APPC'	&&							 **bndlHand != 'APPD'	&&							 **bndlHand != 'cdev'	&&							 **bndlHand != 'rdev'	&&							 **bndlHand != 'INIT' )							AddFileType( **bndlHand );												ReleaseResource((Handle) bndlHand );					}				}			}						#endif			}		else			gAppSignature = kUnknownSignature;	#else		gAppSignature = kApplicationSignature;	#endif			(*itsFileTypes)->appSignature = gAppSignature;	}}/*--------------------------------***  CheckCanRun  ***---------------------------------*//*access:			protected	overrides:description: 	check machine and OS environment for compatibility with this appins: 			noneouts: 			nonenotes:			default runs on System 7.0 or later----------------------------------------------------------------------------------------*/Boolean		ZApplication::CheckCanRun(){	// Returning FALSE will cause the program to	// immediately show an alert and quit.		// by default, we can run on any Mac with System 7.0 or later.		return( gMacInfo.systemVersion >= 0x0700 );	}#pragma mark -/*----------------------------------***  GetName  ***-----------------------------------*//*access:			public	overrides:description: 	obtain the name of the applicationins: 			<appName> pascal string to store application name intoouts: 			nonenotes:----------------------------------------------------------------------------------------*/void		ZApplication::GetName( Str255 appName ){	ProcessInfoRec		pInfo;	FSSpec				pSpec;		pInfo.processInfoLength = sizeof( ProcessInfoRec );	pInfo.processName = appName;	pInfo.processAppSpec = &pSpec;		GetProcessInfo( &pInfo );}/*------------------------------------***  Run  ***-------------------------------------*//*access:			public	overrides:description: 	run the show until the user quitsins: 			noneouts: 			nonenotes:			does not return until app quits, called by main - do not call.----------------------------------------------------------------------------------------*/void		ZApplication::Run(){	// runs the show by asking the event object to get events and handle them. This goes on	// forever until done is set to TRUE.		while( !done )	{		try		{			if ( phase == kInitialising )			{				phase = kRunning;				RunFirstTask();			}						// repeatedly get an event, handle an event						Process1Event();						// deal with the memory shortage situation, if one has arisen as			// a result of the last event. This is not done under OS X since			// the growzone proc is never called (nor installed!)						if ( ! gMacInfo.isRealMacOSX )				CheckLowMemory();						// check for a drag error resulting from the last drag (if any)						if ( gDragErr )			{				HandleError( gDragErr );				gDragErr = noErr;			}		}		catch( ZoopError theErr )		{			// if here, an exception was thrown. Deal with the error by calling the			// application's HandleError() method.						StopCursorAnimation();			HandleError( theErr );						// the buck stops here- no exceptions will be thrown beyond this point.		}		catch( OSErr err )		{			// if this happens, revise your code!						DebugStr("\pYour exceptions should throw ZoopError, not OSErr");		}		catch(...)		{			// catch anything that was thrown that is not a ZoopError. This may happen if the runtime			// lib threw an exception for operator new, etc. At least in this case we can try to keep			// running.						StopCursorAnimation();			HandleError( kRuntimeLibException );		}		// stop any animating cursors. This means that a lengthy process need		// only set the cursor going and can then forget about it. When the		// app resumes handling events, it will be automatically cancelled.				StopCursorAnimation();	}		phase = kQuitting;}/*------------------------------***  CheckLowMemory  ***--------------------------------*//*access:			protected	overrides:description: 	check if a low memory situation has arisen and deal with itins: 			noneouts: 			nonenotes:			not called in OS X----------------------------------------------------------------------------------------*/void		ZApplication::CheckLowMemory(){	if ( memIsShort )	{		// some of the shortage fund was used. Try to replenish it:				memIsShort = FALSE;				Handle temp = NewHandle( kShortageFundSize );				// if that resets memIsShort, then the grow zone func was called, so we		// are not in the clear yet. However, if the grow zone func wasn't		// called, then we can safely get rid of that handle and replace it with		// this one				if ( memIsShort )		{			if ( temp )				DisposeHandle( temp );						// couldn't replenish the fund, so if the user hasn't seen the			// warning yet, show it now.						if (! userHasSeenAlert)			{				StopCursorAnimation();				(void) NotifyAlert( kMemoryLowAlertID );				userHasSeenAlert = TRUE;			}						// if memIsShort is TRUE, it affects UpdateMenus such that New and Open are			// greyed out. This is an attempt to stop the user creating things that will			// eat up even more memory. You might want to use the same technique for commands			// of your own that may allocate lots of memory. For this reason, memIsShort is			// a public member.		}		else		{			// fund replenished, so get rid of any remaining fund and replace it			// with the newly allocated shortage fund.						DisposeHandle( shortageFund );			shortageFund = temp;			userHasSeenAlert = FALSE;		}	}}/*-------------------------------***  MemoryShortage  ***-------------------------------*//*access:			public	overrides:description: 	releases memory to appease memory managerins: 			<bytesShort> the amount of memory manager we should try to releaseouts: 			TRUE if we freed the requested amount, FALSE if we didn'tnotes:			called by the growzone proc (not OS X), Default method releases memory				from the shortage fund.----------------------------------------------------------------------------------------*/Boolean		ZApplication::MemoryShortage( const Size bytesShort ){	// this is called when the memory manager gets into dire straits. We can free some or all	// of our emergency fund to satisfy the request. If we succeed, we return TRUE, else FALSE.		Size	fundSize = 0;	Handle	gzHandle;		// get the handle the mem manager is dealing with at the moment. This is important since	// this might be the shortage fund itself. If it is, we can't resize it, so we really	// are in deep do-do. In this case, we flag memIsShort and hope the user will not ignore	// the message!		gzHandle = GZSaveHnd();		if ( gzHandle != shortageFund )	{		fundSize = GetHandleSize( shortageFund );				// release all or some of the memory to try and satisfy the request				if ( fundSize <= bytesShort )			SetHandleSize( shortageFund, 0 );		else			SetHandleSize( shortageFund, fundSize - bytesShort );	}	// flag the shortage so we can inform the user		memIsShort = TRUE;		// did we actually manage to free the requested amount?		return( fundSize > bytesShort );}/*-------------------------------***  Process1Event  ***--------------------------------*//*access:			public	overrides:description: 	fetch and process a single eventins: 			<mask> event mask of events to process (usually all of them)outs: 			nonenotes:			also runs timer queue----------------------------------------------------------------------------------------*/void		ZApplication::Process1Event( const short mask ){	EventRecord		theEvent;		zEH->GetAnEvent( &theEvent, mask );		if ( ExecuteModifiers( kModifierEventDispatch, &theEvent ))		zEH->DispatchAnEvent( &theEvent );		// timer queue is iterated at the end of handling an event		TimerTimer();	DoChores();}/*-------------------------------***  Process1Event  ***--------------------------------*//*access:			public	overrides:description: 	process an event we already haveins: 			<anExternalEvent> address of valid, unhandled, event record to processouts: 			nonenotes:			also runs timer queue----------------------------------------------------------------------------------------*/void		ZApplication::Process1Event( EventRecord* anExternalEvent ){	if ( ExecuteModifiers( kModifierEventDispatch, anExternalEvent ))		zEH->DispatchAnEvent( anExternalEvent );		TimerTimer();	DoChores();}/*-----------------------------***  ProcessAllEvents  ***------------------------------*//*access:			public	overrides:description: 	process all events pending until there are no more (except nulls)ins: 			noneouts: 			nonenotes:			also runs timer queue, keeps control until there is a null event----------------------------------------------------------------------------------------*/void		ZApplication::ProcessAllEvents(){	EventRecord		theEvent;		do	{		zEH->GetAnEvent( &theEvent );				if ( ExecuteModifiers( kModifierEventDispatch, &theEvent ))			zEH->DispatchAnEvent( &theEvent );				// timer queue is iterated at the end of handling each event				TimerTimer();	}	while( theEvent.what != nullEvent );		// chores are executed at the end of all active processing		DoChores();}/*------------------------------***  ProcessHLEvent  ***--------------------------------*//*access:			public	overrides:description: 	default handler for High Level eventsins: 			<theEvent> prefetched event record to processouts: 			nonenotes:			default dispatches to installed Apple Event handlers----------------------------------------------------------------------------------------*/void        ZApplication::ProcessHLEvent( const EventRecord& theEvent ){    FailOSErr( AEProcessAppleEvent( &theEvent ));}/*------------------------------***  GetCurrentEvent  ***-------------------------------*//*access:			public	overrides:description: 	get the most recent or current event to be processedins: 			<anEvent> address of an event record to fill inouts: 			TRUE if event is not a null event, otherwise FALSEnotes:			----------------------------------------------------------------------------------------*/Boolean		ZApplication::GetCurrentEvent( EventRecord* anEvent ){	zEH->GetLatestEvent( anEvent );		return( anEvent->what != nullEvent );}/*---------------------------------***  GetClicks  ***----------------------------------*//*access:			publicoverrides:	description: 	obtain a count of the number of mouse clicks accumulated in a sequenceins: 			noneouts: 			the number of clicksnotes:			Easy way to test for double, triple clicks, etc. double click returns 2,				triple returns 3, etc. Clicks are accumulated according to the system				DblClickTime and the spatial resolution provided by individual windows.----------------------------------------------------------------------------------------*/short		ZApplication::GetClicks(){	return zEH->GetClicks();}/*--------------------------------***  InBackground  ***--------------------------------*//*access:			publicoverrides:	description: 	query if the application is currently suspendedins: 			noneouts: 			TRUE if application suspended, FALSE if in foregroundnotes:			----------------------------------------------------------------------------------------*/Boolean		ZApplication::InBackground(){	return zEH->InBackground();}/*-----------------------------------***  Quit  ***-------------------------------------*//*access:			public	overrides:description: 	clean up when the application quits, including checking and closing				windowsins: 			noneouts: 			TRUE if application is to Quit, FALSE if notnotes:			The user may prevent quitting by choosing Cancel when the "Save Changes?"				alert is presented, therefore do not assume that the app WILL quit.----------------------------------------------------------------------------------------*/Boolean		ZApplication::Quit(){	Boolean wereDone = done;		if ( phase == kQuitting )	{		CloseAll();				// copy <done> locally to avoid reading bad ref after class deleted				wereDone = done;				// the Quit can be abandoned by resetting <done> to FALSE. If this		// has not occurred, then truly say goodbye.				if ( done )		{			#if _USE_NAVIGATION_SERVICES			if ( gMacInfo.hasNavigationServices )				NavUnload();			#endif						#if APPEARANCE_MGR_AWARE && !TARGET_API_MAC_CARBON			if ( gMacInfo.hasAppearanceMgr )				(void) UnregisterAppearanceClient();			#endif						ShutDown();			FORGETTHIS();		}	}	return wereDone;}/*---------------------------------***  RequestQuit  ***--------------------------------*//*access:			publicoverrides:	description: 	signal that the app should quitins: 			noneouts: 			nonenotes:			called by Quit command and Quit Apple Event----------------------------------------------------------------------------------------*/void		ZApplication::RequestQuit(){	done = TRUE;}/*-----------------------------***  HandleAppleEvent  ***-------------------------------*//*access:			public	overrides:		ZCommanderdescription: 	handle apple events not handled alreadyins: 			<aeClass>	the event class				<aeID> the event ID				<aeEvt> the apple event itself to process				<reply> the result to pass back to senderouts: 			nonenotes:			default process four required events, open, opendocs, print, quit.----------------------------------------------------------------------------------------*/void		ZApplication::HandleAppleEvent(	AEEventClass aeClass, AEEventID aeID,											const AppleEvent* aeEvt, AppleEvent* reply ){	if ( aeClass == kCoreEventClass )	{		AEDescList	docList;				switch ( aeID )		{			case kAEReopenApplication:				if ( GetFrontWindow())					break;				// fall through to normal open app event case if there are no windows:			case kAEOpenApplication:				#if MAKE_UNTITLED_STARTUP_WINDOW				OpenNewWindowType( kDefaultWindowType );				#endif				break;						case kAEOpenDocuments:				// do not handle this event if a modal dialog is up								if ( gWindowManager->IsDialog( GetFrontWindow()))					FailOSErr( kModalDialogOnScreenErr );							FailOSErr( AEGetParamDesc( aeEvt, keyDirectObject, typeAEList, &docList ));									// get each document and open it				try				{					OpenFiles( &docList );				}				catch( ZoopError err )				{					AEDisposeDesc( &docList );					throw err;				}				FailOSErr( AEDisposeDesc( &docList ));				break;						case kAEPrintDocuments:				if ( gWindowManager->IsDialog( GetFrontWindow()))					FailOSErr( kModalDialogOnScreenErr );							FailOSErr( AEGetParamDesc( aeEvt, keyDirectObject, typeAEList, &docList ));									// ask the application to show the page setup dialog								DoPageSetup();								// get each document passed by the finder								try				{					PrintFiles( &docList );				}				catch( ZoopError err )				{					AEDisposeDesc( &docList );					throw err;				}								FailOSErr( AEDisposeDesc( &docList ));				break;						case kAEQuitApplication:				RequestQuit();				break;						default:				ZCommander::HandleAppleEvent( aeClass, aeID, aeEvt, reply );				break;			}	}	else		ZCommander::HandleAppleEvent( aeClass, aeID, aeEvt, reply );}/*--------------------------------***  HandleError  ***--------------------------------*//*access:			publicoverrides:	description: 	notify errors to the userins: 			<theErr> the error code to processouts: 			nonenotes:			some errors are "silent"- they do not result in an alert. This will				call the Notification Manager if the app is suspended.----------------------------------------------------------------------------------------*/void		ZApplication::HandleError( const ZoopError theErr ){	// handles the error passed by displaying an alert. This is called by the exception	// handler for the application, but you can call it at any time. Some errors are "silent"	// in that the exception does not result in a message. These include userCanceled, kSilent	// Err, and aeEventNotHandled. Override this if you want to handle errors differently.		gMenuBar->SetTitleHilite( 0, FALSE );		if ( theErr != userCanceledErr &&		 theErr != kSilentErr	   &&		 theErr != noErr 		   &&		 theErr != errAEEventNotHandled &&		 theErr != iPrAbort )	{		StringHandle	errExpH;			Str255			errMsgStr;		Str31			errExplStr;		Str15			errIDStr;				// in case error thrown while offscreen focused:				SetGWorld((CGrafPtr) FrontWindow(), GetMainDevice());				gMenuBar->ShowHideMenuBar( MBAR_SHOW );		NumToString( theErr, errIDStr );				// try to build a meaningful error message by looking for an 'Estr'		// resource with the same iD as the error. If found, this is concatenated		// onto the generic error stub and displayed. If not found, the default		// explanation "an error occurred" is used.				GetIndString( errMsgStr, 128, 10 );				errExpH = (StringHandle) GetResource( 'Estr', theErr );				if ( errExpH )		{			ConcatPStrings( errMsgStr, *errExpH ); 				ReleaseResource((Handle) errExpH );		}		else		{			GetIndString( errExplStr, 128, 11 );			ConcatPStrings( errMsgStr, errExplStr );		}				ParamText( errIDStr, errMsgStr, NULL, NULL );		(void) NotifyAlert( kExceptionAlertID, ntAlertPlaySound );	}}/*-------------------------***  WaitApplicationForeground  ***--------------------------*//*access:			publicoverrides:	description: 	process events in the background until app is reactivatedins: 			noneouts: 			nonenotes:			keeps control until app is resumed----------------------------------------------------------------------------------------*/void		ZApplication::WaitApplicationForeground(){	while( InBackground())		Process1Event();}/*-----------------------------***  ProcessFunctionKey  ***-----------------------------*//*access:			publicoverrides:	description: 	handle the function keysins: 			<keyCode> raw key code of the key to processouts: 			nonenotes:			converts function key into a command, and dispatches it. The key codes				are correct for the Apple Extended keyboard and iMac type keyboard, others				untested. F1-F4 are converted to standard edit commands.----------------------------------------------------------------------------------------*/void        ZApplication::ProcessFunctionKey( const UInt8 keyCode )	{    UInt8           i, kc[15] = {   0x7A, 0x78, 0x63, 0x76, 0x60,                                    0x61, 0x62, 0x64, 0x65, 0x6D,                                    0x67, 0x6F, 0x69, 0x6B, 0x71 };    ZoopCommand     cmd, fkey[4] = { kCmdUndo, kCmdCut, kCmdCopy, kCmdPaste };        if ( gCurHandler )    {        for( i = 0; i < 15; i++ )        {            if ( keyCode == kc[i] )            {                if ( i > 3 )                    cmd = kCmdF1 + i;                    else                    cmd = fkey[i];                            gCurHandler->HandleCommand( cmd );                return;            }        }    }}#pragma mark -/*-------------------------------***  HandleCommand  ***--------------------------------*//*access:			publicoverrides:		ZCommanderdescription: 	handle commands for the app as a wholeins: 			<aCmd> the command to processouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::HandleCommand( const ZoopCommand aCmd ){	// handle commands at the application level. This includes quit, new, open, etc.		switch( aCmd )	{		case kCmdAbout:			AboutBox();			break;				case kCmdNew:			OpenNewWindowType( kDefaultWindowType );	// open a new "untitled" window			break;				case kCmdOpen:			DoStandardOpen();			break;					case kCmd_OpenMultiple:			OpenMultiple( NULL, FALSE );			break;					case kCmdCloseAll:			CloseAll( FALSE );			break;				case kCmdQuit:			RequestQuit();							// the app should now quit			break;				case kCmdPageSetup:			DoPageSetup();			break;				case kCmdPrint:			DoPrint();			break;				case kCmdUndo:		    DoUndo();			break;				    case kCmdRedo:	        DoRedo();	        break;					case kCmdDoPreferences:			DoPreferences();			break;					case kCmdStackWindows:			gWindowManager->StackWindows( FALSE, TRUE, ( zEH->GetLatestModifiers() & optionKey ) == optionKey );			break;					case kCmdTileWindows:			gWindowManager->TileWindows(( zEH->GetLatestModifiers() & optionKey ) != optionKey );			break;					case kCmd_CycleWindows:			{		    	ZWindow*  	topw;		    	ZWindow*  	zw;		    	short    	n = gWindowManager->CountWindows();		       	short    	i;		      		       	for( i = 2; i <= n; ++i )		       	{		        	FailNIL( zw = gWindowManager->GetNthWindow( i ));		         	if( zw->IsVisible())		         	{		           		topw = gWindowManager->GetTopWindow();		           		zw->Select();		           		gWindowManager->MoveWindowBehind( topw, NULL );		           		break;		         	}		       	}		    }		    break;		    #if __TOOLTIPS		case kCmd_ShowHideTooltips:			gTooltips->EnableTips( ! gTooltips->TipsEnabled());			break;		#endif				}}/*-------------------------------***  HandleCommand  ***--------------------------------*//*access:			publicoverrides:		ZCommanderdescription: 	handle commands for the app as a wholeins: 			<menuID> menu ID of the command				<itemID> item ID of the commandouts: 			nonenotes:			process commands that came from a menu without explicit commands - 				default process the Apple menu only, and not in Carbon.----------------------------------------------------------------------------------------*/void		ZApplication::HandleCommand( const short menuID, const short itemID ){#if !TARGET_API_MAC_CARBON	GrafPtr		savePort;	Str255		daName;		if ( menuID == kAppleMenuID &&		 itemID > 2 )	{		// open desk accessories.		GetMenuItemText( GetMenuHandle( menuID ), itemID, daName );		GetPort( &savePort );		OpenDeskAcc( daName );		SetPort( savePort );	}#endif}/*---------------------------------***  UpdateMenus  ***--------------------------------*//*access:			publicoverrides:		ZCommanderdescription: 	enable menus that apply to the current app state and contextins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::UpdateMenus(){	// enable the menu commands that pertain to the application. This includes "New",	// "Quit" and "About" amongst others		// apple menu		gMenuBar->EnableCommand( kCmdAbout );		// window menu		if ( gWindowManager->CountWindows( TRUE ) > 1 )	{		gMenuBar->EnableCommand( kCmdStackWindows );		gMenuBar->EnableCommand( kCmdTileWindows );		gMenuBar->EnableCommand( kCmd_CycleWindows );	}		// file menu		// if memory is currently short, do not enable new or open, since those are the	// commands that are likely to allocate a lot more memory, which we do not have.		if (! memIsShort)	{		gMenuBar->EnableCommand( kCmdNew );		gMenuBar->EnableCommand( kCmdOpen );	#if _USE_NAVIGATION_SERVICES		gMenuBar->EnableCommand( kCmd_OpenMultiple );	#endif	}	gMenuBar->EnableCommand( kCmdQuit );			// enable the printing items if there is a printer and the front window	// supports printing.#if PRINTING_ON		if ( itsPrinter )	    gMenuBar->EnableCommand( kCmdPageSetup );	ZWindow*	fWindow = GetFrontWindow();		if ( fWindow && fWindow->IsPrintable())		gMenuBar->EnableCommand( kCmdPrint );#endif		// edit:		UpdateUndo();	gMenuBar->EnableCommand( kCmdDoPreferences );	#if __TOOLTIPS	gMenuBar->EnableCommand( kCmd_ShowHideTooltips );	gMenuBar->CheckCommand( kCmd_ShowHideTooltips, gTooltips->TipsEnabled());#endif}/*--------------------------------***  DoPageSetup  ***---------------------------------*//*access:			publicoverrides:		description: 	handle the "Page Setup" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::DoPageSetup(){#if PRINTING_ON	if ( itsPrinter )	{		gWindowManager->DeactivateForDialog( -1, FALSE );		itsPrinter->PageSetUp();		gWindowManager->Activate();	}	else	    FailOSErr( kNoPrinterErr );#endif}/*----------------------------------***  DoPrint  ***-----------------------------------*//*access:			publicoverrides:		description: 	handle the "Print" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::DoPrint(){#if PRINTING_ON	if ( itsPrinter )	{		ZWindow*	aWindow = GetFrontWindow();				if ( aWindow->IsPrintable())		{			gWindowManager->DeactivateForDialog( -1, FALSE );			itsPrinter->Print( aWindow );			gWindowManager->Activate();		}	}	else#endif	    FailOSErr( kNoPrinterErr );}/*----------------------------------***  AboutBox  ***----------------------------------*//*access:			publicoverrides:		description: 	handle the "About..." commandins: 			noneouts: 			nonenotes:			Default method displays alert ID = 128----------------------------------------------------------------------------------------*/void	ZApplication::AboutBox(){#if ABOUT_BOX_IS_DIALOG	OpenDialog( kAboutBoxID );#else	Alert( kAboutBoxID, NULL );#endif}/*---------------------------------***  UpdateUndo  ***---------------------------------*//*access:			publicoverrides:		description: 	manage the state and text of the "Undo" menu commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::UpdateUndo(){	ZWindow*	w;		w = GetFrontWindow();		if ( w )		w->UpdateUndoCommands( !separateRedo );}/*----------------------------------***  DoUndo  ***------------------------------------*//*access:			publicoverrides:		description: 	handle the "Undo" command (and Redo if not separate)ins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void         ZApplication::DoUndo(){	ZWindow* 	w;		w = GetFrontWindow();		if ( w )	{		if ( separateRedo )			w->DoUndo();		else		{			ZUndoTask*	ut = w->GetUndoOrRedoTask();					if ( ut )			{				if ( ut->IsUndone())					w->DoRedo();				else					w->DoUndo();			}		}	}	}/*----------------------------------***  DoRedo  ***------------------------------------*//*access:			publicoverrides:		description: 	handle the "Redo" commandins: 			noneouts: 			nonenotes:			Only called if a multiple Undo stack is in use----------------------------------------------------------------------------------------*/void		ZApplication::DoRedo(){	ZWindow*	w = GetFrontWindow();		if ( w )		w->DoRedo();}/*--------------------------------***  DoSuspend  ***-----------------------------------*//*access:			publicoverrides:		ZCommanderdescription: 	application is being suspended - take required actionins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::DoSuspend(){	SendMessage( msgApplicationSuspending, 0 );	gWindowManager->Suspend();}/*---------------------------------***  DoResume  ***-----------------------------------*//*access:			publicoverrides:		description: 	application is being resumed - take required actionins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::DoResume(){	InvalidateCursor();	gWindowManager->Resume();		SendMessage( msgApplicationResuming, 0 );}/*------------------------------***  SetFrontSleep  ***---------------------------------*//*access:			publicoverrides:		description: 	set the sleep value for the application when activeins: 			<aSleep> sleep time in ticksouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::SetFrontSleep( const short aSleep ){	fFrontSleep = aSleep;		if ( ! zEH->InBackground())		gSleep = fFrontSleep;}/*-------------------------------***  SetBackSleep  ***---------------------------------*//*access:			publicoverrides:		description: 	set the sleep value for the application when suspendedins: 			<aSleep> sleep time in ticksouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::SetBackSleep( const short aSleep ){	fBackSleep = aSleep;		if ( zEH->InBackground())		gSleep = fBackSleep;}#pragma mark -/*-------------------------------***  InitMenuBar  ***----------------------------------*//*access:			protectedoverrides:		description: 	initialise the menu bar when the application starts upins: 			noneouts: 			nonenotes:			Installs MBAR 128 on classic, and MBAR 129 on OS X. This method also				sets up any "Windows" menu and the Undo menu item(s)----------------------------------------------------------------------------------------*/void		ZApplication::InitMenuBar(){	// installs the menu bar. By default, we just install 'MBAR' ID = 128, which means you	// don't need to override this to get other menus- just create the resources you want.	// Note, in OS X, the OS handles Quit, etc. This means that if you want a common source base, you need to	// set up two alternative menu bars- one with the File menu as usual, one that omits Quit. To make it	// easy to do this, MacXZoop uses MBAR 129 under OS X, 128 under classic.		FailNIL( gMenuBar = new ZMenuBar( gMacInfo.isRealMacOSX? kStdOSXMenubarID : kStdMenubarID ));		gMenuBar->InitMenuBar();		#if _AUTO_WINDOWS_MENU_ID		gMenuBar->NominateWindowsMenu( _AUTO_WINDOWS_MENU_ID );		#endif		// determine if the menu bar includes a separate redo command:		short m, i;		m = i = 0;		gMenuBar->FindCommand( kCmdRedo, &m, &i );	separateRedo = (( m != 0 ) && ( i != 0 ));}/*---------------------------***  MouseNotInAnyWindow  ***------------------------------*//*access:			publicoverrides:		description: 	set the cursor shape (or take other action) when mouse is not over any				window belonging to this applicationins: 			<globalMouse> the mouse location in global coordinatesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::MouseNotInAnyWindow( const Point globalMouse ){	ResumeCursorAnimation();	SetCursorShape( 0 );	#if __TOOLTIPS	if ( gTooltips )		gTooltips->HideTooltip( TRUE );#endif}/*----------------------------***  HandleMBarHiding  ***--------------------------------*//*access:			publicoverrides:		description: 	automatically show and hide the menu bar according to mouse position if				this feature is enabledins: 			<globalPt> mouse location in global co-ordinatesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::HandleMBarHiding( const Point globalPt ){#if _AUTO_MBAR_HIDING		if ( ! InBackground())		gMenuBar->ShowHideMenuBar( MBAR_HIDE_MOUSEAWARE, globalPt );	#endif}/*------------------------------***  MakeClipboard  ***---------------------------------*//*access:			protectedoverrides:		description: 	create the clipboard helper objectins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::MakeClipboard(){#if TARGET_API_MAC_CARBON    FailNIL( gClipboard = new ZCarbonClipboard());#else	FailNIL( gClipboard = new ZClipboard());#endif}/*-------------------------------***  MakeHelpers  ***----------------------------------*//*access:			protectedoverrides:		description: 	creates geneal helper objects and sets up default apple event handlersins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::MakeHelpers(){	// make the event handler		FailNIL( zEH = new ZEventHandler());		// make the window manager for handling floating windows, etc.#if TARGET_API_MAC_CARBON    FailNIL( gWindowManager = new ZCarbonWindowManager());#if MAC_OS_X    if ( gMacInfo.isRealMacOSX )    {    	// install Carbon Event timer to provide us with null events on OS X (TO DO)    	    	EventLoopTimerRef	timerRef;    	    	FailNIL( gCarbonTimerUPP = NewEventLoopTimerUPP( MZCarbonTimerCallback ));    	    	FailOSStatus( InstallEventLoopTimer( GetMainEventLoop(), kEventDurationSecond, kEventDurationSecond / 60, gCarbonTimerUPP, this, &timerRef ));    }#endif#else		FailNIL( gWindowManager = new ZWindowManager());#endif		// install handlers for the four required events		zEH->InstallApplescriptHandlers();		#if __TOOLTIPS	if ( gTooltips == NULL )		gTooltips = new ZTooltipHandler();#endif}/*-------------------------------***  MakePrinter  ***----------------------------------*//*access:			publicoverrides:		description: 	creates the printer helper object (if printing option on)ins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::MakePrinter(){#if PRINTING_ON	try	{		FailNIL( itsPrinter = new ZPrinter());	}	catch(...)	{		itsPrinter = NULL;				// note, to not have a printer is not fatal- in this case we carry on,		// but print commands will be greyed out. This may happen if no printer		// driver is selected in the chooser.	}#endif}#pragma mark -/*----------------------------***  MakeNewWindowType  ***-------------------------------*//*access:			protectedoverrides:		description: 	creates window objects in response to New, Open and Apple Event commandsins: 			<aType> type of window to create (usually a file type from Open command)outs: 			partially initialised window object or NULLnotes:			This method is critical to your app in that it is where all windows are				actually created (though not necessarily dialogs). The default method				makes the window type optionally specified in your project settings header.----------------------------------------------------------------------------------------*/ZWindow*		ZApplication::MakeNewWindowType( const OSType aType ){	ZWindow* 		aWindow;		// first see if the registry can make a window for this type		aWindow = CreateMacZoopWindow( aType );		if ( aWindow == NULL )	{	#ifdef USER_DEFAULT_WINDOW_TYPE		short	wID;	#ifdef USER_DEFAULT_WINDOW_ID		wID = USER_DEFAULT_WINDOW_ID;	#else		wID = kUntitledWindowID;	#endif		FailNIL( aWindow = new USER_DEFAULT_WINDOW_TYPE( this,  wID ));	#else		FailNIL( aWindow = new ZWindow( this,  kUntitledWindowID ));	#endif				try		{			aWindow->InitZWindow();		}		catch( ZoopError err )		{			FORGETOBJECT( aWindow );			throw err;		}	}	return aWindow;}/*----------------------------***  OpenNewWindowType  ***-------------------------------*//*access:			publicoverrides:		description: 	handles the "New" commandins: 			<aType> window type to make (usually a file type)outs: 			fully initialised window created (will be already visible)notes:			----------------------------------------------------------------------------------------*/ZWindow*	ZApplication::OpenNewWindowType( OSType aType ){	ZWindow*	theWindow;		gMenuBar->SetZoomSourceToCommand( kCmdNew );	theWindow = MakeNewWindowType( aType );		if ( theWindow )	{		theWindow->Place();		theWindow->OpenNew( aType );		theWindow->Select();	}		return theWindow;}/*--------------------------------***  CloseAll  ***------------------------------------*//*access:			publicoverrides:		description: 	closes all open windows, and checks for changesins: 			<closeFloaters> if TRUE, any floaters are also closedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::CloseAll( Boolean closeFloaters ){	long		i;	ZWindow*	aWindow;		if ( itsUnderlings )	{		i = itsUnderlings->CountItems();				while( i )		{			aWindow = dynamic_cast<ZWindow*>( itsUnderlings->GetObject( i-- ));						if ( aWindow )			{ 				if ( phase == kQuitting )				{					if ( ! aWindow->Close( phase ))					{						phase = kRunning;						done = FALSE;						break;					}				}				else				{					if (! aWindow->NoAutoClose() && ( aWindow->Floats() == closeFloaters ))					{						if ( ! aWindow->Close( phase ))						{							phase = kRunning;							done = FALSE;							break;						}					}				}			}		}	}}/*-----------------------------***  GetFrontWindow  ***---------------------------------*//*access:			publicoverrides:		description: 	get the active window ins: 			noneouts: 			the active window object, or NULL if there isn't onenotes:			----------------------------------------------------------------------------------------*/ZWindow*	ZApplication::GetFrontWindow(){	return ( gWindowManager->GetTopWindow());}/*--------------------------------***  PickFile  ***------------------------------------*//*access:			publicoverrides:		description: 	display the system file dialog and return selected file ins: 			<aFile>	address of filespec to store chosen file				<fType> address of storage for file type of chosen fileouts: 			TRUE if user picked a file, FALSE if they cancelled the dialognotes:			This call uses the installed list of file types to decide what types to				show----------------------------------------------------------------------------------------*/Boolean		ZApplication::PickFile( FSSpec* aFile, OSType* fType ){	return PickFile( aFile, fType, NULL );}/*--------------------------------***  PickFile  ***------------------------------------*//*access:			publicoverrides:		description: 	display the system file dialog and return selected file ins: 			<aFile>	address of filespec to store chosen file				<fType> address of storage for file type of chosen file				<fTypesList> Handle to a file types list you supplyouts: 			TRUE if user picked a file, FALSE if they cancelled the dialognotes:			----------------------------------------------------------------------------------------*/Boolean		ZApplication::PickFile( FSSpec* aFile, OSType* fType, FTypeListHdl fTypesList ){	// uses standard file to choose a file to open to a window. By default, no files types	// are added to the list, which we here interpret to mean "show all files".		if ( fTypesList == NULL )		fTypesList = itsFileTypes;		#if _USE_NAVIGATION_SERVICES	// using navigation services, so we need to tackle things a little differently. The result	// from this method is the same- namely a single filespec and a type.		if ( gMacInfo.hasNavigationServices )	{		OSErr				theErr;		NavReplyRecord		navReply;		NavDialogOptions	navOptions;		Boolean				result = FALSE;				FailOSErr( NavGetDefaultDialogOptions( &navOptions ));		GetName( navOptions.clientName );				// if file list empty, allow "all files"				if ((*fTypesList)->osTypeCount == 0 )			navOptions.dialogOptionFlags |= kNavAllFilesInPopup;				// only permit one selection here:				navOptions.dialogOptionFlags &= ~kNavAllowMultipleFiles;		navOptions.dialogOptionFlags |= kNavSelectAllReadableItem;		gWindowManager->DeactivateForDialog( -1, FALSE );		StopCursorAnimation();				theErr = NavGetFile( NULL,							 &navReply,							 &navOptions,							 gNavEventHandler,							 NULL,							 NULL,							 (NavTypeListHandle) fTypesList,							 (NavCallBackUserData) this );							 		gWindowManager->Activate();										// extract info. Since we only allowed 1 selection, this will be the first item:				if (( theErr == noErr ) && navReply.validRecord )		{			AEDesc	specDesc;			FInfo	fi;						FailOSErr( AEGetNthDesc( &navReply.selection, 1, typeFSS, NULL, &specDesc ));						#if OPAQUE_TOOLBOX_STRUCTS				FailOSErr( AEGetDescData( &specDesc, aFile, sizeof( FSSpec )));			#else				BlockMoveData( *specDesc.dataHandle, aFile, sizeof( FSSpec ));			#endif							// to get the type we need to do a FsGetFInfo:							FSpGetFInfo( aFile, &fi );			*fType = fi.fdType;					result = TRUE;		}		else			result = FALSE;					FailOSErr( NavDisposeReply( &navReply ));		FailOSErr( theErr );				return result;	}	else	{#endif#if ! TARGET_API_MAC_CARBON	StandardFileReply	aReply;	OSType*				listPtr;	short				numTypes;		HLock((Handle) fTypesList );	numTypes = (*fTypesList )->osTypeCount;	listPtr = &(*fTypesList)->osType[0];		// if no types in the list, show all of them		if( numTypes <= 0 )		numTypes = -1;		gWindowManager->DeactivateForDialog( sfGetDialogID );	StopCursorAnimation();		// display the dialog	StandardGetFile( NULL, numTypes, listPtr, &aReply );	HUnlock((Handle) fTypesList );		gWindowManager->Activate();		if ( aReply.sfGood )	{		*aFile = aReply.sfFile;		*fType = aReply.sfType;		return TRUE;	}	else		return FALSE;#endif#if _USE_NAVIGATION_SERVICES	}#endif		return FALSE;}/*--------------------------------***  OpenFile  ***------------------------------------*//*access:			publicoverrides:		description: 	create a window for the file passed, and open the file into it ins: 			<aFile>	filespec of the file to open				<fType> file type of the file to open				<isStationery> TRUE if the file is a stationery fileouts: 			The window object created (will already be visible and have opened the file)notes:			Essential part of ther "Open" command handling, also called from Apple Event----------------------------------------------------------------------------------------*/ZWindow*	ZApplication::OpenFile( const FSSpec& aFile, const OSType fType, Boolean isStationery ){	// opens the file into a new window. This is equivalent to OpenNewWindow, but	// for when the user chose a file with the Open command		ZWindow*	aWindow = NULL;	FSSpec		fs = aFile;		SetWatchCursor();		if ( ExecuteModifiers( kModifierOpenFile, &fs ))	{		aWindow = MakeNewWindowType( fType );				// window created, so ask it to open the chosen file				if ( aWindow )		{			try			{				aWindow->SetFile( fs );				aWindow->OpenFile( fType, isStationery );				aWindow->Place();				aWindow->Select();			}			catch( ZoopError err )			{				FORGETOBJECT( aWindow );				throw err;			}		}	}	return aWindow;}/*-------------------------------***  OpenMultiple  ***----------------------------------*//*access:			publicoverrides:		description: 	allow multi-selection opening of files using Navins: 			<fTypesList> list of types to display				<allowFolders> TRUE to allow selection of foldersouts:			number of selections processednotes:			will create windows as necessary. Note <allowFolders> is not currently				supported by Navigation, so is ignored.----------------------------------------------------------------------------------------*/long		ZApplication::OpenMultiple( FTypeListHdl fTypesList, Boolean allowFolders ){	long	result = 0;#if _USE_NAVIGATION_SERVICES	if ( fTypesList == NULL )		fTypesList = itsFileTypes;	if ( gMacInfo.hasNavigationServices )	{		OSErr				theErr;		NavReplyRecord		navReply;		NavDialogOptions	navOptions;		Boolean				result = FALSE;				FailOSErr( NavGetDefaultDialogOptions( &navOptions ));		GetName( navOptions.clientName );				// if file list empty, allow "all files"				if ((*fTypesList)->osTypeCount == 0 )			navOptions.dialogOptionFlags |= kNavAllFilesInPopup;				// permit multiple selections:				navOptions.dialogOptionFlags |= ( kNavAllowMultipleFiles + kNavSelectAllReadableItem );		gWindowManager->DeactivateForDialog( -1, FALSE );		StopCursorAnimation();				theErr = NavGetFile( NULL,							 &navReply,							 &navOptions,							 gNavEventHandler,							 NULL,							 NULL,							 (NavTypeListHandle) fTypesList,							 (NavCallBackUserData) this );							 		gWindowManager->Activate();										// extract info. This is in the form of an AEDEscList, which we already		// know how to process				if (( theErr == noErr ) && navReply.validRecord )		{			try			{				result = OpenFiles( &navReply.selection );				}			catch( ZoopError err )			{				NavDisposeReply( &navReply );				throw err;			}		}				FailOSErr( NavDisposeReply( &navReply ));	}#endif	return result;}/*------------------------------***  AddFileType  ***-----------------------------------*//*access:			publicoverrides:		description: 	add a file type to the list of openable typesins: 			<aType>	file type to add to the listouts: 			nonenotes:			Called automatically as part of application set up, but can be called				to extend list if required. Duplicate types are ignored.----------------------------------------------------------------------------------------*/void		ZApplication::AddFileType( const OSType aType ){	// adds the file type to the list of types, if not already there		short	nTypes, i;		nTypes = (*itsFileTypes)->osTypeCount;		// check that the file type we are adding is unique in the list		for ( i = 0; i < nTypes; i++ )	{		if ((*itsFileTypes)->osType[i] == aType )			return;	}		// if we are still here, type is unique, so append it		FailOSErr( PtrAndHand((Ptr) &aType, (Handle) itsFileTypes, sizeof( OSType )));		(*itsFileTypes)->osTypeCount++;}/*-------------------------------***  CanOpenFileType  ***------------------------------*//*access:			publicoverrides:		description: 	query if the app can open a given file typeins: 			<aType>	file type to queryouts: 			TRUE if the file type can be opened, FALSE otherwisenotes:			----------------------------------------------------------------------------------------*/Boolean		ZApplication::CanOpenFileType( const OSType aType ){	short	nTypes, i;		nTypes = (*itsFileTypes)->osTypeCount;		if ( nTypes > 0 )	{		for ( i = 0; i < nTypes; i++ )		{			if ( (*itsFileTypes)->osType[i] == aType )				return TRUE;		}				return FALSE;	}	else		return TRUE;}/*-------------------------------***  RegisterClasses  ***------------------------------*//*access:			protectedoverrides:		description: 	register streamable classes with the global registryins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::RegisterClasses(){#if _MACZOOP_STREAMS	FailNIL( gClasses );		REGISTERCLASS( ZComrade );	REGISTERCLASS( ZCommander );	REGISTERCLASS( ZArray );	REGISTERCLASS( ZWindow );	REGISTERCLASS( ZApplication );	REGISTERCLASS( ZObjectList );#endif	// also register cutsom dialog items as required.	// Only ZTextView is added here (for the about box)#if ABOUT_BOX_IS_DIALOG	ZViewDialog::RegisterDialogItem( CreateNewEnhancedTextBox, kMagicStringEnhancedText, kInitItemWithMagicParams );#endif	}/*-----------------------------***  GetDebugInfoString  ***-----------------------------*//*access:			publicoverrides:		description: 	return readable info for the use of inspectors, etcins: 			<s> string to store info intoouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::GetDebugInfoString( Str255 s ){	Str31 ss;		GetName( s );	ConcatPStrings( s, "\p, free memory: " );	NumToString( FreeMem(), ss );	ConcatPStrings( s, ss );	ConcatPStrings( s, "\p bytes" );}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			publicoverrides:		description: 	supply dynamic field info for inspector's useins: 			noneouts: 			nonenotes:			use SHOWFIELD macro only----------------------------------------------------------------------------------------*/void		ZApplication::ReportFields(){	ZCommander::ReportFields();	XSHOWFIELD( done, ft_boolean );	XSHOWFIELD( phase, ft_signedshort );	XSHOWFIELD( appResRefNum, ft_signedshort );	XSHOWFIELD( zEH, ft_objectref );	XSHOWFIELD( shortageFund, ft_Handle );	XSHOWFIELD( itsFileTypes, ft_Handle );	XSHOWFIELD( itsPrinter, ft_objectref );	XSHOWFIELD( memIsShort, ft_boolean );	XSHOWFIELD( userHasSeenAlert, ft_boolean );	XSHOWFIELD( splashVisible, ft_boolean );	XSHOWFIELD( separateRedo, ft_boolean );	XSHOWFIELD( msDepth, ft_signedshort );	XSHOWFIELD( fFrontSleep, ft_signedshort );	XSHOWFIELD( fBackSleep, ft_signedshort );	XSHOWFIELD( fChoreList, ft_objectref );}#pragma mark -/*---------------------------***  GetProcessSerialNumber  ***---------------------------*//*access:			publicoverrides:		description: 	return process serial number for this applicationins: 			<PSN> storage for serial numberouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::GetProcessSerialNumber( ProcessSerialNumber* PSN ){	FailOSErr( MacGetCurrentProcess( PSN ));}/*-------------------------------***  GetProcessInfo  ***-------------------------------*//*access:			publicoverrides:		description: 	return process information record for this applicationins: 			<pInfo> address of process record to fill inouts: 			nonenotes:			WARNING: be careful that you allocate storage correctly - see IM----------------------------------------------------------------------------------------*/void		ZApplication::GetProcessInfo( ProcessInfoRec* pInfo ){	ProcessSerialNumber		PSN;		GetProcessSerialNumber( &PSN );	FailOSErr( GetProcessInformation( &PSN, pInfo ));}/*-----------------------------***  GetProcessLocation  ***-----------------------------*//*access:			publicoverrides:		description: 	return the volume and directory in which the application residesins: 			<volume> volume reference number				<parentDirID> ID of the containing directoryouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::GetProcessLocation( short* volume, long* parentDirID ){	ProcessInfoRec		pInfo;	FSSpec				pSpec;		pInfo.processInfoLength = sizeof( ProcessInfoRec );	pInfo.processName = NULL;	pInfo.processAppSpec = &pSpec;		GetProcessInfo( &pInfo );		*volume = pSpec.vRefNum;	*parentDirID = pSpec.parID;}/*----------------------------------***  AddChore  ***----------------------------------*//*access:			publicoverrides:		description: 	add a chore to the list of chores to perform at idle timeins: 			<aChore> the chore object to addouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::AddChore( ZChore* aChore ){	FailNILParam( aChore );		if ( fChoreList == NULL )		FailNIL( fChoreList = new ZObjectList());			fChoreList->AppendItem( aChore );}/*----------------------------------***  DoChores  ***----------------------------------*//*access:			publicoverrides:		description: 	execute chores that need to be doneins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZApplication::DoChores(){	long		n, i;	ZChore*		chore;		if ( fChoreList )	{		n = fChoreList->CountItems();			for( i = n; i > 0; i-- )		{			chore = (ZChore*) fChoreList->GetObject( i );					if ( chore )			{				chore->Do();								// chores can auto repeat. If they don't however,				// we remove and delete them. Chores are typically one-shot.								if ( !chore->IsRepeatTask())				{					fChoreList->DeleteObject( chore );					FORGETOBJECT( chore );				}			}		}				if ( fChoreList->CountItems() < 1 )			FORGETOBJECT( fChoreList );	}}/*-----------------------------***  RegisterWindowType  ***-----------------------------*//*access:			static publicoverrides:		description: 	registers a construction proc for a window against a file typeins: 			<windowCreationProc> window creation function				<aFileType> the file type associated with the window				<resID> resource template to use for this window (WIND/ZWIN)outs: 			nonenotes:			this is an alternative way to register window classes with ZApplication				that avoid subclassing this object just for new window types.----------------------------------------------------------------------------------------*/void		ZApplication::RegisterWindowType( void* windowCreationProc, const OSType aFileType, const short resID ){	if ( sWindowClassRegistry == NULL )		FailNIL( sWindowClassRegistry = new ZClassRegistry());		sWindowClassRegistry->RegisterClass( aFileType, (ConstructorFunction) windowCreationProc, "\p", resID );}/*----------------------------***  CreateMacZoopWindow  ***-----------------------------*//*access:			protectedoverrides:		description: 	creates a window object by calling through the registryins: 			<aType> file type of window to makeouts: 			the window object, if the file type is registered, else NULLnotes:			normally called by the default MakeNewWindowType method.				Note that the creation function must make a complete, initialised window				object. This is to allow the function to add views or perform other setup -				ZApplication will not do this for you. It will place and show the window however.----------------------------------------------------------------------------------------*/ZWindow*	ZApplication::CreateMacZoopWindow( const OSType aType ){	if ( sWindowClassRegistry )	{		Object_Info		info;		long			indx;				indx = sWindowClassRegistry->FindClass( aType );				if ( indx )		{			sWindowClassRegistry->GetArrayItem( &info, indx );				if ( info.newfunc )			{				WindowCreationProc*	wcp = (WindowCreationProc*) info.newfunc;				short		windowResID = info.refCon;								if ( windowResID == 0 )					windowResID = kUntitledWindowID;								ZWindow*	w = (*wcp)( this, windowResID, aType );							return w;			}		}	}		return NULL;}/*---------------------------------***  OpenFiles  ***----------------------------------*//*access:			protectedoverrides:		description: 	open the documents in the listouts: 			number actually openednotes:			----------------------------------------------------------------------------------------*/long		ZApplication::OpenFiles( const AEDescList* fileList ){	AEDesc		specDesc;	FSSpec		aFile;	long		i, n;	FInfo		fi;		SetWatchCursor();	FailOSErr( AECountItems( fileList, &n ));		// get each document and open it	for ( i = 1; i <= n; i++ )	{		FailOSErr( AEGetNthDesc( fileList, i, typeFSS, NULL, &specDesc ));				#if OPAQUE_TOOLBOX_STRUCTS			FailOSErr( AEGetDescData( &specDesc, &aFile, sizeof( FSSpec )));		#else			BlockMoveData( *specDesc.dataHandle, &aFile, sizeof( FSSpec ));		#endif				FailOSErr( FSpGetFInfo( &aFile, &fi ));				// open the file into a window and select it, provided		// it really is one we can open. If the file is a prefs file, call up		// the kDoPreferences command:				if ( fi.fdType == 'pref' )			HandleCommand( kCmdDoPreferences );		else		{			if ( CanOpenFileType( fi.fdType ))				OpenFile( aFile, fi.fdType, ( fi.fdFlags & kIsStationery ) == kIsStationery );		}	}		return n;}/*--------------------------------***  PrintFiles  ***----------------------------------*//*access:			protectedoverrides:		description: 	print the documents in the listouts: 			nonenotes:			----------------------------------------------------------------------------------------*/long		ZApplication::PrintFiles( const AEDescList* fileList ){	AEDesc		specDesc;	FSSpec		aFile;	long		i, n;	FInfo		fi;		SetWatchCursor();	FailOSErr( AECountItems( fileList, &n ));		// get each document and open it	for ( i = 1; i <= n; i++ )	{		FailOSErr( AEGetNthDesc( fileList, i, typeFSS, NULL, &specDesc ));				#if OPAQUE_TOOLBOX_STRUCTS			FailOSErr( AEGetDescData( &specDesc, &aFile, sizeof( FSSpec )));		#else			BlockMoveData( *specDesc.dataHandle, &aFile, sizeof( FSSpec ));		#endif				FailOSErr( FSpGetFInfo( &aFile, &fi ));				if ( CanOpenFileType( fi.fdType ))		{			ZWindow* zw;						zw = OpenFile( aFile, fi.fdType, ( fi.fdFlags & kIsStationery ) == kIsStationery );					// update the window (not strictly needed, but looks better)		    		    if ( zw )		    {				zw->PerformUpdate();						// ask the application to print the document						DoPrint();						// that done, we can close the window and move on to the next						zw->Close( GetPhase());			}		}	}		return n;}/*------------------------------***  DoStandardOpen  ***--------------------------------*//*access:			protectedoverrides:		description: 	handle the standard Open commandouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZApplication::DoStandardOpen(){	FSSpec		aFile;	OSType		anFType;	FInfo		fi;		if ( PickFile( &aFile, &anFType ))			// choose a file	{		// is it a stationery (template) file?				FSpGetFInfo( &aFile, &fi );		OpenFile( aFile, anFType, ( fi.fdFlags & kIsStationery ) == kIsStationery );			// open the file into a window	}}#pragma mark -/*--------------------------------***  GrowFunction  ***--------------------------------*//*access:			static callback functionoverrides:		description: 	callback handler from growzone proc to application objectins: 			<bytesShort> amount of memory we need to freeouts: 			number of bytes actually freednotes:			This is the growzone proc (not OS X)----------------------------------------------------------------------------------------*/pascal long ZApplication::GrowFunction( Size bytesShort ){	Boolean bytesFreed;		// call application object to free some memory	try	{		bytesFreed = gApplication->MemoryShortage( bytesShort );	}	catch(...)	{		bytesFreed = 0;				// do NOT proagate any exception, since we are within a toolbox callback	}		return bytesFreed;}/*------------------------------***  DoMacZoopBirth  ***--------------------------------*//*access:			static publicoverrides:		description: 	starts up and runs the applicationins: 			noneouts: 			nonenotes:			Do not call - called exclusively from main----------------------------------------------------------------------------------------*/void	ZApplication::DoMacZoopBirth(){	FailNIL( gApplication );		try	{		gApplication->InitMacZoop();			// initialise the whole kaboodle. This is												// NOT done by the constructor since you might												// want to override the initialisation.	}	catch( ZoopError err )	{		// if an exception occurs during startup, the application cannot run, since		// everything must be properly built and in place before handling events. In this		// case we display a fatal alert message and exit.		Str31	appName, errStr;				gApplication->GetName( appName );		NumToString( err, errStr );		ParamText( appName, errStr, NULL, NULL );				StopCursorAnimation();		(void) Alert( kFatalStartupErrAlertID, NULL );		ExitToShell();	}	// initialisation is now complete, so we can go ahead and run the thing		do	{		gApplication->Run();					// run the application until the user quits	}	while (! gApplication->Quit());				// try to quit}#if _USE_NAVIGATION_SERVICES/*-----------------------------***  ZNavEventCallback  ***------------------------------*//*access:			static callback functionoverrides:		description: 	handles events when Navigation Services window displayedins: 			<cbMessage> callback message				<cbParams> callback parameters				<cbData> callback dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/pascal void	ZNavEventCallback( 	NavEventCallbackMessage cbMessage,								NavCBRecPtr	cbParams,								NavCallBackUserData	cbData ){	GrafPtr		savePort;		switch ( cbMessage )	{		case kNavCBEvent:			GetPort( &savePort );						try			{			#if UNIVERSAL_INTERFACES_VERSION < 0x0320				if ( cbParams->eventData.event->what == updateEvt   ||					 cbParams->eventData.event->what == activateEvt ||					 cbParams->eventData.event->what == nullEvent )					gApplication->Process1Event( cbParams->eventData.event );			#else				if ( cbParams->eventData.eventDataParms.event->what == updateEvt   ||					 cbParams->eventData.eventDataParms.event->what == activateEvt ||					 cbParams->eventData.eventDataParms.event->what == nullEvent )					gApplication->Process1Event( cbParams->eventData.eventDataParms.event );			#endif			}			catch(...)			{				// me no propagate			}						SetPort( savePort );			break;					default:			break;			}}#endif#if TARGET_API_MAC_CARBON && MAC_OSX/*---------------------------***  MZCarbonTimerCallback  ***----------------------------*//*access:			static callback functionoverrides:		description: 	handles timer and chores on OSX where NULL events don't existins: 			<inTimer> timer ref				<inUserData> user dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/pascal void MZCarbonTimerCallback( EventLoopTimerRef inTimer, void *inUserData ){	try	{		TimerTimer();		gApplication->DoChores();	}	catch( ... )	{	}}#endif