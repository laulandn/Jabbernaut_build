/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			ZCarbonWindowManager.cpp		-- desktop class - uses Carbon API******			© 2000, Graham Cox*****************************************************************************************************/#include	"ZCarbonWindowManager.h"#include    "MacZoop.h"#include    "ZDialog.h"#include    <macwindows.h>/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZCarbonWindowManager::ZCarbonWindowManager()    : ZWindowManager(){	classID = CLASS_ZCarbonWindowManager;        windows = nonFloaters;}/*---------------------------------***  DESTRUCTOR  ***---------------------------------*/ZCarbonWindowManager::~ZCarbonWindowManager(){    if ( windows )    {        windows->DisposeAll();        ForgetObject( windows );        nonFloaters = NULL;    }	if ( wmWindows )		ForgetObject( wmWindows );}/*---------------------------------***  ADDWINDOW  ***----------------------------------*//*	add the window to the relevant list of windows, and set its initial (Z) position----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::AddWindow( ZWindow* aWindow ){    FailNILParam( aWindow );    windows->AppendItem( aWindow );        // Windows menu setup:        Boolean eligibleWindow;        eligibleWindow = ( !aWindow->Floats() && !IsDialog( aWindow ));    	// if we're maintaining a "Windows" menu, append the window to our list if	// it's non-floating and not a modal dialog box and has a title bar.		if ( wmWindows && eligibleWindow )	{		wmWindows->AppendItem( aWindow );		BuildWindowsMenu();    }    SendMessage( kWMMsgWindowAdded, aWindow );}/*--------------------------------***  REMOVEWINDOW  ***--------------------------------*//*remove the window from the relevant list; make sure the next window is activated correctly.	----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::RemoveWindow( ZWindow* aWindow ){	FailNILParam( aWindow );	    windows->DeleteObject( aWindow );	// if all windows closed, reset global positioning variable		if ( ! aWindow->Floats())	{		if ( wmWindows )			wmWindows->DeleteObject( aWindow );    	if ( CountWindows() == 0 )    	{    		globalPlaceLoc.h = 2;    		globalPlaceLoc.v = GetMBarHeight() + 2;    	}    }        SendMessage( kWMMsgWindowRemoved, aWindow );}/*---------------------------------***  HIDEWINDOW  ***---------------------------------*//*	make the window invisible to the user.----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::HideWindow( ZWindow* aWindow ){    if ( aWindow->IsVisible())    {         ::HideWindow( aWindow->GetMacWindow());        SendMessage( kWMMsgWindowHidden, aWindow );    }}/*---------------------------------***  SHOWWINDOW  ***---------------------------------*//*	make the window visible to the user. Does not change its front-to-back ordering----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::ShowWindow( ZWindow* aWindow ){	if ( ! aWindow->IsVisible())	{		#if _ZOOM_RECT_FX				if ( gMacInfo.hasDragManager )		{			RgnHandle	wStruct;					aWindow->GetStructureRegion( wStruct = NewRgn());			aWindow->SetWindowZoomRectSource( &gZoomFXSourceRect );						ZoomRects( &gZoomFXSourceRect, REGIONBOUNDINGBOX( wStruct ), 10, kZoomAccelerate );			DisposeRgn( wStruct );		}		#endif                ::ShowWindow( aWindow->GetMacWindow());        SendMessage( kWMMsgWindowShown, aWindow );    }}/*--------------------------------***  SELECTWINDOW  ***--------------------------------*//*	make the window active. This handles the front-to-back ordering.----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::SelectWindow( ZWindow* aWindow ){    this->ShowWindow( aWindow );    ::SelectWindow( aWindow->GetMacWindow());}/*------------------------------***  DRAGWINDOWOUTLINE  ***-----------------------------*//*	drag and move the window. Under Carbon, we call the toolbox DragWindow and lose thesnap functionality (for now) because the drag outline isn't drawn properly on OS Xwhen running under classic. ----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::DragWindowOutline( ZWindow* aWindow, Point startPt, const short modifiers, SnapFlags snap ){	FailNILParam( aWindow );		// replaces the toolbox DragWindow, because that will bring a window to the front if	// you let it.		WindowPtr		w;	Rect			limitRect;		w = aWindow->GetMacWindow();	PauseCursorAnimation( 0 );		// if window frontmost and command key down, call command-click hook and return. The hook	// can be overridden to implement stuff such as popping up a directory path menu, etc.		if ( aWindow == GetTopWindow() &&		 ( modifiers & cmdKey ) == cmdKey )	{		// the hook returns a boolean to indicate whether processing should continue or not.		// If FALSE, we continue, otherwise we abort. The default hook method just returns FALSE				if ( CommandClickInFrontDragBar( aWindow, startPt ))			return;	}		// get the limit rect		limitRect = *REGIONBOUNDINGBOX( GetGrayRgn());	InsetRect( &limitRect, 4, 4 );#if _DRAGWINDOW_COMPATIBLE == OFF		if (( modifiers & cmdKey ) == 0 &&		aWindow != GetTopWindow() &&		aWindow != GetTopFloater())	{		SelectWindow( aWindow );	}#if _UPDATE_ON_SELECT		aWindow->PerformUpdate();	#endif#endif	DragWindow( w, startPt, &limitRect );		SendMessage( kWMMsgWindowMoved, aWindow );	ResumeCursorAnimation();}/*-----------------------------------***  SUSPEND  ***----------------------------------*//*	application is suspending- hide the floaters----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::Suspend(){    HideFloatingWindows();}/*-----------------------------------***  RESUME  ***-----------------------------------*//*	application is resuming- show the floaters----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::Resume(){    ShowFloatingWindows();}/*--------------------------------***  GETTOPWINDOW  ***--------------------------------*//*	get uppermost non-floating window----------------------------------------------------------------------------------------*/ZWindow*	ZCarbonWindowManager::GetTopWindow(){    // this must return document or dialog window    WindowPtr   w;        w = FrontNonFloatingWindow();        if ( w )    	return( GetZWindow( w ));    else        return NULL;}/*-------------------------------***  GETTOPFLOATER  ***--------------------------------*//*	get uppermost floating window----------------------------------------------------------------------------------------*/ZWindow*	ZCarbonWindowManager::GetTopFloater(){    WindowPtr   w;        w = GetFrontWindowOfClass( kFloatingWindowClass, TRUE );        if ( w )        return GetZWindow( w );    else        return NULL;}/*------------------------------***  MOVEWINDOWBEHIND  ***------------------------------*//*	move <aWindow> behind <behindWindow>. If NULL, moves it behind all others. Works forfloaters too, within their layer.----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::MoveWindowBehind( ZWindow* aWindow, ZWindow* behindWindow ){    FailNILParam( aWindow );        WindowPtr   w, bw;        if ( behindWindow == NULL )        bw = NULL;    else        bw = behindWindow->GetMacWindow();        w = aWindow->GetMacWindow();       SendBehind( w, bw );            }/*--------------------------------***  LOCATEWINDOW  ***--------------------------------*//*	find the window under the mouse, or NULL if none are----------------------------------------------------------------------------------------*/ZWindow*	ZCarbonWindowManager::LocateWindow( const Point globalMouse ){    WindowPtr       w;    WindowPartCode  wpc;        FindWindowOfClass( &globalMouse, kAllWindowClasses, &w, &wpc );        if ( w )        return GetZWindow( w );    else        return NULL;}ZWindow*	ZCarbonWindowManager::GetNthWindow( const long n ){    WindowPtr       w;    long            c = 0;        w = GetFrontWindowOfClass( kDocumentWindowClass, FALSE );        while(( ++c != n ) && w )        w = GetNextWindowOfClass( w, kDocumentWindowClass, FALSE );            if ( w )        return GetZWindow( w );    else        return NULL;}/*--------------------------------***  GETNTHWINDOW  ***--------------------------------*//*	return the window <n>, or NULL if bad index----------------------------------------------------------------------------------------*/ZWindow*	ZCarbonWindowManager::GetNthFloater( const long n ){    WindowPtr       w;    long            c = 0;        w = GetFrontWindowOfClass( kFloatingWindowClass, FALSE );        while(( ++c != n ) && w )        w = GetNextWindowOfClass( w, kFloatingWindowClass, FALSE );            if ( w )        return GetZWindow( w );    else        return NULL;}/*----------------------------------***  FLOATIDLE  ***---------------------------------*//*	pass idle to each floater, in case they do periodic action----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::FloatIdle(){	long		i;	ZWindow*	aFloater;		for( i = 1; i <= windows->CountItems(); i++ )	{		aFloater = (ZWindow*) windows->GetObject( i );			if ( aFloater && aFloater->Floats())			aFloater->GetHandler()->Idle();	}	}/*---------------------------------***  COUNTWINDOWS  ***-------------------------------*//*	return the number of non-floating windows the manager knows about----------------------------------------------------------------------------------------*/short		ZCarbonWindowManager::CountWindows(){	long		i, n = 0;	ZWindow*	w;		for( i = 1; i <= windows->CountItems(); i++ )	{		w = (ZWindow*) windows->GetObject( i );			if ( w && !w->Floats())		    n++;	}		return n;	}/*---------------------------------***  COUNTFLOATERS  ***------------------------------*//*	return the number of floating windows the manager knows about----------------------------------------------------------------------------------------*/short		ZCarbonWindowManager::CountFloaters(){	long		i, n = 0;	ZWindow*	w;		for( i = 1; i <= windows->CountItems(); i++ )	{		w = (ZWindow*) windows->GetObject( i );			if ( w && w->Floats())		    n++;	}		return n;	}/*-----------------------------***  FINDWINDOWBYUSERID  ***-----------------------------*//*	Searches the window list and returns the first window it finds that has thesame user ID as that passed in. The user ID is a way for a window to be tracked withouthaving to keep a seperate list or reference for it.----------------------------------------------------------------------------------------*/ZWindow*	ZCarbonWindowManager::FindWindowByUserID( long id ){	ZWindow*	w = NULL;	long		m, i;		m = windows->CountItems();		for( i = 1; i <= m; i++ )	{		w = (ZWindow*) windows->GetObject( i );				if ( w && w->GetUserID() == id )			return w;	}		return NULL;}/*------------------------------***  SHOWHIDEFLOATER  ***-------------------------------*//*	show or hide a floater----------------------------------------------------------------------------------------*/void		ZCarbonWindowManager::ShowHideFloater( ZWindow* aFloater, Boolean hide ){    if ( hide )        ::HideWindow( aFloater->GetMacWindow());    else        ::ShowWindow( aFloater->GetMacWindow());}