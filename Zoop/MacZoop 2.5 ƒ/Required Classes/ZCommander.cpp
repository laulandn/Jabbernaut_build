/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZCommander.cpp			-- an object for handling commands******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZCommander.h"#include	"MacZoop.h"#if ! NO_NEW_DIALOGS#include	"ZViewDialog.h"#endif#if _ZCOMMANDER_DIALOG_AWARE#include	"ZDialog.h"#endifextern ZCommander* gCurHandler;CLASSCONSTRUCTOR( ZCommander );/*----------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZCommander::ZCommander( ZCommander* aBoss )	: ZComrade(){	classID = CLASS_ZCommander;		itsBoss = aBoss;	itsUnderlings = NULL;	itsModifiers = NULL;		if ( itsBoss )		itsBoss->AddUnderling( this );}ZCommander::ZCommander()	: ZComrade(){	classID = CLASS_ZCommander;	itsBoss = NULL;	itsUnderlings = NULL;	itsModifiers = NULL;}/*-----------------------------------***  DESTRUCTOR  ***----------------------------------*/ZCommander::~ZCommander(){	// kill any timers associated with this commander		KillAllTimers( this );		// get rid of any modifiers		if ( itsModifiers )	{		itsModifiers->DisposeAll();		FORGETOBJECT( itsModifiers );	}		// dispose of any objects whose boss this is 		if ( itsUnderlings )		itsUnderlings->DisposeAll();			// remove us from our boss	if ( itsBoss )		itsBoss->RemoveUnderling( this );}/*-------------------------------***  HandleCommand  ***--------------------------------*//*access:			public	overrides:description: 	handle a command passed directly from menuins: 			<menuID, itemID> Id of menu and item that initiated the commandouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::HandleCommand( const short menuID, const short itemID ){	long    cmd;		cmd = ((long) menuID << 16 ) | itemID;		(void) ExecuteModifiers( kModifierHandleCmd2, &cmd );		if ( itsBoss )		itsBoss->HandleCommand(( cmd & 0xFFFF0000 ) >> 16, cmd & 0x0000FFFF );}/*-------------------------------***  HandleCommand  ***--------------------------------*//*access:			public	overrides:description: 	handle a command based on command IDins: 			<theCommand> command ID to be processedouts: 			nonenotes:			this class dispatches the standard Edit commands----------------------------------------------------------------------------------------*/void	ZCommander::HandleCommand( const ZoopCommand theCommand ){	// pass edit menu commands to the local handler methods. It is easier to override	// those methods than to override this method, but the choice is yours.		ZoopCommand     cmd = theCommand;		if ( ExecuteModifiers( kModifierHandleCommand, &cmd ))	{    	switch ( cmd )    	{    		case kCmdCut:    			DoCut();    			break;    		    		case kCmdCopy:    			DoCopy();    			break;    		    		case kCmdPaste:    			DoPaste();    			break;    		    		case kCmdClear:    			DoClear();    			break;    		    		case kCmdSelectAll:    			DoSelectAll();    			break;    		    		default:    			if ( itsBoss )    				itsBoss->HandleCommand( theCommand );    			break;    	}    }    else    {		if ( itsBoss )			itsBoss->HandleCommand( theCommand );    }}/*--------------------------------***  UpdateMenus  ***--------------------------------*//*access:			public	overrides:description: 	enable menu commands that pertain right nowins: 			noneouts: 			nonenotes:			enables paste if CanPasteType returns TRUE----------------------------------------------------------------------------------------*/void	ZCommander::UpdateMenus(){	// enable the paste command if there is something this object can	// paste.		if ( ExecuteModifiers( kModifierUpdateMenus, NULL ))	{    	if ( CanPasteType())    		gMenuBar->EnableCommand( kCmdPaste );    }		if ( itsBoss )		itsBoss->UpdateMenus();}/*------------------------------***  HandleAppleEvent  ***------------------------------*//*access:			public	overrides:description: 	respond to an Apple event - default just passes it to the bossins: 			<aeClass> the event class				<aeID> the event ID				<aeEvt> pointer to event parameters, etc				<reply> pointer to event reply recordouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::HandleAppleEvent(	AEEventClass aeClass, AEEventID aeID,										const AppleEvent* aeEvt, AppleEvent* reply ){		if ( itsBoss )		itsBoss->HandleAppleEvent( aeClass, aeID, aeEvt, reply );}/*---------------------------------***  HandleTimer  ***--------------------------------*//*access:			public	overrides:description: 	primary timer callbackins: 			<aTimer> timer that is calling back the objectouts: 			nonenotes:			normally applications override DoTimer instead, but you have the choice----------------------------------------------------------------------------------------*/void	ZCommander::HandleTimer( ZTimer* aTimer ){	FailNILParam( aTimer );	DoTimer( aTimer->GetID());}/*-------------------------------------***  Idle  ***-----------------------------------*//*access:			public	overrides:description: 	periodic call as long as this object in the command chainins: 			noneouts: 			nonenotes:			default just passes Idle up the chain----------------------------------------------------------------------------------------*/void	ZCommander::Idle(){	if ( itsBoss )		itsBoss->Idle();}/*-------------------------------------***  Type  ***-----------------------------------*//*access:			public	overrides:description: 	handle keyboard inputins: 			<theKey> the character typed				<modifiers> the modifier key stateouts: 			nonenotes:			this maps backspace to clear command----------------------------------------------------------------------------------------*/void	ZCommander::Type( const char theKey, const short modifiers ){	KeyInfo     keyInfo;		keyInfo.theKey = theKey;	keyInfo.modifiers = modifiers;		if ( ExecuteModifiers( kModifierTyping, &keyInfo ))	{    	if ( keyInfo.theKey == BACKSPACE_KEY )    		DoClear();    	else    	{    		if ( itsBoss )    			itsBoss->Type( keyInfo.theKey, keyInfo.modifiers );    	}    }}/*----------------------------------***  DoSuspend  ***---------------------------------*//*access:			public	overrides:description: 	the application is being suspendedins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::DoSuspend(){	if ( itsBoss )		itsBoss->DoSuspend();}/*-----------------------------------***  DoResume  ***---------------------------------*//*access:			public	overrides:description: 	the application is coming back to the frontins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::DoResume(){	if ( itsBoss )		itsBoss->DoResume();}/*---------------------------------***  AddUnderling  ***-------------------------------*//*access:			protected	overrides:description: 	add an underling commander to this one's list of underlingsins: 			<anUnderling> object to addouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::AddUnderling( ZCommander* anUnderling ){	if ( itsUnderlings == NULL )		FailNIL( itsUnderlings = new ZCommanderList());		itsUnderlings->AppendItem( anUnderling );}/*-------------------------------***  RemoveUnderling  ***------------------------------*//*access:			protected	overrides:description: 	remove an underling commander from this one's list of underlingsins: 			<anUnderling> object to removeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::RemoveUnderling( ZCommander* anUnderling ){	if ( itsUnderlings && itsUnderlings->Contains( anUnderling ))	{		itsUnderlings->DeleteObject( anUnderling );				if ( itsUnderlings->CountItems() < 1 )			FORGETOBJECT( itsUnderlings );	}	}/*---------------------------------***  SendMessage  ***--------------------------------*//*access:			public	overrides:		ZComradedescription: 	send all messages to the boss as well as any explicit listenersins: 			<aMessage> message to send				<msgData> data sent along with messageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::SendMessage( ZoopMessage aMessage, UntypedPtr msgData ){	// we always send this message to our boss		if ( itsBoss )		itsBoss->ReceiveMessage( this, aMessage, msgData );			ZComrade::SendMessage( aMessage, msgData );}/*--------------------------------***  OpenSubDialog  ***-------------------------------*//*access:			public	overrides:		description: 	open a dialog as an underling of this commanderins: 			<dlogID> resource ID of dialog to createouts: 			the dialog objectnotes:			this is deprecated in favour of OpenDialog in MacZoop 2.5 and later----------------------------------------------------------------------------------------*/ZDialog*	ZCommander::OpenSubDialog( const short dlogID ){#if _ZCOMMANDER_DIALOG_AWARE	ZDialog*	zd;		SetBeachBallCursor();		FailNIL( zd = new ZDialog( this, dlogID ));	try	{		zd->InitZWindow();		zd->Place();		zd->Select();	}	catch( ZoopError err )	{		FORGETOBJECT( zd );				throw err;	}		return zd;#else	return NULL;#endif}/*---------------------------------***  OpenDialog  ***---------------------------------*//*access:			publicoverrides:		description: 	create a views based dialogins: 			<dlogID> ID of resource to use as dialog templateouts: 			the dialog objectnotes:			recommended in MacZoop 2.5 and later----------------------------------------------------------------------------------------*/ZViewDialog*	ZCommander::OpenDialog( const short dlogID ){#if ! NO_NEW_DIALOGS	ZViewDialog*	zd;		SetBeachBallCursor();		FailNIL( zd = new ZViewDialog( this, dlogID ));	try	{		zd->InitZWindow();		zd->Place();		zd->Select();	}	catch( ZoopError err )	{		FORGETOBJECT( zd );				throw err;	}		return zd;#else	return NULL;#endif}/*---------------------------------***  AddModifier  ***--------------------------------*//*access:			public	overrides:		description: 	add a modifier object to the commander's list of modifiersins: 			<aModifier> modifier object to addouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::AddModifier( ZModifier* aModifier ){	FailNILParam( aModifier );		if ( itsModifiers == NULL )		FailNIL( itsModifiers = new ZModifierList());			itsModifiers->AppendItem( aModifier );}/*-------------------------------***  RemoveModifier  ***-------------------------------*//*access:			public	overrides:		description: 	remove a modifier object to the commander's list of modifiersins: 			<aModifier> modifier object to removeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::RemoveModifier( ZModifier* aModifier ){	FailNILParam( aModifier );	FailNILParam( itsModifiers );		itsModifiers->DeleteObject( aModifier );		if ( itsModifiers->CountItems() < 1 )		FORGETOBJECT( itsModifiers );}/*------------------------------***  ExecuteModifiers  ***------------------------------*//*access:			public	overrides:		description: 	allow modifiers a chance to do their processingins: 			<modifierMessage> message of interest to the modifier				<modData> additional data that the modifier may modify or processouts: 			TRUE if original code to execute, FALSE if it is to be bypassed.notes:			----------------------------------------------------------------------------------------*/Boolean	ZCommander::ExecuteModifiers( const long modifierMessage, UntypedPtr modData ){	ZModifier*	zm;	Boolean		hExec = TRUE;		if ( itsModifiers )	{		for ( long i = 1; i <= itsModifiers->CountItems(); i++ )		{			zm = (ZModifier*) itsModifiers->GetObject( i );				zm->Execute( this, modifierMessage, modData );			hExec = zm->GetHostExecution();		}	}	return hExec;}/*-----------------------------------***  SetBoss  ***----------------------------------*//*access:			public	overrides:		description: 	change the boss of this commander to another oneins: 			<aBoss> the new boss commanderouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::SetBoss( ZCommander* aBoss ){	if ( aBoss != itsBoss )	{		if ( itsBoss )			itsBoss->RemoveUnderling( this );				itsBoss = aBoss;		if ( itsBoss )			itsBoss->AddUnderling( this );	}	}/*----------------------------***  IsInDirectCommandChain  ***--------------------------*//*access:			public	overrides:		description: 	query whether the commander is part of the current command chain or notins: 			noneouts: 			TRUE if we are in the command chain, FALSE if notnotes:			----------------------------------------------------------------------------------------*/Boolean	ZCommander::IsInDirectCommandChain()	{	ZCommander*		tc = gCurHandler;	while( tc )	{		if ( tc == this )			return TRUE;					tc = tc->GetBoss();	}		return FALSE;}/*---------------------------------***  ReportFields  ***-------------------------------*//*access:			public	overrides:		description: 	supply data member info to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZCommander::ReportFields(){	ZComrade::ReportFields();	XSHOWFIELD( itsBoss, ft_objectref );	XSHOWFIELD( itsUnderlings, ft_objectref );	XSHOWFIELD( itsModifiers, ft_objectref );}