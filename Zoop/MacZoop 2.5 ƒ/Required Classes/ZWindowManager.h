/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			ZWindowManager.h		-- desktop class; handles floaters******			© 1996, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZWINDOWMANAGER__#define __ZWINDOWMANAGER__#include	"ZComrade.h"#ifndef __ZOBJECTARRAY__#include	"ZObjectArray.h"#endifclass	ZWindow;class	ZResourceFile;// container class definition for window listtypedef ZObjectList		ZWindowList;// structure of 'Wpos' resource:#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endiftypedef struct{	short	globalH;	short	globalV;	short	width;	short	height;	long	userRef;	long	reserved;}WPosResource, *WPosPtr, **WPosHdl;// resource types for saving position info:enum{	kWindowPosResType		= 'Wpos',	kDialogPosResType		= 'Dpos'};// note that you supply the ID for the resource, unless it's 0, in which case the window template// (or dialog template) ID is used.#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif// window manager can snap windows to other windows when dragging (optionally). These flags are used to// control the process. This is actually pretty cool... try it!enum{    snapNONE            = 0,    snapFLOATERS        = 1,    snapNONFLOATERS     = 2,    snapTOFLOATERS      = 4,    snapTONONFLOATERS   = 8,    snapTOMAINONLY      = 16,    snapTOSCREENEDGE    = 32,    snapALL             = 47};typedef unsigned char   SnapFlags;DEFINECLASSID( ZWindowManager, 'zwmg' );// window manager class:class	ZWindowManager	: public ZComrade{	friend class ZMenuBar;	protected:		ZWindowList*	nonFloaters;		// list of non-floating windows	ZWindowList*	floaters;			// list of floating windows			ZWindowList*	wmWindows;			// list of windows in menu	MenuHandle		wmMenu;				// handle of "Windows" menu if any	short			wmItemOffset;		// item count of initial number of items in menu	Point			globalPlaceLoc;		// placement position	Rect			fStoredZoom;		// stored zoom for DeactivateForDialog	Rect			fStoredZoomSource;	// ditto but source rect	Boolean			wmActive;			// tracks active state of entire window manager	Boolean			wmDDDeactivated;	// deactivated by non-MacZoop dialog or alert.public:	ZWindowManager();	virtual	~ZWindowManager();		virtual void		AddWindow( ZWindow* aWindow );	virtual void		RemoveWindow( ZWindow* aWindow );		virtual void		HideWindow( ZWindow* aWindow );	virtual void		ShowWindow( ZWindow* aWindow );		virtual void		SelectWindow( ZWindow* aWindow );	virtual void		DragWindowOutline( ZWindow* aWindow, Point startPt, const short modifiers, SnapFlags snap = snapNONE, Rect* dragLimit = NULL );	virtual void		Suspend();	virtual void		Resume();	virtual void		Deactivate();	virtual void		DeactivateForDialog( short dlogID, Boolean isAlert = FALSE );	virtual void		Activate();		virtual ZWindow*	GetTopWindow();	virtual ZWindow*	GetTopFloater();	virtual ZWindow*	GetBottomFloater();		virtual void		MoveWindowBehind( ZWindow* aWindow, ZWindow* behindWindow = NULL );		virtual ZWindow*	LocateWindow( const Point globalMouse );	virtual ZWindow*	GetNthWindow( const long n );	virtual ZWindow*	GetNthFloater( const long n );	virtual Boolean		IsDialog( ZWindow* aWindow );	virtual Boolean		IsModalDialogActive();		virtual Boolean		GetUniqueUntitledName( Str255 wName );	virtual void		FloatIdle();		virtual short		CountWindows( const Boolean visOnly = FALSE );	virtual short		CountFloaters();		virtual void		InitiallyPlace( ZWindow* aWindow );	virtual void		ZoomWindowClosed( ZWindow* aWindow );// saving/restoring window positions- use ZWindow methods for easier use (these are lowest level)		virtual short		SaveWindowPosition( ZWindow* aWindow, ZResourceFile* aFile = NULL, short id = 0 );	virtual void		RestoreWindowPosition( ZWindow* aWindow, ZResourceFile* aFile = NULL, const short id = 0 );		virtual void		StackWindows( Boolean resize = TRUE, Boolean mainList = TRUE, Boolean floaterList = FALSE );	virtual void		TileWindows( Boolean verticalPreferred = TRUE );		virtual ZWindow*	FindWindowByUserID( long id );	virtual void		DragWindowCallback( ZWindow* draggedWindow, RgnHandle dragRgn ){}	virtual long		DragRegion( RgnHandle rgn, Point startPt, Rect* limitRect, SnapFlags snap = snapNONE );	virtual CGrafPtr    OpenScreenPort();	virtual void		DisposeScreenPort( CGrafPtr aPort );		virtual long        DragGrayRgnSnap( RgnHandle rgn, Point startPt, Rect* limitRect, DragGrayRgnUPP wdUPP, SnapFlags snap = snapNONE );    virtual void        GetMouseSnap( Point* pt, SnapFlags snap = snapNONE );        virtual void		ReportFields();    private:	void				BringBehind( ZWindow* aWindow, ZWindow* behindWindow );	void				PostActivation( ZWindow* aWindow, Boolean state );		void				CalcWindowRgns( ZWindow* aWindow, RgnHandle aRgn );	void				ShowHideFloater( ZWindow* aFloater, Boolean hide );	Boolean				WindowOnDesktop( Rect* wFrame );	protected:	// these methods accessible to gMenuBar, but not user's code.	virtual void		SetWindowsMenu( MenuHandle aMenu );	virtual void		SelectWindowFromMenu( const short itemID );	virtual void		BuildWindowsMenu();		virtual Boolean		CommandClickInFrontDragBar( ZWindow* target, const Point startPt );		static pascal void	DragWindowsProc();	static ZWindow*		sDraggedWindow;	static RgnHandle	sDraggedRegion;	static Point		sRelMouseOffset;};// This object is created by the application and installed as the global gWindowManager.// Windows ask this object to manage their selection, etc instead of calling the Mac's// window manager directly. This allows us to have floaters in our app. Windows have a// "isFloater" flag, which is inited automatically by detecting which WDEF is used, though this// can be forced as needed. The event handler also calls this to manage certain window chores// like dragging, to make sure the Mac Window Manager is never given the chance to screw things// up for us.// WARNING: You must not call high-level mac window-manager calls from your code within MacZoop.// Calls such as SelectWindow() and DragWindow() in particular will cause problems. FrontWindow()// must be used with caution, since it does not distinguish between floating and non-floating// windows. Methods are provided here and in ZApplication that provide the equivalent floater-// savvy functionality.// New in version 1.8.3 (July 1998). ZWindowManger is now a subclass of ZComrade. Why? This allows// an object to get notified by activities involving other windows from a central source. This makes// implementing things like inspector windows much easier- become a listener of gWindowManager to// discover when other windows are activated, shown, hidden, created and destroyed. Doing this by// other means is possible, but generally more involved.// messages: In all cases, parameter passed is the window in question, except mac dialog messages// which pass no parameter (NULL).enum{	kWMMsgWindowAdded			= 'wm++',	kWMMsgWindowRemoved			= 'wm--',	kWMMsgWindowActivated		= 'wmak',	kWMMsgWindowDeactivated 	= 'wmdk',	kWMMsgWindowShown			= 'wmv+',	kWMMsgWindowHidden			= 'wmv-',	kWMMsgWindowMoved			= 'wmmv',	kWMMsgMacDialogUp			= 'wmd+',	kWMMsgMacDialogDown			= 'wmd-',	kWMMsgFloaterActivated		= 'wmfa',	kWMMsgFloaterDeactivated	= 'wmfd'};// windows will snap to others if dragged within this many pixels of an edge:enum{	kSnapTolerance		= 8};/*ABOUT Window-snapping...Window snapping is a custom drag behaviour that helps you align windows with each other as they are draggedon the screen. This is especially neat if you have a series of palettes, and is widely used in Adobe applications.The implementation here is very general, as you might expect for MacZoop. You can snap floaters or main windowsto the other floaters, the other mains, or both, or just the active main. This is controlled by the <snapFlags>passed down through DragWindowOutline to the lower methods.Snap behaviour is set on a per-window basis, the default being set to snapNONE (see below). Set your window's<windowSnap> member to the behaviour flags you want, or use the ZWindow::SetSnap() method. The value returnedby the ZWindow::GetSnap() method is passed to DragWindowOutline().Snapping works by detecting the edges extending along all edges of a window. When a similar edge of the draggedwindow comes within the tolerance range of the snap edge, the drag outline will jump into alignment. The snap edgesextend infinitely in all directions from the snap object, and operate on all four edges of both snapper andsnapee. This allows snapping to edges, corners, and all combinations of them. The easiest way to understand thisbehaviour is to try it out.Flags:snapNONE- no snapping is done at allsnapFLOATERS- only floating windows will be snappedsnapNONFLOATERS- only non-floating windows will be snappedsnapTOFLOATERS- the window being dragged will only snap to floating windowssnapTONONFLOATERS- the window being dragged will only snap to non-floating windowssnapMAINONLY- the window being dragged will only snap to the active non-floating windowflags can be added together to give combinations of snappers and snapees.snapALL is a handy shortcut which is the sum of the flags, allowing all windows to snap to all others.*/#endif