/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZWindow.cpp			-- the window object******			© 1996, Graham Cox**			14/11/96- modified to support undo and printing.***************************************************************************************************/#include	"ZWindow.h"#include	"MacZoop.h"#include	"ZEventHandler.h"#include	"BottleneckFix.h"#if _INSTALL_STD_MOUSE_TRACKING#include	"ZMouseTracker.h"#endif#if APPEARANCE_MGR_AWARE	#include	"Appearance.h"#endif#if _WPOS_WINDOW_PLACEMENT#include	"ZResourceFile.h"#endifstatic short CalculateOffsetAmount(	short idealStartPoint,									short idealEndPoint,									short idealOnScreenStartPoint,									short idealOnScreenEndPoint,									short screenEdge1,									short screenEdge2 );									DragTrackingHandlerUPP	ZWindow::sDragTrackProc = NULL;DragReceiveHandlerUPP	ZWindow::sDragReceiveProc = NULL;ZView*					ZWindow::sDropTargetView = NULL;extern OSErr			gDragErr;static ModalFilterUPP   gDSKeyUPP = NewModalFilterUPP( DSKeyProc );CLASSCONSTRUCTOR( ZWindow );/*------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZWindow::ZWindow( ZCommander* aBoss, const short windowID )	: ZView( aBoss ), MTaskStack(){	classID = CLASS_ZWindow;		windID = windowID;	macWindow = NULL;	dirty = FALSE;	isNamed = FALSE;	stationeryFile = FALSE;	macFile.vRefNum = kNoFile;	macFile.parID = 0;	macFile.name[0] = 0;	macFType = 0;	printable = FALSE;	isPrinting = FALSE;	floating = FALSE;	fResizeable = FALSE;	disableAutoClose = FALSE;	SetRect( &zoomSource, 0, 0, 0, 0 );	windowSnap = snapNONE;	fHandler = this;	fPrintView = this;	fFiler = NULL;		// initial sizeRect is set to an arbitrary size- 'WLIM' resource	// will override this, or program can set it		SetRect( &sizeRect,120 ,90 ,2000, 2000 );}ZWindow::ZWindow()	: ZView(), MTaskStack(){	classID = CLASS_ZWindow;	windID = 0;	macWindow = NULL;	dirty = FALSE;	isNamed = FALSE;	stationeryFile = FALSE;	macFile.vRefNum = kNoFile;	macFile.parID = 0;	macFile.name[0] = 0;	macFType = 0;	printable = FALSE;	isPrinting = FALSE;	floating = FALSE;	fResizeable = FALSE;	disableAutoClose = FALSE;	SetRect( &zoomSource, 0, 0, 0, 0 );	SetRect( &sizeRect, 0, 0, 0, 0 );	windowSnap = snapNONE;	fHandler = this;	fPrintView = this;	fFiler = NULL;}	/*------------------------------***  DESTRUCTOR  ***---------------------------------*/ZWindow::~ZWindow(){	// set the current port to something else		if ( FrontWindow())		SetPortWindowPort( FrontWindow()); 		// wMgr no longer needs us			gWindowManager->RemoveWindow( this );		if ( fFiler )		FORGETOBJECT( fFiler );		if ( GetMacWindow())	{		#if _AUTO_WPOS_FOR_FLOATERS				if ( floating )			SavePosition();				#endif				if ( MacHasDM())			RemoveDragHandlers();		DisposeWindow( GetMacWindow());	}		macWindow = NULL;}/*--------------------------------***  InitZWindow  ***---------------------------------*//*access:			publicoverrides:		description: 	Initialise the window as neededins: 			noneouts: 			nonenotes:			this is called after creating all window objects - overridable.----------------------------------------------------------------------------------------*/void	ZWindow::InitZWindow(){	MakeMacWindow( windID );	if ( gMacInfo.hasAppearanceMgr )		InstallBottleneckFix( GetMacWindow());	if ( gMacInfo.hasDragManager )		InstallDragHandlers();	// tell the window manager of our existence. This must be done after the	// full build of the mac window since the window manager needs to get	// information from it. Thus if you override this method, make sure you	// make the same call.		gWindowManager->AddWindow( this );		#if _AUTO_WPOS_FOR_FLOATERS		if ( floating )		RestorePosition();		#endif		InitSizeFromResource( kWindowSizeLimitResType );	ExecuteModifiers( kModifierWindowOpen, NULL );	SetNoBackgroundErase( TRUE );}/*-------------------------------***  MakeMacWindow  ***--------------------------------*//*access:			protectedoverrides:		description: 	create underlying Mac toolbox window structure for the objectins: 			<windID> ID of WIND or ZWIN (Carbon) window resource to useouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::MakeMacWindow( const short windID ){#if USE_MODERN_WINDOW_MGR	// with modern window manager, try loading from 'ZWIN', rather than WIND. 	// A WIND will be used if no ZWIN is founnd, but it is strongly recommended that Carbon	// apps are based on ZWIN resources to obtain the correct layering behaviour.		if ( gMacInfo.hasModernWindowMgr )	{		// we create our windows from a 'ZWIN' resource				MZWindowTemplateHdl	zwin;				FailNILRes( zwin = ( MZWindowTemplateHdl ) GetResource( kMacZoopWindowTemplateType, windID ));		HNoPurge((Handle) zwin );				// if wClass is kSpecialTooltipWindowClassID, treat this as a special case - make a plain window that		// floats. This is needed to support tooltips under carbon, where such a window doesn't have a		// defined class				if ((*zwin)->wClass == kSpecialTooltipWindowClassID )		{		#if TARGET_API_MAC_CARBON && UNIVERSAL_INTERFACES_VERSION >= 0x0335			WindowDefSpec	wSpec;						wSpec.defType = kWindowDefProcID;			wSpec.u.procID = kPlainDialogVariantCode;						FailOSStatus( CreateCustomWindow( &wSpec, kHelpWindowClass, (*zwin)->attribs, &(*zwin)->bounds, &macWindow ));			floating = TRUE;		#else			//#warning - this feature requires UH 3.4 or later and CarbonLib 1.1 or later			FailOSErr( kMacZoopUnsupportedFeatureErr );		#endif		}		else			FailOSStatus( CreateNewWindow((*zwin)->wClass, (*zwin)->attribs, &(*zwin)->bounds, &macWindow ));					SetWTitle( GetMacWindow(), (*zwin)->title );		SetBackColour( &(*zwin)->backColour );				fResizeable = ((*zwin)->attribs & kWindowResizableAttribute ) != 0;				HPurge((Handle) zwin );		ReleaseResource((Handle) zwin );	}	else	{#endif		if ( gMacInfo.supportsColour )		{			FailNIL( macWindow = GetNewCWindow( windID, NULL, NULL ));			SetPortWindowPort( GetMacWindow());		}		else			FailNIL( macWindow = GetNewWindow( windID, NULL, NULL ));					short v = GetWVariant( macWindow );		fResizeable = (( v == documentProc ) || ( v == zoomDocProc ));			#if USE_MODERN_WINDOW_MGR	}#endif	// store the background colour so we can avoid GetAuxWin, etc.		SetFrame( WINDOWPORTRECT( GetMacWindow()));			// so we can identify the window, we set the windowKind to a special value. The refCon	// contains the object reference so we can freely locate the object from the window and	// vice versa. Your application must not touch the refCon- add members to your window	// objects instead.		SetWindowKind( GetMacWindow(), kMacZoopWindowIdentifier );	SetWRefCon( GetMacWindow(), (long) this );		// what WDEF are we using for this window? If it's one of the known "floater" types,	// then we should set the floating flag automatically- one less thing the programmer	// needs to worry about, and will work for the common cases.#if USE_MODERN_WINDOW_MGR	if ( gMacInfo.hasModernWindowMgr )	{		// setting the floats flag just means looking at the window class		WindowClass		wClass;				GetWindowClass( GetMacWindow(), &wClass );		floating |= ( wClass == kFloatingWindowClass );	}	else	{#endif			WindTemplateHdl		wTH = (WindTemplateHdl) GetResource( 'WIND', windID );				if ( wTH )		{			// the system floater has a proc of 124. The commonly used "Infinity" windoid			// has a proc of 128.						short	pID = (*wTH)->procID / 16;						// with appearance manager, the WDEF IDs for floating windows are 66 & 67						#if APPEARANCE_MGR_AWARE						if ( gMacInfo.hasAppearanceMgr )				floating |= ( 	pID == kWindowUtilityDefProcResID ||								pID == kWindowUtilitySideTitleDefProcResID );						#endif						floating |= (	pID == kFloatingWindowDefinition ||							pID == kInfinityWindoidDefinition );			ReleaseResource((Handle) wTH );		}#if USE_MODERN_WINDOW_MGR	}#endif	// allocate a unique title. This we'll base on the current title	// (which should be "untitled"), with an appended digit to ensure uniqueness		Str255	wTitle;		GetWTitle( GetMacWindow(), wTitle );	if ( gWindowManager->GetUniqueUntitledName( wTitle ))		SetWTitle( GetMacWindow(), wTitle );			CopyPString( wTitle, macFile.name );		// set up a theme-aware environment:		ZViewEnvironment*	env = MakeEnvironment();		if ( env )	{		env->SetThemedBack( floating? kThemeBrushUtilityWindowBackgroundActive : kThemeBrushDocumentWindowBackground );		env->SetThemedInactiveBack( floating? kThemeBrushUtilityWindowBackgroundInactive : kThemeBrushDocumentWindowBackground );	}}/*-------------------------------***  MakeMacWindow  ***--------------------------------*//*access:			protectedoverrides:		description: 	create underlying Mac toolbox window structure for the objectins: 			<aRect> global bounds rect of initial window				<title> title string				<visible> whether window is visible or not				<varCode> variation code of window proc				<hasCloseBox> TRUE if window has a close box				<userData> window refConouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZWindow::MakeMacWindow( Rect* aRect, Str255 title, Boolean visible, short varCode, Boolean hasCloseBox, void* userData ){	if ( gMacInfo.supportsColour )		FailNIL( macWindow = NewCWindow( NULL, aRect, title, visible, varCode, NULL, hasCloseBox, 0 ));	else		FailNIL( macWindow = NewWindow( NULL, aRect, title, visible, varCode, NULL, hasCloseBox, 0 ));	SetWindowKind( GetMacWindow(), kMacZoopWindowIdentifier );	SetWRefCon( GetMacWindow(), (long) this );	SetFrame( WINDOWPORTRECT( GetMacWindow()));	CopyPString( title, macFile.name );}#pragma mark -/*----------------------------------***  Activate  ***----------------------------------*//*access:			publicoverrides:		description: 	window is becoming activeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::Activate(){	if ( !floating )		gCurHandler = fHandler;	else		fHandler = this;			ZView::Activate();	DrawGrow();	PerformUpdate();}/*---------------------------------***  Deactivate  ***---------------------------------*//*access:			publicoverrides:		description: 	window is becoming inactiveins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::Deactivate(){	ZView::Deactivate();	DrawGrow();	PerformUpdate();}/*-------------------------------***  PerformUpdate  ***--------------------------------*//*access:			publicoverrides:		description: 	redraw the content of the window based on pending update eventins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::PerformUpdate(){	GrafPtr		savePort;		GetPort( &savePort );	Focus();		// start the update sequence		BeginUpdate( GetMacWindow());		try	{		RgnHandle	vis;				FailNIL( vis = NewRgn());		GETWINDOWVISRGN( GetMacWindow(), vis );				if ( ! EmptyRgn( vis ))		{			PrepareForDrawing();			Draw();		}				DisposeRgn( vis );	}	catch( ZoopError err )	{		// do not propagate redraw errors	}		EndUpdate( GetMacWindow());	SetOrigin( 0, 0 );	SetPort( savePort );}/*------------------------------------***  Draw  ***------------------------------------*//*access:			publicoverrides:		description: 	draw the actual window contentins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::Draw(){	// if we are growable, we should clip out the growbox area otherwise	// the DrawContent call may erase the growbox, etc		Rect	    r = *WINDOWPORTRECT( GetMacWindow());		if ( IsResizeable())	{		RgnHandle   temp;				ClipRect( &r );				r.left = r.right - kStdScrollbarWidth;		r.top = r.bottom - kStdScrollbarWidth;				temp = NewRgn();		RectRgn( gUtilRgn, &r );		GETWINDOWCLIPRGN( GetMacWindow(), temp );		DiffRgn( temp, gUtilRgn, temp );		SETWINDOWCLIPRGN( GetMacWindow(), temp );		DisposeRgn( temp );	}		if ( fChildViews )		DrawAll();	else	{		EraseBackground();		DrawContent();	}		SetOrigin( 0, 0 );	ClipRect( WINDOWPORTRECT( GetMacWindow()));			// for compatibility, we draw all controls as long as we have no child views	// Windows that have subviews must never call DrawControls - views draw their	// own controls as needed		if ( fChildViews == NULL )		DrawControls( GetMacWindow());		DrawGrow();}/*--------------------------------***  SetBackColour  ***-------------------------------*//*access:			publicoverrides:		description: 	set the background colour of the windowins: 			<aColour> colour to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::SetBackColour( const RGBColor* aColour ){	ZView::SetBackColour( aColour );	#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON		if ( gMacInfo.hasModernWindowMgr )	{		SetWindowContentColor( GetMacWindow(), aColour );	}#endif}	/*-----------------------------------***  DrawGrow  ***---------------------------------*//*access:			publicoverrides:		description: 	draw the growbox for the windowins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::DrawGrow(){	if ( GetMacWindow())	{		if ( IsResizeable())		{			Rect	r;					#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON			if ( gMacInfo.hasModernWindowMgr )				GetWindowBounds( GetMacWindow(), kWindowGrowRgn, &r );			else			{		#endif							r = *WINDOWPORTRECT( GetMacWindow());				r.left = r.right - kStdScrollbarWidth;				r.top = r.bottom - kStdScrollbarWidth;					#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON			}		#endif				Focus();			ClipRect( &r );			DrawGrowIcon( GetMacWindow());		}	}}#pragma mark -/*----------------------------------***  CalcPages  ***---------------------------------*//*access:			publicoverrides:		description: 	calculate pagination for printing window content to printerins: 			<paperRect> the rectangle of the drawable area of the paper				<pagesH> receives page tiles horizontally				<pagesV> receives page tiles verticallyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::CalcPages( const Rect& paperRect, short* pagesH, short* pagesV ){	Rect	cr;	short	pWidth, pHeight, cWidth, cHeight;		fPrintView->GetBounds( &cr );		pWidth = paperRect.right - paperRect.left;	pHeight = paperRect.bottom - paperRect.top;		cWidth = cr.right - cr.left;	cHeight = cr.bottom - cr.top;		*pagesH = (cWidth / pWidth) + 1;	*pagesV = (cHeight / pHeight) + 1;}/*--------------------------------***  PrintOnePage  ***--------------------------------*//*access:			publicoverrides:		description: 	renders a page to the printerins: 			<paperRect> the rectangle of the drawable area of the paper				<pageNum> which page is being printed (1..n)outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::PrintOnePage( const short pageNum, const Rect& paperRect ){	Rect		pr;	short		hp, vp, dH, dV;		// calculate the printing area		CalcPages( paperRect, &hp, &vp );	pr = paperRect;		dH = paperRect.right  * ((pageNum - 1) % hp);	dV = paperRect.bottom * ((pageNum - 1) / hp);		OffsetRect( &pr, dH, dV );		// draw the contents.		SetOrigin( pr.left, pr.top );	SetRootPort((CGrafPtr) CURRENTPORT );		sViewBaseClipRgn = NewRgn();	RectRgn( sViewBaseClipRgn, &pr );		fPrintView->PrepareForDrawing();	fPrintView->DrawContent();	SetOrigin( 0, 0 );	SetRootPort( NULL );	DisposeRgn( sViewBaseClipRgn );	sViewBaseClipRgn = NULL;}/*------------------------------------***  Click  ***-----------------------------------*//*access:			publicoverrides:		description: 	handle a mouse click in the windowins: 			<mouse> location of mouse local to window				<modifiers> state of modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::Click( const Point mouse, const short modifiers ){	ZView::Click( mouse, modifiers );	SetOrigin( 0, 0 );}/*-------------------------------***  ClickInSamePlace  ***-----------------------------*//*access:			publicoverrides:		description: 	resolve sequential clicks into double-clicks, etcins: 			<ptA, ptB> location of two sequential clicksouts: 			TRUE if points should be considered part of a double-clicknotes:			this further resolves clicks based on which views were clicked; caller				deals with the timing of the clicks, this only needs to be concerned				about their spatiality----------------------------------------------------------------------------------------*/Boolean		ZWindow::ClickInSamePlace( const Point ptA, const Point ptB ){	Boolean		spClick = FALSE;	ZView		*a, *b;		a = FindView( ptA );	b = FindView( ptB );		if ( a == b )	{		if ( a && ( a != this ))			spClick = a->ClickInSamePlace( ptA, ptB );			else			spClick = TRUE;	}		return spClick;}/*----------------------------------***  SetSizeRect  ***-------------------------------*//*access:			publicoverrides:		description: 	set the minimum and maximum growable size of the windowins: 			<szRect> rectangle indicating sizesouts: 			nonenotes:			top and left contain minimum sizes, bottom and right the max sizes.----------------------------------------------------------------------------------------*/void	ZWindow::SetSizeRect( const Rect& szRect ){	sizeRect = szRect;		// make sure max is not less than min:		sizeRect.right = MAX( sizeRect.right, sizeRect.left );	sizeRect.bottom = MAX( sizeRect.bottom, sizeRect.top );		// if the window does not conform to the size constraints, change its size so	// that it does.		Rect		pr;		pr = *WINDOWPORTRECT( GetMacWindow());		if (( pr.right - pr.left ) < sizeRect.left 	||		( pr.right - pr.left ) > sizeRect.right ||		( pr.bottom - pr.top ) < sizeRect.top 	||		( pr.bottom - pr.top ) > sizeRect.bottom )		SetSize( pr.right - pr.left, pr.bottom - pr.top );}/*----------------------------------***  GetSizeRect  ***-------------------------------*//*access:			publicoverrides:		description: 	return the minimum and maximum growable size of the windowins: 			<szRect> receives rectangleouts: 			nonenotes:			top and left contain minimum sizes, bottom and right the max sizes.----------------------------------------------------------------------------------------*/void	ZWindow::GetSizeRect( Rect* szRect ){	*szRect = sizeRect;}/*-------------------------------------***  Close  ***----------------------------------*//*access:			publicoverrides:		description: 	attempt to close the windowins: 			<phase> application phase - running or quittingouts: 			TRUE if window actually did close, FALSE if it was preventednotes:			A window may not close if the user cancels a save, for example----------------------------------------------------------------------------------------*/Boolean	ZWindow::Close( const short phase ){	// the user wants to close the window. This checks the dirty flag and if dirty, asks the	// user if they want to save changes, if so, this calls save.		// first see if we have any subsidiary windows and ask them to close		if (! CloseSubsidiaryWindows( phase ))		return FALSE;		short check = CheckForSave( phase );		if ( check != kCloseCancel )	{		if ( gFontMenuID )			gMenuBar->DisableCommand( gFontMenuID, 0 );		Hide();				SendMessage( kMsgWindowClosing, NULL );		// tell interested parties we're going away				// to make life safer, we defer the actual deletion until the app gets back to		// the main loop, by making a chore here to do the dirty work for us. This is		// especially helpful with dialogs. The application will delete the chore once		// it's done.				ZWindowCloseChore*	cc;				FailNIL( cc = new ZWindowCloseChore( this ));				gApplication->AddChore( cc );				if ( itsBoss )		{			itsBoss->RemoveUnderling( this );			itsBoss = NULL;		}						return TRUE;	// was closed	}	else		return FALSE;	// wasn't closed}/*-----------------------------***  CloseSubsidiaryWindows  ***-------------------------*//*access:			publicoverrides:		description: 	attempt to close all windows this one is the boss ofins: 			<phase> application phase - running or quittingouts: 			TRUE if windows actually did close, FALSE if any were preventednotes:			----------------------------------------------------------------------------------------*/Boolean	ZWindow::CloseSubsidiaryWindows( const short phase ){	Boolean  	allClosed = TRUE;		if ( itsUnderlings )	{		// there are some commanders supervised by this object. If they are		// window objects, call their close method				ZWindow*	w;		long		i = itsUnderlings->CountItems();				while( i )		{			// use RTTI to make sure the object is some sort of window						w = dynamic_cast<ZWindow*>(itsUnderlings->GetObject( i-- ));						if (w)			{				// yes it is, so ask it to close								if (! w->Close( phase ))				{					// if it didn't close, then abandon the closure sequence										allClosed = FALSE;					break;				}			}		}	}		return allClosed;}/*-----------------------------------***  SendBehind  ***-------------------------------*//*access:			publicoverrides:		description: 	send this window behind the one passedins: 			<aWindow> putthis window behind this one - or behind all if NULLouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::SendBehind( ZWindow* aWindow ){	gWindowManager->MoveWindowBehind( this, aWindow );	}/*----------------------------------***  DoWindowDrag  ***------------------------------*//*access:			publicoverrides:		description: 	drag this window on screenins: 			<mouse> mouse locaiton in global coordinates				<modifiers> modifier keysouts: 			nonenotes:			default method calls back to window manager. Drag is vectored through the				window to allow drag behaviour to be overridden individually if required----------------------------------------------------------------------------------------*/void	ZWindow::DoWindowDrag( const Point mouse, const short modifiers ){	gWindowManager->DragWindowOutline( this, mouse, modifiers, GetSnap());}/*--------------------------------------***  Hide  ***----------------------------------*//*access:			publicoverrides:		description: 	make this window no longer visible on screenins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::Hide(){	Boolean wasVis = IsVisible();		gWindowManager->HideWindow( this );		if ( wasVis )		gWindowManager->ZoomWindowClosed( this );}/*--------------------------------------***  Show  ***----------------------------------*//*access:			publicoverrides:		description: 	make this hidden window visible on screenins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::Show(){	gWindowManager->ShowWindow( this );}/*------------------------------------***  Select  ***----------------------------------*//*access:			publicoverrides:		description: 	make this window visible if necessary and active (frontmost)ins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::Select(){	Boolean		wasVis = IsVisible();		gWindowManager->SelectWindow( this );		if ( ! wasVis )	{		// select a subview if there isn't one focused				if ( fChildViews && ( fHandler == NULL || fHandler == this ) && !floating )			Type( TAB_KEY, 0 );				PerformUpdate();	}}/*-----------------------------------***  PlaceAt  ***----------------------------------*//*access:			publicoverrides:		description: 	place the window at the global coordinates on screenins: 			<hGlobal, vGlobal> position toplace the window atouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::PlaceAt( const short hGlobal, const short vGlobal ){	MoveWindow( GetMacWindow(), hGlobal, vGlobal, FALSE );}/*------------------------------------***  Place  ***-----------------------------------*//*access:			publicoverrides:		description: 	place the window on screen according to currently set rulesins: 			noneouts: 			nonenotes:			will stagger the window or restore it to its previous saved position----------------------------------------------------------------------------------------*/void	ZWindow::Place(){	gWindowManager->InitiallyPlace( this );		if ( macFile.vRefNum != kNoFile && ! IsVisible())		RestorePosition();}/*--------------------------------***  PlaceRelative  ***-------------------------------*//*access:			publicoverrides:		description: 	place the window on screen relative to another windowins: 			<relWindow> window to posiution relative to				<aPlacing> how the window should be placedouts: 			nonenotes:			for some placings, relWindow is ignored----------------------------------------------------------------------------------------*/void	ZWindow::PlaceRelative( ZWindow* relWindow, WindowPlacing aPlacing ){	short		h, v, hh, vv;	short		ww, wh, sw, sh;	GDHandle	sDev;		GetContentRegion( gUtilRgn );		ww = REGIONBOUNDINGBOX( gUtilRgn )->right - REGIONBOUNDINGBOX( gUtilRgn )->left;	wh = REGIONBOUNDINGBOX( gUtilRgn )->bottom - REGIONBOUNDINGBOX( gUtilRgn )->top;		if ( relWindow && ( aPlacing == kCentreOnParent ||					    aPlacing == kAlertPositionOnParent ||					    aPlacing == kStaggerOnParent ))	{		relWindow->GetContentRegion( gUtilRgn );				sw = REGIONBOUNDINGBOX( gUtilRgn )->right - REGIONBOUNDINGBOX( gUtilRgn )->left;		sh = REGIONBOUNDINGBOX( gUtilRgn )->bottom - REGIONBOUNDINGBOX( gUtilRgn )->top;		hh = REGIONBOUNDINGBOX( gUtilRgn )->left;		vv = REGIONBOUNDINGBOX( gUtilRgn )->top;	}	else	{		sDev = GetMainDevice();				sw = (*sDev)->gdRect.right;		sh = (*sDev)->gdRect.bottom;		hh = vv = 0;		}		if ( aPlacing == kStaggerOnParent )	{		h = hh + 10;		v = vv + 20;	}	else	{		// centre on something				h = hh + ( sw / 2 ) - ( ww / 2 );				if ( aPlacing == kAlertPositionOnParent ||			 aPlacing == kAlertPositionOnScreen )			v = vv + ( sh / 3 ) - ( wh / 2 );		else			v = vv + ( sh / 2 ) - ( wh / 2 );	}		PlaceAt( h, v );}/*---------------------------------***  SavePosition  ***-------------------------------*//*access:			publicoverrides:		description: 	save the window position ins: 			<id> resource ID under which to save this window's dataouts: 			nonenotes:			saves in either local document file if there is one or global prefs file----------------------------------------------------------------------------------------*/void	ZWindow::SavePosition( short id ){#if _WPOS_WINDOW_PLACEMENT	if ( id == 0 )		id = windID;			ZResourceFile*	aFile = NULL;		if ( macFile.vRefNum != kNoFile )		FailNIL( aFile = new ZResourceFile( macFile ));			gWindowManager->SaveWindowPosition( this, aFile, id );	if ( aFile )		FORGETOBJECT( aFile );		#endif}/*-------------------------------***  RestorePosition  ***------------------------------*//*access:			publicoverrides:		description: 	restore the window position ins: 			<id> resource ID under which this window's data is savedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::RestorePosition( short id ){#if _WPOS_WINDOW_PLACEMENT	if ( id == 0 )		id = windID;			ZResourceFile*	aFile = NULL;		if ( macFile.vRefNum != kNoFile )		FailNIL( aFile = new ZResourceFile( macFile ));		gWindowManager->RestoreWindowPosition( this, aFile, id );		if ( aFile )		FORGETOBJECT( aFile );			#endif}#pragma mark -/*--------------------------------***  HandleCommand  ***-------------------------------*//*access:			publicoverrides:		description: 	handle generic window-level commandsins: 			<aCmd> command to handleouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::HandleCommand( const ZoopCommand aCmd ){	EventRecord		ev;		switch ( aCmd )	{		case kCmdClose:			gApplication->GetCurrentEvent( &ev );						if ( ev.modifiers & optionKey )				gApplication->CloseAll( Floats());			else				Close( kRunning );			break;				case kCmdSave:			Save( FALSE );			break;				case kCmdSaveAs:			Save( TRUE );			break;				case kCmdRevert:			Revert();			break;				default:			// pass other commands up to this object's boss						ZView::HandleCommand( aCmd );			break;	}}/*---------------------------------***  UpdateMenus  ***--------------------------------*//*access:			publicoverrides:		description: 	enable generic window-level commandsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::UpdateMenus(){	// this enables the Close, Save and SaveAs commands.		EventRecord		ev;		gApplication->GetCurrentEvent( &ev );		// show "Close All" if the option key is down, else "Close"		if (ev.modifiers & optionKey )		gMenuBar->SetCommandText( kCmdClose, kMiscStrListID, 8 );	else		gMenuBar->SetCommandText( kCmdClose, kMiscStrListID, 9 );		gMenuBar->EnableCommand( kCmdClose );		if ( IsDirty())	{		gMenuBar->EnableCommand( kCmdSave );				if ( isNamed )			gMenuBar->EnableCommand( kCmdRevert );	}	gMenuBar->EnableCommand( kCmdSaveAs );	// call the boss to enable her menus		ZView::UpdateMenus();}/*-----------------------------------***  SetTask  ***----------------------------------*//*access:			publicoverrides:		description: 	attach new undo task to the stack for this windowins: 			<aTask> new undo task to attachouts: 			nonenotes:			this automatically marks the document dirty----------------------------------------------------------------------------------------*/void		ZWindow::SetTask( ZUndoTask* aTask ){	// if we're not dirty when the task arrives, then this must be the first task. Let it	// know so that if the task is undone, it can clear the dirty flag so that undoing the	// first task doesn't result in the "save changes?" alert.		if ( ! IsDirty() && aTask )		aTask->SetIsFirstTask();		SetDirty( TRUE );	// document has been changed by the task		AddTaskToUndo( aTask );}/*------------------------------------***  Type  ***------------------------------------*//*access:			publicoverrides:		description: 	handle keyboard inout common to all windowsins: 			<theKey> character typed				<modifiers> modifier keysouts: 			nonenotes:			Tab key selects between handler views in the window----------------------------------------------------------------------------------------*/void		ZWindow::Type( const char theKey, const short modifiers ){	if ( fChildViews && theKey == TAB_KEY )	{		ZView*	nextView = FindNextTabbingView(( modifiers & shiftKey ) == shiftKey );				if ( nextView )			SelectHandlingView( nextView );	}		if (( theKey == RETURN_KEY || theKey == ENTER_KEY || theKey == ESCAPE_KEY ) && floating )	{		gApplication->SendMessage( kMsgReleaseTemporaryFloatChain, NULL );		fHandler = this;	}}/*-----------------------------------***  SetSize  ***----------------------------------*//*access:			publicoverrides:		description: 	set the window's sizeins: 			<width, height> window width and height desiredouts: 			nonenotes:			constraints set by SetSizeRect are enforced----------------------------------------------------------------------------------------*/void	ZWindow::SetSize( const short width, const short height ){	// sets the window's size to the width and height passed, constrained to sizeRect.		short	w, h;	Rect	pr;		pr = *WINDOWPORTRECT( GetMacWindow());		w  = MIN( sizeRect.right,  MAX( width, sizeRect.left ));	h  = MIN( sizeRect.bottom, MAX( height, sizeRect.top ));	if (( w != ( pr.right - pr.left )) ||		( h != ( pr.bottom - pr.top )))	{		Focus();		SizeWindow( GetMacWindow(), w, h, TRUE );		ZView::SetSize( w, h );		WindowResized();	}}/*-------------------------------------***  Zoom  ***-----------------------------------*//*access:			publicoverrides:		description: 	zoom the window between user state and optimal stateins: 			<partCode> partcode returned from zoom box click eventouts: 			nonenotes:			constraints set by SetSizeRect are enforced----------------------------------------------------------------------------------------*/enum{	kNudgeSlop				= 2,	kIconAllowance			= 64,	kTabFolderAllowance		= 20};void	ZWindow::Zoom( const short partCode ){	RgnHandle	contRgn, strucRgn, scratchRgn;	Rect		portRect, crBBox, srBBox, zwBounds, wpOnScreen;	short		wfTop, wfLeft, wfBottom, wfRight;	GDHandle	targetMonitor;		Focus();	PrepareForDrawing();		if ( fChildViews == NULL )		EraseRect( WINDOWPORTRECT( GetMacWindow()));		// calculate the most intelligent zoom state for the window and set the	// standard state to it. The most intelligent state is on the monitor with	// the largest area of the window, and that involves the minimum amount of	// window movement.		if ( partCode == inZoomOut )	{		GetContentRegion( contRgn = NewRgn());		GetStructureRegion( strucRgn = NewRgn());		portRect = *WINDOWPORTRECT( GetMacWindow());		crBBox = *REGIONBOUNDINGBOX( contRgn );		srBBox = *REGIONBOUNDINGBOX( strucRgn );				// calculate the window frame size				wfTop		= crBBox.top 	- srBBox.top;		wfLeft		= crBBox.left 	- srBBox.left;		wfBottom 	= srBBox.bottom - crBBox.bottom;		wfRight 	= srBBox.right 	- crBBox.right;				// the ideal size for this window is the max sizeRect. For scrollable windows,		// this is set according to the bounds, which will give us the expected results		// we now need to find the monitor that has the largest portion of the window		// intersecting it.				scratchRgn = NewRgn();		SectRgn( GetGrayRgn(), contRgn, scratchRgn );		if (EmptyRgn( scratchRgn ))			zwBounds = srBBox;		else			zwBounds = crBBox;		DisposeRgn( scratchRgn );				// re-use srBBox for the new standard state rect, initially set to the ideal		// window size if we had an infinitely large monitor.				GetIdealWindowZoomSize( &srBBox );				// walk the device list to determine which monitor the window should be		// zoomed to:				targetMonitor = GetMaxMonitor();				// ok, we have found the monitor we wish to zoom to. Store the monitor's		// global rect in the wpOnScreen variable				wpOnScreen = (*targetMonitor)->gdRect;				// allow for the menubar and desktop icons if it's the main one				if (targetMonitor == GetMainDevice())		{			wpOnScreen.top += GetMBarHeight();			wpOnScreen.right -= kIconAllowance;						// if we have tabbed folders (8.x), allow space for it						if ( gMacInfo.systemVersion >= 0x0800 )				wpOnScreen.bottom -= kTabFolderAllowance;		}					// OK, we can now calculate the standard rect we wish to zoom to (finally).		// We calculate this using srBBox, since that now holds the new std state				OffsetRect( &srBBox, crBBox.left, crBBox.top );		srBBox.top 	  -= wfTop;		srBBox.left   -= wfLeft;		srBBox.right  += wfRight;		srBBox.bottom += wfBottom;				// this is the ideal size for the window content. See if it needs nudging onto the		// monitor				SectRect( &srBBox, &wpOnScreen, &zwBounds );		if (! EqualRect( &srBBox, &zwBounds ))		{			// needs to be nudged onto the monitor.						short	oH, oV;						oH = CalculateOffsetAmount( srBBox.left, srBBox.right,										zwBounds.left, zwBounds.right,										wpOnScreen.left, wpOnScreen.right );			oV = CalculateOffsetAmount( srBBox.top, srBBox.bottom,										zwBounds.top, zwBounds.bottom,										wpOnScreen.top, wpOnScreen.bottom );			OffsetRect( &srBBox, oH, oV );		}				// If this still falls off the screen in any direction, it means that it is too large		// for the montior, so it will need to be shrunk down to fit.				SectRect( &srBBox, &wpOnScreen, &zwBounds);		if (! EqualRect( &srBBox, &zwBounds ))		{			// nope- still doesn't fit. So shrink it down.						if ((srBBox.right - srBBox.left) > (wpOnScreen.right - wpOnScreen.left))			{				srBBox.left = wpOnScreen.left + kNudgeSlop;				srBBox.right = wpOnScreen.right - kNudgeSlop;			}						if ((srBBox.bottom - srBBox.top) > (wpOnScreen.bottom - wpOnScreen.top))			{				srBBox.top = wpOnScreen.top + kNudgeSlop;				srBBox.bottom = wpOnScreen.bottom - kNudgeSlop;			}		}				// adjust for the thickness of the frame and set the standard rect				srBBox.top 	  += wfTop;		srBBox.left   += wfLeft;		srBBox.right  -= wfRight;		srBBox.bottom -= wfBottom;				SetStdZoomRect( srBBox );				DisposeRgn( contRgn );		DisposeRgn( strucRgn );	}	// and.... Zoom!	ZoomWindow( GetMacWindow(), partCode, FALSE );	portRect = *WINDOWPORTRECT( GetMacWindow());	ZView::SetSize( portRect.right - portRect.left, portRect.bottom - portRect.top );		// notify resize of window		WindowResized();}/*---------------------------***  GetIdealWindowZoomSize  ***--------------------------*//*access:			publicoverrides:		description: 	return the ideal size for the window when optimally zoomed, ignoring				current position, monitor constraints, etc.ins: 			<idealSize> receives the optimal size rectouts: 			nonenotes:			called by Zoom----------------------------------------------------------------------------------------*/void	ZWindow::GetIdealWindowZoomSize( Rect* idealSize ){	if ( fPrintView == this )	{		idealSize->top = idealSize->left = 0;		idealSize->right = sizeRect.right;		idealSize->bottom = sizeRect.bottom;	}	else	{		fPrintView->GetBounds( idealSize );				idealSize->right += kStdScrollbarWidth;		idealSize->bottom += kStdScrollbarWidth;	}}/*-------------------------------***  SetStdZoomRect  ***-------------------------------*//*access:			publicoverrides:		description: 	set the size and position of the window's zoomed stateins: 			<aRect> zoomed state rectouts: 			nonenotes:			called by Zoom----------------------------------------------------------------------------------------*/void	ZWindow::SetStdZoomRect( const Rect& aRect ){	Boolean zoomable = FALSE;	short	v = 0;#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )	{		UInt32	wFeatures;				GetWindowFeatures( GetMacWindow(), &wFeatures );			zoomable = ( wFeatures & kWindowCanZoom ) == kWindowCanZoom;	}	else#endif		v = GetWVariant( GetMacWindow());		if (v == zoomDocProc ||		v == zoomNoGrow	 ||		zoomable )		SetWindowStandardState( GetMacWindow(), &aRect );	// using copland macro}/*------------------------------***  SetUserZoomRect  ***-------------------------------*//*access:			publicoverrides:		description: 	set the size and position of the window's user stateins: 			<aRect> user state rectouts: 			nonenotes:			called by Zoom----------------------------------------------------------------------------------------*/void	ZWindow::SetUserZoomRect( const Rect& aRect ){	Boolean zoomable = FALSE;	short	v = 0;	#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )	{		UInt32	wFeatures;				GetWindowFeatures( GetMacWindow(), &wFeatures );			zoomable = ( wFeatures & kWindowCanZoom ) == kWindowCanZoom;	}	else#endif		v = GetWVariant( GetMacWindow());	if (v == zoomDocProc ||		v == zoomNoGrow	 ||		zoomable )		SetWindowUserState( GetMacWindow(), &aRect );		// using copland macro}#pragma mark -/*-------------------------------***  CheckForSave  ***--------------------------------*//*access:			publicoverrides:		description: 	check whether user wants to save a dirty document or notins: 			<phase> application phase (running or quitting)outs: 			nonenotes:			displays "Save Changes?" alert----------------------------------------------------------------------------------------*/short	ZWindow::CheckForSave( const short phase ){	// they were all closed successfully, now check this one		short check = kCloseNoSave;		if ( IsDirty())	{		// we are about to show the "Save Changes?" alert- so make sure we are frontmost and		// fully updated. This also ensures that a window that is hidden will be correctly		// reshown under this situation, but not otherwise.				Select();		PerformUpdate();			#if _USE_NAV_SAVEREVERT_ALERTS		if ( gMacInfo.hasNavigationServices )		{			// use nav services version of the "save changes" dialog:						NavDialogOptions			navOptions;			NavAskSaveChangesResult		navResult;			NavAskSaveChangesAction		navAction;						FailOSErr( NavGetDefaultDialogOptions( &navOptions ));						gApplication->GetName( navOptions.clientName );			GetName( navOptions.savedFileName );						navAction = (phase == kQuitting)? kNavSaveChangesQuittingApplication : kNavSaveChangesClosingDocument;		    PauseCursorAnimation( 0 );			SysBeep( 1 );						FailOSErr( NavAskSaveChanges(	&navOptions,											navAction,											&navResult,											gNavEventHandler,											(NavCallBackUserData) this ));													    ResumeCursorAnimation();			// convert nav result back to MacZoop constants:						switch ( navResult )			{				case kNavAskSaveChangesSave:					check = kConfirmSave;					break;									case kNavAskSaveChangesCancel:					check = kCloseCancel;					break;									case kNavAskSaveChangesDontSave:					check = kCloseNoSave;					break;			}		}		else		{	#endif					Str31	nameStr;			Str31	phaseStr;						GetName( nameStr );			GetIndString( phaseStr, kMiscStrListID, phase );			ParamText( nameStr, phaseStr, NULL, NULL );						PauseCursorAnimation( 0 );			check = Alert( kConfirmSaveAlertID, gDSKeyUPP );		// do you wish to save?			ResumeCursorAnimation();			#if _USE_NAV_SAVEREVERT_ALERTS		}	#endif				if ( check == kConfirmSave )		{			if (! Save( FALSE ))						// if so, save the file				check = kCloseCancel;		}	}		return check;}/*------------------------------------***  Save  ***-----------------------------------*//*access:			publicoverrides:		description: 	perform coordination of Save sequence for the documentins: 			<forceSaveAs> TRUE to force the Save dialog to appear regardlessouts: 			TRUE if save completed, FALSE if user cancellednotes:			users should usually override SaveFile, not this method.----------------------------------------------------------------------------------------*/Boolean	ZWindow::Save( const Boolean forceSaveAs ){	// handles the save and save as commands.		Boolean		requiresNavPostProcess = FALSE;	#if _USE_NAVIGATION_SERVICES || TARGET_API_MAC_CARBON	NavReplyRecord		navReply;	OSErr				theErr;#endif		if (! isNamed || forceSaveAs)	{		// do Save As			#if _USE_NAVIGATION_SERVICES || TARGET_API_MAC_CARBON				if ( gMacInfo.hasNavigationServices )		{			PickFile( &navReply );						if ( navReply.validRecord )			{				AEDesc	specDesc;				FInfo	fi;						FailOSErr( AEGetNthDesc( &navReply.selection, 1, typeFSS, NULL, &specDesc ));						#if OPAQUE_TOOLBOX_STRUCTS				FailOSErr( AEGetDescData( &specDesc, &macFile, sizeof( FSSpec )));			#else				BlockMoveData( *specDesc.dataHandle, &macFile, sizeof( FSSpec ));			#endif							// to get the type we need to do a FSpGetFInfo, which may return fnfErr							theErr = FSpGetFInfo( &macFile, &fi );							if ( theErr == noErr )					macFType = fi.fdType;									requiresNavPostProcess = TRUE;			}			else			{				NavDisposeReply( &navReply );				return FALSE;			}		}		else		{	#endif		#if !TARGET_API_MAC_CARBON			StandardFileReply	macReply;						PickFile( &macReply );						if ( macReply.sfGood )				macFile = macReply.sfFile;			else				return FALSE;		// user cancelled the save	#endif		#if _USE_NAVIGATION_SERVICES || TARGET_API_MAC_CARBON		}		#endif	}		// now do a save with the info.		SetWatchCursor();	SaveFile();		#if _USE_NAVIGATION_SERVICES		if ( gMacInfo.hasNavigationServices && requiresNavPostProcess )	{		NavCompleteSave( &navReply, kNavTranslateInPlace );		NavDisposeReply( &navReply );	}	#endif		return TRUE;}/*----------------------------------***  PickFile  ***----------------------------------*//*access:			publicoverrides:		description: 	display Save dialog for setting up file to saveins: 			<macReply> filled in with save file detailsouts: 			nonenotes:			separate versions for Carbon or classic----------------------------------------------------------------------------------------*/#if !TARGET_API_MAC_CARBONvoid	ZWindow::PickFile( StandardFileReply* macReply ){	Str31	prompt;	Str255 	name;		GetIndString( prompt, kMiscStrListID, 3 );	GetName( name );		// make sure that filename is no longer than 31 chars		name[0] = MIN( name[0], 31 );		// here, we use the "classic" standard file dialog:		gWindowManager->DeactivateForDialog( sfPutDialogID );	StopCursorAnimation();	StandardPutFile( prompt, name, macReply );	gWindowManager->Activate();}#endif#if _USE_NAVIGATION_SERVICES || TARGET_API_MAC_CARBONextern NavEventUPP		gNavEventHandler;/*----------------------------------***  PickFile  ***----------------------------------*//*access:			publicoverrides:		description: 	display Save dialog for setting up file to saveins: 			<navReply> filled in with save file detailsouts: 			nonenotes:			separate versions for Carbon or classic----------------------------------------------------------------------------------------*/void	ZWindow::PickFile( NavReplyRecord* navReply ){	OSErr				theErr;	NavDialogOptions	navOptions;		FailOSErr( NavGetDefaultDialogOptions( &navOptions ));	gApplication->GetName( navOptions.clientName );	GetName( navOptions.savedFileName );	gWindowManager->DeactivateForDialog( -1, FALSE );	StopCursorAnimation();		theErr = NavPutFile( NULL,						 navReply,						 &navOptions,						 gNavEventHandler,						 macFType,						 gAppSignature,						 (NavCallBackUserData) this );						 	gWindowManager->Activate();		if ( theErr != userCanceledErr )		FailOSErr( theErr );}#endif/*------------------------------***  AttachFileHelper  ***------------------------------*//*access:			publicoverrides:		description: 	attach a file helper to the windowins: 			<aHelper> helper object to attachouts: 			nonenotes:			file helpers are small objects that know how to open and save a file on				behalf of the window----------------------------------------------------------------------------------------*/void	ZWindow::AttachFileHelper( ZFileHelper* aHelper ){	if ( fFiler && fFiler != aHelper )		FORGETOBJECT( fFiler );			fFiler = aHelper;}/*----------------------------------***  SaveFile  ***----------------------------------*//*access:			publicoverrides:		description: 	save the window content data to its fileins: 			noneouts: 			nonenotes:			clears dirty status----------------------------------------------------------------------------------------*/void	ZWindow::SaveFile(){	// actually save the window's contents to the file.		if ( macFile.vRefNum != kNoFile )	{		SetTitle( macFile.name );				ZFileHelper*	fh = GetFileHelper();				if ( fh )			fh->SaveFileForWindow( this, &macFile, macFType );				// no longer dirty				isNamed = TRUE;		SetDirty( FALSE );				// save the window's position to the file				SavePosition();	#if USE_PROXY_ICONS		GrafPtr	savePort;						if ( gMacInfo.hasModernWindowMgr )		{			GetPort( &savePort );			SetPortWindowPort( GetMacWindow());			SetWindowProxyFSSpec( GetMacWindow(), &macFile );			SetPort( savePort );		}	#endif	}}/*-----------------------------------***  GetName  ***----------------------------------*//*access:			publicoverrides:		description: 	return the name of the windowins: 			<name> receives the nameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::GetName( Str255 name ){	GetWTitle( GetMacWindow(), name );}/*------------------------------------***  Revert  ***----------------------------------*//*access:			publicoverrides:		description: 	implements the Revert commandins: 			noneouts: 			nonenotes:			displays alert to confirm the operation, then uses OpenFile to achieve it.				clears dirty status.----------------------------------------------------------------------------------------*/void	ZWindow::Revert(){	// revert the contents. By default, this just calls OpenFile.	#if _USE_NAV_SAVEREVERT_ALERTS	if ( gMacInfo.hasNavigationServices )	{		NavDialogOptions			navOptions;		NavAskDiscardChangesResult	navResult;				GetName( navOptions.savedFileName );		FailOSErr( NavAskDiscardChanges( &navOptions,										 &navResult,										 gNavEventHandler,										 (NavCallBackUserData) this ));										 		if ( navResult == kNavAskDiscardChanges )		{			SetWatchCursor();			OpenFile( macFType );		}	}	else	{#endif		Str31	title;				GetName( title );		ParamText( title, NULL, NULL, NULL );				if ( NotifyAlert( kRevertConfirmAlertID ) == ok )		{			SetWatchCursor();			OpenFile( macFType );		}#if _USE_NAV_SAVEREVERT_ALERTS	}#endif}/*-----------------------------------***  SetFile  ***----------------------------------*//*access:			publicoverrides:		description: 	set the file spec for the document of this window ins: 			<aFile> the file in questionouts: 			nonenotes:			normally called by ZApplication when the window is created from a file----------------------------------------------------------------------------------------*/void	ZWindow::SetFile( const FSSpec& aFile ){	macFile = aFile;#if USE_PROXY_ICONS		GrafPtr	savePort;		if ( gMacInfo.hasModernWindowMgr )	{		GetPort( &savePort );		SetPortWindowPort( GetMacWindow());		SetWindowProxyFSSpec( GetMacWindow(), &aFile );		SetPort( savePort );	}		#endif}/*----------------------------------***  OpenFile  ***----------------------------------*//*access:			publicoverrides:		description: 	opens the window's file so that the window can display it ins: 			<aFileType> file type of the file				<isStationeryt> TRUE if the file is stationery - i.e. to be copiedouts: 			nonenotes:			normally called by ZApplication when the window is created from a file----------------------------------------------------------------------------------------*/void	ZWindow::OpenFile( const OSType aFileType, Boolean isStationery ){	// this opens the current file into this window. This function should read the	// contents of the file, replacing the current contents.	// You should check that the vRefNum of the file spec is not kNoFile.	// Call the inherited method to maintain the proper window state variables.		if ( macFile.vRefNum != kNoFile )	{		macFType = aFileType;				ZFileHelper*	fh = GetFileHelper();				if ( fh )			fh->OpenFileForWindow( this, &macFile, aFileType );				if ( ! isStationery )		{			SetTitle(macFile.name);			isNamed = TRUE;		}				stationeryFile = isStationery;				if ( IsVisible())			PostRefresh();					// delete any existing undo task for this window after opening a file,		// since it probably contains stale data.				SetTask( NULL );		SetDirty( FALSE );	}}/*----------------------------------***  SetDirty  ***----------------------------------*//*access:			publicoverrides:		description: 	mark the window as dirty (needs saving)ins: 			<dState> TRUE to set dirtyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::SetDirty( Boolean dState ){	dirty = dState;#if USE_PROXY_ICONS		if ( gMacInfo.systemVersion >= 0x0850 )		SetWindowModified( GetMacWindow(), dirty );#endif}/*----------------------------------***  SetTitle  ***----------------------------------*//*access:			publicoverrides:		description: 	sets the title of the windowins: 			<aTitle> the title stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::SetTitle( Str255 aTitle ){	SetWTitle( GetMacWindow(), aTitle );}/*---------------------------------***  IsVisible  ***----------------------------------*//*access:			publicoverrides:		description: 	returns whether the window is visible or notins: 			noneouts: 			TRUE if visiblenotes:			----------------------------------------------------------------------------------------*/Boolean	ZWindow::IsVisible(){	if ( GetMacWindow())		return MacIsWindowVisible( GetMacWindow());	else		return FALSE;}/*-----------------------------***  GetTitleBarHeight  ***------------------------------*//*access:			publicoverrides:		description: 	returns the title bar height of the windowins: 			noneouts: 			height in pixelsnotes:			----------------------------------------------------------------------------------------*/short	ZWindow::GetTitleBarHeight(){	RgnHandle	sRgn, cRgn;	short		tHeight;		FailNIL( sRgn = NewRgn());	FailNIL( cRgn = NewRgn());		GetStructureRegion( sRgn );	GetContentRegion( cRgn );		tHeight =  REGIONBOUNDINGBOX( cRgn )->top - REGIONBOUNDINGBOX( sRgn )->top;		DisposeRgn( sRgn );	DisposeRgn( cRgn );		return tHeight;}/*----------------------------***  GetStructureRegion  ***------------------------------*//*access:			publicoverrides:		description: 	returns a copy of the window's structure regionins: 			<aRgn> window region copied into thisouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::GetStructureRegion( RgnHandle aRgn ){	FailNILParam( aRgn );		Boolean wasFudged = FALSE;	short	h, v;	Rect	saveUserRect;		// if the window isn't visible, the structure region isn't valid, so we have to	// make it visible offscreen in order to get the region		if ( ! MacIsWindowVisible( GetMacWindow()))	{		GetWindowUserState( GetMacWindow(), &saveUserRect );			GetGlobalPosition( &h, &v ); 				MoveWindow( GetMacWindow(), h + 10000, v + 100, FALSE );		ShowHide( GetMacWindow(), TRUE );				wasFudged = TRUE;	}		GetWindowStructureRgn( GetMacWindow(), aRgn );		if ( wasFudged )	{		ShowHide( GetMacWindow(), FALSE );			MoveWindow( GetMacWindow(), h, v, FALSE );				OffsetRgn( aRgn, -10000, -100 );				SetWindowUserState( GetMacWindow(), &saveUserRect );	}}/*-----------------------------***  GetContentRegion  ***-------------------------------*//*access:			publicoverrides:		description: 	returns a copy of the window's content regionins: 			<aRgn> window region copied into thisouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::GetContentRegion( RgnHandle aRgn ){	FailNILParam( aRgn );		Boolean wasFudged = FALSE;	short	h, v;	Rect	saveUserRect;		// if the window isn't visible, the content region isn't valid, so we have to	// make it visible offscreen in order to get the region		if ( ! MacIsWindowVisible( GetMacWindow() ))	{		GetWindowUserState( GetMacWindow(), &saveUserRect );			GetGlobalPosition( &h, &v ); 				MoveWindow( GetMacWindow(), h + 10000, v + 100, FALSE );		ShowHide( GetMacWindow(), TRUE );				wasFudged = TRUE;	}		GetWindowContentRgn( GetMacWindow(), aRgn );		if ( wasFudged )	{		ShowHide( GetMacWindow(), FALSE );			MoveWindow( GetMacWindow(), h, v, FALSE );				OffsetRgn( aRgn, -10000, -100 );		SetWindowUserState( GetMacWindow(), &saveUserRect );	}}/*--------------------------***  GetStructureFrameBorder  ***---------------------------*//*access:			publicoverrides:		description: 	returns the frame thicknesses of all four sides of the windowins: 			<aRect> values returned in this rectangleouts: 			nonenotes:			top is title bar height, left and right are side edge thicknesses and				bottom is bottom frame thickness----------------------------------------------------------------------------------------*/void	ZWindow::GetStructureFrameBorder( Rect* aRect ){	RgnHandle	sRgn, cRgn;	Rect		s, c;		FailNILParam( aRect );		FailNIL( sRgn = NewRgn());	FailNIL( cRgn = NewRgn());		GetStructureRegion( sRgn );	GetContentRegion( cRgn );		s = *REGIONBOUNDINGBOX( sRgn );	c = *REGIONBOUNDINGBOX( cRgn );		aRect->top 		= c.top    - s.top;	aRect->left 	= c.left   - s.left;	aRect->right 	= s.right  - c.right;	aRect->bottom 	= s.bottom - c.bottom;		DisposeRgn( sRgn );	DisposeRgn( cRgn );}/*-----------------------------***  GetGlobalPosition  ***------------------------------*//*access:			publicoverrides:		description: 	return current global screen position of windowins: 			<hGlobal, vGlobal> receive the global position of the windowouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::GetGlobalPosition( short* hGlobal, short* vGlobal ){	GrafPtr		savePort;	Point		gloc;		GetPort( &savePort );	SetPortWindowPort( GetMacWindow());		gloc = TOPLEFTPOINT( *WINDOWPORTRECT( GetMacWindow()));	LocalToGlobal( &gloc );		SetPort( savePort );		*hGlobal = gloc.h;	*vGlobal = gloc.v;}/*-------------------------------***  GetGrowBoxSize  ***-------------------------------*//*access:			publicoverrides:		description: 	return width and height of the growboxins: 			<width, height> receive width and height of the grow boxouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::GetGrowBoxSize( short* width, short* height ){#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON	if ( gMacInfo.hasModernWindowMgr )	{		// with carbon, we can just ask. This only works if theme savvy windows are		// used - older WIND created ones always return the empty rect				Rect		growRect;				GetWindowBounds( GetMacWindow(), kWindowGrowRgn, &growRect );			*width = growRect.right - growRect.left;		*height = growRect.bottom - growRect.top;				// classic systems handled by WindowsLib don't work correctly with this		// function, returning 0. So we can keep going as best we can, if we get a zero		// result, return fixed values based on platinum metrics				if ( *width == 0 )		{			if ( Floats())			{				*width = kVerySmallScrollbarWidth;				*height = kVerySmallScrollbarWidth;			}			else			{				*width = kStdScrollbarWidth;				*height = kStdScrollbarWidth;			}		}	}	else	{#endif		// older wmgr, we have no way to query the metrics, so we		// just use fixed constants. Floaters may not always be right...		if ( Floats())		{			*width = kSmallScrollbarWidth;			*height = kSmallScrollbarWidth;		}		else		{			*width = kStdScrollbarWidth;			*height = kStdScrollbarWidth;		}#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON	}#endif}/*--------------------------------***  GetMaxMonitor  ***-------------------------------*//*access:			publicoverrides:		description: 	get the monitor containg the largest part of the windowins: 			noneouts: 			Handle to devicenotes:			----------------------------------------------------------------------------------------*/GDHandle	ZWindow::GetMaxMonitor(){	GDHandle	aScreen, targetMonitor;	RgnHandle	strucRgn;	Rect		br, wpOnScreen;	long 		wpArea, largestArea = -1;		targetMonitor = aScreen = GetDeviceList();		GetStructureRegion( strucRgn = NewRgn());	br = *REGIONBOUNDINGBOX( strucRgn );	DisposeRgn( strucRgn );	while ( aScreen )	{		// find the intersection of the window and the screen				SectRect( &br, &(*aScreen)->gdRect, &wpOnScreen );				// find the area of this portion				OffsetRect( &wpOnScreen, -wpOnScreen.left, -wpOnScreen.top );		wpArea = (long) wpOnScreen.right * (long) wpOnScreen.bottom;				// if this is larger than the area found so far, keep track of		// the monitor that contains it				if ( wpArea > largestArea )		{			largestArea = wpArea;			targetMonitor = aScreen;		}		// look at the next monitor in the list				aScreen = GetNextDevice( aScreen );	}		return targetMonitor;}/*--------------------------------***  WriteToStream  ***-------------------------------*//*access:			publicoverrides:		description: 	stream window objectins: 			<aStream> stream to write toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::WriteToStream( ZStream* aStream ){#if _MACZOOP_STREAMS#pragma warning - window streams need updating for 2.5#endif}/*-------------------------------***  ReadFromStream  ***-------------------------------*//*access:			publicoverrides:		description: 	stream window objectins: 			<aStream> stream to readouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::ReadFromStream( ZStream* aStream ){#if _MACZOOP_STREAMS#pragma warning - window streams need updating for 2.5#endif}/*-----------------------------***  GetDebugInfoString  ***-----------------------------*//*access:			publicoverrides:		description: 	return basic debug info to inspectorins: 			<s> receives debug infoouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::GetDebugInfoString( Str255 s ){	Str255 ss;		CopyPString( "\pÒ", s );	GetName( ss );	ConcatPStrings( s, ss );	ConcatPStrings( s, "\pÓ; dirty = " );	ConcatPStrings( s, dirty? "\p1" : "\p0" );	ConcatPStrings( s, "\p; owner ID = " );	NumToString( itsBoss->GetInstanceID(), ss );	ConcatPStrings( s, ss );}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			publicoverrides:		description: 	pass field info to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::ReportFields(){	ZView::ReportFields();	MTaskStack::ReportFields();		XSHOWFIELD( sizeRect, ft_Rect );	XSHOWFIELD( windID, ft_signedshort );	XSHOWFIELD( isNamed, ft_boolean );	XSHOWFIELD( stationeryFile, ft_boolean );	XSHOWFIELD( macFile, ft_FSSpec );	XSHOWFIELD( macFType, ft_fourcharcode );	XSHOWFIELD( printable, ft_boolean );	XSHOWFIELD( isPrinting, ft_boolean );	XSHOWFIELD( floating, ft_boolean );	XSHOWFIELD( disableAutoClose, ft_boolean );	XSHOWFIELD( zoomSource, ft_Rect );	XSHOWFIELD( windowSnap, ft_boolean );	XSHOWFIELD( dirty, ft_boolean );		WindowPtr	w = GetMacWindow();		SHOWFIELD( "->GetMacWindow()", w, ft_address );}#pragma mark -/*----------------------------***  InstallDragHandlers  ***-----------------------------*//*access:			publicoverrides:		description: 	set up toolbox stuff so that window can support drag and dropins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::InstallDragHandlers(){	// set up the drag handler proc to call this object when a drag occurs over this window. The	// window's refCon field contains the object reference, so the handler can find this object.		if ( sDragTrackProc == NULL )		sDragTrackProc = NewDragTrackingHandlerUPP( WindowTrackingHandler );			if ( sDragReceiveProc == NULL )		sDragReceiveProc = NewDragReceiveHandlerUPP( WindowDropHandler );		FailOSErr( InstallTrackingHandler( sDragTrackProc, 	 GetMacWindow(), 0L ));	FailOSErr( InstallReceiveHandler ( sDragReceiveProc, GetMacWindow(), 0L ));	}/*-----------------------------***  RemoveDragHandlers  ***-----------------------------*//*access:			publicoverrides:		description: 	remove handlers when window is deletedins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::RemoveDragHandlers(){	// removes the drag handlers when the window is deleted		OSErr	theErr;		theErr = RemoveTrackingHandler( sDragTrackProc,   GetMacWindow());		theErr = RemoveReceiveHandler ( sDragReceiveProc, GetMacWindow());	}/*---------------------------------***  DropHandler  ***--------------------------------*//*access:			publicoverrides:		description: 	handle drop of dragged object on the windowins: 			<theDrag> drag reference for data droppedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::DropHandler( const DragReference theDrag ){	Boolean handled = FALSE;		if ( sDropTargetView )		handled = sDropTargetView->UnpackDrop( theDrag );			if ( ! handled )		FailOSErr( dragNotAcceptedErr );}/*--------------------------------***  DragDispatch  ***--------------------------------*//*access:			publicoverrides:		description: 	dispatch tracking callbacks to the places they need to goins: 			<theDrag> drag reference for data dropped				<theMessage> tracking messageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::DragDispatch( const DragTrackingMessage theMessage, const DragReference theDrag ){	// this method handles the tracking of a drag within this window. It calls various other	// methods to implement its behaviour- normally you would override those where necessary	// rather than this, which is quite low-level.		Point mouse;			switch ( theMessage )	{			case kDragTrackingEnterHandler:			EnteredHandler( theDrag );			break;				case kDragTrackingEnterWindow:			sCurRxDragRef = theDrag;			break;				case kDragTrackingInWindow:			Focus();			GetDragMouse( theDrag, &mouse, NULL );			GlobalToLocal( &mouse );			ZView::DDDispatchView( mouse, theDrag );			sDropTargetView = GetDragTargetView();			break;				case kDragTrackingLeaveWindow:			if ( GetDragTargetView())				GetDragTargetView()->DDExitView( theDrag );			sCurRxDragRef = NULL;			break;				case kDragTrackingLeaveHandler:			LeftHandler( theDrag );			break;	}}/*-------------------------------***  ShowBalloonHelp  ***------------------------------*//*access:			publicoverrides:		description: 	displays a baloon help balloon for this windowins: 			<localRect> hot rect within the window				<tip> tip position local to window				<hm> content of balloonouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::ShowBalloonHelp( Rect* localRect, Point tip, HMMessageRecord* hm ){	Rect	gr = *localRect;		Focus();		LocalToGlobal( &TOPLEFTPOINT( gr ));	LocalToGlobal( &BOTTOMRIGHTPOINT( gr ));	LocalToGlobal( &tip );#if TARGET_API_MAC_CARBON	// solution sought (TO DO)#else		OSErr	hmErr;	hmErr = HMShowBalloon( hm, tip, &gr, NULL, 0, 0, kHMRegularWindow );#endif}/*------------------------------***  SelectHandlingView  ***----------------------------*//*access:			publicoverrides:		description: 	select a subview to be the handler for the window's command chainins: 			<aView> a view to become the handlerouts: 			nonenotes:			if view ineligible, method does nothing, otherwise command chain within				the window is set up to start at <aView> and work back up to the window.----------------------------------------------------------------------------------------*/void	ZWindow::SelectHandlingView( ZView* aView ){	FailNILParam( aView );		if (( aView != fHandler ) && aView->CanBeHandler() && aView->IsEnabled())	{		ZCommander*		hTemp;				hTemp = fHandler;		SetHandler( aView );				if ( gCurHandler == hTemp )			gCurHandler = fHandler;				if ( hTemp )			hTemp->BecomeHandler( FALSE );				fHandler->BecomeHandler( TRUE );				if ( floating )			gApplication->SendMessage( kMsgRequestTemporaryFloatChain, fHandler );		else			gApplication->SendMessage( kMsgReleaseTemporaryFloatChain, NULL );			}	}/*-----------------------------***  FindNextTabbingView  ***----------------------------*//*access:			publicoverrides:		description: 	find a view that can be the next handler when the user types the tab keyins: 			<searchBackwards> TRUE to operate in reverseouts: 			a view that can be the next handlernotes:			----------------------------------------------------------------------------------------*/ZView*	ZWindow::FindNextTabbingView( Boolean  searchBackwards ){	// the next handler may be buried in the hierarchy, so the whole thing is searched. We do	// this by building a temporary list which is a flat version. ZView can do this easily.		ZView* 		nView = NULL;	ZViewList*	flatList = FlattenViewsToList( NULL );	long		n, i, k;		n = flatList->CountItems();	k = i = flatList->FindIndex( fHandler );		do	{		if ( searchBackwards )		{			// going down...						if( --i < 1 )				i = n;		}		else		{			// going up...						if ( ++i > n )				i = 1;			}				if ( i == k )		{			// gone full circle without a result, so			// give up.						nView = NULL;			break;		}		nView = (ZView*) flatList->GetObject( i );			if ( nView->CanBeHandler() && nView->IsEnabled() && nView->IsVisible())			break;	}	while( 1 );		// don't need this anymore:		FORGETOBJECT( flatList );	return nView;}/*----------------------------***  InitSizeFromResource  ***----------------------------*//*access:			publicoverrides:		description: 	set up window size limits from associated resourceins: 			<aType> resource type to use - its ID is the same as the windowouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindow::InitSizeFromResource( ResType aType ){	// look for an associated 'WLIM/DLIM' resource to set up the limit rectangle. The resource	// is simply a standard Rect.		Rect**	rh;		rh = (Rect**) GetResource( aType, windID );		if ( rh )	{		SetSizeRect( **rh );		ReleaseResource((Handle) rh );	}}#pragma mark -/*---------------------------***  CalculateOffsetAmount  ***----------------------------*//*access:			static globaloverrides:		description: 	calculate amount ot move window to implement minimal zoomingins: 			outs: 			nonenotes:			----------------------------------------------------------------------------------------*/static short CalculateOffsetAmount(short idealStartPoint, short idealEndPoint, short idealOnScreenStartPoint,							short idealOnScreenEndPoint, short screenEdge1, short screenEdge2){	short	offsetAmount;	// First check to see if the window fits on the screen in this dimension.	if ((idealStartPoint < screenEdge1) && (idealEndPoint > screenEdge2))		offsetAmount = 0;	else	{			// Find out how much of the window lies off this screen by subtracting the amount of the window		// that is on the screen from the size of the entire window in this dimension. If the window		// is completely offscreen, the offset amount is going to be the distance from the ideal		// starting point to the first edge of the screen.		if ((idealOnScreenStartPoint - idealOnScreenEndPoint) == 0)		{			// See if the window is lying to the left or above the screen			if (idealEndPoint < screenEdge1)				offsetAmount = screenEdge1 - idealStartPoint + kNudgeSlop;			else			// Otherwise, itÕs below or to the right of the screen				offsetAmount = screenEdge2 - idealEndPoint - kNudgeSlop;		}		else		{			// Window is already partially or completely on the screen			offsetAmount = (idealEndPoint - idealStartPoint) -							(idealOnScreenEndPoint - idealOnScreenStartPoint);				// If we are offscreen a little, move the window in a few more pixels from the edge of the screen.			if (offsetAmount != 0)				offsetAmount += kNudgeSlop;						// Check to see which side of the screen the window was falling off of, so that it can be			// nudged in the opposite direction.			if (idealEndPoint > screenEdge2)				offsetAmount = -offsetAmount;		}	}		return offsetAmount;}/*--------------------------------***  SetRootPort  ***---------------------------------*//*access:			protectedoverrides:		description: 	set up root port of window so that views draw into the right portins: 			<aPort> port to useouts: 			nonenotes:			normally, do not call this. It is used purely to support printing and				buffering of windows.----------------------------------------------------------------------------------------*/void	ZWindow::SetRootPort( CGrafPtr aPort ){	sActivePort = aPort;		if ( sActivePort )		sCurPortOrigin = TOPLEFTPOINT( *PORTPORTRECT( aPort ));			if ( aPort == NULL )		SetPort((GrafPtr) GetMacPort());}/*---------------------------***  WindowTrackingHandler  ***----------------------------*//*access:			static protectedoverrides:		description: 	drag tracking callback for all windowsins: 			outs: 			nonenotes:			----------------------------------------------------------------------------------------*/pascal OSErr	ZWindow::WindowTrackingHandler(DragTrackingMessage theMsg, WindowPtr theWindow, void* refCon,									DragReference theDrag){	ZWindow*	zdWindow = NULL;	OSErr		theErr = noErr;		// get the object		if ( theWindow )		zdWindow = GETZWINDOW( theWindow );	try	{		FailNIL( zdWindow );				zdWindow->DragDispatch( theMsg, theDrag );	}	catch( ZoopError err )	{		theErr = err;	}		return theErr;}/*------------------------------***  WindowDropHandler  ***-----------------------------*//*access:			static protectedoverrides:		description: 	drop callback for all windowsins: 			outs: 			nonenotes:			----------------------------------------------------------------------------------------*/pascal OSErr	ZWindow::WindowDropHandler( WindowPtr theWindow, void* refCon, DragReference theDrag ){	ZWindow*	zdWindow = NULL;	OSErr		theErr = noErr;	// get the object		if ( theWindow )		zdWindow = GETZWINDOW( theWindow );	try	{		FailNIL( zdWindow );				zdWindow->DropHandler( theDrag );	}	catch( ZoopError err )	{		theErr = err;				// if there was an error that aborted the drop, we would like to report it to the		// user. However, this is a bad time to do it, so instead we set <gDragErr> which		// ZApplication will pick up & report next time it loops, using the Notification		// Manager if in background.				if ( err != dragNotAcceptedErr )			gDragErr = err;	}		return theErr;}/*----------------------------------***  DSKeyProc  ***---------------------------------*//*access:			static globaloverrides:		description: 	dialog filetr proc for save changes so that command-D worksins: 			outs: 			nonenotes:			----------------------------------------------------------------------------------------*/static pascal Boolean DSKeyProc( DialogPtr dlg, EventRecord* evt, short* item ){    char        key;    Boolean     isCmd;    Boolean     result = FALSE;        if ( evt->what == keyDown )    {        isCmd = ( evt->modifiers & cmdKey ) != 0;        key = evt->message & charCodeMask;        switch ( key )        {            case 'd':            case 'D':                if ( isCmd )                {                    *item = kDontSaveButtonID;                    result = TRUE;                }                break;                            case RETURN_KEY:            case ENTER_KEY:                result = TRUE;                *item = ok;                break;                            case ESCAPE_KEY:                result = TRUE;                *item = cancel;                break;                    case '.':                if ( isCmd )                {                    result = TRUE;                    *item = cancel;                }                break;        }                if ( result )        {            short           iType;            Handle          iHand;            Rect            iBox;            unsigned long   ignored;                        GetDialogItem( dlg, *item, &iType, &iHand, &iBox );            if ( iType & ctrlItem )            {                SETPORTTODIALOG( dlg );                HiliteControl((ControlHandle) iHand, 1 );                Delay( 8, &ignored );                HiliteControl((ControlHandle) iHand, 0 );            }        }    }          return result;  }