/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZObjectArray.cpp	-- a container for objects (template class)******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZObjectArray.h"#include    "MacZoop.h"#include	"ZStream.h"#include	<typeinfo.h>#include	<string.h>/*---------------------------------***  CONSTRUCTOR  ***---------------------------------*/template <class T> ZObjectArray<T>::ZObjectArray()	: ZArray( sizeof(T*) ){	classID = CLASS_ZObjectArray;		// we manipulate our handle via <o> rather than <a> so we can take advantage	// of direct register copies, etc for maximum performance, which is what this	// class is all about (it avoids BlockMove).		o = (T***) a;}/*---------------------------------***  operator[]  ***----------------------------------*//*	return the object at <index>-----------------------------------------------------------------------------------------*/template <class T> T*	ZObjectArray<T>::operator[]( const long index ){	if ((index < 1) || (index > numElements))		FailOSErr( kIndexOutOfRangeErr );	return ((*o)[index - 1]);}/*---------------------------------***  GetObject  ***----------------------------------*//*access:			public	overrides:description: 	return the object stored at indexins: 			<index> index position to obtainouts: 			the object stored therenotes:----------------------------------------------------------------------------------------*/template <class T> T*	ZObjectArray<T>::GetObject( const long index ){	// gets the item at position <index> in the array. Index is one-based.		if ((index < 1) || (index > numElements))		FailOSErr( kIndexOutOfRangeErr );			return ((*o)[index - 1]);}/*--------------------------------***  DeleteObject  ***--------------------------------*//*access:			public	overrides:description: 	delete the object from the array - does not dispose of the objectins: 			<item> the object to removeouts: 			nonenotes:----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::DeleteObject( T* item ){	long	index;		index = FindIndex( item );		if (index > 0)		DeleteItem ( index );}/*---------------------------------***  DisposeAll  ***---------------------------------*//*access:			public	overrides:description: 	remove and dispose of all objects in the arrayins: 			noneouts: 			nonenotes:----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::DisposeAll(){	// calls ForgetObject for every object in the array, then forces the array empty. Since	// it is possible for ForgetObject to modify this array, we iterate in reverse order.		long	i = numElements;	T*		p;		while(i--)	{		p = (*o)[i];				if (p)			FORGETOBJECT(p);	}	SetHandleSize( a, 0 );	numElements = 0;	physicalBlks = 0;}/*----------------------------------***  DoForEach  ***---------------------------------*//*access:			public	overrides:description: 	calls the supplied proc with each object in the arrayins: 			<aProc> iteration proc to call				<ref> value passed to proc verbatimouts: 			nonenotes:----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::DoForEach( IteratorProcPtr aProc, const long ref ){	// calls the grovelling function for every object in the array.		if (aProc && (numElements > 0))	{		long	i = numElements;				while(i)			(*aProc)((*o)[--i] , ref);	}}/*-----------------------------------***  Contains  ***---------------------------------*//*access:			public	overrides:description: 	query whether the array contains the objectins: 			<item> object to checkouts: 			TRUE if object in the array, else FALSEnotes:----------------------------------------------------------------------------------------*/template <class T> Boolean	ZObjectArray<T>::Contains( T* item ){	return (FindIndex( item ) > 0);}/*---------------------------------***  SetArrayItem  ***-------------------------------*//*access:			public	overrides:description: 	store an object into the arrayins: 			<item> object to store				<index> where to store itouts: 			nonenotes:			overwrites any data existing at <index>----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::SetArrayItem( void* item, const long index ){	if ((index < 1) || (index > numElements))		FailOSErr( kIndexOutOfRangeErr );			(*o)[index - 1] = (T*) item;}/*---------------------------------***  GetArrayItem  ***-------------------------------*//*access:			public	overrides:description: 	retrieve an object from the arrayins: 			<item> pointer to an object pointer - receives the object				<index> where to get itouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::GetArrayItem( void* item, const long index ){	if ((index < 1) || (index > numElements))		FailOSErr( kIndexOutOfRangeErr );			*(T**)item = ((*o)[index - 1]);}/*-------------------------------***  ConcatenateArray  ***-----------------------------*//*access:			public	overrides:description: 	append another array to this oneins: 			<anArray> array to appendouts: 			nonenotes:			passed array is not changed----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::ConcatenateArray( ZObjectArray<T>* anArray ){	ZArray::ConcatenateArray((ZArray*) anArray );}/*---------------------------------***  FindIndex  ***----------------------------------*//*access:			public	overrides:description: 	locate the index at which the object is storedins: 			<item> object to look forouts: 			index of object in array, or 0 if not foundnotes:			linear search----------------------------------------------------------------------------------------*/template <class T> long	ZObjectArray<T>::FindIndex( T* item ){	if ( numElements < 1 )		return 0;			long		i = 0;	Boolean		found = FALSE;		do	{		if ((*o)[i] == item)		{			found = TRUE;			break;		}		}	while( ++i < numElements );	return ( found? i + 1 : 0 );}/*-----------------------------***  InsertSortedItem  ***-------------------------------*//*access:			public	overrides:description: 	insert object into sorted array at correct positionins: 			<item> object to insert				<compareProc> comparison function used to sort the array				<ref> value passed to comparison function verbatimouts: 			index where object was insertednotes:			----------------------------------------------------------------------------------------*/template <class T> long	ZObjectArray<T>::InsertSortedItem( void* item, SortCmpProcPtr compareProc, const long ref ){	T*		itemB;	short	rel;	long	pos = BFindIndex( &item, compareProc, ref );		// <pos> represents the NEAREST item, but we don't know if we need to insert	// before or after this item, so we need to do one more compare		if ( pos > 0 )	{		GetArrayItem( &itemB, pos );				rel = (*compareProc)( &item, &itemB, ref );				if ( rel > 0 )			pos++;	}			if (( pos > numElements ) || ( pos == 0 ))	{		AppendItem( item );		pos = numElements;	}	else		InsertItem( item, pos );			return pos;}/*-----------------------------------***  Swap  ***-------------------------------------*//*access:			public	overrides:description: 	exchange the positions of two objects in the arrayins: 			<itema, itemb> index positions to exchangeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::Swap( const long itema, const long itemb ){	register T* temp;		if ((itema < 1) ||		(itema > numElements) ||		(itemb < 1) ||		(itemb > numElements))		FailOSErr( kIndexOutOfRangeErr );			temp = GetObject( itema );		(*o)[itema - 1] = (*o)[itemb - 1];	(*o)[itemb - 1] = temp;}/*---------------------------------***  MoveItem  ***-----------------------------------*//*access:			public	overrides:description: 	move an object at one location to anotherins: 			<curIndex> location of object to move				<newIndex> position to move it toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::MoveItem( const long curIndex, const long newIndex ){	register T*	temp;		if ((curIndex < 1) 				||		(curIndex > numElements) 	||		(newIndex < 1) 				||		(newIndex > numElements))		FailOSErr( kIndexOutOfRangeErr );		// don't do anything if indices the same (not an error)		if ( curIndex != newIndex )	{			temp = GetObject( curIndex );				DeleteItem( curIndex );		InsertItem( temp, newIndex );				SendMessage( msgArrayItemMoved, (void*) newIndex );	}}/*-------------------------------***  MoveToFront  ***----------------------------------*//*access:			public	overrides:description: 	move an object to the beginning of the arrayins: 			<index> location of object to moveouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::MoveToFront( const long index ){	MoveItem( index, 1 );}/*--------------------------------***  MoveToBack  ***----------------------------------*//*access:			public	overrides:description: 	move an object to the end of the arrayins: 			<index> location of object to moveouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::MoveToBack( const long index ){	MoveItem( index, CountItems());}/*------------------------------***  WriteToStream  ***---------------------------------*//*access:			public	overrides:description: 	write the array to the stream and all the objects within itins: 			<aStream> the stream to write the objects toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::WriteToStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZComrade::WriteToStream( aStream );		register long	i;		// count of objects to follow:		aStream->WriteLong( numElements );		// write the object references as needed:		for ( i = 1; i <= numElements; i++ )		aStream->WriteObject( GetObject( i ));#endif}/*-----------------------------***  ReadFromStream  ***---------------------------------*//*access:			public	overrides:description: 	establish the array from the stream and create the objects within itins: 			<aStream> the stream to read the objects fromouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::ReadFromStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZComrade::ReadFromStream( aStream );		register T*		temp;	register long	i, numObjects;		aStream->ReadLong( &numObjects );		// size the storage handle as needed to hold this many objects:		if ( numElements != numObjects )	{		SetHandleSize( a, numObjects * blkSize );		FailMemError();				numElements = numObjects;		physicalBlks = numObjects;	}		for ( i = 1; i <= numObjects; i++ )	{		temp = (T*) aStream->ReadObject();		SetArrayItem( temp, i );	}#endif}/*-------------------------------***  ReportFields  ***---------------------------------*//*access:			public	overrides:description: 	report data members to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/template <class T> void	ZObjectArray<T>::ReportFields(){	ZArray::ReportFields();	T*		t;	Str15	ns;	char	jc[256];		for( long j = 1; j <= numElements; j++ )	{		t = GetObject( j );				strcpy( jc, "[element #" );		NumToString( j, ns );		ns[ns[0] + 1] = 0;		strcat( jc, (char*) &ns[1] );		strcat( jc, "]" );			FSHOWFIELD( jc, t, ft_objectref, *t );	}}