/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZView.cpp		-- manages drawing in part of a window******			©2000, Graham Cox*****************************************************************************************************/#include	"ZView.h"#include	"MacZoop.h"#include	"ZGrafState.h"#include	"ZWindow.h"#include	"ZControlView.h"// streaming support:CLASSCONSTRUCTOR( ZView );CLASSCONSTRUCTOR( ZViewBorder );// globals & statics:static RgnHandle	gViewUtilRgn = NewRgn();RgnHandle			ZView::sViewBaseClipRgn = NULL;ZView*				ZView::sCurRxDragTarget = NULL;ZView*				ZView::sCurTxDragSender = NULL;DragReference		ZView::sCurRxDragRef = NULL;DragReference		ZView::sCurTxDragRef = NULL;CGrafPtr			ZView::sActivePort = NULL;Point				ZView::sCurPortOrigin = { 0, 0 };/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZView::ZView( ZView* parentView, Rect* aFrame )	: ZCommander( parentView ){	classID = CLASS_ZView;		fChildViews = NULL;		if ( aFrame )		fFrame = *aFrame;	else		SetRect( &fFrame, 0, 0, 0, 0 );	ViewInit();	if ( parentView )		parentView->AddChildView( this );}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZView::ZView( ZCommander* aBoss )	: ZCommander( aBoss ){	classID = CLASS_ZView;		fChildViews = NULL;	SetRect( &fFrame, 0, 0, 0, 0 );	ViewInit();}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZView::ZView( ZView* aParent, const short viewResourceID )	: ZCommander( aParent ){	classID = CLASS_ZView;		fChildViews = NULL;	fBorder = NULL;		ViewResInit( viewResourceID );}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZView::ZView()	: ZCommander(){	classID = CLASS_ZView;		fChildViews = NULL;		SetRect( &fFrame, 0, 0, 0, 0 );		ViewInit();}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZView::~ZView(){	if ( GetParent())		GetParent()->RemoveChildView( this );		DeleteChildren();		if ( fBorder )		FORGETOBJECT( fBorder );			if ( fGrafEnv )		FORGETOBJECT( fGrafEnv );			if ( fTipText )		DisposeHandle((Handle) fTipText );		}/*-----------------------------------***  Focus  ***------------------------------------*//*access:			publicoverrides:		description: 	prepare this view for drawingins: 			noneouts: 			nonenotes:			set the current port to this view's mac port & sets up origin & clip----------------------------------------------------------------------------------------*/void		ZView::Focus(){	Rect	pFrame, parFrame;		if ( GetRootWindow() == this )	{		// we're the root view, so set the port and base origin.				SetActivePort();			// set initial clip to whole port, or saved base clip region (needed for scroll views)			if ( sViewBaseClipRgn )			SetClip( sViewBaseClipRgn );		else		{			pFrame = *PORTPORTRECT( GetMacPort());			ClipRect( &pFrame );		}	}	else	{		// not the root view, so offset the origin to our parent's bounds				GetParent()->Focus();				RgnHandle	temp;		short		oh, ov, ph, pv, dh, dv;				// what is the current origin?				oh = PORTPORTRECT( GetMacPort())->left;		ov = PORTPORTRECT( GetMacPort())->top;				// our frame is positioned relative to the bounds of our parent, but our		// parent's frame is focused. Compute the offset between our frame and the		// parent frame				GetFrame( &pFrame );		GetParent()->GetPosition( &ph, &pv );		GetParent()->GetContentRect( &parFrame );				dh = pFrame.left - ph + parFrame.left;		dv = pFrame.top - pv + parFrame.top;		SetOrigin( oh - dh, ov - dv );				// the frame of this view is now focused				GetClip( gViewUtilRgn );		OffsetRgn( gViewUtilRgn, -dh, -dv );					if ( ! IsPrinting())		{			// set up the clip - we must clip to the correct intersection of all our			// parent views (including the content rect of our parent)						GetParent()->GetContentRect( &parFrame );			OffsetRect( &parFrame, -dh, -dv );			OffsetRect( &pFrame, -pFrame.left, -pFrame.top );			SectRect( &parFrame, &pFrame, &pFrame );						RectRgn( temp = NewRgn(), &pFrame );			SectRgn( gViewUtilRgn, temp, temp );			SetClip( temp );			DisposeRgn( temp );		}	}}/*----------------------------------***  DrawAll  ***-----------------------------------*//*access:			publicoverrides:		description: 	draw this view and all child viewsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::DrawAll(){	if ( IsVisible())	{		ZGrafState		gs;			if ( ExecuteModifiers( kModifierDrawViewFrame, NULL ))		{			// to draw the content, the origin is set to our local bounds			// note that if the clip region is empty, the result is FALSE and we			// don't bother drawing any subviews			if ( FocusForContent())			{				PrepareForDrawing();				ClipViewsAbove();				if ( ErasesBackground())					EraseBackground();								DrawContent();			}		}	}}/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	draw the content of this view and the child views in itins: 			noneouts: 			nonenotes:			you can draw as if the view was always at 0,0 - always call the inherited				method if your view has child views.----------------------------------------------------------------------------------------*/void		ZView::DrawContent(){	if ( ExecuteModifiers( kModifierDrawViewContent, NULL ))	{		// at this bound this view's bounds are focused, so before focusing a child		// view, we can draw its border, which is permitted to draw outside the view frame.				if( fChildViews )		{			long		i, n;			ZView*		aView;			Rect		bf;						n = fChildViews->CountItems();						// draw all the child borders first within our own bounds						for( i = 1; i <= n; i++ )			{				aView = GetChildView( i );						if ( aView )				{					aView->GetFrame( &bf );					InsetRect( &bf, -1, -1 );					aView->DrawBorder( &bf );				}			}						// now draw each child						for( i = 1; i <= n; i++ )			{				aView = GetChildView( i );						if ( aView )				{					aView->Focus();					aView->DrawAll();				}			}		}	}}/*----------------------------------***  DrawBorder  ***---------------------------------*//*access:			publicoverrides:		description: 	draw any border of the viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::DrawBorder( Rect* frame ){	if ( IsVisible())	{		if ( ExecuteModifiers( kModifierDrawViewBorder, frame ))		{			if ( fBorder )				fBorder->Draw( frame );			else			{				if ( fStateFlags & kViewHasStdBorder )					StandardBorder( frame, IsActive() && IsEnabled());			}		}	}}/*------------------------------***  PrepareForDrawing  ***-----------------------------*//*access:			publicoverrides:		description: 	set up the font and coloursins: 			<rAlign> align pattern to this rect for certain typesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::PrepareForDrawing( const Rect* rAlign ){	Rect	br;	if ( rAlign )		br = *rAlign;	else		GetBounds( &br );		if ( GetParent())	{		GetParent()->PrepareForDrawing( &br );	}	else	{		PenNormal();		SetPortBlackWhite();		TextFont( 1 );		TextFace( 0 );		TextSize( 0 );		TextMode( srcOr );	}		if ( fGrafEnv )		fGrafEnv->Apply( &br, IsActive() && IsEnabled());}/*--------------------------------***  PostRefresh  ***---------------------------------*//*access:			publicoverrides:		description: 	invalidates the view's frameins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::PostRefresh(){	Rect		qdr;		GetFrame( &qdr );	if ( HasStdBorder())		InsetRect( &qdr, -2, -2 );			OffsetRect( &qdr, -qdr.left, -qdr.top );	Focus();	PostRefresh( &qdr );	}/*--------------------------------***  PostRefresh  ***---------------------------------*//*access:			publicoverrides:		description: 	invalidates the the rect passed (relative to view's current focus)ins: 			<aRect> rect to invalidateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::PostRefresh( Rect* aRect ){	if ( IsVisible())	{		WindowPtr	macW;		macW = GetRootWindowMacWindow();		MZInvalWindowRect( macW, aRect );	}}/*--------------------------------***  PostRefresh  ***---------------------------------*//*access:			publicoverrides:		description: 	invalidates the the region passed (relative to view's current focus)ins: 			<aRgn> region to invalidateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::PostRefresh( RgnHandle aRgn ){	if ( IsVisible())	{		WindowPtr	macW;		macW = GetRootWindowMacWindow();		MZInvalWindowRgn( macW, aRgn );	}}/*-----------------------------***  PostContentRefresh  ***-----------------------------*//*access:			publicoverrides:		description: 	invalidates the content area onlyins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::PostContentRefresh(){	Rect	cr;		Focus();	GetContentRect( &cr );	PostRefresh( &cr );}/*-----------------------------***  EraseBackground  ***--------------------------------*//*access:			publicoverrides:		description: 	erases the background of the content area prior to drawing the contentins: 			noneouts: 			nonenotes:			can be overridden if no erasure needed, called by DrawAll----------------------------------------------------------------------------------------*/void		ZView::EraseBackground(){	Rect	cr;		GetContentRectInBounds( &cr );	EraseRect( &cr );}/*------------------------------***  FocusForContent  ***-------------------------------*//*access:			publicoverrides:		description: 	offset the origin so that the bounds is set as the originins: 			noneouts: 			nonenotes:			Assumes view already focused on frame----------------------------------------------------------------------------------------*/Boolean		ZView::FocusForContent(){	RgnHandle	temp;	short		oh, ov, ph, pv;	Boolean		result;	Rect		rCont;		oh = PORTPORTRECT( GetMacPort())->left;	ov = PORTPORTRECT( GetMacPort())->top;		GetContentRect( &rCont );	GetPosition( &ph, &pv );	SetOrigin( oh + ph - rCont.left, ov + pv - rCont.top );		GetClip( gViewUtilRgn );	OffsetRgn( gViewUtilRgn, ph - rCont.left, pv - rCont.top );			if ( ! IsPrinting())	{		Rect	cr;		GetContentRectInBounds( &cr );		RectRgn( temp = NewRgn(), &cr );		SectRgn( temp, gViewUtilRgn, temp );		SetClip( temp );				result = ! EmptyRgn( temp );				DisposeRgn( temp );	}	else		result = TRUE;			return result;}/*----------------------------------***  FindView  ***----------------------------------*//*access:			publicoverrides:		description: 	find the view containing the point (in frame coordinates)ins: 			noneouts: 			nonenotes:			this searches down from this to any level to find the innermost view----------------------------------------------------------------------------------------*/ZView*		ZView::FindView( const Point mouse ){	Rect		qr, cr;	Point		cm;	short		ph, pv;		GetContentRect( &cr );	cm = mouse;	GetPosition( &ph, &pv );	cm.h += ph - cr.left;	cm.v += pv - cr.top;	ZView*	cv = Find1View( cm );		if ( cv && ( cv != this ))	{		// point within a child view - translate point to child view and recurse					cv->GetFrame( &qr );				cm.h -= qr.left;		cm.v -= qr.top;				cv = cv->FindView( cm );	}		return cv;	}/*---------------------------------***  Find1View  ***----------------------------------*//*access:			publicoverrides:		description: 	find the view containing the point (in bounds coordinates)ins: 			noneouts: 			nonenotes:			this only searches 1-deep. Usually called recursively for n-deep.----------------------------------------------------------------------------------------*/ZView*		ZView::Find1View( const Point mouse ){	ZView*		fv = NULL;	ZView*		cv;	long		n, i;	Rect		br;		// the point passed is relative to our bounds rect		GetBounds( &br );		if ( PtInRect( mouse, &br ) && IsVisible() && AcceptsClicks())	{		// within the bounds, what about a child?				fv = this;		if ( fChildViews )		{			Rect	cvFrame;						n = fChildViews->CountItems();						for( i = 1; i <= n; i++ )			{				cv = GetChildView( i );								if ( cv->IsVisible() && cv->AcceptsClicks())				{					// child frames are relative to our bounds as well,					// so there is no need to adjust the mouse here										cv->GetFrame( &cvFrame );										if ( PtInRect( mouse, &cvFrame ))					{						fv = cv;						break;					}				}			}			}	}		return fv;}/*-----------------------------***  FindEnclosingView  ***------------------------------*//*access:			publicoverrides:		description: 	find the view that encloses the rectangle passed.ins: 			<aRect> a rectangleouts: 			The view, or NULL if no view wholly encloses the rect.notes:			This searches as deep as necessary to find the deepest enclosing view.				The rectangle may share an edge with an enclosing view, but not overlap.				This may be used to find a parent view suitable for a new view object based 				on its position. Note: this considers FRAMES only, reflecting its purpose.----------------------------------------------------------------------------------------*/ZView*		ZView::FindEnclosingView( const Rect* aRect ){	ZView*	fv = NULL;	Rect	tr, rr;		GetFrame( &tr );		if ( SectRect( aRect, &tr, &rr ))	{		if ( EqualRect( &tr, &rr ))			{			// this at least encloses the rectangle - but see if any of its children do						if ( fChildViews )			{				// translate rect from parent to child co-ordinates								rr = *aRect;				OffsetRect( &rr, -tr.left, -tr.top );								for( long i = 1; i <= fChildViews->CountItems(); i++ )				{					fv = GetChildView( i );					fv = fv->FindEnclosingView( &rr );										if ( fv )						return fv;				}						}						// no child found that encloses, or no children at all - so enclosing			// view is this one						fv = this;		}	}		return fv;}/*-------------------------------***  AdjustCursor  ***---------------------------------*//*access:			publicoverrides:		description: 	set the cursor according to the viewins: 			<mouse> the point relative to the frame				<modifiers> the modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::AdjustCursor( const Point mouse, const short modifiers ){	short	ph, pv;	Point	cm;	Rect	cr;		GetContentRect( &cr );		if ( PtInRect( mouse, &cr ))	{		GetPosition( &ph, &pv );		cm = mouse;		cm.h += ph - cr.left;		cm.v += pv - cr.top;				ZView*	cv = Find1View( cm );				if ( cv == this )		{			ViewMouseInfo	mInfo;						mInfo.mouse = cm;			mInfo.modifiers = modifiers;			mInfo.active = IsActive() && IsEnabled();						SendMessage( kMsgViewCursorTooltipHook, &mInfo );			OpenTip( mouse, modifiers );			SetViewCursor( cm, modifiers );		}		else		{			if ( cv )			{				// mouse is within a child view, so translate point				// to child view's bounds and call its AdjustCursor method								Rect	qr;								cv->GetFrame( &qr );				cm.h -= qr.left;				cm.v -= qr.top;								cv->AdjustCursor( cm, modifiers );			}			else			{				SendMessage( kMsgViewTooltipCancel, NULL );				CloseTip();			}		}	}	else	{		SendMessage( kMsgViewTooltipCancel, NULL );		CloseTip();		SetViewCursor( mouse, modifiers );	}}/*------------------------------***  SetViewCursor  ***---------------------------------*//*access:			publicoverrides:		description: 	set the cursor for the viewins: 			<mouse> the point relative to the bounds				<modifiers> the modifier flagsouts: 			nonenotes:			this is only called if this view (and no child) contains the cursor----------------------------------------------------------------------------------------*/void		ZView::SetViewCursor( const Point mouse, const short modifiers ){	SetCursorShape( ARROW_CURSOR );}/*-----------------------------------***  Click  ***------------------------------------*//*access:			publicoverrides:		description: 	dispatch a click to the view clickedins: 			<mouse> the mouse coordinates local to frame of view				<modifiers> modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::Click( const Point mouse, const short modifiers ){	Rect		cr, qr;	Point		cm;	short		ph, pv;		GetContentRect( &cr );	cm = mouse;	GetPosition( &ph, &pv );	cm.h += ph - cr.left;	cm.v += pv - cr.top;		// cm relative to bounds, Find1View expects this		ZView*		cv = Find1View( cm );		if ( cv == this )	{		if ( IsEnabled())		{			if ( CanBeHandler() && !IsTheHandler())				GetRootWindow()->SelectHandlingView( this );						Focus();			ZGrafState	gs;						PrepareForDrawing();			FocusForContent();			ClipViewsAbove();						// test for a drag out of this view:						if ( ShouldDrag( cm, modifiers ) && MZWaitForMouseMove( cm ))				StartDrag( cm, modifiers );			else				ClickContent( cm, modifiers );		}	}	else	{		if ( cv )		{			// click was in a child view. Correct the mouse for the child view's			// frame and recurse on this						cv->GetFrame( &qr );						cm.h -= qr.left;			cm.v -= qr.top;						cv->Focus();			cv->Click( cm, modifiers );		}	}}/*----------------------------------***  Activate  ***----------------------------------*//*access:			publicoverrides:		description: 	view is becoming activeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::Activate(){	Focus();	fStateFlags |= kViewActive;		if ( IsVisible() && ( fStateFlags & kViewRefreshOnActivate ) == kViewRefreshOnActivate )		PostRefresh();		ITERATECHILDVIEWS( Activate());}/*----------------------------------***  Deactivate  ***--------------------------------*//*access:			publicoverrides:		description: 	view is becoming activeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::Deactivate(){	Focus();	fStateFlags &= ~kViewActive;		if ( IsVisible() && ( fStateFlags & kViewRefreshOnActivate ) == kViewRefreshOnActivate )		PostRefresh();		ITERATECHILDVIEWS( Deactivate());}/*-----------------------------------***  Enable  ***-----------------------------------*//*access:			publicoverrides:		description: 	view is being enabledins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::Enable(){	if ( ! IsEnabled())	{		fStateFlags |= kViewEnabled;		PostRefresh();	}}/*-----------------------------------***  Disable  ***----------------------------------*//*access:			publicoverrides:		description: 	view is being disabledins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::Disable(){	if ( IsEnabled())	{		fStateFlags &= ~kViewEnabled;		PostRefresh();	}}/*------------------------------------***  Hide  ***------------------------------------*//*access:			publicoverrides:		description: 	make the view non-visible.ins: 			noneouts: 			nonenotes:		----------------------------------------------------------------------------------------*/void		ZView::Hide(){	Rect	br;		GetFrame( &br );		if ( HasStdBorder())		InsetRect( &br, -3, -3 );		if ( GetParent())	{		GetParent()->Focus();		GetParent()->PrepareForDrawing();		EraseRect( &br );	}			fStateFlags &= ~kViewVisible;	Focus();	PostRefresh();}/*------------------------------------***  Show  ***------------------------------------*//*access:			publicoverrides:		description: 	make the view visible.ins: 			noneouts: 			nonenotes:		----------------------------------------------------------------------------------------*/void		ZView::Show(){	fStateFlags |= kViewVisible;	PostRefresh();}/*-----------------------------***  DoSelectionUpdate  ***------------------------------*//*access:			publicoverrides:		description: 	alter selection state, etc when handling view is switchedins: 			noneouts: 			nonenotes:		----------------------------------------------------------------------------------------*/void		ZView::DoSelectionUpdate( Boolean state ){	if ( GetParent())		GetParent()->DoSelectionUpdate( state );}/*-----------------------------------***  SetSize  ***----------------------------------*//*access:			publicoverrides:		description: 	set the height and width of the view.ins: 			<aWidth> - new width of view				<aHeight> - new height of viewouts: 			nonenotes:			position is not affected----------------------------------------------------------------------------------------*/void		ZView::SetSize( const short aWidth, const short aHeight ){	if (( fFrame.right - fFrame.left ) != aWidth ||		( fFrame.bottom - fFrame.top ) != aHeight )	{		Rect	br, nbr;			GetBounds( &br );				// the calls here to PostRefresh were the main cause of flicker when resizing windows.		// for 95% of views, simply not doing this is fine. For some view types, they will		// need to calculate a refresh region here depending on what actually happened.				if ( fStateFlags & kViewRefreshOnResize )			PostRefresh();				fFrame.right = fFrame.left + aWidth;		fFrame.bottom = fFrame.top + aHeight;		GetBounds( &nbr );				short	dt, dl, db, dr;				dt = nbr.top - br.top;		dl = nbr.left - br.left;		db = nbr.bottom - br.bottom;		dr = nbr.right - br.right;				if ( dt || dl || db || dr )		{			ITERATECHILDVIEWS( AdjustToParent( dt, dl, db, dr ));		}				if ( fStateFlags & kViewRefreshOnResize )			PostRefresh();		GetFrame( &br );		SendMessage( kMsgViewResized, &br );	}}/*-----------------------------------***  PlaceAt  ***----------------------------------*//*access:			publicoverrides:		description: 	set the view's position with its parentins: 			<hPos> - horizontal position in parent				<vPos> - vertical position in parentouts: 			nonenotes:			position is not affected----------------------------------------------------------------------------------------*/void		ZView::PlaceAt( const short hPos, const short vPos ){	if ( hPos != fFrame.left || vPos != fFrame.top )	{		PostRefresh();		OffsetRect( &fFrame, hPos - fFrame.left, vPos - fFrame.top );		PostRefresh();	}}/*---------------------------------***  FitToParent  ***--------------------------------*//*access:			publicoverrides:		description: 	size and position view to fit the parent's bounds rectins: 			<fitH> fit to the bounds horizontally				<fitV> fit to the bounds verticallyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::FitToParent( const Boolean fitH, const Boolean fitV ){	Rect	pr;		if ( GetParent())	{		GetParent()->GetBounds( &pr );				PostRefresh();				if ( fitV )			fFrame.top = 0;				if ( fitH )				fFrame.left = 0;				SetSize( fitH? ( pr.right - pr.left ) : ( fFrame.right - fFrame.left ),				 fitV? ( pr.bottom - pr.top ) : ( fFrame.bottom - fFrame.top ));	}}/*------------------------------***  FitToParentPlusOne  ***----------------------------*//*access:			publicoverrides:		description: 	as above, but outset by one on each edge affectedins: 			<fitH> fit to the bounds horizontally				<fitV> fit to the bounds verticallyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::FitToParentPlusOne( const Boolean fitH, const Boolean fitV ){	FitToParent( fitH, fitV );	ChangeSize( fitV? -1 : 0, fitH? -1 : 0, fitV? 1 : 0, fitH? 1 : 0 );}/*--------------------------------***  CentreInParent  ***------------------------------*//*access:			publicoverrides:		description: 	centres the view frame within its parent boundsins: 			<centreH> centre horizontally				<centreV> centre verticallyouts: 			nonenotes:			does not change the view's size, only its position----------------------------------------------------------------------------------------*/void		ZView::CentreInParent( const Boolean centreH, const Boolean centreV ){	if ( GetParent())	{		Rect	parBounds;		short	ph, pv, width, height;				ph = fFrame.left;		pv = fFrame.top;		width = fFrame.right - fFrame.left;		height = fFrame.bottom - fFrame.top;			GetParent()->GetBounds( &parBounds );				if ( centreH )			ph = (( parBounds.right + parBounds.left ) / 2 ) - ( width / 2 );				if ( centreV )			pv = (( parBounds.bottom + parBounds.top ) / 2 ) - ( height / 2 );				PlaceAt( ph, pv );	}}/*-------------------------------***  AdjustToParent  ***-------------------------------*//*access:			publicoverrides:		description: 	adjust anything after parent resizedins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::AdjustToParent( const short dt, const short dl, const short db, const short dr ){	// our parent view has been resized, so we may need to adjust ourselves to it		if ( fAutoSizing && GetParent())	{		Rect		newFrame = fFrame;		Boolean		hCentre = FALSE, vCentre = FALSE;				switch( TOPEDGESIZING( fAutoSizing ))		{			case NONE:				break;							case FIXEDTOP:				newFrame.top += dt;				break;							case FIXEDBOTTOM:				// top edge a fixed distance from bottom of bounds				newFrame.top += db;				break;							case AUTOCENTRE:				vCentre = TRUE;				break;		}						switch( LEFTEDGESIZING( fAutoSizing ))		{			case NONE:				break;							case FIXEDLEFT:				newFrame.left += dl;				break;							case FIXEDRIGHT:				newFrame.left += dr;				break;							case AUTOCENTRE:				hCentre = TRUE;				break;		}				switch( BOTTOMEDGESIZING( fAutoSizing ))		{			case NONE:				break;							case FIXEDBOTTOM:				newFrame.bottom += db;				break;							case FIXEDTOP:				newFrame.bottom += dt;				break;							case AUTOCENTRE:				vCentre = TRUE;				break;		}				switch( RIGHTEDGESIZING( fAutoSizing ))		{			case NONE:				break;							case FIXEDRIGHT:				newFrame.right += dr;				break;							case FIXEDLEFT:				newFrame.right += dl;				break;							case AUTOCENTRE:				hCentre = TRUE;				break;		}					if ( hCentre || vCentre )			CentreInParent( hCentre, vCentre );					PlaceAt( newFrame.left, newFrame.top );		SetSize( newFrame.right - newFrame.left, newFrame.bottom - newFrame.top );		}}/*---------------------------------***  ChangeSize  ***---------------------------------*//*access:			publicoverrides:		description: 	alter edges of frame by small incrementsins: 			<deltaTop>, etc.. deltas for top, left, bottom, right				pos values are down and right, neg values up and leftouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::ChangeSize( const short deltaTop, const short deltaLeft, const short deltaBottom, const short deltaRight ){	Rect	newFrame = fFrame;		newFrame.top 	+= deltaTop;	newFrame.left 	+= deltaLeft;	newFrame.bottom += deltaBottom;	newFrame.right 	+= deltaRight;		PlaceAt( newFrame.left, newFrame.top );	SetSize( newFrame.right - newFrame.left, newFrame.bottom - newFrame.top );	}/*------------------------------***  ReceiveMessage  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to message about radio buttons to manage sets of themins: 			<aSender> sender of message				<msg> the message				<msgData> data with messageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	if ( msg == kMsgRadioControlTurningOn )	{		short group = *(short*) msgData;		RadioButtonChore( fChildViews, group );	}		ZCommander::ReceiveMessage( aSender, msg, msgData );	}/*-------------------------------***  GetContentRect  ***-------------------------------*//*access:			publicoverrides:		description: 	get interior writable area of view in frame coordinates.ins: 			<aRect> accepts resultouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::GetContentRect( Rect* aRect ){	*aRect = fFrame;	OffsetRect( aRect, -aRect->left, -aRect->top );}/*-----------------------------------***  GetFrame  ***---------------------------------*//*access:			publicoverrides:		description: 	get frame of view in parent bounds coordinatesins: 			<aFrame> accepts resultouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::GetFrame( Rect* aFrame ){	*aFrame = fFrame;}/*----------------------------------***  GetBounds  ***---------------------------------*//*access:			publicoverrides:		description: 	get logical bounds of the viewins: 			<aBounds> accepts resultouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::GetBounds( Rect* aBounds ){	GetContentRect( aBounds );}/*---------------------------------***  GetPosition  ***--------------------------------*//*access:			publicoverrides:		description: 	get position of bounds with respect to the frameins: 			<posH, posV> accepts horizontal and vertical position of boundsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::GetPosition( short* posH, short* posV ){	*posH = *posV = 0;}/*---------------------------***  GetContentRectInBounds  ***---------------------------*//*access:			publicoverrides:		description: 	get interior writable area of view in bounds coordinates.ins: 			<aRect> accepts resultouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::GetContentRectInBounds( Rect* aRect ){	short	h, v;		GetContentRect( aRect );	OffsetRect( aRect, -aRect->left, -aRect->top );	GetPosition( &h, &v );	OffsetRect( aRect, h, v );}/*---------------------------------***  SetFontInfo  ***--------------------------------*//*access:			publicoverrides:		description: 	set the text characteristics for this viewins: 			<fontID> the font				<size> the size of the font				<style> the style of the fontouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::SetFontInfo( const short fontID, const short size, const Style style ){	MakeEnvironment();		fGrafEnv->SetFontInfo( fontID, size, style );}/*--------------------------------***  SetForeColour  ***-------------------------------*//*access:			publicoverrides:		description: 	set the foreground colourins: 			<aColour> - the colour to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::SetForeColour( const RGBColor* aColour ){	MakeEnvironment();		fGrafEnv->SetForeColour( aColour );}/*--------------------------------***  SetBackColour  ***-------------------------------*//*access:			publicoverrides:		description: 	set the background colourins: 			<aColour> - the colour to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::SetBackColour( const RGBColor* aColour ){	MakeEnvironment();		fGrafEnv->SetBackColour( aColour );}/*---------------------------------***  GetChildView  ***-------------------------------*//*access:			publicoverrides:		description: 	return the Nth child view, or NULL if noneins: 			<index> - index of view to obtainouts: 			nonenotes:			----------------------------------------------------------------------------------------*/ZView*		ZView::GetChildView( const long index ){	ZView*	cv = NULL;		if ( fChildViews )		cv = (ZView*) fChildViews->GetObject( index );			return cv;}/*----------------------------***  FindChildViewByUserID  ***---------------------------*//*access:			publicoverrides:		description: 	find a child view by searching for the userID passedins: 			<aUserID> - userID to look for				<deepSearch> if TRUE, keep looking through hierarchy. If FALSE, check only				child views of this viewouts: 			View found with user ID, or NULLnotes:			----------------------------------------------------------------------------------------*/ZView*		ZView::FindChildViewByUserID( const long aUserID, Boolean deepSearch ){	ZView*	cv = NULL;	long	i, n;		if ( fChildViews )	{		n = fChildViews->CountItems();				for( i = 1; i <= n; i++ )		{			cv = GetChildView( i );					if ( cv->GetUserID() == aUserID )				return cv;						// if a deep search, scan the child views of the view							if ( deepSearch )			{				cv = cv->FindChildViewByUserID( aUserID, deepSearch );								if ( cv )					return cv;			}		}	}		return NULL;}/*----------------------------------***  GetMacPort  ***--------------------------------*//*access:			publicoverrides:		description: 	return GrafPort the view is part ofins: 			noneouts: 			the grafportnotes:			----------------------------------------------------------------------------------------*/CGrafPtr	ZView::GetMacPort(){	CGrafPtr	mPort = NULL;		if ( GetParent())		mPort = GetParent()->GetMacPort();	else	{		// we're the root view, which must be a window of some kind,		// so get port of window. If this is called before we have		// been added to a parent, will return NULL				ZWindow*	zw = dynamic_cast<ZWindow*>( this );			if ( zw )		{			if ( sActivePort )				mPort = sActivePort;			else				mPort = WINDOWGRAFPTR( zw->GetMacWindow());		}	}		return mPort;}/*----------------------------------***  GetParent  ***---------------------------------*//*access:			publicoverrides:		description: 	returns the parent of this view, unless this is the root viewins: 			noneouts: 			the parent view of this one, or NULL if this is root viewnotes:			----------------------------------------------------------------------------------------*/ZView*		ZView::GetParent(){	ZWindow*	zw;		zw = dynamic_cast<ZWindow*>( this );		if (( zw == NULL ) && itsBoss )		return dynamic_cast<ZView*>( itsBoss );	else		return NULL;}/*--------------------------------***  GetRootWindow  ***-------------------------------*//*access:			publicoverrides:		description: 	return the window that ultimately encloses the viewins: 			noneouts: 			the window, or NULL if root view not a windownotes:			----------------------------------------------------------------------------------------*/ZWindow*	ZView::GetRootWindow(){	ZWindow*	zw = NULL;		zw = dynamic_cast<ZWindow*>( this );		if ( zw == NULL )		zw = GetParent()->GetRootWindow();			return zw;}/*---------------------------***  GetRootWindowMacWindow  ***---------------------------*//*access:			publicoverrides:		description: 	return the Mac window pointer that ultimately owns the viewins: 			noneouts: 			the WindowPtr, or NULL if root view not a windownotes:			----------------------------------------------------------------------------------------*/WindowPtr	ZView::GetRootWindowMacWindow(){	ZWindow*	rw = GetRootWindow();		if ( rw )		return rw->GetMacWindow();	else		return NULL;}/*---------------------------------***  IsEnabled  ***----------------------------------*//*access:			publicoverrides:		description: 	returns if view is enabledins: 			noneouts: 			TRUE is enablednotes:			takes account of enable state of parent view as well----------------------------------------------------------------------------------------*/Boolean		ZView::IsEnabled(){	Boolean	enb = ( fStateFlags & kViewEnabled ) == kViewEnabled;		if ( GetParent())		enb = ( enb && GetParent()->IsEnabled());		return enb;}/*---------------------------------***  IsVisible  ***----------------------------------*//*access:			publicoverrides:		description: 	returns if view is visibleins: 			noneouts: 			TRUE is visiblenotes:			takes account of visiblity of parent view as well----------------------------------------------------------------------------------------*/Boolean		ZView::IsVisible(){	Boolean	vis;		vis = ( fStateFlags & kViewVisible ) == kViewVisible;		if ( GetParent())		vis = ( vis && GetParent()->IsVisible());		return vis;		}/*--------------------------------***  IsPrinting  ***----------------------------------*//*access:			publicoverrides:		description: 	returns if the root window is currently printing. A printable view may				check this to suppress non-printable drawing elements, etc.ins: 			noneouts: 			TRUE if printing in progressnotes:			----------------------------------------------------------------------------------------*/Boolean		ZView::IsPrinting(){	return GetRootWindow()->IsPrinting();}/*-------------------------------***  IsTheHandler  ***---------------------------------*//*access:			publicoverrides:		description: 	returns if this voiew is currently the handler for the root windowins: 			noneouts: 			TRUE if this view is the handlernotes:			----------------------------------------------------------------------------------------*/Boolean		ZView::IsTheHandler(){	return ( GetRootWindow()->GetHandler() == this );}/*--------------------------------***  AddChildView  ***-------------------------------*//*access:			publicoverrides:		description: 	add a child view to this view. This automatically sets the parent and portins: 			<aView> - the child view to attachouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::AddChildView( ZView* aView ){	FailNILParam( aView );		if ( fChildViews == NULL )		FailNIL( fChildViews = new ZObjectList());			fChildViews->AppendItem( aView );		// child view initially inherits basic grafPort settings from this	/*	aView->fFore 		= fFore;	aView->fBack 		= fBack;	aView->fFont 		= fFont;	aView->fFontSize 	= fFontSize;	aView->fStyle 		= fStyle;	*/}/*--------------------------------***  RemoveChildView  ***-----------------------------*//*access:			publicoverrides:		description: 	remove a child view from this viewins: 			<aView> - the child view to removeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::RemoveChildView( ZView* aView ){	if ( fChildViews )		fChildViews->DeleteObject( aView );}/*----------------------------------***  CountViews  ***--------------------------------*//*access:			publicoverrides:		description: 	count all views starting with this oneins: 			noneouts: 			count of viewsnotes:			----------------------------------------------------------------------------------------*/long		ZView::CountViews(){	long	n = 1;		if ( fChildViews )	{		ZView*	child;			for( long i = 1; i <= fChildViews->CountItems(); i++ )		{			child = (ZView*) fChildViews->GetObject( i );					n += child->CountViews();		}	}		return n;}/*---------------------------------***  IsChildView  ***--------------------------------*//*access:			publicoverrides:		description: 	test if a view is achild of this oneins: 			<aView> view to test				<deepSearch> TRUE to test if a child view at any level, FALSE for				immediate level onlyouts: 			TRUE if view a child of this onenotes:			----------------------------------------------------------------------------------------*/Boolean		ZView::IsChildView( ZView* aView, Boolean deepSearch ){	if ( fChildViews )	{		if ( deepSearch )		{			// TO DO			return FALSE;		}		else			return fChildViews->Contains( aView );	}	else		return FALSE;}/*----------------------------------***  DDEnterView  ***-------------------------------*//*access:			publicoverrides:		description: 	a drag/drop has entered the viewins: 			<mouse> local mouse coordinates				<theDrag> the drag dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::DDEnterView( const DragReference theDrag ){	DDHiliteView( TRUE, theDrag );	sCurRxDragTarget = this;}/*---------------------------------***  DDHiliteView  ***-------------------------------*//*access:			publicoverrides:		description: 	hilite the view for a drag/dropins: 			<state> on or offouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::DDHiliteView( const Boolean state, const DragReference theDrag, const Boolean insideFrame ){	RgnHandle	dragHiliteRgn;	Rect		content;	ZGrafState	gs;		Focus();	PrepareForDrawing();		if ( state )	{		// make the hilite region				FailNIL( dragHiliteRgn = NewRgn());					GetContentRect( &content );		RectRgn( dragHiliteRgn, &content );		ShowDragHilite( theDrag, dragHiliteRgn, insideFrame );		DisposeRgn( dragHiliteRgn );	}	else		HideDragHilite( theDrag );}/*--------------------------------***  DDDispatchView  ***------------------------------*//*access:			publicoverrides:		description: 	determine target of drag and highlight appropriatelyins: 			<mouse> local mouse coordinates				<theDrag> the drag dataouts: 			nonenotes:			called repeatedly by tracking handler - do not override----------------------------------------------------------------------------------------*/void		ZView::DDDispatchView( const Point mouse, const DragReference theDrag ){	ZView*	cv = FindView( mouse );		if ( cv && ( cv != GetDragTargetView()))	{		if ( GetDragTargetView())			GetDragTargetView()->DDExitView( theDrag );				if ( cv->CanAcceptTheDrag( theDrag ))			cv->DDEnterView( theDrag );		}		// repeatedly call "inside" method		if ( cv && ( cv == GetDragTargetView()))	{		Point	cm;				cv->Focus();		cv->PrepareForDrawing();		cv->FocusForContent();		cv->ClipViewsAbove();		GetDragMouse( theDrag, &cm, NULL );		GlobalToLocal( &cm );		cv->DDInsideView( cm, theDrag );	}}/*-----------------------------------***  DDExitView  ***-------------------------------*//*access:			publicoverrides:		description: 	a drag/drop has left the viewins: 			<mouse> local mouse coordinates				<theDrag> the drag dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::DDExitView( const DragReference theDrag ){	DDHiliteView( FALSE, theDrag );	sCurRxDragTarget = NULL;}/*------------------------------***  CanAcceptTheDrag  ***------------------------------*//*access:			publicoverrides:		description: 	checks if the view can accept any flavour in the dragins: 			<theDrag> the drag dataouts: 			TRUE if can accept at least one flavour, else FALSEnotes:			not normally overridden - override AcceptsFlavour instead----------------------------------------------------------------------------------------*/Boolean		ZView::CanAcceptTheDrag( const DragReference theDrag )	{	unsigned short	dragItemCount;	unsigned short	dragFlavourCount;	ItemReference	iRef;	FlavorType		theFlavour;		if ( IsEnabled())	{		FailOSErr( CountDragItems( theDrag, &dragItemCount ));				if ( dragItemCount )		{			do			{				// for each drag item, count the flavours								FailOSErr( GetDragItemReferenceNumber( theDrag, dragItemCount, &iRef ));				FailOSErr( CountDragItemFlavors( theDrag, iRef, &dragFlavourCount ));								// for each flavour, see if we can accept it. As soon as we get one that we can				// handle, we have our answer and can exit immediately								do				{					FailOSErr( GetFlavorType( theDrag, iRef, dragFlavourCount, &theFlavour ));										if ( AcceptsFlavour( theFlavour ))						return TRUE;				}				while( --dragFlavourCount );			}			while( --dragItemCount );		}	}	return FALSE;}/*---------------------------------***  UnpackDrop  ***---------------------------------*//*access:			publicoverrides:		description: 	called if data is dropped on this view - unpacks drag and calls Drop methodins: 			<theDrag> the drag dataouts: 			TRUE if something was accepted, FALSE if nothing wasnotes:			called by the drop handler callback----------------------------------------------------------------------------------------*/Boolean		ZView::UnpackDrop( const DragReference theDrag )	{	// method to dispatch drops from the drag manager. This unpacks the drag data, and for	// each flavour that the AcceptsFlavour method returns TRUE for, will call Drop with the	// data of the item. The data is sent directly to the target view of the drop.		unsigned short	dragItemCount, i;	unsigned short	dragFlavourCount, f;	ItemReference	iRef;	FlavorType		theFlavour;	Boolean			atLeastOneAccepted = FALSE;	Size			dataSize;	Ptr				theData = NULL;		FailOSErr( CountDragItems( theDrag, &dragItemCount ));		SetBeachBallCursor();		for ( i = 1; i <= dragItemCount; i++ )	{		// get the item				FailOSErr( GetDragItemReferenceNumber( theDrag, i, &iRef ));				// count the flavours in the item				FailOSErr( CountDragItemFlavors( theDrag, iRef, &dragFlavourCount ));				// for each flavour, if target can accept the flavour, unpack it and pass the data		// to the drop method.				for ( f = 1; f <= dragFlavourCount; f++ )		{			FailOSErr( GetFlavorType( theDrag, iRef, f, &theFlavour ));					if ( AcceptsFlavour( theFlavour ))			{				// get the data for this object								FailOSErr( GetFlavorDataSize( theDrag, iRef, theFlavour, &dataSize ));								// create a buffer big enough to hold the object								FailNIL( theData = NewPtr( dataSize ));								// get the data into the buffer								try				{					FailOSErr( GetFlavorData( theDrag, iRef, theFlavour, theData, &dataSize, 0L ));					Drop( theFlavour, theData, dataSize, theDrag );					atLeastOneAccepted = TRUE;				}				catch( ZoopError err )				{					if ( theData )						DisposePtr( theData );											theData = NULL;										throw err;					}					if ( theData )					DisposePtr( theData );									theData = NULL;			}		}	}		return atLeastOneAccepted;}/*------------------------------------***  StartDrag  ***-------------------------------*//*access:			publicoverrides:		description: 	start dragging from this viewins: 			<mouse> point relative to bounds				<modifiers> modifiers for current eventouts: 			TRUE if the drag occurred successfully, otherwise falsenotes:			----------------------------------------------------------------------------------------*/Boolean		ZView::StartDrag( const Point mouse, const short modifiers ){	OSErr 	theErr = paramErr;	if ( gMacInfo.hasDragManager )	{		if ( WaitMouseMoved( mouse ))		{			RgnHandle		dragRgn;			Point			dragOffset;			DragReference	dragRef;			EventRecord		fakeEvt;						FailNIL( dragRgn = NewRgn());			MakeDragRegion( dragRgn );				CopyRgn( dragRgn, gUtilRgn );			InsetRgn( gUtilRgn, 1, 1 );			DiffRgn( dragRgn, gUtilRgn, dragRgn );						dragOffset = TOPLEFTPOINT( *REGIONBOUNDINGBOX( dragRgn ));						OffsetRgn( dragRgn, -dragOffset.h, -dragOffset.v );			LocalToGlobal( &dragOffset );			OffsetRgn( dragRgn, dragOffset.h, dragOffset.v );						// make up a fake mousedown event						dragOffset = mouse;			LocalToGlobal( &dragOffset );						fakeEvt.what = mouseDown;			fakeEvt.when = TickCount();			fakeEvt.where = dragOffset;			fakeEvt.message = 0;			fakeEvt.modifiers = modifiers;						// create drag and add data to it						FailOSErr( NewDrag( &dragRef ));			sCurTxDragRef = dragRef;			sCurTxDragSender = this;			MakeDragData( dragRef, modifiers );						// do it...						theErr = TrackDrag( dragRef, &fakeEvt, dragRgn );						// ...call completion method if drag completed OK...						if ( theErr == noErr )				DragCompleted( dragRef );						// ...and clean up						sCurTxDragSender = NULL;			sCurTxDragRef = NULL;			DisposeDrag( dragRef );			DisposeRgn( dragRgn );				}	}		return ( theErr == noErr );}/*---------------------------------***  MakeDragRegion  ***-----------------------------*//*access:			publicoverrides:		description: 	create the drag region for the viewins: 			<aRgn> receives the regionouts: 			nonenotes:			region is relative to bounds - caller will form outline from it & do				global conversion----------------------------------------------------------------------------------------*/void		ZView::MakeDragRegion( RgnHandle aRgn ){	Rect	cr;		FailNILParam( aRgn );	GetContentRectInBounds( &cr );	RectRgn( aRgn, &cr );}/*----------------------------------***  AttachBorder  ***------------------------------*//*access:			publicoverrides:		description: 	attach a border drawing object to the viewins: 			<aBorder> the border object to attachouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::AttachBorder( ZViewBorder* aBorder ){	if ( fBorder && ( aBorder != fBorder ))		FORGETOBJECT( fBorder );			fBorder = aBorder;}/*-------------------------------***  StandardBorder  ***------------------------------*//*access:			publicoverrides:		description: 	draw the default border when no special border is attachedins: 			<bFrame> border frameouts: 			nonenotes:			draws focus ring and 3D edge if appropriate----------------------------------------------------------------------------------------*/void		ZView::StandardBorder( Rect* bFrame, Boolean inState ){#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		InsetRect( bFrame, 1, 1 );				if ( IsInDirectCommandChain())		{			if ( fStateFlags & kViewHasListBoxBorder )				DrawThemeListBoxFrame( bFrame, inState );			else				DrawThemeEditTextFrame( bFrame, inState );			DrawThemeFocusRect( bFrame, inState );		}		else		{			DrawThemeFocusRect( bFrame, FALSE );						if ( fStateFlags & kViewHasListBoxBorder )				DrawThemeListBoxFrame( bFrame, inState );			else				DrawThemeEditTextFrame( bFrame, inState );		}	}		else	{#endif		RGBColor	bColour;				if ( inState )			RGBForeColor( &gBlack );		else			RGBForeColor( &gMidGray );				PenNormal();		FrameRect( bFrame );				if ( inState && ! IsInDirectCommandChain())			FrameGrayRect( bFrame );		else			InsetRect( bFrame, 1, 1 );		InsetRect( bFrame, -3, -3 );		PenSize( 2, 2 );				if ( IsInDirectCommandChain() && inState )			bColour = gDarkGray;		else			GetBackColor( &bColour );					RGBForeColor( &bColour );		FrameRoundRect( bFrame, 4, 4 );		#if APPEARANCE_MGR_AWARE	}#endif	}/*--------------------------------***  DrawSelfBorder  ***------------------------------*//*access:			publicoverrides:		description: 	redraw the view's border - the view itself may sometimes need to do thisins: 			noneouts: 			nonenotes:			normally border drawn by parent, but view can drw own border with this----------------------------------------------------------------------------------------*/void		ZView::DrawSelfBorder(){	if ( GetParent())	{		GetParent()->Focus();		GetParent()->PrepareForDrawing();		GetParent()->FocusForContent();				Rect	fr;				GetFrame( &fr );		InsetRect( &fr, -1, -1 );		DrawBorder( &fr );	}}/*--------------------------------***  WriteToStream  ***-------------------------------*//*access:			publicoverrides:		description: 	write view state to streamins: 			<aStream> stream to write toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::WriteToStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZCommander::WriteToStream( aStream );		aStream->WriteObject( fChildViews );	aStream->WriteObject( fBorder );	aStream->WriteRect( &fFrame );	//aStream->WriteColour( &fFore );	//aStream->WriteColour( &fBack );	aStream->WriteLong( fUserID );	//aStream->WriteShort( fFont );	//aStream->WriteShort( fFontSize );	//aStream->WriteChar( fStyle );	aStream->WriteChar( fAutoSizing );	aStream->WriteShort( fStateFlags );	#endif}/*-------------------------------***  ReadFromStream  ***-------------------------------*//*access:			publicoverrides:		description: 	read view state from streamins: 			<aStream> stream to read fromouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::ReadFromStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZCommander::ReadFromStream( aStream );		fChildViews = (ZViewList*) aStream->ReadObject();	fBorder = (ZViewBorder*) aStream->ReadObject();	aStream->ReadRect( &fFrame );	//aStream->ReadColour( &fFore );	//aStream->ReadColour( &fBack );	aStream->ReadLong( &fUserID );	//aStream->ReadShort( &fFont );	//aStream->ReadShort( &fFontSize );	//aStream->ReadChar((char*) &fStyle );	aStream->ReadChar((char*) &fAutoSizing );	aStream->ReadShort((short*) &fStateFlags );#endif}/*------------------------------***  InitViewFromResource  ***--------------------------*//*access:			publicoverrides:		description: 	initialise the view from data in a 'View' resource handleins: 			<theRes> handle to 'View' resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZView::InitViewFromResource( Handle theRes ){	FailNILParam( theRes );		ViewTemplateHdl		vtH = (ViewTemplateHdl) theRes;		fFrame 		= (*vtH)->frame;	//fFore 		= (*vtH)->fore;	//fBack 		= (*vtH)->back;	fUserID 	= (*vtH)->userID;	//fFont 		= (*vtH)->font;	//fFontSize 	= (*vtH)->fontSize;	//fStyle 		= (*vtH)->style;	fAutoSizing = (*vtH)->autoSizing;	fStateFlags = 0;		SetCanBeHandler((*vtH)->canBeHandler );	SetNoBackgroundErase((*vtH)->noBackgroundErase );	SetAcceptsMouseClicks((*vtH)->acceptsMouseClicks );	SetStandardBorder((*vtH)->hasStdBorder );	SetDefaultItem((*vtH)->isDefaultItem );		// auto fit to parent if set to do so		if ( GetParent() && (*vtH)->autoFitToParent )	{		char 	hf, vf;				hf = (*vtH)->autoFitToParent & 0x0003;		vf = (*vtH)->autoFitToParent & 0x000C >> 2;				switch( hf )		{			case kViewAutoFitFrame:				FitToParent( TRUE, FALSE );				break;							case kViewAutoFitFramePlus:				FitToParentPlusOne( TRUE, FALSE );				break;							case kViewAutoFitCentre:				CentreInParent( TRUE, FALSE );				break;		}			switch( vf )		{			case kViewAutoFitFrame:				FitToParent( FALSE, TRUE );				break;							case kViewAutoFitFramePlus:				FitToParentPlusOne( FALSE, TRUE );				break;							case kViewAutoFitCentre:				CentreInParent( FALSE, TRUE );				break;		}	}}/*-------------------------------***  CreateViewResource  ***---------------------------*//*access:			publicoverrides:		description: 	Fills in the resource handle according to its templated structureins: 			<resHandle> valid handle of adequate sizeouts: 			nonenotes:			This method should only be used by the RAD tool to create View resources				(not for application use)----------------------------------------------------------------------------------------*/void	ZView::CreateViewResource( Handle resHandle ){	FailNILParam( resHandle );		// check handle is big enough:		if ( GetHandleSize( resHandle ) < sizeof( ViewTemplate ))		FailOSErr( kViewTemplateHandleSizeTooSmallErr );		ViewTemplateHdl		vtH = (ViewTemplateHdl) resHandle;		(*vtH)->viewType 	= GetClassRef();	(*vtH)->viewVersion = kViewTemplateCurrentVersion;	(*vtH)->headerSize  = sizeof( ViewTemplate );	(*vtH)->frame 		= fFrame;	//(*vtH)->fore		= fFore;	//(*vtH)->back		= fBack;	(*vtH)->userID		= GetUserID();	//(*vtH)->font		= fFont;	//(*vtH)->fontSize	= fFontSize;	//(*vtH)->style		= fStyle;	(*vtH)->autoSizing	= fAutoSizing;	if ( GetParent())		(*vtH)->parentID = GetParent()->GetPrivateID();	else		(*vtH)->parentID = 0;			(*vtH)->canBeHandler = CanBeHandler();	(*vtH)->noBackgroundErase = ErasesBackground();	(*vtH)->acceptsMouseClicks = AcceptsClicks();	(*vtH)->hasStdBorder = HasStdBorder();	(*vtH)->isDefaultItem = IsDefaultItem();}/*----------------------------------***  ReportFields  ***------------------------------*//*access:			publicoverrides:		description: 	provide info for the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::ReportFields(){	ZCommander::ReportFields();		XSHOWFIELD( fChildViews, ft_objectref );	XSHOWFIELD( fBorder, ft_objectref );	XSHOWFIELD( fGrafEnv, ft_objectref );	XSHOWFIELD( fFrame, ft_Rect );	XSHOWFIELD( fPrivateID, ft_signedlong );	XSHOWFIELD( fUserID, ft_signedlong );	XSHOWFIELD( fAutoSizing, ft_unsignedchar );	XSHOWFIELD( fStateFlags, ft_binary16 );}/*------------------------------------***  OpenTip  ***---------------------------------*//*access:			publicoverrides:		description: 	open a tooltip for this viewins: 			<mouse> mouse location				<modifiers>outs: 			nonenotes:			default method defers to standard tooltip handler; this method will be				repeatedly called while mouse is in the view----------------------------------------------------------------------------------------*/void		ZView::OpenTip( const Point mouse, const short modifiers ){#if __TOOLTIPS	if ( gTooltips && IsActive() && IsEnabled())		gTooltips->ShowTooltip( this );#endif}/*-----------------------------------***  CloseTip  ***---------------------------------*//*access:			publicoverrides:		description: 	close a previously opened tooltip for this viewins: 			noneouts: 			nonenotes:			default method defers to standard tooltip handler----------------------------------------------------------------------------------------*/void		ZView::CloseTip(){#if __TOOLTIPS	if ( gTooltips )		gTooltips->HideTooltip();#endif}/*-------------------------------***  GetTooltipText  ***-------------------------------*//*access:			publicoverrides:		description: 	return string displayed by tooltipins: 			<tipText> receives view's tip stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::GetTooltipText( Str255 tipText ){	if ( fTipText )		BlockMoveData( *fTipText, tipText, GetHandleSize((Handle) fTipText ));	else		tipText[0] = 0;			#if _TIPS_DEBUG	if ( tipText[0] == 0 )	{		char*	cn;				cn = (char*) typeid( *this ).name();		CopyCToPString( cn, tipText );	}#endif	}/*-------------------------------***  SetTooltipText  ***-------------------------------*//*access:			publicoverrides:		description: 	set string displayed by tooltipins: 			<tipText> the stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::SetTooltipText( Str255 tipText ){	if ( fTipText )		SetString( fTipText, tipText );	else		FailNIL( fTipText = NewString( tipText ));}#pragma mark -/*---------------------------------***  ClipViewsAbove  ***-----------------------------*//*access:			privateoverrides:		description: 	clip out child views within this oneins: 			noneouts: 			nonenotes:			this view already focused & clipped when called----------------------------------------------------------------------------------------*/void		ZView::ClipViewsAbove(){	Rect		rv;	RgnHandle	tr, vr;	long		n, i;	ZView*		cv;		if ( fChildViews )	{		FailNIL( tr = NewRgn());		FailNIL( vr = NewRgn());			n = fChildViews->CountItems();				for( i = 1; i <= n; i++ )		{			cv = GetChildView( i );						// do not clip views that don't erase their background. This			// means they are filled with their parent's back colour, as desired						if ( cv->IsVisible() && cv->ErasesBackground())			{				cv->GetFrame( &rv );				RectRgn( vr, &rv );				UnionRgn( vr, tr, tr );			}		}				GetClip( vr );		DiffRgn( vr, tr, vr );		SetClip( vr );				DisposeRgn( tr );		DisposeRgn( vr );	}		}/*---------------------------------***  DeleteChildren  ***-----------------------------*//*access:			privateoverrides:		description: 	delete all of the child viewsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::DeleteChildren(){	if ( fChildViews )	{		fChildViews->DisposeAll();		FORGETOBJECT( fChildViews );	}}/*------------------------------------***  SetFrame  ***--------------------------------*//*access:			protectedoverrides:		description: 	force the frame and bounds to a valueins: 			<frame> frame to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::SetFrame( Rect* frame ){	fFrame = *frame;}/*---------------------------------***  SetActivePort  ***------------------------------*//*access:			protectedoverrides:		description: 	set current port to the root of the view, or active port if setins: 			noneouts: 			nonenotes:			Do NOT call - internal method only.----------------------------------------------------------------------------------------*/void		ZView::SetActivePort(){	if ( sActivePort )	{		SetPort((GrafPtr) sActivePort );		SetOrigin( sCurPortOrigin.h, sCurPortOrigin.v );	}	else	{		SetGWorld( GetMacPort(), GetMainDevice());		SetOrigin( 0, 0 );	}}/*------------------------------------***  ViewInit  ***--------------------------------*//*access:			protectedoverrides:		description: 	perform common initialisationins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::ViewInit(){	fChildViews = NULL;	fBorder = NULL;	fGrafEnv = NULL;	fStateFlags = kViewVisible + kViewEnabled + kViewAcceptsMouseClicks + kViewRefreshOnActivate;	fPrivateID = 0;	fUserID = 0;	fAutoSizing = NONE;	fTipText = NULL;}/*---------------------------------***  ViewResInit  ***--------------------------------*//*access:			protectedoverrides:		description: 	perform view object initialisation from 'View' resourceins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZView::ViewResInit( const short viewResID ){	Handle		vr;		FailNILRes( vr = GetResource( kViewTemplateResType, viewResID ));		// by this ID, code is able to locate the view and use it as a parent for	// another view. This allows hierarchies to be built from resources created	// by the RAD tool.		fPrivateID = viewResID;		HNoPurge( vr );	InitViewFromResource( vr );	ReleaseResource( vr );}/*--------------------------------***  ViewDragInParent  ***----------------------------*//*access:			protectedoverrides:		description: 	debug method - allows direct dragging of a view to a new positionins: 			<mouse> the pointouts: 			nonenotes:			Focus should be on view's parent bounds - mouse relative to this----------------------------------------------------------------------------------------*/void		ZView::ViewDragInParent( Point mouse ){	Rect	dr;	Point	om;	long	delta;		GetFrame( &dr );	PenMode( patXor );	PenSize( 1, 1 );	PenPat( QDGRAYPATTERN );	FrameRect( &dr );	om = mouse;		do	{		GetMouse( &mouse );				delta = DeltaPoint( mouse, om );				if ( delta )		{			FrameRect( &dr );			OffsetRect( &dr, LoWord( delta ), HiWord( delta ));			FrameRect( &dr );						om = mouse;		}	}	while( WaitMouseUp());	FrameRect( &dr );	PenNormal();	PlaceAt( dr.left, dr.top );}/*--------------------------------***  GetEnvironment  ***------------------------------*//*access:			protectedoverrides:		description: 	return the environment object of this or one of its parentsins: 			noneouts: 			the environment objectnotes:			returns the closest environment----------------------------------------------------------------------------------------*/ZViewEnvironment*	ZView::GetEnvironment(){	if ( fGrafEnv )		return fGrafEnv;	else	{		if ( GetParent())			return GetParent()->GetEnvironment();		else			return NULL;	}}/*--------------------------------***  MakeEnvironment  ***-----------------------------*//*access:			protectedoverrides:		description: 	create and attach an environment object if necessaryins: 			noneouts: 			the environment objectnotes:			returns the closest environment----------------------------------------------------------------------------------------*/ZViewEnvironment*	ZView::MakeEnvironment(){	if ( ! fGrafEnv )		FailNIL( fGrafEnv = new ZViewEnvironment());			return GetEnvironment();}#pragma mark -/*-----------------------------***  FlattenViewsToList  ***-----------------------------*//*access:			publicoverrides:		description: 	make a linear list of views starting from this oneins: 			<aList> the list to add views to				<leafViewsOnly> if TRUE, only views that have no children are includedouts: 			list of view objectsnotes:			Caller must delete the list object----------------------------------------------------------------------------------------*/ZViewList*			ZView::FlattenViewsToList( ZViewList* aList, Boolean leafViewsOnly ){	if ( aList == NULL )		FailNIL( aList = new ZViewList());		if ( ! (( fChildViews != NULL ) && leafViewsOnly ))		aList->AppendItem( this );		ITERATECHILDVIEWS( FlattenViewsToList( aList ));		return aList;}/*-----------------------------***  RadioButtonChore  ***-------------------------------*//*access:			globaloverrides:		description: 	handle bulk of radio button grouping choreins: 			<childViews> list of child views of a view				<groupID> the group to handleouts: 			nonenotes:			sets all controls in the list that match the group to 0.----------------------------------------------------------------------------------------*/void	RadioButtonChore( ZViewList* childViews, const short groupID ){	FailNILParam( childViews );		// a group ID of 0 is ignored, since all controls are in group 0	// by default.		if ( groupID )	{		ZItemView*		cv;		long			n, i;				n = childViews->CountItems();				for( i = 1; i <= n; i++ )		{			cv = dynamic_cast<ZItemView*>( childViews->GetObject( i ));			if ( cv )			{				if ( cv->GetGroupID() == groupID )					cv->SetValue( 0L );			}		}	}}#pragma mark -/*-------------------------------------***  Draw  ***-----------------------------------*//*access:			publicoverrides:		description: 	draw drop-shadowed border around a viewins: 			<borderFrame> rect defining border edgeouts: 			nonenotes:			attach this to any view to draw a drop-shadow around it----------------------------------------------------------------------------------------*/void	ZDropShadowBorder::Draw( Rect* borderFrame ){	PenNormal();	RGBForeColor( &gBlack );	FrameRect( borderFrame );	MoveTo( borderFrame->left + 2, borderFrame->bottom );	LineTo( borderFrame->right, borderFrame->bottom );	LineTo( borderFrame->right, borderFrame->top + 2 );}#pragma mark -/*----------------------------***  CONSTRUCTOR  ***-------------------------------*/ZViewEnvironment::ZViewEnvironment()	: ZObject(){	classID = CLASS_ZViewEnvironment;		fEnvFlags = 0;	fFont = kFontIDGeneva;	fFontSize = 0;	fStyle = 0;	fFore = gBlack;	fBack = gWhite;	fPenBrush = kThemeBrushBlack;	fBackBrush = kThemeBrushWhite;	fBackInactive = kThemeBrushWhite;	fBackKind = 0;	fThemeFont = kThemeSystemFont;	fTextColour = kThemeTextColorBlack;}/*------------------------------------***  Apply  ***-----------------------------------*//*access:			publicoverrides:		description: 	apply the environment's settings to the current portins: 			<local> loacl rectangle used with ApplyThemeBackground				<isActive> drawing state of owning objectouts: 			nonenotes:			sets up ports text, colours and patterns according to the flags; appearance				settings override standard ones where appearance present----------------------------------------------------------------------------------------*/void	ZViewEnvironment::Apply( const Rect* local, const Boolean isActive ){	PenNormal();	if ( isActive )		TextMode( srcOr );	else		TextMode( grayishTextOr );			if ( fEnvFlags & kEnvironmentChangeFont )		TextFont( fFont );			if ( fEnvFlags & kEnvironmentChangeFontSize )		TextSize( fFontSize );			if ( fEnvFlags & kEnvironmentChangeFontFace )		TextFace( fStyle );			if ( fEnvFlags & kEnvironmentChangeForeColour )		RGBForeColor( &fFore );			if ( fEnvFlags & kEnvironmentChangeBackColour )	{#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )			SetThemeBackground( kThemeBrushWhite, GetMainScreenDepth(), gMacInfo.supportsColour );#endif		RGBBackColor( &fBack );	}#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ThemeDrawState	ds;		short			depth;		Boolean			colour;				ds = isActive? kThemeStateActive : kThemeStateInactive;		depth = GetMainScreenDepth();		colour = gMacInfo.supportsColour;				if ( fEnvFlags & kEnvironmentChangeThemePen )			SetThemePen( fPenBrush, depth, colour );					if ( fEnvFlags & kEnvironmentChangeThemeBack )			SetThemeBackground( ds? fBackBrush : fBackInactive, depth, colour );				if ( fEnvFlags & kEnvironmentChangeThemeBackKind )			ApplyThemeBackground( fBackKind, local, ds, depth, colour );							if ( fEnvFlags & kEnvironmentChangeThemeFont )			UseThemeFont( fThemeFont, smSystemScript );						if ( fEnvFlags & kEnvironmentChangeThemeTextColour )			SetThemeTextColor( fTextColour, depth, colour );	}#endif}/*---------------------------------***  SetFontInfo  ***--------------------------------*//*access:			publicoverrides:		description: 	set the basic text characteristics for the viewins: 			<fontID> the font				<size> the size of the font				<style> the style of the fontouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetFontInfo( const short font, const short size, const Style face ){	fFont = font;	fFontSize = size;	fStyle = face;	fEnvFlags |= ( kEnvironmentChangeFont + kEnvironmentChangeFontSize + kEnvironmentChangeFontFace );	fEnvFlags &= ~kEnvironmentChangeThemeFont;}/*--------------------------------***  SetForeColour  ***-------------------------------*//*access:			publicoverrides:		description: 	set the basic foreground colour for the viewins: 			<rgb> the colourouts: 			nonenotes:			this call clears the flags for theme text and pen, so will override				those settings if called later----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetForeColour( const RGBColor* rgb ){	fFore = *rgb;	fEnvFlags |= kEnvironmentChangeForeColour;	fEnvFlags &= ~( kEnvironmentChangeThemePen + kEnvironmentChangeThemeTextColour );}/*--------------------------------***  SetBackColour  ***-------------------------------*//*access:			publicoverrides:		description: 	set the basic background colour for the viewins: 			<rgb> the colourouts: 			nonenotes:			this call clears the flags for theme background, so will override				those settings if called later----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetBackColour( const RGBColor* rgb ){	fBack = *rgb;	fEnvFlags |= kEnvironmentChangeBackColour;	fEnvFlags &= ~( kEnvironmentChangeThemeBack + kEnvironmentChangeThemeBackKind );}/*---------------------------------***  SetThemedPen  ***-------------------------------*//*access:			publicoverrides:		description: 	set the theme drawing pen for the viewins: 			<pen> the theme penouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetThemedPen( const ThemeBrush pen ){	fPenBrush = pen;	fEnvFlags |= kEnvironmentChangeThemePen;}/*--------------------------------***  SetThemedBack  ***-------------------------------*//*access:			publicoverrides:		description: 	set the active theme background for the viewins: 			<back> the theme backgroundouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetThemedBack( const ThemeBrush back ){	fBackBrush = back;	fEnvFlags |= kEnvironmentChangeThemeBack;}/*----------------------------***  SetThemedInactiveBack  ***---------------------------*//*access:			publicoverrides:		description: 	set the inactive theme background for the viewins: 			<back> the theme inactive backgroundouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetThemedInactiveBack( const ThemeBrush back ){	fBackInactive = back;	fEnvFlags |= kEnvironmentChangeThemeBack;}/*------------------------------***  SetThemedBackKind  ***-----------------------------*//*access:			publicoverrides:		description: 	set the special theme background type for a view (placards, tabs, etc)ins: 			<back> the theme backgroundouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetThemedBackKind( const ThemeBackgroundKind kind ){	fBackKind = kind;	fEnvFlags |= kEnvironmentChangeThemeBackKind;}/*--------------------------------***  SetThemedFont  ***-------------------------------*//*access:			publicoverrides:		description: 	set the theme font for a viewins: 			<font> the theme fontouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetThemedFont( const ThemeFontID font ){	fThemeFont = font;	fEnvFlags |= kEnvironmentChangeThemeFont;}/*----------------------------***  SetThemedTextColour  ***----------------------------*//*access:			publicoverrides:		description: 	set the theme text colour for a viewins: 			<colour> the theme text colourouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::SetThemedTextColour( const ThemeTextColor colour ){	fTextColour = colour;	fEnvFlags |= kEnvironmentChangeThemeTextColour;}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			publicoverrides:		description: 	report inspector infoins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZViewEnvironment::ReportFields(){	ZObject::ReportFields();	XSHOWFIELD( fEnvFlags, ft_binary16 );	XSHOWFIELD( fFont, ft_signedshort );	XSHOWFIELD( fFontSize, ft_signedshort );	XSHOWFIELD( fStyle, ft_unsignedchar );	XSHOWFIELD( fFore, ft_RGBColor );	XSHOWFIELD( fBack, ft_RGBColor );	XSHOWFIELD( fPenBrush, ft_signedshort );	XSHOWFIELD( fBackBrush, ft_signedshort );	XSHOWFIELD( fBackInactive, ft_signedshort );	XSHOWFIELD( fBackKind, ft_unsignedlong );	XSHOWFIELD( fThemeFont, ft_unsignedshort );	XSHOWFIELD( fTextColour, ft_signedshort );}