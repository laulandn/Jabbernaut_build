/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZTimer.cpp			-- simple timer object******			© 1998, Graham Cox*****************************************************************************************************/#include	"ZTimer.h"#include	"ZWindow.h"#include	"MacZoop.h"ZTimerQueue*			gTimerQ = NULL;ZTimerQueue*			gMillisecQ = NULL;static unsigned long	gTickCount = 0;static unsigned long	gMilliseconds = 0;long		ZTimer::sTimerIDSeed = 20000;void		TimerTimer();/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZTimer::ZTimer( unsigned long tRate, long anID, ZCommander* owner, Boolean isOneShot )	: ZComrade(){	classID = CLASS_ZTimer;		wOwner = owner;	id = anID;	oneShot = isOneShot;	ismSecTimer = FALSE;		if ( id == 0 )		id = ++sTimerIDSeed;			interval = tRate;	lastTicks = gTickCount;}	/*-------------------------------------***  Do  ***-------------------------------------*//*access:			public	overrides:description: 	fire the timer if readyins: 			<ticksNow> current ticks valueouts: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZTimer::Do( unsigned long ticksNow ){	// check if time has elapsed or if tickcount has wrapped...		if ( ticksNow >= ( lastTicks + interval ) || ( ticksNow < lastTicks ))	{		lastTicks = ticksNow;				// preserve port & device around timer firing				CGrafPtr		savePort;		GDHandle		saveDevice;				GetGWorld( &savePort, &saveDevice );				if ( wOwner )		{			// if the owner's a window, focus it.						if ( dynamic_cast<ZWindow*>( wOwner ))				((ZWindow*) wOwner )->Focus();						// call virtual HandleTimer method (default dispatches to DoTimer)						wOwner->HandleTimer( this );		}		else			SendMessage( ismSecTimer? kTimerMillisecTripped : kTimerMsgTimerTripped, (void*) id );				SetGWorld( savePort, saveDevice );				// if one shot, destroy after firing				if ( oneShot )		{			// delete from list						if ( ismSecTimer )			{				gMillisecQ->DeleteObject( this );								if ( gMillisecQ->CountItems() <= 0 )					FORGETOBJECT( gMillisecQ );			}			else			{				gTimerQ->DeleteObject( this );								if ( gTimerQ->CountItems() <= 0 )					FORGETOBJECT( gTimerQ );			}			FORGETTHIS();		}	}}/*-----------------------------***  GetDebugInfoString  ***-----------------------------*//*access:			public	overrides:description: 	return basic debug info to inspectorins: 			<s> receives stringouts: 			nonenotes:----------------------------------------------------------------------------------------*/void		ZTimer::GetDebugInfoString( Str255 s ){	Str15	ss;		NumToString( interval, s );	ConcatPStrings( s, "\p ticks; owner ID = " );		if ( wOwner )		NumToString( wOwner->GetInstanceID(), ss );	else		CopyPString( "\p<none>", ss );	ConcatPStrings( s, ss );}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			public	overrides:description: 	report data members to the inspectorins: 			noneouts: 			nonenotes:----------------------------------------------------------------------------------------*/void		ZTimer::ReportFields(){	ZComrade::ReportFields();		XSHOWFIELD( id, ft_signedlong );	XSHOWFIELD( interval, ft_unsignedlong );	XSHOWFIELD( lastTicks, ft_unsignedlong );	XSHOWFIELD( wOwner, ft_objectref );	XSHOWFIELD( oneShot, ft_boolean );	XSHOWFIELD( ismSecTimer, ft_boolean );}/*-------------------------------***  InitMSecTimer  ***--------------------------------*//*access:			public	overrides:description: 	initialise a millisecond timerins: 			<mSec> number of millisecondsouts: 			nonenotes:----------------------------------------------------------------------------------------*/void		ZTimer::InitMSecTimer( unsigned long mSec ){	lastTicks = mSec;	ismSecTimer = TRUE;}/*---------------------------------***  SetTimer  ***-----------------------------------*//*access:			global	overrides:description: 	create and install a timer (tick-based)ins: 			<aCmdr> object to call when timer fires				<id> ID number for this timer if more than one				<interval> timer period in ticks				<isOneShot> TRUE if timer fires once, FALSE if keeps firingouts: 			nonenotes:			oneshot timers delete themselves----------------------------------------------------------------------------------------*/ZTimer*		SetTimer( ZCommander* aCmdr, long id, unsigned long interval, Boolean isOneShot ){	ZTimer*		zt;		if ( gTimerQ == NULL )		FailNIL( gTimerQ = new ZTimerQueue());	FailNIL( zt = new ZTimer( interval, id, aCmdr, isOneShot ));		gTimerQ->AppendItem( zt );		return zt;}/*---------------------------***  SetMillisecondTimer  ***-----------------------------*//*access:			global	overrides:description: 	create and install a timer (mS-based)ins: 			<aCmdr> object to call when timer fires				<id> ID number for this timer if more than one				<interval> timer period in milliseconds				<isOneShot> TRUE if timer fires once, FALSE if keeps firingouts: 			nonenotes:			oneshot timers delete themselves----------------------------------------------------------------------------------------*/ZTimer*		SetMillisecondTimer( ZCommander* aCmdr, long id, unsigned long interval, Boolean isOneShot ){	ZTimer*		zt;		if ( gMillisecQ == NULL )		FailNIL( gMillisecQ = new ZTimerQueue());	FailNIL( zt = new ZTimer( interval, id, aCmdr, isOneShot ));		zt->InitMSecTimer( gMilliseconds );		gMillisecQ->AppendItem( zt );		return zt;}/*---------------------------------***  KillTimer  ***----------------------------------*//*access:			global	overrides:description: 	deinstall and delete a timerins: 			<aCmdr> object that "owns" the timer				<id> ID number of the timer				<whichQueue> which queue to look in - TRUE for mS queue, FALSE for ticks queueouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		KillTimer( ZCommander* aCmdr, long id, Boolean whichQueue ){	long			iMax;	ZTimer*			zt;	ZTimerQueue*	zq;		if ( whichQueue )		zq = gMillisecQ;	else		zq = gTimerQ;		if ( zq )	{		iMax = zq->CountItems();				while ( iMax )		{			zt = (ZTimer*) zq->GetObject( iMax-- );						if ( zt && ( zt->GetID() == id ) && ( zt->GetOwner() == aCmdr ))			{				zq->DeleteObject( zt );				FORGETOBJECT( zt );								break;			}		}				if ( zq->CountItems() <= 0 )		{			if ( whichQueue )			{				FORGETOBJECT( gMillisecQ );			}			else			{				FORGETOBJECT( gTimerQ );			}		}	}}/*-------------------------------***  KillAllTimers  ***--------------------------------*//*access:			global	overrides:description: 	deinstall and delete all timers belonging to a given objectins: 			<aCmdr> object that "owns" the timersouts: 			nonenotes:			usually automatically called when owning object is disposed----------------------------------------------------------------------------------------*/void		KillAllTimers( ZCommander* aCmdr ){	long			iMax;	ZTimer*			zt;	ZTimerQueue*	zq;		zq = gTimerQ;		for( short i = 0; i < 2; i++ )	{		if ( zq )		{			iMax = zq->CountItems();						while ( iMax )			{				zt = (ZTimer*) zq->GetObject( iMax-- );							if ( zt && zt->GetOwner() == aCmdr )				{					zq->DeleteObject( zt );					FORGETOBJECT( zt );				}			}						if ( zq->CountItems() <= 0 )			{				if ( zq == gTimerQ )				{					FORGETOBJECT( gTimerQ );				}				else				{					FORGETOBJECT( gMillisecQ );				}			}		}		zq = gMillisecQ;	}}/*---------------------------------***  TimerTimer  ***---------------------------------*//*access:			global	overrides:description: 	iterate and deal with timersins: 			noneouts: 			nonenotes:			should be called repeatedly from main event loop----------------------------------------------------------------------------------------*/void		TimerTimer(){	// copy the tickcount to a global so the iteration can proceed as fast as possible		long		iMax;	ZTimer*		zt;		gTickCount = TickCount();	UnsignedWide	us;		Microseconds( &us );	gMilliseconds = us.lo / 1000;		if ( gMillisecQ )	{		iMax = gMillisecQ->CountItems();				// note that Do() method can potentially delete the timer queue, so make sure we		// test it each loop.				while( gMillisecQ && iMax )		{			zt = (ZTimer*) gMillisecQ->GetObject( iMax-- );						if ( zt )				zt->Do( gMilliseconds );		}	}	if ( gTimerQ )	{		iMax = gTimerQ->CountItems();				// note that Do() method can potentially delete the timer queue, so make sure we		// test it each loop.				while( gTimerQ && iMax )		{			zt = (ZTimer*) gTimerQ->GetObject( iMax-- );						if ( zt )				zt->Do( gTickCount );		}	}}