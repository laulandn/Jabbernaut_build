/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			ZWindowManager.cpp		-- desktop class handles floaters******			© 1996, Graham Cox*****************************************************************************************************/#include	"MacZoop.h"#include	"ZWindow.h"#if _ZCOMMANDER_DIALOG_AWARE	#include	"ZDialog.h"#endif#include	"ZViewDialog.h"#include	"ZEventHandler.h"#if _USE_DIR_POPUP#include	"DirectoryPopup.h"#include	"FinderObjects.h"#endif#if _WPOS_WINDOW_PLACEMENT#include	"ZResourceFile.h"#endif#include	<macwindows.h>#include	<dialogs.h>enum{	kStdStackWidth		= 480,	kStdStackHeight		= 360};// usually we use our own drag function, but by setting this to 1 you// can revert to the use of the toolbox function in case your app needs it// for some particular reason#define     _USE_DRAG_GRAY_RGN  0// drag callback and snap handling stuff (private):ZWindow*		ZWindowManager::sDraggedWindow = NULL;RgnHandle		ZWindowManager::sDraggedRegion = NULL;Point			ZWindowManager::sRelMouseOffset;// macros for doing type checking on dialog windows:#if _ZCOMMANDER_DIALOG_AWARE#define		ISOLDDIALOG( w )	( dynamic_cast<ZDialog*>(w) != NULL )#else#define		ISOLDDIALOG( w )	( FALSE )#endif#define		ISNEWDIALOG( w )	( dynamic_cast<ZViewDialog*>(w) != NULL )/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZWindowManager::ZWindowManager()	: ZComrade(){	classID = CLASS_ZWindowManager;		// make the lists		FailNIL( nonFloaters = new ZWindowList());	FailNIL( floaters = new ZWindowList());		wmWindows = NULL;	wmMenu = NULL;	wmItemOffset = 0;	wmActive = TRUE;	wmDDDeactivated = FALSE;		SetRect( &fStoredZoom, 0, 0, 0, 0 );	fStoredZoomSource = fStoredZoom;		// set up member for controlling window placement		globalPlaceLoc.h = 2;	globalPlaceLoc.v = GetMBarHeight() + 2;}/*---------------------------------***  DESTRUCTOR  ***---------------------------------*/ZWindowManager::~ZWindowManager(){	if ( nonFloaters )	{		nonFloaters->DisposeAll();		FORGETOBJECT( nonFloaters );	}			if ( floaters )	{		floaters->DisposeAll();		FORGETOBJECT( floaters );	}			if ( wmWindows )		FORGETOBJECT( wmWindows );}/*---------------------------------***  AddWindow  ***----------------------------------*//*access:			public	overrides:description: 	add a window to the list of windowsins: 			<aWindow> window to addouts: 			nonenotes:			windows normally call this automatically----------------------------------------------------------------------------------------*/void	ZWindowManager::AddWindow( ZWindow* aWindow ){	FailNILParam( aWindow );		ZWindow*	zw = GetBottomFloater();		// determine if this window is a floater or not:		if ( aWindow->Floats())	{		BringBehind( aWindow, zw );		floaters->AppendItem( aWindow );	}	else	{		Boolean		eligibleWindow;				eligibleWindow = ( ! IsDialog( aWindow ));				// move behind the bottom floater unless this is a modal dialog		if ( eligibleWindow )			BringBehind( aWindow, zw );		nonFloaters->AppendItem( aWindow );				// if we're maintaining a "Windows" menu, append the window to our list if		// it's non-floating and not a modal dialog box.				if ( wmWindows && eligibleWindow )			wmWindows->AppendItem( aWindow );					BuildWindowsMenu();	}			SendMessage( kWMMsgWindowAdded, aWindow );}/*-------------------------------***  RemoveWindow  ***---------------------------------*//*access:			public	overrides:description: 	remove a window to the list of windowsins: 			<aWindow> window to removeouts: 			nonenotes:			windows normally call this automatically when they close----------------------------------------------------------------------------------------*/void	ZWindowManager::RemoveWindow( ZWindow* aWindow ){	FailNILParam( aWindow );		aWindow->Hide();		if ( aWindow->Floats())		floaters->DeleteObject( aWindow );	else	{		nonFloaters->DeleteObject( aWindow );				if ( wmWindows )			wmWindows->DeleteObject( aWindow );				// if all windows closed, reset global positioning variable				if ( CountWindows() == 0 )		{			globalPlaceLoc.h = 2;			globalPlaceLoc.v = GetMBarHeight() + 2;		}	}		SendMessage( kWMMsgWindowRemoved, aWindow );}/*------------------------------***  InitiallyPlace  ***--------------------------------*//*access:			public	overrides:description: 	initially places a window on screenins: 			<aWindow> window to placeouts: 			nonenotes:			staggers windows from top left to bottom right----------------------------------------------------------------------------------------*/void	ZWindowManager::InitiallyPlace( ZWindow* aWindow ){	Rect	wBorder;	short	gh, gv;		FailNILParam( aWindow );		if ( ! aWindow->Floats())	{		aWindow->GetStructureFrameBorder( &wBorder );				gh = globalPlaceLoc.h + wBorder.left;		gv = globalPlaceLoc.v + wBorder.top;				aWindow->PlaceAt( gh, gv );				globalPlaceLoc.h += wBorder.left + 2;		globalPlaceLoc.v += wBorder.top + 2;				// if the bottom of the window falls off the screen, make it a bit less		// tall so that all its frame is visible.				RgnHandle	wStruct;		short		overHang;		GDHandle	mainDev;				mainDev = GetMainDevice();		aWindow->GetStructureRegion( wStruct = NewRgn());				overHang = (*mainDev)->gdRect.bottom - REGIONBOUNDINGBOX( wStruct )->bottom;				// if overhang is negative, we've gone too far, so make the window smaller.				if ( overHang < 0 )		{			// only resize the window if it's a naturally resizable type, otherwise			// the user may end up with an unexpectedly nasty-looking window.						WindowPtr	macWindow = aWindow->GetMacWindow();			short		wType;						wType = GetWVariant( macWindow );			if ( wType == documentProc  ||				 wType == zoomDocProc )			{				wBorder = *WINDOWPORTRECT( macWindow );							wBorder.bottom += overHang;				aWindow->SetSize( wBorder.right - wBorder.left, wBorder.bottom - wBorder.top - 2 );			}						// in any case the next window placed had better start back at the top...						globalPlaceLoc.v = GetMBarHeight() + 2;			globalPlaceLoc.h += 10;		}				DisposeRgn( wStruct );	}}/*--------------------------------***  HideWindow  ***----------------------------------*//*access:			public	overrides:description: 	hide a windowins: 			<aWindow> window to hideouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::HideWindow( ZWindow* aWindow ){	FailNILParam( aWindow );		WindowPtr	w = aWindow->GetMacWindow();	short		i;		if ( w != NULL )	{		ShowHide( w, FALSE );		HiliteWindow( w, FALSE );				SendMessage( kWMMsgWindowHidden, aWindow );	}	// if this was the top window, select the next non-hidden one		if ( aWindow->Floats())	{		if ( aWindow == GetTopFloater() &&			 floaters->CountItems() > 1 )		{			for( i = 2; i <= floaters->CountItems(); i++ )			{				aWindow = (ZWindow*) floaters->GetObject( i );							if ( aWindow && aWindow->IsVisible())				{					SelectWindow( aWindow );					break;				}			}		}	}	else	{		if ( aWindow == GetTopWindow())		{			if ( nonFloaters->CountItems() > 1 )			{				for( i = 2; i <= nonFloaters->CountItems(); i++ )				{					aWindow = (ZWindow*) nonFloaters->GetObject( i );									if ( aWindow && aWindow->IsVisible())					{						SelectWindow( aWindow );						break;					}				}			}			else			{				// the window being hidden is the only one. If a dialog,				// activate the floaters								if ( IsDialog( aWindow ))					Activate();			}		}	}}/*--------------------------------***  ShowWindow  ***----------------------------------*//*access:			public	overrides:description: 	reshow a windowins: 			<aWindow> window to showouts: 			nonenotes:			does not bring the window to the front----------------------------------------------------------------------------------------*/void	ZWindowManager::ShowWindow( ZWindow* aWindow ){	FailNILParam( aWindow );		if ( ! aWindow->IsVisible())	{		#if _ZOOM_RECT_FX				if ( gMacInfo.hasDragManager && !gApplication->InBackground())		{			RgnHandle	wStruct;					aWindow->GetStructureRegion( wStruct = NewRgn());			aWindow->SetWindowZoomRectSource( &gZoomFXSourceRect );						ZoomRects( &gZoomFXSourceRect, REGIONBOUNDINGBOX( wStruct ), 10, kZoomAccelerate );			DisposeRgn( wStruct );		}		#endif				ShowHide( aWindow->GetMacWindow(), TRUE );		SendMessage( kWMMsgWindowShown, aWindow );			if ( aWindow == GetTopWindow() ||			 aWindow == GetTopFloater())			SelectWindow( aWindow );	}}/*-------------------------------***  SelectWindow  ***---------------------------------*//*access:			public	overrides:description: 	make a window frontmost and activeins: 			<aWindow> window to selectouts: 			nonenotes:			generates activate events as required----------------------------------------------------------------------------------------*/void	ZWindowManager::SelectWindow( ZWindow* aWindow ){	FailNILParam( aWindow );		// this is where a certain amount of cunning comes in. To "Select" a non-floater, it	// is actually moved to come behind the bottom floater. Floaters are treated normally.	// Dialogs can come in front of all windows, though they will be set to non-floating.		ZWindow*	zw;	long		i;		if (! aWindow->IsVisible())	{		// if window hitherto has not been seen by the user, and the setting indicates we		// want the effect, perform the zoom open animation				#if _ZOOM_RECT_FX				if ( gMacInfo.hasDragManager )		{			RgnHandle	wStruct;					aWindow->GetStructureRegion( wStruct = NewRgn());			aWindow->zoomSource = gZoomFXSourceRect;						ZoomRects( &gZoomFXSourceRect, REGIONBOUNDINGBOX( wStruct ), 10, kZoomAccelerate );			DisposeRgn( wStruct );		}		#endif	}		// manipulate our lists and the mac window list		if ( aWindow->Floats())	{		i = floaters->FindIndex( aWindow );				// move to head of list, if not there already				if (( i > 1 ) || !aWindow->IsVisible())		{			// deactivate current "top"				#if _ALL_FLOATERS_ACTIVE == OFF			zw = GetTopFloater();						if ( zw )				PostActivation( zw, FALSE );		#endif						floaters->MoveToFront( i );		}			// hilite and activate the new "top" window			BringBehind( aWindow, NULL );		ShowHide( aWindow->GetMacWindow(), TRUE );		PostActivation( aWindow, TRUE );	}	else	{		i = nonFloaters->FindIndex( aWindow );				// if already on top, do nothing				if ( i > 1 )		{			// deactivate the current "top"						zw = GetTopWindow();						if ( zw )				PostActivation( zw, FALSE );						// move to head of list						nonFloaters->MoveToFront( i );		}					// bring window behind the bottom floater, unless it's a dialog, in which		// case it's put on top of everything		if ( IsDialog( aWindow ))		{			if ( wmActive )				Deactivate();						BringBehind( aWindow, NULL );		}		else		{			zw = GetBottomFloater();			BringBehind( aWindow, zw );						if ( ! wmActive )				Activate();		}				// hilite and activate the new "top" window		// if window is not visible, make it so			ShowHide( aWindow->GetMacWindow(), TRUE );		PostActivation( aWindow, TRUE );	}}/*----------------------------***  DragWindowOutline  ***------------------------------*//*access:			public	overrides:description: 	drag a window on screen to reposition itins: 			<aWindow> window to move				<startPt> global mouse position at which drag starts				<modifiers> modifier keys				<snap> snap flags of the window				<limitRect> rectangle limiting the area where a window can be dragged				(pass NULL to use the standard desktop bounds)outs: 			nonenotes:			keeps control until drag completes and window moved----------------------------------------------------------------------------------------*/void	ZWindowManager::DragWindowOutline( ZWindow* aWindow, Point startPt, const short modifiers, SnapFlags snap, Rect* dragLimit ){	FailNILParam( aWindow );		// replaces the toolbox DragWindow, because that will bring a window to the front if	// you let it.		WindowPtr		w;	RgnHandle		dragRgn, temp = NULL;	Rect			limitRect;	short           posH, posV;	long			dragOffset;	GrafPtr			savePort;	CGrafPtr		screenPort;		w = aWindow->GetMacWindow();	PauseCursorAnimation( 0 );		// if window frontmost and command key down, call command-click hook and return. The hook	// can be overridden to implement stuff such as popping up a directory path menu, etc.		if ( aWindow == GetTopWindow() &&		 ( modifiers & cmdKey ) == cmdKey )	{		// the hook returns a boolean to indicate whether processing should continue or not.		// If FALSE, we continue, otherwise we abort. The default hook method just returns FALSE				if ( CommandClickInFrontDragBar( aWindow, startPt ))			return;	}		// select the window if command key not down	#if _DRAGWINDOW_COMPATIBLE == OFF		if (( modifiers & cmdKey ) == 0 &&		aWindow != GetTopWindow() &&		aWindow != GetTopFloater())	{		SelectWindow( aWindow );	}#if _UPDATE_ON_SELECT		aWindow->PerformUpdate();	#endif#endif		// get the limit rect if the one supplied is NULL		if ( dragLimit )		limitRect = *dragLimit;	else	{		limitRect = *REGIONBOUNDINGBOX( GetGrayRgn());		InsetRect( &limitRect, 4, 4 );	}	// get the outline to drag. This is simply a copy of the window's structure region		FailNIL( dragRgn = NewRgn());	aWindow->GetStructureRegion( dragRgn );		// set up a port in which to drag the outline. We do this to be good citizens,	// since meddling with the Mac's Window Manager port is tricky to get away with.		GetPort( &savePort );	screenPort = OpenScreenPort();		// Remove the regions of all windows in front from the clip region, so it is clearer	// what will happen when the window moves.		FailNIL( temp = NewRgn());	CalcWindowRgns( aWindow, temp );		DiffRgn( GetGrayRgn(), temp, temp );	SetClip( temp );    DisposeRgn( temp );	    	// if we have system 8.0 or later, use a 2-pixel gray drag region, not a 1-pixel		if ( gMacInfo.systemVersion >= 0x0800 )	{		CopyRgn( dragRgn, gUtilRgn );		InsetRgn( gUtilRgn, 2, 2 );		DiffRgn( dragRgn, gUtilRgn, dragRgn );	}		// the mouse may have moved away from the startPt already, since the update may have taken	// a while. In order to prevent the window jumping in this situation, we just check that the	// mouse is still in fact, down!		sDraggedWindow = aWindow;	if ( StillDown())		dragOffset = DragRegion( dragRgn, startPt, &limitRect, snap );	else		dragOffset = kMouseUpOutOfSlop;		sDraggedWindow = NULL;			// close our screen port		DisposeScreenPort( screenPort );	SetPort( savePort );	DisposeRgn( dragRgn );		// check the window drag wasn't bogus:		if ( dragOffset != kMouseUpOutOfSlop )	{		// OK, figure out where the window moved to, and move it there. If the command key		// is not down, select tha' booga!				aWindow->GetGlobalPosition( &posH, &posV );				// if we are exactly compatible with toolbox DragWindow(), then select the window here				#if _DRAGWINDOW_COMPATIBLE				if (( modifiers & cmdKey ) == 0 &&			aWindow != GetTopWindow() &&			aWindow != GetTopFloater())			SelectWindow( aWindow );				#endif				aWindow->PlaceAt( posH + LoWord( dragOffset ), posV + HiWord( dragOffset ));		SendMessage( kWMMsgWindowMoved, aWindow );	}		ResumeCursorAnimation();}/*--------------------------------***  DragRegion  ***----------------------------------*//*access:			public	overrides:description: 	drags a region in the current portins: 			<rgn> region to drag				<startPt> starting point of the drag				<limitRect> limit rectangle of the drag				<snap> snap flags to honourouts: 			nonenotes:			this is used to custom drag a window when snapping is used----------------------------------------------------------------------------------------*/long	ZWindowManager::DragRegion( RgnHandle rgn, Point startPt, Rect* limitRect, SnapFlags snap ){	long			result = 0;	DragGrayRgnUPP	wdUPP;		// set up a drag callback. This calls back the window manager while dragging the window.	wdUPP = NewDragGrayRgnUPP( DragWindowsProc );		sDraggedRegion = rgn;	sRelMouseOffset.h = startPt.h - REGIONBOUNDINGBOX( rgn )->left;	sRelMouseOffset.v = startPt.v - REGIONBOUNDINGBOX( rgn )->top;		// the toolbox DragGrayRgn is a bit too high-level if we want to do e.g. window snapping.	// This is because we need to modify the result of GetMouse. Since I have an aversion to	// patching toolbox traps, instead we simply replace the function with our own so we can	// just override it.	#if _USE_DRAG_GRAY_RGN	result = DragGrayRgn( rgn, startPt, limitRect, limitRect, noConstraint, wdUPP );#else    result = DragGrayRgnSnap( rgn, startPt, limitRect, wdUPP, snap );#endif	DisposeDragGrayRgnUPP( wdUPP );		return result;}/*-----------------------------***  OpenScreenPort  ***--------------------------------*//*access:			public	overrides:description: 	create a port for doing window dragging inins: 			noneouts: 			a port covering the desktopnotes:			this should not be used on OS X; always dispose of this port with				DisposeScreenPort below----------------------------------------------------------------------------------------*/CGrafPtr   ZWindowManager::OpenScreenPort(){	CGrafPtr	cp = NULL;	Rect		br;	RgnHandle	temp;		br = *REGIONBOUNDINGBOX( GetGrayRgn());	temp = NewRgn();	RectRgn( temp, &br );	#if OPAQUE_TOOLBOX_STRUCTS	FailNIL( cp = CreateNewPort());	SetPort((GrafPtr) cp );	SetPortBounds( cp, &br );#else	FailNIL( cp = (CGrafPtr) NewPtr( sizeof( CGrafPort )));		OpenCPort( cp );	SetPort((GrafPtr) cp );		// make sure we can drag on the whole desktop		cp->portRect = br;#endif	SetClip( temp );	SETPORTVISRGN( cp, temp );	DisposeRgn( temp );		return cp;}/*-----------------------------***  DisposeScreenPort  ***------------------------------*//*access:			public	overrides:description: 	dispose of a port created with CreateScreenPortins: 			<aPort> the port to disposeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::DisposeScreenPort( CGrafPtr aPort ){#if OPAQUE_TOOLBOX_STRUCTS	DisposePort( aPort );#else	CloseCPort( aPort );	DisposePtr((Ptr) aPort );#endif}/*----------------------------------***  Suspend  ***-----------------------------------*//*access:			public	overrides:description: 	application is being suspended - hide the floatersins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::Suspend(){	// the application is being suspended, so all floaters should be hidden		ZWindow		*aFloater, *tw;	short		i;		for (i = 1; i <= floaters->CountItems(); i++)	{		aFloater = (ZWindow*) floaters->GetObject( i );				if ( aFloater )			ShowHideFloater( aFloater, TRUE );	}		tw = GetTopWindow();		if ( tw )		PostActivation( tw, FALSE );}/*----------------------------------***  Suspend  ***-----------------------------------*//*access:			public	overrides:description: 	application is resuming - show the floatersins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::Resume(){	// the application is being resumed, so all floaters should be re-shown.		ZWindow		*aFloater, *tw;	short		i;		for (i = 1; i <= floaters->CountItems(); i++)	{		aFloater = (ZWindow*) floaters->GetObject( i );				if ( aFloater )			ShowHideFloater( aFloater, FALSE );	}	tw = GetTopWindow();		if ( tw )		PostActivation( tw, TRUE );}/*--------------------------------***  Deactivate  ***----------------------------------*//*access:			public	overrides:description: 	deactivate floaters when modal dialog is displayedins: 			noneouts: 			nonenotes:			called automatically by SelectWindow----------------------------------------------------------------------------------------*/void	ZWindowManager::Deactivate(){	// a dialog is up, so all floaters plus the top window must be deactivated		ZWindow*	zw;	#if _ALL_FLOATERS_ACTIVE == OFF		zw = GetTopFloater();		if ( zw )		PostActivation( zw, FALSE );		#else		short	i;		for (i = 1; i <= floaters->CountItems(); i++ )	{		zw = (ZWindow*) floaters->GetObject( i );			if ( zw )		{			PostActivation( zw, FALSE );			HiliteWindow( zw->GetMacWindow(), FALSE );		}	}	#endif	wmActive = FALSE;}/*---------------------------***  DeactivateForDialog  ***------------------------------*//*access:			public	overrides:description: 	deactivate floaters and top window if "alien" dialog displayedins: 			<dlogID> dialog being shown				<isAlert> dialog is actually an alert boxouts: 			nonenotes:			you can use this if you show a dialog that is not a MacZoop object, e.g.				StandardFile or Navigation. This ensures that windows are put into the				right state and that you get zoom effects for the dialog.----------------------------------------------------------------------------------------*/void	ZWindowManager::DeactivateForDialog( short dlogID, Boolean isAlert  ){	ZWindow*	zw;		Deactivate();		zw = GetTopWindow();		if ( zw )	{		PostActivation( zw, FALSE );		wmDDDeactivated = TRUE;				zw->PerformUpdate();	}		SendMessage( kWMMsgMacDialogUp, NULL );		#if _ZOOM_RECT_FX		// in order to display the animation by proxy for the dialog we are about to put	// up, we need to obtain the dialog's window frame by taking a peek into the	// dialog record		if ( gMacInfo.hasDragManager && ( dlogID != -1 ))	{		Rect			r;		AlertTHndl		atH;		DialogTHndl		dtH;				if ( isAlert )		{			atH = (AlertTHndl) GetResource( 'ALRT', dlogID );					if ( atH )			{				r = (*atH)->boundsRect;				ReleaseResource((Handle) atH );			}		}		else		{				dtH = (DialogTHndl) GetResource( 'DLOG', dlogID );						if ( dtH )			{				r = (*dtH)->boundsRect;				ReleaseResource((Handle) dtH );			}			}				// we are going to need to assume that the dialog/alert is going to be placed on the screen		// in the standard alert position (for now- there are ways to be more intelligent about this)		// so we have to compute that location:				Rect	screen = (*GetMainDevice())->gdRect;				screen.top += GetMBarHeight();				short	topSpace = screen.bottom - screen.top - r.bottom - r.top;		short	leftSpace = screen.right - screen.left - r.right - r.left;				OffsetRect( &r, ( leftSpace / 2 ) - r.left, ( topSpace / 4 ) - r.top );				// that's the one- do the animation					ZoomRects( &gZoomFXSourceRect, &r, 10, kZoomAccelerate );				// store the rects on behalf of the dialog/alert so we can do the reverse animation		// when we are reactivated				fStoredZoomSource = gZoomFXSourceRect;		fStoredZoom = r;	}	#endif}/*---------------------------------***  Activate  ***-----------------------------------*//*access:			public	overrides:description: 	reactivate floaters etc when a modal dialog is closedins: 			noneouts: 			nonenotes:			called for you for MacZoop dialogs, but you should call it for Mac				dialogs.----------------------------------------------------------------------------------------*/void	ZWindowManager::Activate(){	// a dialog is going away, so all floaters plus the top window must be reactivated		SendMessage( kWMMsgMacDialogDown, NULL );		ZWindow*	zw;		if ( wmDDDeactivated )	{		zw = GetTopWindow();				if ( zw )			PostActivation( zw, TRUE );					wmDDDeactivated = FALSE;	}	#if _ALL_FLOATERS_ACTIVE == OFF		zw = GetTopFloater();		if ( zw )		PostActivation( zw, TRUE );#else		short	i;		for (i = 1; i <= floaters->CountItems(); i++ )	{		zw = (ZWindow*) floaters->GetObject( i );			if ( zw )			PostActivation( zw, TRUE );	}	#endif	// if we have a stored zoom, zoom down from it.	#if _ZOOM_RECT_FX		if ( ! EmptyRect( &fStoredZoom ) && gMacInfo.hasDragManager )	{		ZoomRects( &fStoredZoom, &fStoredZoomSource, 10, kZoomDecelerate );			SetRect( &fStoredZoom, 0, 0, 0, 0 );		fStoredZoomSource = fStoredZoom;	}	#endif	wmActive = TRUE;}/*-------------------------------***  GetTopWindow  ***---------------------------------*//*access:			public	overrides:description: 	return the top, non-floating windowins: 			noneouts: 			top window, or NULL if there isn't onenotes:			----------------------------------------------------------------------------------------*/ZWindow*	ZWindowManager::GetTopWindow(){	// returns the top non-floating window		if ( nonFloaters->CountItems() > 0 )		return (ZWindow*) nonFloaters->GetObject( 1 );	else		return NULL;}/*------------------------------***  GetTopFloater  ***---------------------------------*//*access:			public	overrides:description: 	return the top floating windowins: 			noneouts: 			top floater, or NULL if there isn't onenotes:			----------------------------------------------------------------------------------------*/ZWindow*	ZWindowManager::GetTopFloater(){	// returns the top floating window (even if not visible)		if ( floaters->CountItems() > 0 )		return (ZWindow*) floaters->GetObject( 1 );	else		return NULL;}/*----------------------------***  GetBottomFloater  ***--------------------------------*//*access:			public	overrides:description: 	return the bottom floating windowins: 			noneouts: 			bottom floater, or NULL if there isn't onenotes:			called internally to manage window layering----------------------------------------------------------------------------------------*/ZWindow*	ZWindowManager::GetBottomFloater(){	// returns the bottom-most VISIBLE floater		long	fCount = floaters->CountItems();		if ( fCount > 0 )	{		ZWindow*	botFloater;				// iterate through the list of floaters looking for the bottom-most visible one.		// Iterate in reverse order to facilitate finding the bottom one.				while( fCount )		{			botFloater = (ZWindow*) floaters->GetObject( fCount-- );						if ( botFloater->IsVisible())				break;			else				botFloater = NULL;		}				return botFloater;		}	else		return NULL;	}/*----------------------------***  MoveWindowBehind  ***--------------------------------*//*access:			public	overrides:description: 	move a window behind another one, or to the backins: 			<aWindow> the window to reorder				<behindWindow> move it behind this one, or pass NULL to move to backouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZWindowManager::MoveWindowBehind( ZWindow* aWindow, ZWindow* behindWindow ){	FailNILParam( aWindow );		long		wIndex, nIndex;	Boolean		wasActive = FALSE;		wasActive = aWindow->IsActive();		if ( aWindow->Floats())	{		if ( behindWindow != NULL )		{			if ( ! behindWindow->Floats())				behindWindow = GetBottomFloater();		}		else			behindWindow = GetBottomFloater();					// manipulate our list				wIndex = floaters->FindIndex( aWindow );		nIndex = floaters->FindIndex( behindWindow );				if ( wIndex <= nIndex )	    	floaters->MoveItem( wIndex, nIndex );		else	    	floaters->MoveItem( wIndex, nIndex +1 );	}	else	{		if ( behindWindow == NULL )		{			behindWindow = (ZWindow*) nonFloaters->GetObject( nonFloaters->CountItems());					if ( behindWindow == aWindow && ( nonFloaters->CountItems() > 1 ))				behindWindow = (ZWindow*) nonFloaters->GetObject( nonFloaters->CountItems() - 1 );		}		wIndex = nonFloaters->FindIndex( aWindow );		nIndex = nonFloaters->FindIndex( behindWindow );				if ( wIndex <= nIndex )	    	nonFloaters->MoveItem( wIndex, nIndex );		else	    	nonFloaters->MoveItem( wIndex, nIndex + 1 );	}			BringBehind( aWindow, behindWindow );		if ( wasActive )	{		PostActivation( aWindow, FALSE );		SelectWindow( GetTopWindow());	}}/*------------------------------***  LocateWindow  ***----------------------------------*//*access:			public	overrides:description: 	find which window, if any, is under the mouseins: 			<globalMouse> the global mouse positionouts: 			window under mouse, or NULLnotes:			active state of window is not relevant----------------------------------------------------------------------------------------*/ZWindow*	ZWindowManager::LocateWindow( const Point globalMouse ){	WindowPtr	w;	ZWindow*	zw = NULL;	RgnHandle   temp;		w = FrontWindow();		FailNIL( temp = NewRgn());		while ( w )	{		GetWindowStructureRgn( w, temp );				if ( PtInRgn( globalMouse, temp ))		{					zw = GETZWINDOW( w );			break;		}				w = MacGetNextWindow( w );	}		DisposeRgn( temp );		return zw;}/*------------------------------***  GetNthWindow  ***----------------------------------*//*access:			public	overrides:description: 	get the nth non-floating window window ins: 			<n> ordinal position of windowouts: 			the windownotes:			windows are ordered from 1 at the front to n at the back----------------------------------------------------------------------------------------*/ZWindow*	ZWindowManager::GetNthWindow( const long n ){	ZWindow*	zw = NULL;		try	{		zw = (ZWindow*) nonFloaters->GetObject( n );	}	catch(...)	{	}		return zw;}/*------------------------------***  GetNthFloater  ***---------------------------------*//*access:			public	overrides:description: 	get the nth floating window window ins: 			<n> ordinal position of windowouts: 			the windownotes:			windows are ordered from 1 at the front to n at the back----------------------------------------------------------------------------------------*/ZWindow*	ZWindowManager::GetNthFloater( const long n ){	ZWindow*	zw = NULL;		try	{		zw = (ZWindow*) floaters->GetObject( n );	}	catch(...)	{	}		return zw;}	/*---------------------------------***  IsDialog  ***-----------------------------------*//*access:			public	overrides:description: 	query whether a given window is actually a MODAL dialogins: 			<aWindow> window to checkouts: 			TRUE if a modal dialog, else FALSEnotes:			Modeless dialogs return FALSE----------------------------------------------------------------------------------------*/Boolean		ZWindowManager::IsDialog( ZWindow* aWindow ){	// return TRUE if the window is a modal dialog (but not for modeless ones)		if ( aWindow )	{#if _ZCOMMANDER_DIALOG_AWARE		ZDialog*	zd = dynamic_cast<ZDialog*>( aWindow );				if ( zd && zd->IsModal())			return TRUE;		else		{#endif						// see if it's a new dialog type (ZViewDialog)						ZViewDialog*	vd = dynamic_cast<ZViewDialog*>( aWindow );						if ( vd && vd->IsModal())				return TRUE;			else				return FALSE;#if _ZCOMMANDER_DIALOG_AWARE		}#endif	}	else		return FALSE;}/*------------------------------***  IsModalDialogActive  ***---------------------------*//*access:			publicoverrides:		description: 	test if top window is a dialogins: 			noneouts: 			TRUE if top window is a modal dialognotes:			----------------------------------------------------------------------------------------*/Boolean		ZWindowManager::IsModalDialogActive(){	return IsDialog( GetTopWindow());}/*---------------------------***  GetUniqueUntitledName  ***----------------------------*//*access:			public	overrides:description: 	check and modify a title string as needed to ensure it's uniqueins: 			<wName> name to check/modifyouts: 			TRUE if the name was modified, FALSE if it is already uniquenotes:			This works by searching the existing window titles for a match with the				string passed. If a match is found, the name is modified by appending				1, 2, 3... etc until no match is found.----------------------------------------------------------------------------------------*/Boolean		ZWindowManager::GetUniqueUntitledName( Str255 wName ){	short		n = 1, i;	Boolean		result = FALSE, match;	Str255		sName, temp;	ZWindow*	zw;		CopyPString( wName, temp );		do	{		match = FALSE;				for ( i = 1; i <= nonFloaters->CountItems(); i++ )		{				zw = (ZWindow*) nonFloaters->GetObject( i );			zw->GetName( sName );						if ( EqualString( temp, sName, FALSE, FALSE ))			{				match = TRUE;				break;			}		}				if ( match )		{			// the name matched some window, so append a digit and try again					CopyPString( wName, temp );						NumToString( n++, sName );			ConcatPStrings( temp, "\p " );			ConcatPStrings( temp, sName );		}		else		{			result = TRUE;			CopyPString( temp, wName );		}	}	while( ! result );		return result;	}/*---------------------------------***  FloatIdle  ***----------------------------------*//*access:			public	overrides:description: 	give periodic time to all the floatersins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::FloatIdle(){	long		i;	ZWindow*	aFloater;		for( i = 1; i <= floaters->CountItems(); i++ )	{		aFloater = (ZWindow*) floaters->GetObject( i );			if ( aFloater )			aFloater->GetHandler()->Idle();	}	}/*--------------------------------***  CountWindows  ***--------------------------------*//*access:			public	overrides:description: 	count the number of non-floating windowsins: 			<visOnly> if TRUE, do not count hidden windowsouts: 			count of windowsnotes:			----------------------------------------------------------------------------------------*/short		ZWindowManager::CountWindows( const Boolean visOnly ){	short 	wc = nonFloaters->CountItems();		if ( visOnly )	{		short		vwc = 0;		ZWindow*	w;				while( wc )		{			w = (ZWindow*) nonFloaters->GetObject( wc );						if ( w->IsVisible())				vwc++;					--wc;		}				return vwc;	}	else		return wc;}/*--------------------------------***  CountFloaters  ***-------------------------------*//*access:			public	overrides:description: 	count the number of floating windowsins: 			noneouts: 			count of floatersnotes:			----------------------------------------------------------------------------------------*/short		ZWindowManager::CountFloaters(){	return floaters->CountItems();}/*--------------------------------***  SetWindowsMenu  ***------------------------------*//*access:			protected	overrides:description: 	set up a windows menuins: 			<aMenu> the menu to useouts: 			nonenotes:			this is called by ZMenuBar - apps should use NominateWindowsMenu instead----------------------------------------------------------------------------------------*/void		ZWindowManager::SetWindowsMenu( MenuHandle aMenu ){	FailNILParam( aMenu );		wmMenu = aMenu;	wmItemOffset = CountMenuItems( aMenu );		// make a list to keep an ordered list of windows that does not depend on	// the front-to-back order		FailNIL( wmWindows = new ZWindowList());		BuildWindowsMenu();}/*----------------------------***  SelectWindowFromMenu  ***----------------------------*//*access:			protected	overrides:description: 	handle a choice from the windows menuins: 			<itemID> item ID the user choseouts: 			nonenotes:			selects the associated window----------------------------------------------------------------------------------------*/void		ZWindowManager::SelectWindowFromMenu( const short itemID ){	if ( wmMenu && wmWindows && !IsDialog( GetTopWindow()))	{		short	n = itemID - wmItemOffset;				if ( wmItemOffset > 0 )			n--;	// allow for divider line				if (( n > 0 ) && ( n <= wmWindows->CountItems()))		{			ZWindow*	zw = (ZWindow*) wmWindows->GetObject( n );					if ( zw )				zw->Select();		}	}}/*------------------------------***  ZoomWindowClosed  ***------------------------------*//*access:			public	overrides:description: 	perform zoom animation when window closesins: 			<aWindow> window being closedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZWindowManager::ZoomWindowClosed( ZWindow* aWindow ){#if _ZOOM_RECT_FX	if ( gMacInfo.hasDragManager &&		( gApplication->GetPhase() == kRunning ) &&		!gApplication->InBackground())	{		RgnHandle	wStruct;		Rect        wZoom;				aWindow->GetStructureRegion( wStruct = NewRgn());		aWindow->GetWindowZoomRectSource( &wZoom );				// make sure we're up to date on events before doing this- updates especially		// this avoids the zoom effects from making the program seem slow!				gApplication->ProcessAllEvents();				ZoomRects( REGIONBOUNDINGBOX( wStruct ), &wZoom, 10, kZoomDecelerate );		DisposeRgn( wStruct );	}#endif}/*-------------------------***  CommandClickInFrontDragBar  ***-------------------------*//*access:			public	overrides:description: 	handle command-click in title bar of active windowins: 			<target> window clicked				<startPt> starting point of the clickouts: 			TRUE if click was actionednotes:			pops up a menu of path to window's file, and selects it in the Finder----------------------------------------------------------------------------------------*/Boolean		ZWindowManager::CommandClickInFrontDragBar( ZWindow* target, const Point startPt ){#if USE_MODERN_WINDOW_MGR	if ( gMacInfo.hasModernWindowMgr )	{		WindowPathSelect( target->GetMacWindow(), NULL, NULL );		return TRUE;	}	else		return FALSE;#else#if _USE_DIR_POPUP		// if we're using the directory pop-up code, call that here.	// has the window got a file?		FSSpec		ffs;	Boolean		result;			target->GetFileSpec( &ffs );		if ( ffs.vRefNum != kNoFile )	{		// we have a spec, so do that menu tracking thang, courtesy of Marco Piovanelli...				result = TrackDirectoryPopup( &ffs, target->GetMacWindow(), startPt );				if ( result )		{			// ffs now contains spec of selected directory, so we now assemble			// an apple event to tell the Finder to open it.						FailOSErr( OpenFinderObject( &ffs ));		}		else			result = ! StillDown();					return result;	}	else		return FALSE;#else	return FALSE;#endif#endif}/*----------------------------***  SaveWindowPosition  ***-----------------------------*//*access:			public	overrides:description: 	save information about a window's position in a fileins: 			<aWindow> window in question				<aFile> file to save it in (or NULL to use prefs file)				<id> ID under which to save the data (or 0 to make one up)outs: 			the actual id used to save the datanotes:			creates a WPos or DPos resource----------------------------------------------------------------------------------------*/short		ZWindowManager::SaveWindowPosition( ZWindow* aWindow, ZResourceFile* aFile, short id ){#if _WPOS_WINDOW_PLACEMENT	WPosHdl				wpH;	ZResourceFile*		st;	Rect				pr;	short				x, y;		FailNILParam( aWindow );		// if <aFile> is NULL, use gPrefsFile if it exists. Otherwise do nothing.		if ( aFile == NULL )		st = (ZResourceFile*) gPrefsFile;	else		st = aFile;			if ( st == NULL )		return 0;		FailNIL( wpH = ( WPosHdl ) NewHandleClear( sizeof( WPosResource )));		aWindow->GetGlobalPosition( &x, &y );	pr = *WINDOWPORTRECT( aWindow->GetMacWindow());		(*wpH)->globalH = x;	(*wpH)->globalV = y;	(*wpH)->width = pr.right - pr.left;	(*wpH)->height = pr.bottom - pr.top;		if ( id == 0 )		id = _UNIQUE_ID;			// make sure the resource fork is open, etc. In general the file should already exist-	// this will create it if not, but you'll have more control if you deal with this.		if ( ! st->IsReal() || ! st->HasResFork())		st->CreateResFork();			short	rf = st->GetResourceRefNumber();		try	{			st->OpenResFork();				if ( ISOLDDIALOG( aWindow ) || ISNEWDIALOG( aWindow ))			st->WriteResource((Handle) wpH, kDialogPosResType, id );		else			st->WriteResource((Handle) wpH, kWindowPosResType, id );				st->Flush();		ReleaseResource((Handle) wpH );				if ( rf == _NOT_OPEN )			st->CloseResFork();	}	catch(...)	{		if ( rf == _NOT_OPEN )			st->CloseResFork();					// don't propagate- not important.	}	#endif	// return the ID we actually used:		return id;}/*--------------------------***  RestoreWindowPosition  ***-----------------------------*//*access:			public	overrides:description: 	restore a window's position from fileins: 			<aWindow> window in question				<aFile> file with data (NULL = prefs file)				<id> ID of position dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZWindowManager::RestoreWindowPosition( ZWindow* aWindow, ZResourceFile* aFile, const short id ){#if _WPOS_WINDOW_PLACEMENT	WPosHdl				wpH;	ZResourceFile*		st;	Rect				pr;	FailNILParam( aWindow );		// if <aFile> is NULL, use gPrefsFile if it exists. Otherwise do nothing.		if ( aFile == NULL )		st = (ZResourceFile*) gPrefsFile;	else		st = aFile;			if ( st == NULL )		return;		// detach & read the pos resource, if any.		short	 rf = st->GetResourceRefNumber();		try	{		st->OpenResFork();					if ( ISOLDDIALOG( aWindow ) || ISNEWDIALOG( aWindow ))			wpH = (WPosHdl) st->ReadResource( kDialogPosResType, id );		else			wpH = (WPosHdl) st->ReadResource( kWindowPosResType, id );				if ( wpH )		{				// build the potential global rect of the window, to see if it's going to be on screen.			// Note that under System 8.0+, the window frame can be dragged by its edges, but on			// earlier systems only the title bar is draggable. We must check that a DRAGGABLE part of			// the window is visible before moving it to that location.						SetRect( &pr, 0, 0, (*wpH)->width, (*wpH)->height );			OffsetRect( &pr, (*wpH)->globalH, (*wpH)->globalV );						short	tBar = aWindow->GetTitleBarHeight();						pr.top -= tBar;						// modify rect according to titlebar height, and system, etc						if ( gMacInfo.systemVersion < 0x0800 )				pr.bottom = pr.top + tBar;						// if on screen, move the window. Otherwise leave it where it is:						if ( WindowOnDesktop( &pr ))				aWindow->PlaceAt((*wpH)->globalH, (*wpH)->globalV );		    		#if _RESTORE_WINDOW_SIZE				    // restore the window size if it's resizeable and not a dialog		    		    if ( aWindow->IsResizeable() && !ISOLDDIALOG( aWindow ) && !ISNEWDIALOG( aWindow ))		        aWindow->SetSize((*wpH)->width, (*wpH)->height );		#endif				#if _RESTORE_DIALOG_SIZE				    // restore the window size if it's resizeable and is a dialog (normally turned off)		    if ( aWindow->IsResizeable() && (ISOLDDIALOG( aWindow ) || ISNEWDIALOG( aWindow )))		        aWindow->SetSize((*wpH)->width, (*wpH)->height );		#endif					ReleaseResource((Handle) wpH );		}		if ( rf == _NOT_OPEN )			st->CloseResFork();	}	catch(...)	{		if ( rf == _NOT_OPEN )			st->CloseResFork();					// don't propagate- it's not serious if this fails.	}	#endif}/*-------------------------------***  StackWindows  ***---------------------------------*//*access:			public	overrides:description: 	stack windows on the screenins: 			<resize> resize the windows to standard stack dimensions				<mainList> TRUE to stack main windows				<floaterList> TRUE to stack floaters as wellouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::StackWindows( Boolean resize, Boolean mainList, Boolean floaterList ){	ZWindow*	zw;	long		i;		SetBeachBallCursor();		if ( mainList && ( nonFloaters->CountItems() > 0 ))	{		globalPlaceLoc.h = 2;		globalPlaceLoc.v = GetMBarHeight() + 2;				// since windows are listed in front-to-back order, iterate in reverse:			for( i = nonFloaters->CountItems(); i > 0; i-- )		{			zw = (ZWindow*) nonFloaters->GetObject( i );						if ( !zw->Floats())			{			    InitiallyPlace( zw );				    if ( resize )				    zw->SetSize( kStdStackWidth, kStdStackHeight );		    }		}	}		if ( floaterList && ( floaters->CountItems() > 0 ))	{		Rect		mr, fb;		GDHandle	mDev;		short		hOffset, vOffset;			mDev = GetMainDevice();		mr = (*mDev)->gdRect;		mr.top += GetMBarHeight();		InsetRect( &mr, 2, 2 );				zw = (ZWindow*) floaters->GetObject( 1 );		zw->GetGlobalPosition( &hOffset, &vOffset );		zw->GetStructureFrameBorder( &fb );				hOffset = mr.right - hOffset - fb.right;		vOffset = mr.top + fb.top;				for( i = floaters->CountItems(); i > 0; i-- )		{			zw = (ZWindow*) floaters->GetObject( i );						if ( zw->Floats())			{			    zw->PlaceAt( hOffset, vOffset );						    hOffset += fb.top + 4;			}		}	}}/*--------------------------------***  TileWindows  ***---------------------------------*//*access:			public	overrides:description: 	tile windows on the screenins: 			<vertyicalPreferred> TRUE if tiles should be vertical rather than hori-				zontal. Once there are more than three windows, this is ignoredouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::TileWindows( Boolean verticalPreferred ){	ZWindow*	zw;	long		i;	short		h, v, ph, pv, wh, wv;	Rect		mr, fb;	GDHandle	mDev;		i = CountWindows();		if ( i < 1 )		return;			SetBeachBallCursor();			mDev = GetMainDevice();	mr = (*mDev)->gdRect;	mr.top += GetMBarHeight();	InsetRect( &mr, 2, 2 );		// tiling requires that we evenly distribute windows on the screen, with no	overlap.	// for up to 3 windows, we use a vertical or horizontal arrangement, for 4 or more	// we try to find a "good fit"		if ( i < 4 )	{		h = v = 1;				if ( verticalPreferred )			v = i;		else			h = i;		}	else	{		// try to find a nice rectangular arrangement. We start with the square root, then		// jiggle around looking for a good fit. The problem is to find two factors of the		// number of windows that minimises screen wastage. This is quite a hard problem, but		// the following code does a pretty good job in the main. Start with the square root		// as a reasonable best guess, then increment the horizontal factor from just below		// this value to just above it, looking for a minimum, then repeat with the vertical		// factor. Finally, we correct for factors that are close but lower than the desired		// product, and calculate the window sizes based on the computed factors.			short 	r = SquareRoot( i );		short	m, min = 1000;			h = MAX( 1, r - 2);		v = r;				// search for a minimal horizontal factor:				do		{			h++;			m = ABS( i - ( h * v));						if ( m > min )				break;						min = m;			}		while( 1 );				// repeat, iterating the vertical factor				min = 1000;		h--;		v = MAX( 1, r - 2);				do		{			v++;			m = ABS( i - ( v * h ));						if ( m > min )				break;							min = m;		}		while( 1 );				// make sure that we don't find the wrong minimum- h * v MUST be equal or greater		// than i. e.g. 10 windows yields 3 x 3 as best arrangement, but in fact 3 x 4 is needed				v--;		if (( h * v ) < i )			v++;	}			// OK, v and h are the number of windows horizontally and vertically. Now compute the	// size we need to make them. Naturally, we take into account the window borders:	FailNILParam( zw = GetTopWindow());	zw->GetStructureFrameBorder( &fb );		wh = (( mr.right - mr.left ) / h ) - ( fb.left + fb.right );	wv = (( mr.bottom - mr.top ) / v ) - ( fb.top + fb.bottom );		ph = mr.left + fb.left;	pv = mr.top + fb.top;		// OK, now move and resize the windows, ta-daaaa!		for ( i = 1; i <= nonFloaters->CountItems(); i++ )	{		zw = (ZWindow*) nonFloaters->GetObject( i );				if ( !zw->Floats())		{    		if ( zw->IsResizeable())    			zw->SetSize( wh, wv );    		zw->PlaceAt( ph, pv );    		    		if ( i % h )    			ph += wh + fb.left + fb.right;    		else    		{    			ph = mr.left + fb.left;    			pv += wv + fb.top + fb.bottom;    		}    	}	}}/*----------------------------***  FindWindowByUserID  ***------------------------------*//*access:			public	overrides:description: 	find a window by searching for its user IDins: 			<id> the ID to findouts: 			the window, or NULL if not foundnotes:			search both main and floater lists for the window----------------------------------------------------------------------------------------*/ZWindow*	ZWindowManager::FindWindowByUserID( long id ){	ZWindow*	w = NULL;	long		m, i;		m = CountWindows();		for( i = 1; i <= m; i++ )	{		w = GetNthWindow( i );				if ( w && w->GetUserID() == id )			return w;	}		m = CountFloaters();		for( i = 1; i <= m; i++ )	{		w = GetNthFloater( i );				if ( w && w->GetUserID() == id )			return w;	}		return NULL;}/*-------------------------------***  ReportFields  ***---------------------------------*//*access:			public	overrides:description: 	report data members to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZWindowManager::ReportFields(){	ZComrade::ReportFields();	XSHOWFIELD( nonFloaters, ft_objectref );	XSHOWFIELD( floaters, ft_objectref );	XSHOWFIELD( wmWindows, ft_objectref );	XSHOWFIELD( wmMenu, ft_Handle );	XSHOWFIELD( wmItemOffset, ft_signedshort );	XSHOWFIELD( globalPlaceLoc, ft_Point );	XSHOWFIELD( fStoredZoom, ft_Rect );	XSHOWFIELD( fStoredZoomSource, ft_Rect );	XSHOWFIELD( wmActive, ft_boolean );	XSHOWFIELD( wmDDDeactivated, ft_boolean );}#pragma mark -/*--------------------------------***  BringBehind  ***---------------------------------*//*access:			protected	overrides:description: 	move a window up behind anotherins: 			<aWindow> the window to move				<behindWindow> window to move it behindouts: 			nonenotes:			low-level method deals with toolbox ordering----------------------------------------------------------------------------------------*/void		ZWindowManager::BringBehind( ZWindow* aWindow, ZWindow* behindWindow ){	// brings <aWindow> behind <behindWindow>. If <behindWindow> is NULL, it is brought	// to the front. This manipulates the mac windowlist to match the state here.		WindowPtr	a, b;		if ( aWindow == behindWindow )		return;		if ( behindWindow )	{		a = aWindow->GetMacWindow();		b = behindWindow->GetMacWindow();				::SendBehind( a, b );	}	else		::BringToFront( aWindow->GetMacWindow()); }/*-------------------------------***  PostActivation  ***-------------------------------*//*access:			protected	overrides:description: 	post an activation event to the windowins: 			<aWindow> the window to send the event to				<state> TRUE if activating, FALSE if deactivatingouts: 			nonenotes:			this will either create a real activation event, or just send one directly				to the object involved, depending on how you compile.----------------------------------------------------------------------------------------*/void		ZWindowManager::PostActivation( ZWindow* aWindow, Boolean state )	{	// posts an activate event for the window. This will be picked up by the event handler, which	// will then maintain the command chain correctly. Floater activations are never sent in this	// way, but their activate methods are called directly.		if ( aWindow->IsVisible())	{		// actiavtes are supressed if the applicaiton is suspended. On resume, the topmost		// window is activated.				if ( gApplication->InBackground() && state )			return;				if ( aWindow->Floats())		{			#if _ALL_FLOATERS_ACTIVE			HiliteWindow( aWindow->GetMacWindow(), TRUE );			#else			HiliteWindow( aWindow->GetMacWindow(), state );			#endif						if ( state == aWindow->IsActive())				return;					aWindow->Focus();			if ( state )			{				aWindow->Activate();				SendMessage( kWMMsgFloaterActivated, aWindow );			}			else			{				aWindow->Deactivate();				SendMessage( kWMMsgFloaterDeactivated, aWindow );			}		}		else		{			HiliteWindow( aWindow->GetMacWindow(), state );						if ( state == aWindow->IsActive())				return;			#if _ACTIVATE_EVENTS_ARE_REAL						EvQElPtr	evQ;						if ( aWindow )			{				long		evtMessage = (long) aWindow->GetMacWindow();								FailOSErr( PPostEvent( activateEvt, evtMessage, &evQ ));								// set up the modifiers to indicate activation state								if ( state )					evQ->evtQModifiers |= activeFlag;				else					evQ->evtQModifiers &= ~activeFlag;			}						#else			ZEventHandler*	ze = gApplication->GetEventHandler();						ze->HandleWindowActivate( aWindow->GetMacWindow(), state );						#endif					SendMessage( state? kWMMsgWindowActivated : kWMMsgWindowDeactivated, aWindow );		}	}}/*-------------------------------***  CalcWindowRgns  ***-------------------------------*//*access:			protected	overrides:description: 	set up a region for window dragging that excludes windows in front of				the one being draggedins: 			<aWindow> the window being dragged				<aRgn> region receives resultouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::CalcWindowRgns( ZWindow* aWindow, RgnHandle aRgn ){	// sets <theRgn> to the union of all windows in front if <aWindow>, including floaters.	// This is used to form the clip region for a window drag. Note- this doesn't check the	// parameters for sanity.		SetEmptyRgn( aRgn );		// the simplest way to achieve this is to scan the real mac window list, since that	// allows us to treat the window ordering simply without consideration of our separate	// lists.		WindowPtr	w = FrontWindow();	RgnHandle   temp;		FailNIL( temp = NewRgn());		while ( w && w != aWindow->GetMacWindow())	{		GetWindowStructureRgn( w, temp );		UnionRgn( temp, aRgn, aRgn );			w = MacGetNextWindow( w );	}		DisposeRgn( temp );}/*------------------------------***  ShowHideFloater  ***-------------------------------*//*access:			protected	overrides:description: 	show or hide a floating windowins: 			<aFloater> the window in question				<hide> TRUE to hide the window, FALSE to show itouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::ShowHideFloater( ZWindow* aFloater, Boolean hide ){	FailNILParam( aFloater );		short		dh = 10000;	Point		wLoc;	WindowPtr	w = aFloater->GetMacWindow();	Rect		dtBounds  = *REGIONBOUNDINGBOX( GetGrayRgn());		if (! hide)		dh = -dh;			aFloater->Focus();	wLoc = TOPLEFTPOINT( *WINDOWPORTRECT( w ));	LocalToGlobal( &wLoc );		// don't attempt to hide or show more than once- it doesn't work. To this end we check	// that the window is not already positioned		if (( hide && wLoc.h < dtBounds.right ) ||		( ! hide && wLoc.h > dtBounds.right ))		MoveWindow( w, wLoc.h + dh, wLoc.v, FALSE );	}/*-----------------------------***  BuildWindowsMenu  ***-------------------------------*//*access:			protected	overrides:description: 	populate the windows menu when necessaryins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZWindowManager::BuildWindowsMenu(){	short	n, i, mi;		if ( wmMenu )	{		// delete items beyond initial number				n = CountMenuItems( wmMenu );				while( n > wmItemOffset )			DeleteMenuItem( wmMenu, n-- );					// set menu to window titles. If the offset was >0, add a dividing line first				if ( wmWindows )		{				ZWindow*	zw;			Str255		title;						n = wmWindows->CountItems();						if (( wmItemOffset > 0 ) && ( n > 0 ))				AppendMenu( wmMenu, "\p-" );					for( i = 1; i <= n; i++ )			{				mi = i + wmItemOffset;								if ( wmItemOffset > 0 )					mi++;	// allow for extra divider line								zw = (ZWindow*) wmWindows->GetObject( i );								zw->GetName( title );								AppendMenu( wmMenu, "\px(" );				SetMenuItemText( wmMenu, mi, title );							#if _ENUMERATE_WM_CMDS								if ( i < 11 )					SetItemCmd( wmMenu, mi, i + 0x2F );						#endif								if ( ! IsDialog( GetTopWindow()))					ENABLEMENUITEM( wmMenu, mi );								// if window is active, check that item								if ( zw == GetTopWindow())					CHECKMENUITEM( wmMenu, mi, TRUE );			}		}	}}/*------------------------------***  WindowOnDesktop  ***-------------------------------*//*access:			protected	overrides:description: 	query whether any part of window frame is on the desktopins: 			<wFrame> global structure rect of a windowouts: 			TRUE if some part is on the desktopnotes:			----------------------------------------------------------------------------------------*/Boolean		ZWindowManager::WindowOnDesktop( Rect* wFrame ){	// return TRUE if the rect passed intersects the desktop. Called by RestoreWindowPosition	// to see if the restored position is legal on this system.		RectRgn( gUtilRgn, wFrame );	SectRgn( gUtilRgn, GetGrayRgn(), gUtilRgn );	return ( ! EmptyRgn( gUtilRgn ));}#pragma mark -/*------------------------------***  DragGrayRgnSnap  ***-------------------------------*//*access:			public	overrides:description: 	special version of DragGrayRgn can handle snap behaviourins: 			<rgn> region to drag				<startPt> stsrtin gpoint for the drag				<limitRect> the limit rectangle for the drag				<wdUPP> callback function to call when dragging				<snap> snap flagsouts: 			drag offsetnotes:			keeps control until mouse released----------------------------------------------------------------------------------------*/long        ZWindowManager::DragGrayRgnSnap( RgnHandle rgn, Point startPt, Rect* limitRect, DragGrayRgnUPP wdUPP, SnapFlags snap ){    // this method is broadly equivalent to DragGrayRgn, (though has no constraint or slopRect parameter), but    // is overrideable, and relies on GetMouseSnap() to obtain the mouse location, which implements the rather cool    // window-snapping behaviour. Read the comments in the header about how to configure this.    long        offset = 0, mDelta, mPin;    Point       m, old;    RgnHandle   temp;    PenState    penSave;        FailNIL( temp = NewRgn());    old = m = startPt;        // create a hollow region we can paint        CopyRgn( rgn, temp );    InsetRgn( temp, 1, 1 );    DiffRgn( rgn, temp, rgn );    CopyRgn( rgn, temp );        // paint it initially        GetPenState( &penSave );    PenMode( patXor );    PenPat( QDGRAYPATTERN );    PaintRgn( rgn );        do    {        // call the callback method:                if ( wdUPP )            InvokeDragGrayRgnUPP( wdUPP );                // where are we?                GetMouseSnap( &m, snap );                // check whether we're within the limit rect                if ( PtInRect( m, limitRect ))        {            // yes, but we should pin to this rect anyway                        mPin = PinRect( limitRect, m );            m = *(Point*) &mPin;                        // has the mouse actually moved since last time?                        mDelta = DeltaPoint( m, old );                        if ( mDelta )            {                // yes- recalculate the region and repaint it                        OffsetRgn( rgn, LoWord( mDelta ), HiWord( mDelta ));                XorRgn( rgn, temp, temp );                PaintRgn( temp );                CopyRgn( rgn, temp );                        old = m;            }        }        else        {            // outside limit, so hide the region                        PaintRgn( temp );            SetEmptyRgn( temp );        }    }    while( WaitMouseUp());        // turn off outline:        if ( PtInRect( m, limitRect ))    {        PaintRgn( rgn );        offset = DeltaPoint( m, startPt );    }    else        offset = kMouseUpOutOfSlop;        DisposeRgn( temp );    SetPenState( &penSave );        return offset;}/*--------------------------------***  GetMouseSnap  ***--------------------------------*//*access:			public	overrides:description: 	obtain the mouse point, but modify it slightly to "snap" to window edgesins: 			<pt> returns the mouse point				<snap> snap optionsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZWindowManager::GetMouseSnap( Point* pt, SnapFlags snap ){    GetMouse( pt );        if (( snap & ( snapTOFLOATERS + snapTONONFLOATERS )) != 0 )    {        Boolean     snappable = FALSE;                // to snap a window, we need to see if we are close to a snap edge and modify the returned point accordingly        // we also honour the snap flags- the dragged window must be snappable, and will only snap to windows of        // the flagged type                if ( sDraggedWindow )        {            ZWindow*    snapWindow;            RgnHandle   snapRgn;            Rect        snapRect, dragRect;            short       k, i, m, dh, dv, mh, mv, fh, fv;                        // see if the dragged window is snappable                        if ((( snap & snapFLOATERS ) != 0 ) && sDraggedWindow->Floats())                snappable = TRUE;                            if ((( snap & snapNONFLOATERS ) != 0 ) && !sDraggedWindow->Floats())                snappable = TRUE;                            if ( ! snappable )                return;                            // OK, this window is looking to be snapped- but what to (floaters, main or both)?                        FailNIL( snapRgn = NewRgn());                        for( k = 0; k < 3; k++ )            {                switch ( k )                {                    case 0:                        if ( snap & snapTONONFLOATERS )                        {                             m = CountWindows();                            break;                        }                        else                            continue;                                                case 1:                        if ( snap & snapTOFLOATERS )                        {                            m = CountFloaters();                            break;                        }                        else                            continue;                                                case 2:                        if ( snap & snapTOMAINONLY )                        {                            m = 1;                            break;                        }                        else                            continue;                }                                                // OK, snap to all windows in that particular class                                for( i = 1; i <= m; i++ )                {                    if ( k == 0 )                        snapWindow = GetNthWindow( i );                    else                    {                        if ( k == 2 )                            snapWindow = GetTopWindow();                        else                            snapWindow = GetNthFloater( i );                    }                                        if ( snapWindow && ( snapWindow != sDraggedWindow ) && snapWindow->IsVisible())                    {                            snapWindow->GetStructureRegion( snapRgn );                        snapRect = *REGIONBOUNDINGBOX( snapRgn );                        dragRect = *REGIONBOUNDINGBOX( sDraggedRegion );                                                mh = sRelMouseOffset.h;                        mv = sRelMouseOffset.v;                        dh = pt->h - mh;                        dv = pt->v - mv;                        fh = dh + dragRect.right - dragRect.left;                        fv = dv + dragRect.bottom - dragRect.top;                                                // look for snap edges                        // first vertical edges:                        if ( ABS( snapRect.right - dh ) < kSnapTolerance )                            pt->h = snapRect.right + mh;                        else                        {                            if ( ABS( snapRect.left - fh ) < kSnapTolerance )                                pt->h = snapRect.left - ( dragRect.right - dragRect.left ) + mh;                            else                            {                                if ( ABS( snapRect.left - dh ) < kSnapTolerance )                                    pt->h = snapRect.left + mh;                                else                                {                                    if ( ABS( snapRect.right - fh ) < kSnapTolerance )                                        pt->h = snapRect.right - ( dragRect.right - dragRect.left ) + mh;                                }                            }                        }                            // then horizontal edges                                                if ( ABS( snapRect.bottom - dv ) < kSnapTolerance )                            pt->v = snapRect.bottom + mv;                        else                        {                            if ( ABS( snapRect.top - fv ) < kSnapTolerance )                                pt->v = snapRect.top - ( dragRect.bottom - dragRect.top ) + mv;                            else                            {                                if ( ABS( snapRect.top - dv ) < kSnapTolerance )                                    pt->v = snapRect.top + mv;                                else                                {                                    if ( ABS( snapRect.bottom - fv ) < kSnapTolerance )                                        pt->v = snapRect.bottom - ( dragRect.bottom - dragRect.top ) + mv;                                }                            }                        }                        }                }            }            DisposeRgn( snapRgn );        }    }}/*-------------------------------***  DragWindowsProc  ***------------------------------*//*access:			static callback	overrides:description: 	callback function for DragGrayRgnins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/pascal void		ZWindowManager::DragWindowsProc(){	try	{		gWindowManager->DragWindowCallback( sDraggedWindow, sDraggedRegion );	}	catch(...)	{	}}