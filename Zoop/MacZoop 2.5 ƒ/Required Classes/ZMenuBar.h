/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZMenuBar.h			-- the menubar manager object******			© 1996, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZMENUBAR__#define	__ZMENUBAR__#include	"ZComrade.h"#include	"TextStyleUtils.h"#include	"MacZoopTypes.h"#include	<Menus.h>class	ZArray;// structure for storing info about a menu commandtypedef struct{	ZoopCommand		theCmd;			// item's basic command	ZoopCommand		altCommand;		// command with option key	ZoopCommand		shiftCommand;	// command with shift key	short			menuID;			// menu ID	short			itemID;			// item index	short 			cmdFlags;		// associated command flags	short			subMenuID;		// if parent of submenu, menu we "own".	MenuHandle		macMenu;		// actual handle of menu that owns this command}MenuCmd;// dimming options for entire menus:enum{	neverDim = 0,	dimCommands = 1,	dimParentItems = 2,	dimOthers = 4,	dimAll = 8,	dimTitle = 32};typedef unsigned char DimmingOptions;// structure for storing info about a whole menu:typedef struct{	short			menuID;			// menu ID of the menu	short			mIndex;			// index into original MBAR resource	MenuHandle		macMenu;		// handle to the menu	DimmingOptions	mDimming;		// dimming flags	Boolean			mIsResource;	// TRUE if menu is a resource	Boolean			mIsSubmenu;		// TRUE if menu is a submenu}MenuInfRec;#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif// structure of CMNU resource:typedef struct{	short			menuID;	long			fill1;	short			procID;	short			fill2;	unsigned long	flags;	char			mTitle;}CMNUResource, *CMNUResPtr, **CMNUResHdl;// the items in the menu follow after the title, given the length of the title as// a number of bytes to skip forward. Each entry consists of the command item text// followed immediately by four bytes, <icon>, <key equiv>, <mark char>, <style>, // followed by command ID (long), followed by next item.typedef struct{	unsigned char	iconID;	unsigned char	keyEqu;	unsigned char	markChar;	unsigned char	iStyle;}CMNUEntry, *CMNUEntryPtr;// structures used by low-level Mac menu manager:typedef struct{	MenuHandle	theMenu;	short		leftEdge;}mListEntry;typedef struct{	short		lastMOffset;	short		lastRightEdge;	short		spare;	mListEntry	mListItem[1];}mList, *mListPtr, **mListHdl;#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif// cmd flagsenum{	nothingSpecial = 0,	disableCmdsOnly = 1,	disableAll = 2,	disableParentItems = 4,	isPrimaryMenu = 8,	autoUnCheck = 16,	menuIsResource = 32};// special commands, constants and messages:enum{	noCommand 				= 0,	parentCmd 				= 99,	menuIDMenuTornOff 		= -1,	kMsgMBarAboutToShowMenu = 'zmb!',	kMenuHiliteDelay    	= 6};// constants for AppendStdItemsenum{	kAppendDANames = 0,	kAppendFontNames};// constants for menu hiding:typedef enum{	MBAR_SHOW,						// show the menubar	MBAR_HIDE,						// hide the menubar	MBAR_HIDE_MOUSEAWARE			// hide the menu bar unless mouse within 20 pixels of screen top}MBarHiding;DEFINECLASSID( ZMenuBar, 'zmbr' );// menubar manager classclass	ZMenuBar : public ZComrade{protected:	short			mBarID;				// res ID of original MBAR resource	short			mbCount;			// number of items in main bar at top level	short			miSeed;				// index counter	short			mHelpOffset;		// count of items in help menu before we added any	short**			mBarH;				// Handle to menubar data during construction	ZArray*			theMenuCmds;		// array of MenuCmd structs used to map commands	ZArray*			theMenus;			// array of MenuInfRec structs for menu behaviours	char			menuCheckChar;		// character used for checking a menu item	short			wmMenuID;			// ID of windows menu	short			mBarHeight;			// saved menubar height when hidden	MBarHiding		mbHiding;			// menubar hiding behaviour	Boolean			rbPending;			// TRUE if menubar redraw called during dispatch	Boolean			inDispatch;			// TRUE if currently in dispatchpublic:		ZMenuBar( const short barID ) : ZComrade() { classID = CLASS_ZMenuBar; mBarID = barID; };	virtual ~ZMenuBar();		virtual void		InitMenuBar();		virtual void		UpdateMenuBar();	virtual void		ClickMenuBar( const Point mousePt );	virtual void		DispatchCommand( const long mSelect, const short modifiers = 0 );	virtual void		DimMenus();	virtual void		PrepareMenusForDisplay();		virtual void		EnableCommand( const ZoopCommand cmd );	virtual void		EnableCommand( const short menuID, const short itemID );	virtual void		DisableCommand( const ZoopCommand cmd );	virtual void		DisableCommand( const short menuID, const short itemID );		virtual void		CheckCommand( const ZoopCommand cmd, const Boolean checkOnOff );	virtual void		CheckCommand( const short menuID, const short itemID, const Boolean checkOnOff );	virtual void		CheckCommand( const short menuID, Str255 itemString, const Boolean checkOnOff );	virtual void		CheckCommandWithChar( const ZoopCommand cmd, const char checkChar );	virtual void		CheckCommandWithChar( const short menuID, Str255 itemString, const char checkChar );	virtual void		SetCommandText( const ZoopCommand cmd, Str255 aText );	virtual void		SetCommandText( const short menuID, const short itemID, Str255 aText );	virtual void		SetCommandText( const ZoopCommand cmd, const short strListID, const short strIndex );	virtual void		SetCommandText( const short menuID, const short itemID, const short strListID, const short strIndex );		virtual void		SetCommandTextStyle( const ZoopCommand cmd, Style aStyle );		virtual void		SetTitleHilite( const short menuID, const Boolean state );	virtual void		SetMenuDimming( const short menuID, const DimmingOptions dimOpts );		virtual void		AppendMenuToBar( const short menuID );	virtual void		RemoveMenuFromBar( const short menuID );	virtual void		AppendStdItems( const short menuID, const short iType = kAppendDANames );	virtual MenuHandle	FindMenuID( const short menuID );		virtual short		AppendHelpItem( Str255 itemText );		// automatic "windows" menu handling:	virtual void		NominateWindowsMenu( const short menuID );			inline	void		SetCheckMarkChar( const char aChar ) { menuCheckChar = aChar; };	inline  char		GetCheckMarkChar() { return menuCheckChar; };	// font, style and size menu utilities, can be called from any UpdateMenus():	virtual void		UpdateStyleMenu( TEStyleRunInfo* runInfo );	virtual void		UpdateStyleMenu( Style aStyle );	virtual void		UpdateFontSizeMenu( TEStyleRunInfo* runInfo );	// showing and hiding the menubar:	virtual void		ShowHideMenuBar( MBarHiding	mHiding, Point gMouseLoc );	virtual void		ShowHideMenuBar( MBarHiding	mHiding );	inline	MBarHiding	GetMenuBarVisState() { return mbHiding; };		virtual void		SetZoomSourceToCommand( const ZoopCommand aCmd );	virtual void		FindCommand( const ZoopCommand cmd, short* menuID, short* itemID );		virtual void		LoadMenus( const Boolean autoInstall = TRUE );	virtual void		LoadMenu( const short menuID, Boolean isHMenu = FALSE, Boolean autoInstall = TRUE );	virtual void		LoadCMNUMenu( const short menuID, Boolean isHMenu = FALSE, Boolean autoInstall = TRUE );	virtual void		UnloadMenu( MenuHandle mH );		virtual void		ReportFields();protected:	virtual void		PredimMenu( MenuHandle theMenu );	virtual void		ParseMenuItem( Str255 iText, long* aCmd ); 		virtual void		FindMCmd( const long mSelect, MenuCmd* aCmd );	virtual long		TrackMenuBar( const Point mouse );	virtual void		FindMenuInfo( const short menuID, MenuInfRec* mRec );	virtual void		GetMenuTitleRect( short menuID, Rect* tRect );	};// this object handles a menubar. By default, it calls the mac menu manager to work with the// global menubar at the top of the main monitor, but it can be subclassed to implement other// sorts of menubar, for example a mini-menubar in a window (this is left as an exercise!).// This loads menus and parses the items into a list of command IDs. When the menu item is// chosen, the associated command is looked up. This is then generally passed up the command// chain in force at the time.// commands are associated initially with menu items using a #character, so your TCL resources// etc. can be used directly with this. e.g. "Open File...#12345" will result in the menu item// "Open File..." and the command number 12345. This will also use CMNU resources (a la MacApp)// if it can't find a MENU resource. Thus you get the best of both worlds!extern	ZMenuBar*	gMenuBar;extern	short		gFontMenuID;#endif