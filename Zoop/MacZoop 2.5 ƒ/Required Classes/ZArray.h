/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZArray.h			-- the basic container class object******			© 1996, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZARRAY__#define	__ZARRAY__#ifndef __ZCOMRADE__#include	"ZComrade.h"#endif// form of the basic grovelling function you can pass to DoForEach(). Read note below.typedef void (*IteratorProcPtr)( void* item, const long ref );// Form of the sort comparison function you can pass to Sort(). This function should return// -1 if a < b, +1 if a > b, and 0 if they are equal. The sort function uses a very fast// shellsort algorithm. <itema> and <itemb> are POINTERS to the data held in the array, whatever// it is. If the array contains object pointers, this is therefore a POINTER to a POINTER to the// object, not the object pointer itself. This is an important point if you use Sort() with the// ZObjectArray<> class. This is also true of the grovelling function above.typedef short (*SortCmpProcPtr)( void* itema, void* itemb, const long ref );#ifdef __cplusplusextern "C"{#endiftypedef int	  (*QSortProcPtr)( const void* itema, const void* itemb );#ifdef __cplusplus}#endif// set up streaming stuff:DEFINECLASSID( ZArray, 'zarr' );// class definitionclass ZArray : public ZComrade{protected:	Handle			a;	unsigned long	blkSize;	unsigned long	numElements;	unsigned long	physicalBlks;	public:		ZArray( unsigned long elementSize = sizeof(Ptr));	ZArray( ZArray* copyThis );	virtual ~ZArray();	// operator version of I/O	void*			operator[]( const long index );// putting stuff in the array		virtual void	InsertItem( void* item, const long index );	virtual void	AppendItem( void* item );	virtual void	SetArrayItem( void* item, const long index );	virtual void	ConcatenateArray( ZArray* anArray );	virtual void	Copy( ZArray* anArray );// getting stuff out	virtual void	GetArrayItem( void* item, const long index );	virtual long	CountItems();	virtual long	FindIndex( void* item );// deleting items	virtual void	DeleteItem( const long index );	virtual void	DeleteAll();	// moving items	virtual void	MoveItem( const long curIndex, const long newIndex );	virtual void	Swap( const long itema, const long itemb );	// grovelling over the items	virtual void	DoForEach( IteratorProcPtr aProc, const long ref );	// sorting the items	virtual void	Sort( SortCmpProcPtr compareProc, const long ref );	virtual void	Sort();	virtual void	QSort( QSortProcPtr compareProc );	virtual short	Compare( void* itema, void* itemb, const long ref );	// randomising the item order	virtual void	Randomise();	// inserting items in a sorted list	virtual long	InsertSortedItem( void* item, SortCmpProcPtr compareProc, const long ref = 0 );	virtual long	InsertSortedItem( void* item, const long ref = 0 );	// finding items in a sorted list	virtual long	BFindIndex( void* item, SortCmpProcPtr compareProc, const long ref );	virtual long	BFindIndex( void* item, const long ref = 0 );	// streaming	virtual void	ReadFromStream( ZStream* aStream );	virtual void	WriteToStream( ZStream* aStream );		virtual void	GetDebugInfoString( Str255 s );	virtual void	ReportFields();	inline	long	GetBlockSize() { return blkSize; };		void			AppendToHandle( Handle aHand );	protected:			virtual void	InsertElement( const long index );			virtual void	DeleteElement( const long index );};// errors:enum{	kIndexOutOfRangeErr		= 230,	kElementSizeMismatchErr	= 231,	kUndefinedCompProcErr	= 232};// message "transmitted" when array is manipulatedenum{	msgArrayItemAdded = 'arr1',	msgArrayItemDeleted,	msgArrayItemMoved,	msgArrayItemChanged,	msgArrayItemInserted,	msgArrayAllDeleted};// to improve speed, the storage is expanded in sets of blocks// according to this constant- when full, this many blocks are// added.enum{	kNumPhysicalBlockAlloc	= 8};#endif