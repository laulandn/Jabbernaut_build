/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZView.h		-- manages drawing in part of a window******			©2000, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZVIEW__#define	__ZVIEW__#include	"ZCommander.h"#include	<drag.h>#include	<appearance.h>class	ZWindow;class	ZViewBorder;class	ZViewEnvironment;typedef ZObjectList  ZViewList;// state flags:enum{	kViewVisible				= 1,			// view actually drawn	kViewEnabled				= 2,			// view enabled	kViewActive					= 4,			// view active (in active window)	kViewCanBeHandler			= 8,			// view can start command chain	kViewHasStdBorder			= 16,			// view has a standard border	kViewIsDefaultItem			= 32,			// view is default item in dialog	kViewAcceptsMouseClicks		= 64,			// view responds to the mouse	kViewDontEraseBackground	= 128,			// view does not erase background when drawn	kViewBuffered				= 256,			// view buffered with GWorld (not yet implemented)	kViewHasListBoxBorder		= 512,			// standard border is listbox style	kViewRefreshOnResize		= 1024,			// if set, post updates before and after resize	kViewRefreshOnActivate		= 2048			// if set, post updates on activate/deactivate};typedef unsigned short 	ViewState;// structure sent with tooltip hook messagetypedef struct{	Point		mouse;	short		modifiers;	Boolean		active;}ViewMouseInfo;	// class identifiers:DEFINECLASSID( ZView, 'zvew' );DEFINECLASSID( ZViewBorder, 'zvbd' );DEFINECLASSID( ZDropShadowBorder, 'zvbs' );DEFINECLASSID( ZViewEnvironment, 'zenv' );// generic view classclass	ZView	: public ZCommander{protected:	ZViewList*			fChildViews;			// list of child views belonging to this one	ZViewBorder*		fBorder;				// border drawing object (if any)	ZViewEnvironment*	fGrafEnv;				// attached graphics environment	Rect				fFrame;					// frame rectangle of view in parent bounds coordinates	long				fPrivateID;				// ID tag used by the MacZoop	long				fUserID;				// user settable ID tag	Sizing				fAutoSizing;			// automatic resizing flags	ViewState			fStateFlags;			// status flags	StringHandle		fTipText;				// tooltip text (if any)public:	ZView( ZView* parentView, Rect* aFrame = NULL );	ZView( ZCommander* aBoss );	ZView( ZView* aParent, const short viewResourceID );	ZView();	virtual ~ZView();// drawing		virtual void		Focus();	virtual void		DrawAll();	virtual void		DrawContent();	virtual void		DrawBorder( Rect* frame );	virtual void		PrepareForDrawing( const Rect* rAlign = NULL );	virtual void		PostRefresh();	virtual void		PostRefresh( Rect* aRect );	virtual void		PostRefresh( RgnHandle aRgn );	virtual void		PostContentRefresh();	virtual void		EraseBackground();	virtual Boolean		FocusForContent();// clicking	virtual ZView*		FindView( const Point mouse );	virtual ZView*		Find1View( const Point mouse );	virtual ZView*		FindEnclosingView( const Rect* aRect );	virtual void		AdjustCursor( const Point mouse, const short modifiers );	virtual void		SetViewCursor( const Point mouse, const short modifiers );	virtual void		Click( const Point mouse, const short modifiers );	virtual void		ClickContent( const Point mouse, const short modifiers ){};	virtual Boolean		ClickInSamePlace( const Point ptA, const Point ptB ) { return TRUE; };// state			virtual void		Activate();	virtual void		Deactivate();	virtual void		Enable();	virtual void		Disable();	virtual void		Hide();	virtual void		Show();	virtual void		BecomeHandler( Boolean isBecoming ){ DoSelectionUpdate( isBecoming ); };	virtual void		DoSelectionUpdate( Boolean state );// state info	inline  Boolean		IsActive() { return ( fStateFlags & kViewActive ) == kViewActive; };	virtual Boolean		IsEnabled();	virtual Boolean		IsVisible();	virtual Boolean		IsPrinting();	virtual Boolean		IsTheHandler();// sizing & positioning	virtual void		SetSize( const short aWidth, const short aHeight );	virtual void		PlaceAt( const short hPos, const short vPos );	virtual void		FitToParent( const Boolean fitH = TRUE, const Boolean fitV = TRUE );	virtual void		FitToParentPlusOne( const Boolean fitH = TRUE, const Boolean fitV = TRUE );	virtual void		CentreInParent( const Boolean centreH = TRUE, const Boolean centreV = TRUE );	virtual void		AdjustToParent( const short dt, const short dl, const short db, const short dr );	virtual void		SetAutoSizing( Sizing aSizing ) { fAutoSizing = aSizing; };	virtual void		ChangeSize( const short deltaTop, const short deltaLeft, const short deltaBottom, const short deltaRight );	virtual void		ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData );// info about frame, bounds, etc		virtual void		GetContentRect( Rect* aRect );	virtual void		GetFrame( Rect* aFrame );	virtual void		GetBounds( Rect* aBounds );	virtual void		GetPosition( short* posH, short* posV );	virtual void		GetContentRectInBounds( Rect* aRect );// setting graphics state	virtual void		SetFontInfo( const short fontID, const short size, const Style style );	virtual void		SetForeColour( const RGBColor* aColour );	virtual void		SetBackColour( const RGBColor* aColour );	ZViewEnvironment*	GetEnvironment();// child views		virtual ZView*		GetChildView( const long index );	virtual ZView*		FindChildViewByUserID( const long aUserID, Boolean deepSearch = FALSE );	virtual void		AddChildView( ZView* aView );	virtual void		RemoveChildView( ZView* aView );	virtual long		CountChildViews() { return fChildViews? fChildViews->CountItems() : 0; }	virtual long		CountViews();	virtual ZViewList*	GetChildViewList() { return fChildViews; }	virtual Boolean		IsChildView( ZView* aView, Boolean deepSearch = FALSE );// info about the parent and container window	virtual CGrafPtr	GetMacPort();	virtual ZView*		GetParent();	virtual ZWindow*	GetRootWindow();	virtual WindowPtr	GetRootWindowMacWindow();// other getters & setters		virtual void		SetDefaultItem( Boolean isDefault ){ isDefault? fStateFlags |= kViewIsDefaultItem: fStateFlags &= ~kViewIsDefaultItem; }	inline void			SetCanBeHandler( Boolean canBeIt ){ canBeIt? fStateFlags |= kViewCanBeHandler : fStateFlags &= ~kViewCanBeHandler; }	inline Boolean		CanBeHandler() { return ( fStateFlags & ( kViewCanBeHandler + kViewAcceptsMouseClicks )) == kViewCanBeHandler + kViewAcceptsMouseClicks; }	inline Boolean		IsDefaultItem() { return ( fStateFlags & kViewIsDefaultItem ) == kViewIsDefaultItem; }	inline void			SetAcceptsMouseClicks( Boolean clicks ){ clicks? fStateFlags |= kViewAcceptsMouseClicks : fStateFlags &= ~kViewAcceptsMouseClicks; }	inline Boolean		AcceptsClicks() { return ( fStateFlags & kViewAcceptsMouseClicks ) == kViewAcceptsMouseClicks; }	inline void			SetNoBackgroundErase( Boolean noErase ){ noErase? fStateFlags |= kViewDontEraseBackground : fStateFlags &= ~kViewDontEraseBackground; }	inline Boolean		ErasesBackground() { return ( fStateFlags & kViewDontEraseBackground ) == 0; }	inline void			SetRefreshOnResize( Boolean refresh ){ refresh? fStateFlags |= kViewRefreshOnResize : fStateFlags &= ~kViewRefreshOnResize; }	inline void			SetRefreshOnActivate( Boolean refresh ){ refresh? fStateFlags |= kViewRefreshOnActivate : fStateFlags &= ~kViewRefreshOnActivate; }		inline void			SetUserID( const long id ) { fUserID = id; };	inline long			GetUserID() { return fUserID; };	inline long			GetPrivateID() { return fPrivateID; };// drag and drop		virtual void		DDEnterView( const DragReference theDrag );	virtual void		DDExitView( const DragReference theDrag );	virtual void		DDHiliteView( const Boolean state, const DragReference theDrag, const Boolean insideFrame = TRUE );	virtual void		DDDispatchView( const Point mouse, const DragReference theDrag );	virtual Boolean		AcceptsFlavour( const OSType aFlavour ) { return FALSE; };	virtual Boolean		CanAcceptTheDrag( const DragReference theDrag );	virtual void		DDInsideView( const Point mouse, const DragReference theDrag ) {}	virtual Boolean		UnpackDrop( const DragReference theDrag );		virtual void		Drop( const OSType flavour, const Ptr data, const long dataSize, const DragReference theDrag ) {}	inline  ZView*		GetDragTargetView() { return sCurRxDragTarget; };	inline	ZView*		GetDragSenderView() { return sCurTxDragSender; };	// dragging:	virtual Boolean		ShouldDrag( const Point mouse, const short modifiers ) { return FALSE; }	virtual Boolean		StartDrag( const Point mouse, const short modifiers );	virtual void		MakeDragRegion( RgnHandle aRgn );	virtual void		MakeDragData( const DragReference theDrag, const short modifiers ) {}	virtual void		DragCompleted( const DragReference theDrag ) {}// borders		virtual void		AttachBorder( ZViewBorder* aBorder );	virtual void		StandardBorder( Rect* bFrame, Boolean inState );	void				SetStandardBorder( Boolean hasBorder, Boolean isListBorder = FALSE ) { hasBorder? fStateFlags |= kViewHasStdBorder : fStateFlags &= ~kViewHasStdBorder;																								if ( isListBorder )																									fStateFlags |= kViewHasListBoxBorder; }	inline Boolean		HasStdBorder() { return ( fStateFlags & kViewHasStdBorder ); }	ZViewBorder*		GetBorder() { return fBorder; };	virtual void		DrawSelfBorder();// streaming:	virtual void		WriteToStream( ZStream* aStream );	virtual void		ReadFromStream( ZStream* aStream );	virtual void		InitViewFromResource( Handle theRes );	virtual void		CreateViewResource( Handle resHandle );	// debug support		virtual void		ReportFields();	ZViewList*			FlattenViewsToList( ZViewList* aList, Boolean leafViewsOnly = FALSE );	// tooltip support:	virtual void		OpenTip( const Point mouse, const short modifiers );	virtual void		CloseTip();	virtual void		GetTooltipText( Str255 tipText );	virtual void		SetTooltipText( Str255 tipText );	protected:	virtual void		SetFrame( Rect* frame );	virtual void		SetActivePort();	virtual void		ViewDragInParent( Point mouse );	ZViewEnvironment*	MakeEnvironment();	void				ClipViewsAbove();	void				DeleteChildren();	void				ViewInit();	void				ViewResInit( const short viewResID );		static RgnHandle		sViewBaseClipRgn;	static ZView*			sCurRxDragTarget;	static ZView*			sCurTxDragSender;	static DragReference	sCurRxDragRef;	static DragReference	sCurTxDragRef;	static CGrafPtr			sActivePort;	static Point			sCurPortOrigin;};// this macro is just there to avoid having to write this code over and over#define	ITERATECHILDVIEWS( method )		{ if( fChildViews ) {\										long i, n = fChildViews->CountItems(); \											for( i = 1; i <= n; i++ ) {\												GetChildView(i)->method;\											}}}											// modifier & other messages sent by ZView:enum{	kModifierDrawViewFrame		= 'drvf',	kModifierDrawViewBorder		= 'drvb',	kModifierDrawViewContent	= 'drvc',	kMsgViewResized				= 'vwns',	kMsgSignalViewClicked		= 'vwwc',	kMsgSignalViewTyping		= 'vtyp',	kMsgUnspecifiedItemClicked	= 'udik',	kMsgViewCursorTooltipHook	= 'ttip',	kMsgViewTooltipCancel		= '~tip'};// border drawing class:class	ZViewBorder : public ZObject{public:	ZViewBorder() : ZObject() { classID = CLASS_ZViewBorder; };		virtual void	Draw( Rect* borderFrame ){ FrameRect( borderFrame ); };};// border class for drop-shadow borderclass	ZDropShadowBorder	: public ZViewBorder{public:	ZDropShadowBorder() : ZViewBorder() { classID = CLASS_ZDropShadowBorder; };		virtual void	Draw( Rect* borderFrame );};// graphics environment class for setting up grafPortclass	ZViewEnvironment	: public ZObject{protected:	unsigned short		fEnvFlags;			// what to set/change	short				fFont;				// text font	short				fFontSize;			// text size	Style				fStyle;				// text style	RGBColor			fFore;				// drawing colour	RGBColor			fBack;				// erasing colour	ThemeBrush			fPenBrush;			// theme pen brush	ThemeBrush			fBackBrush;			// theme background	ThemeBrush			fBackInactive;		// inactive theme background	ThemeBackgroundKind	fBackKind;			// theme special background	ThemeFontID			fThemeFont;			// themed font	ThemeTextColor		fTextColour;		// themed text colour	public:	ZViewEnvironment();		virtual void		Apply( const Rect* local, const Boolean isActive );		virtual void		SetFontInfo( const short font, const short size, const Style face );	virtual void		SetForeColour( const RGBColor* rgb );	virtual void		SetBackColour( const RGBColor* rgb );	virtual void		SetThemedPen( const ThemeBrush pen );	virtual void		SetThemedBack( const ThemeBrush back );	virtual void		SetThemedInactiveBack( const ThemeBrush back );	virtual void		SetThemedBackKind( const ThemeBackgroundKind kind );	virtual void		SetThemedFont( const ThemeFontID font );	virtual void		SetThemedTextColour( const ThemeTextColor colour );		short				GetFont() { return fFont; }	short				GetFontSize() { return fFontSize; }	Style				GetFace() { return fStyle; }	void				GetForeColour( RGBColor* rgb ){ *rgb = fFore; }	void				GetBackColour( RGBColor* rgb ){ *rgb = fBack; }	ThemeBrush			GetThemedPen(){ return fPenBrush; }	ThemeBrush			GetThemedBack(){ return fBackBrush; }	ThemeBrush			GetThemedInactiveBack(){ return fBackInactive; }	ThemeBackgroundKind	GetThemedBackKind(){ return fBackKind; }	ThemeFontID			GetThemedFont(){ return fThemeFont; }	ThemeTextColor		GetThemedTextColour(){ return fTextColour; }		virtual void		ReportFields();};// change flags for setting environment:enum{	kEnvironmentChangeFont				= 1,	kEnvironmentChangeFontSize			= 2,	kEnvironmentChangeFontFace			= 4,	kEnvironmentChangeForeColour		= 8,	kEnvironmentChangeBackColour		= 16,	kEnvironmentChangeThemePen			= 32,	kEnvironmentChangeThemeBack			= 64,	kEnvironmentChangeThemeBackKind		= 128,	kEnvironmentChangeThemeFont			= 256,	kEnvironmentChangeThemeTextColour	= 512};CLASSCFPROTOTYPE( ZView );CLASSCFPROTOTYPE( ZViewBorder );CLASSCFPROTOTYPE( ZViewEnvironment );// view template resource:#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endiftypedef struct{	OSType			viewType;			// view type (what class to make)	short			viewVersion;		// structure version (currently 1)	long			headerSize;			// size of header (offset to variable data)	long			parentID;			// ID of parent view, where used	Rect			frame;				// frame rectangle of view in parent bounds coordinates	RGBColor		fore;				// foreground colour	RGBColor		back;				// background colour	long			userID;				// user settable ID tag	short			font;				// the view's font	short			fontSize;			// the font size	Style			style;				// the font style	Sizing			autoSizing;			// automatic resizing flags	unsigned short	autoFitToParent;	// flags for fitting to parent automatically (see below)	Boolean			canBeHandler;		// true if can be handler	Boolean			noBackgroundErase;	// true if doesn't erase background	Boolean			acceptsMouseClicks;	// true if mouse clicks accepted	Boolean			hasStdBorder;		// true if has std border attached	Boolean			isDefaultItem;		// true if default item in dialog window}ViewTemplate, *ViewTemplatePtr, **ViewTemplateHdl;// a view resource may consist of more than this - individual view classes can extend this// as needed, and just declare the first field of any structure as a ViewTemplate. This// is the data shared by all views. This mechanism is the basis for the RAD tool.#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endifenum{	kViewTemplateResType		= 'View',	kViewTemplateCurrentVersion = 1,	kViewTemplateHandleSizeTooSmallErr = 801};// these flags are part of the <autoFitToParent> field in the template:enum{	kViewAutoFitFrame			= 1,	kViewAutoFitFramePlus		= 2,	kViewAutoFitCentre			= 3};/*ZView manages a visible portion of the screen or window.ZWindow and ZDialog are themselves subclasses of this, and your existing MacZoop code that overrides ZWindow, etcto draw things will work as normal. However, ZView itself can be subclassed and attached to a window as a childview, and this vastly simplifies things when it comes to creating more complex interfaces.ZView also handles drag and drop so now any view can have drag and drop of its own.-------------------------------------------------------------------------------------------------------------Every view has a frame and a bounds.The frame is the visible extent of the view within its parent's bounds.The bounds is the logical area of the view relative to the frame.For a simple view, the bounds and the frame are coincident, but in a scrollview, the boundscan be a different size from the frame and may be offset from it.The content within the view is always drawn relative to the bounds, which logically always has a top, left of 0,0.The Focus() method sets the Mac's grafport origin to the top, left of the bounds, ready for drawing the content. Thestructure of the view is drawn within its parent's bounds space. The structure is drawn by the Draw() method, andthe content by the DrawContent() method. Usually you'll only override the DrawContent() method. The defaultmethod draws the attached child views.ZScrollView provides a generic scrollable view with bars, and ZControlView a view containing a toolbox control.*/#endif