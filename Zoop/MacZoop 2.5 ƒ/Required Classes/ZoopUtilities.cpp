/****************************************************************************************************			MacZoop 2.0 - "the framework for the rest of us"		 ****			ZoopUtilities.cpp		-- general utilities******			© 1999, Graham Cox*****************************************************************************************************/#include	"MacZoop.h"#include	<FixMath.h>#include	<fp.h>#include	<palettes.h>#if _USE_URANDOMLIB#include	"URandomLib.h"#endif#if !TARGET_API_MAC_CARBON#include    "CarbonList.cpp"#endifRect				gZoomFXSourceRect = { 0, 0, 0, 0 };/*---------------------------------***  CopyPString  ***--------------------------------*//*access:			globaloverrides:		description: 	copy one pascal string to anotherins: 			<srcString> string to copy				<destString> receives copy of srcStringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	CopyPString( const Str255 srcString, Str255 destString ){	BlockMoveData( srcString, destString, MIN( srcString[0] + 1, 255 ));}/*-------------------------------***  ConcatPStrings  ***-------------------------------*//*access:			globaloverrides:		description: 	concatenate a pascal string onto anotherins: 			<root> string to append to				<append> string to be appendedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ConcatPStrings( Str255 root, const Str255 append ){    short charsToCopy;    // Truncate if concatenated string would be longer than 255 chars.    charsToCopy = MIN( append[0], 255 - root[0]);    BlockMoveData( append + 1, root + root[0] + 1, (long) charsToCopy);    root[0] += charsToCopy;}/*-----------------------------***  CopyPStringTrunc  ***-------------------------------*//*access:			globaloverrides:		description: 	copy a pascal string to another, limiting the length copiedins: 			<srcString> string to copy				<destString> receives copy of srcString				<ccLim> maximum number of characters to copyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	CopyPStringTrunc( const Str255 srcString, Str255 destString, const unsigned char ccLim ){	BlockMoveData( srcString, destString, MIN( srcString[0] + 1, ccLim + 1 ));	destString[0] = MIN( srcString[0], ccLim );}/*---------------------------***  ConcatPStringsTrunc  ***------------------------------*//*access:			globaloverrides:		description: 	concatentate a pascal string to another, limiting overall lengthins: 			<root> string to append to				<append> string to append				<ccLim> maximum length of resulting stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ConcatPStringsTrunc( Str255 root, const Str255 append, const unsigned char ccLim ){    short charsToCopy;    // Truncate if concatenated string would be longer than <ccLim> chars.    charsToCopy = MIN( append[0], ccLim - root[0]);    BlockMoveData( append + 1, root + root[0] + 1, (long) charsToCopy);    root[0] += charsToCopy;}/*-----------------------------***  CopyCToPString  ***--------------------------------*//*access:			globaloverrides:		description: 	copy C formatted string to a pascal stringins: 			<cStringIn> string to copy				<pStringOut> receives pascal formatted copy of stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	CopyCToPString( const char* cStringIn, Str255 pStringOut ){	short u = 0;		while( cStringIn[u++] ){};	// no error here, ignore warning.		if ( u > 255 )		u = 255;			BlockMoveData( cStringIn, &pStringOut[1], u );		pStringOut[0] = u - 1;}/*-----------------------------***  CopyPToCString  ***--------------------------------*//*access:			globaloverrides:		description: 	copy pascal formatted string to a C formatted stringins: 			<pStringIn> string to copy				<cStringOut> receives C formatted copy of stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	CopyPToCString( const Str255 pStringIn, char* cStringOut ){	short u = pStringIn[0];	BlockMoveData( &pStringIn[1], cStringOut, u );	cStringOut[u] = 0;}/*-------------------------------***  IsColourPort  ***---------------------------------*//*access:			globaloverrides:		description: 	test whether a grafPort is actually a colour port or notins: 			<aPort> port to testouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean	IsColourPort( CGrafPtr aPort ){	// in Carbon, all ports are colour	#if OPAQUE_TOOLBOX_STRUCTS		return TRUE;	#else		return ( aPort->portVersion & 0xC000 ) != 0;	#endif}/*-----------------------------***  SetPortBlackWhite  ***------------------------------*//*access:			globaloverrides:		description: 	set the fore and back colours of the current port to black and whiteins: 			noneouts: 			nonenotes:			also resets back pattern as per current recommendations for appearance----------------------------------------------------------------------------------------*/void	SetPortBlackWhite(){	RGBForeColor( &gBlack );	RGBBackColor( &gWhite );	BackPat( QDWHITEPATTERN );}/*-------------------------------***  SetHiliteMode  ***--------------------------------*//*access:			globaloverrides:		description: 	set hilite mode for the next invert operationins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	SetHiliteMode(){	LMSetHiliteMode( LMGetHiliteMode() & pHiliteBit );}/*---------------------------------***  MacHasDM  ***-----------------------------------*//*access:			globaloverrides:		description: 	check if drag manager available on this systemins: 			noneouts: 			TRUE if drag manager availablenotes:			----------------------------------------------------------------------------------------*/Boolean		MacHasDM(){	// returns TRUE if drag manager is installed on this mac and is loaded by the CFM.		return gMacInfo.hasDragManager;}/*--------------------------------***  NotifyAlert  ***---------------------------------*//*access:			globaloverrides:		description: 	display an alert, but use notification manager if app suspendedins: 			<alertID> the ID of the 'ALRT' resource to display				<ntFlags> options to the notification managerouts: 			item number of alert item clickednotes:			if app suspended, keeps control until app resumes, then displays alert.				Processes events normally while waiting.----------------------------------------------------------------------------------------*/static NMRec	gNotification;static Str255	gNotifyMessage;static Boolean	gNotificationPosted = FALSE;short		NotifyAlert( const short alertID, NTAlertFlags ntFlags ){	// basically: if ( background ):	//				install notification	//				wait for app foreground	//				delete notification		if ( ! gNotificationPosted )	{		if ( gApplication->InBackground())		{			// if an alert is to be displayed, set it up						if ( ntFlags & ntAlertDisplayMessage )			{				// build a string that says "The application Ò<name>Ó requires your attention.				// Please bring it to the front.								Str255	appName;								GetIndString( gNotifyMessage, kMiscStrListID, 17 );				gApplication->GetName( appName );				ConcatPStrings( gNotifyMessage, appName );				GetIndString( appName, kMiscStrListID, 18 );				ConcatPStrings( gNotifyMessage, appName );								gNotification.nmStr = gNotifyMessage;			}			else				gNotification.nmStr = NULL;						// set up any sound:						if ( ntFlags & ntAlertPlaySound )				gNotification.nmSound = ( Handle ) -1L;			else				gNotification.nmSound = NULL;						Handle	appIconSuiteH;			OSErr	theErr;							// set up icon and menu mark						gNotification.qType = 8;			gNotification.nmMark = TRUE;			gNotification.nmResp = NULL;			gNotification.nmRefCon = NULL;						theErr = GetIconSuite( &appIconSuiteH, kApplicationIconSuiteID, svAllAvailableData );						if ( theErr == noErr )				gNotification.nmIcon = appIconSuiteH;			else				gNotification.nmIcon = NULL;							// install notification:			NMInstall( &gNotification );							gNotificationPosted = TRUE;						// handle events until we come back to the front:					gApplication->WaitApplicationForeground();						// we're back, so delete the notification						NMRemove( &gNotification );			gNotificationPosted = FALSE;						if ( appIconSuiteH )				DisposeIconSuite( appIconSuiteH, FALSE );		}				if ( alertID > 0 )		{			StopCursorAnimation();			SetCursorShape( ARROW_CURSOR );						return Alert( alertID, NULL );		}		else			return ok;	}	else	{		// what can we do? This shouldn't arise in normal use, but just in case, we act as		// though the user saw an alert and clicked OK. Not ideal, but since a notification		// can't interrupt another, there's little choice.				SysBeep( 1 );		return ok;	}}/*----------------------------------***  MZDelay  ***-----------------------------------*//*access:			globaloverrides:		description: 	delay for a brief periodins: 			<ticks> number of ticks to wait until returningouts: 			nonenotes:			keeps control for delay period, and does not process events----------------------------------------------------------------------------------------*/void	MZDelay( short ticks ){	unsigned long ignored;		Delay( ticks, &ignored );}/*-----------------------------------***  MZWait  ***-----------------------------------*//*access:			globaloverrides:		description: 	delay for a brief periodins: 			<ticks> number of ticks to wait until returningouts: 			nonenotes:			keeps control for delay period, but does process events----------------------------------------------------------------------------------------*/void	MZWait( unsigned short ticks ){	long	tc = TickCount() + ticks;		while( TickCount() < tc )		gApplication->Process1Event();}/*----------------------------------***  AssertErr  ***---------------------------------*//*access:			globaloverrides:		description: 	post an alert box describing assertion problemins: 			<lineNo> line number of file				<srcFile> filename of file				<reason> reason string				<val> value of whatever failed the assertionouts: 			nonenotes:			used only for debugging----------------------------------------------------------------------------------------*/void	AssertErr( long lineNo, char* srcFile, char* reason, long val ){#if _DEBUG_		Str15			lineStr, valStr;	Str255		 	fileStr, reasonStr;		NumToString( lineNo, lineStr );	NumToString( val, valStr );		CopyCToPString( srcFile, fileStr );	CopyCToPString( reason, reasonStr );			ParamText( lineStr, fileStr, reasonStr, valStr );	StopCursorAnimation();		(void) Alert( kAssertionAlertID, NULL );		FailOSErr( kSilentErr );	#endif}/*-----------------------------***  SetGlobalZoomSource  ***----------------------------*//*access:			globaloverrides:		description: 	set the origin rectangle for next window zoomrect effectins: 			<aGlobalRect> rectangle in global coordinatesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	SetGlobalZoomSource( Rect* aGlobalRect ){	gZoomFXSourceRect = *aGlobalRect;}/*------------------------------***  SetLocalZoomSource  ***----------------------------*//*access:			globaloverrides:		description: 	set the origin rectangle for next window zoomrect effectins: 			<aLocalRect> rectangle in coordinates local to current portouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	SetLocalZoomSource( Rect* aLocalRect ){	Rect	r = *aLocalRect;		LocalToGlobal( &TOPLEFTPOINT( r ));	LocalToGlobal( &BOTTOMRIGHTPOINT( r ));		SetGlobalZoomSource( &r );}/*-----------------------------------***  EqualMem  ***---------------------------------*//*access:			globaloverrides:		description: 	byte compare two blocks of memoryins: 			<a, b> pointers to two arbitrary blocks of memory				<length> number of bytes to compareouts: 			TRUE if blocks match, FALSE if they do notnotes:			----------------------------------------------------------------------------------------*/Boolean		EqualMem( void* a, void* b, const unsigned long length ){	Boolean		result = (length > 0);	Ptr			aa, bb;		register unsigned long	len = length;		aa = (Ptr) a;	bb = (Ptr) b;		while( len-- )	{		if ( *aa++ != *bb++ )		{			result = FALSE;			break;		}	}	return result;}/*---------------------------------***  EqualHandle  ***--------------------------------*//*access:			globaloverrides:		description: 	byte compare two handlesins: 			<a, b> handles to two arbitrary blocks of memoryouts: 			TRUE if blocks match, FALSE if they do notnotes:			if handles not of equal size, this returns FALSE even if handle contents				match smaller handle otherwise----------------------------------------------------------------------------------------*/Boolean		EqualHandle( Handle a, Handle b ){	long	siza, sizb;		if ( a == NULL || b == NULL )		return FALSE;			siza = GetHandleSize( a );	sizb = GetHandleSize( b	);		if ( siza != sizb )		return FALSE;		// n.b-- no need to lock handles- EqualMem cannot move memory.			return	EqualMem( *a, *b, siza );}/*-------------------------------***  ChecksumHandle  ***-------------------------------*//*access:			globaloverrides:		description: 	return a checksum value for a handleins: 			<h> handle to arbitrary block of memoryouts: 			checksum of data in the handlenotes:			----------------------------------------------------------------------------------------*/long		ChecksumHandle( Handle h ){	FailNIL( h );		register long	q = 0;	register long	c = GetHandleSize( h );	register long	v = 0;	register Ptr	p = *h;		while( c-- )		v += (*p++ ^ (++q % 11));	return v;}/*---------------------------------***  Scale2Rects  ***--------------------------------*//*access:			globaloverrides:		description: 	scale a rectangle to fit within reference rect, preserving its original				aspect ratioins: 			<theRect> rectangle to modify				<refRect> reference rectangleouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	Scale2Rects( Rect *theRect, const Rect *refRect ){	Fixed 	aspectRatio;	Rect	destFrame;	short	refWidth,refHeight;		destFrame.top = destFrame.left = 0;	OffsetRect( theRect, -theRect->left, -theRect->top );		refWidth = refRect->right - refRect->left;	refHeight = refRect->bottom - refRect->top;		if ( theRect->right < theRect->bottom )	{		// the rect is taller than it is wide, so we centre horizontally				aspectRatio = FixRatio( theRect->right, theRect->bottom );		destFrame.right = FixRound( FixMul( aspectRatio, FixRatio( refHeight, 1 )));		destFrame.bottom = refHeight;				OffsetRect( &destFrame, refRect->left + (( refWidth - destFrame.right ) / 2 ), refRect->top );	}	else	{		// the rect is wider than it is tall, so we centre vertically 				aspectRatio = FixRatio( theRect->bottom, theRect->right );		destFrame.bottom = FixRound( FixMul( aspectRatio, FixRatio( refWidth, 1 )));		destFrame.right = refWidth;				OffsetRect( &destFrame, refRect->left, refRect->top + (( refHeight - destFrame.bottom ) / 2 ));	}	*theRect = destFrame;}/*---------------------------------***  CentreRects  ***--------------------------------*//*access:			globaloverrides:		description: 	centre a rectangle with respct to reference rectins: 			<theRect> rectangle to centre				<refRect> reference rectangleouts: 			nonenotes:			does not change size of the rectangle----------------------------------------------------------------------------------------*/void	CentreRects( const Rect* refRect, Rect* theRect ){	OffsetRect( theRect,				refRect->left - theRect->left + (( refRect->right - refRect->left ) / 2) - (( theRect->right - theRect->left ) / 2 ),				refRect->top - theRect->top + (( refRect->bottom - refRect->top ) / 2) - (( theRect->bottom - theRect->top ) / 2 ));}/*--------------------------------***  RealToString  ***--------------------------------*//*access:			globaloverrides:		description: 	convert a real number to a stringins: 			<num> number to convert				<str> receives resulting string				<decPlaces> number of decimal places to perform conversion toouts: 			nonenotes:			string is always in fixed point notation----------------------------------------------------------------------------------------*/void RealToString( const double num, Str255 str, const short decPlaces ){	decimal 	d;	decform		df;		df.style = FIXEDDECIMAL;	df.digits = decPlaces;		num2dec( &df, num, &d );	dec2str( &df, &d, (char*) &str[1] );		// set length of pascal string by scanning until we reach null terminator		str[0] = 0;	while( str[++str[0]] ){};		// no error here, ignore warning.}/*-------------------------------***  DrawLongAsHex  ***--------------------------------*//*access:			globaloverrides:		description: 	converst a number to its hexadecimal representation and draws itins: 			<val> number to drawouts: 			nonenotes:			draws in current port at current location with current style, etc----------------------------------------------------------------------------------------*/void	DrawLongAsHex( const register long val ){	register char 			c, shift, t = 1;	register unsigned long 	mask;		static 	 char			lineCache[10];		mask = 0xF0000000;	shift = 28;	lineCache[0] = 8;		while( mask )	{		c = ( val & mask ) >> shift;				lineCache[ t++ ] = (c > 9 )? c + 0x37 : c + 0x30;		mask >>= 4;		shift -= 4;	}		DrawString((ConstStr255Param) lineCache );}/*-----------------------------***  MacZoopVersionStr  ***------------------------------*//*access:			globaloverrides:		description: 	get the current MacZoop version number as a stringins: 			<aStr> receives the version stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	MacZoopVersionStr( Str255 aStr ){	Str15 ts;		NumToString(( MACZOOP_VERSION & 0xFF00 ) >> 8, aStr );	ConcatPStrings( aStr, "\p." );	NumToString(( MACZOOP_VERSION & 0x00F0 ) >> 4, ts );	ConcatPStrings( aStr, ts );		if ( MACZOOP_VERSION & 0x000F )	{		NumToString( MACZOOP_VERSION & 0x000F, ts );		ConcatPStrings( aStr, "\p." );		ConcatPStrings( aStr, ts );	}			switch( MACZOOP_VERSION_STAGE )	{		case k_Version_Alpha:			ConcatPStrings( aStr, "\pa" );			break;					case k_Version_Beta:			ConcatPStrings( aStr, "\pb" );			break;					case k_Version_Final_Candidate:			ConcatPStrings( aStr, "\pf" );			break;					default:			return;	}		NumToString( MACZOOP_VERSION_NONRELEASE_NUM, ts );	ConcatPStrings( aStr, ts );	#if TARGET_API_MAC_CARBON	ConcatPStrings( aStr, "\p (Carbon)");#endif}/*-------------------------------***  FrameGrayRect  ***--------------------------------*//*access:			globaloverrides:		description: 	draw a 1-pixel 3D effect frame around the rectangleins: 			<aRect> rectangle to draw frame aroundouts: 			nonenotes:			draws 1 pixel outside the frame passed----------------------------------------------------------------------------------------*/void	FrameGrayRect( const Rect* aRect ){	Rect		globRect;	GDHandle	aDev;	RGBColor	aColour;	RGBColor	bColour;		// frames a rectangle using two shades of gray so that the rectangle appears to	// be recessed into a gray surface. This actually draws 1 pixel outside the	// passed rectangle, so that normal FrameRect calls work as expected in addition.		globRect = *aRect;	LocalToGlobal( &TOPLEFTPOINT( globRect ));	LocalToGlobal( &BOTTOMRIGHTPOINT( globRect ));	aDev = GetMaxDevice( &globRect );		GetBackColor( &aColour );	bColour.red = bColour.green = bColour.blue = 0xFFFF;	GetGray( aDev, &aColour, &bColour );		RGBForeColor( &bColour );	MoveTo( aRect->left, aRect->bottom );	LineTo( aRect->right, aRect->bottom );	LineTo( aRect->right, aRect->top );		bColour.red = bColour.green = bColour.blue = 0;	GetGray( aDev, &aColour, &bColour );	RGBForeColor( &bColour );		Move( 0, -1 );	LineTo( aRect->left - 1, aRect->top - 1 );	LineTo( aRect->left - 1, aRect->bottom );}/*--------------------------------***  EtchGrayRect  ***--------------------------------*//*access:			globaloverrides:		description: 	draw a 2-pixel 3D effect frame around the rectangleins: 			<aRect> rectangle to draw frame aroundouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	EtchGrayRect( const Rect* aRect ){	Rect		r, globRect;	GDHandle	aDev;	RGBColor	aColour;	RGBColor	bColour;		// frames a rectangle using two shades of gray so that the rectangle appears to	// be recessed into a gray surface. This differs from FrameGrayRect in that it draws	//a 2-pixel rect that appears to recess into the surface, for decorative purposes.		PenNormal();		globRect = r = *aRect;	LocalToGlobal( &TOPLEFTPOINT( globRect ));	LocalToGlobal( &BOTTOMRIGHTPOINT( globRect ));	aDev = GetMaxDevice( &globRect );		GetBackColor( &aColour );	bColour.red = bColour.green = bColour.blue = 0xFFFF;	GetGray( aDev, &aColour, &bColour );		RGBForeColor( &bColour );	FrameRect( &r );		bColour.red = bColour.green = bColour.blue = 0;	GetGray( aDev, &aColour, &bColour );	RGBForeColor( &bColour );		OffsetRect( &r, -1, -1 );	FrameRect( &r );}/*-----------------------------***  GetMainScreenDepth  ***-----------------------------*//*access:			globaloverrides:		description: 	get pixel depth of main monitorins: 			noneouts: 			pixel depth of main monitornotes:			----------------------------------------------------------------------------------------*/short	GetMainScreenDepth(){	GDHandle	ms;		ms = GetMainDevice();		return (*(*ms)->gdPMap)->pixelSize;}/*-----------------------------***  GetMainScreenSize  ***------------------------------*//*access:			globaloverrides:		description: 	get bounds rect of main monitorins: 			<aRect> receives bounds rectouts: 			notes:			----------------------------------------------------------------------------------------*/void	GetMainScreenSize( Rect* aRect ){	GDHandle	ms;		ms = GetMainDevice();		*aRect = (*ms)->gdRect;}/*-------------------------------***  ShiftPattern  ***---------------------------------*//*access:			globaloverrides:		description: 	modify a pattern by rotating it by one rowins: 			<aPat> pattern to modifyouts: 			notes:			----------------------------------------------------------------------------------------*/void	ShiftPattern( Pattern* aPat ){	unsigned char topRow, i;		topRow = aPat->pat[0];		for( i = 0; i < 7; i++ )		aPat->pat[i] = aPat->pat[i + 1];			aPat->pat[7] = topRow;}/*-------------------------------***  ShiftCPattern  ***--------------------------------*//*access:			globaloverrides:		description: 	modify a colour pattern by rotating it by one rowins: 			<aPat> pattern to modifyouts: 			notes:			----------------------------------------------------------------------------------------*/void	ShiftCPattern( PixPatHandle aPat ){	long	patImgSize;	short	rowBytes;	Ptr		tempBuffer;		if ( aPat )	{		rowBytes = (*(*aPat)->patMap )->rowBytes & 0x3FFF;		patImgSize = GetHandleSize((*aPat)->patData );				// copy the top row of the data into a temporary buffer		// that we create. This holds one row of image data.				FailNIL( tempBuffer = NewPtr( rowBytes ));				BlockMoveData(*(*aPat)->patData, tempBuffer, rowBytes );				// copy the rest of the data up one row				BlockMoveData((*(*aPat)->patData) + rowBytes, *(*aPat)->patData, patImgSize - rowBytes );			// copy the temp row to the bottom of the image				BlockMoveData(tempBuffer, (*(*aPat)->patData) + patImgSize - rowBytes, rowBytes );				DisposePtr( tempBuffer );		PixPatChanged( aPat );	}}/*---------------------------------***  AntsRegion  ***---------------------------------*//*access:			globaloverrides:		description: 	create the "marching ants" effect by rotating a striped patternins: 			<aRgn> region to draw pattern aroundouts: 			nonenotes:			call repeatedly to animate the ants - implements its own rate timer----------------------------------------------------------------------------------------*/enum{	kAntsRate	= 2};void	AntsRegion( RgnHandle aRgn ){	static Pattern			antsPat = { 0x0F, 0x1E, 0x3C, 0x78, 0xF0, 0xE1, 0xC3, 0x87 };	static unsigned long 	antsTime = TickCount();	unsigned long			t;	PenState				ps;		t = TickCount();		if ( t >= ( antsTime + kAntsRate ))	{		antsTime = t;				GetPenState( &ps );				ShiftPattern( &antsPat );		PenPat( &antsPat );			PenSize( 1, 1 );		PenMode( patCopy );			FrameRgn( aRgn );				SetPenState( &ps );	}}/*-----------------------------***  BalloonHelpRefresh  ***-----------------------------*//*access:			globaloverrides:		description: 	removes current balloon help balloon from the screenins: 			noneouts: 			nonenotes:			does nothing on Carbon system----------------------------------------------------------------------------------------*/void		BalloonHelpRefresh(){#if !TARGET_API_MAC_CARBON	if ( HMIsBalloon() && HMGetBalloons())		HMRemoveBalloon();#endif}/*----------------------------***  GetDetachedResource  ***-----------------------------*//*access:			globaloverrides:		description: 	return a detached copy of a resource with the given type and IDins: 			<aType> resource type to look for				<anID> ID of the resourceouts: 			Handle to copy of resource - caller must dispose of itnotes:			----------------------------------------------------------------------------------------*/Handle	GetDetachedResource( const ResType aType, const short anID ){	Handle	temp = NULL;		temp = GetResource( aType, anID );		if ( temp )		DetachResource( temp );	return temp;}/*---------------------------------***  SquareRoot  ***---------------------------------*//*access:			globaloverrides:		description: 	return approximate integer square root of the argumentins: 			<n> number to find square root ofouts: 			approximate integer square root of nnotes:			uses Newton's iterative method, not MathLib----------------------------------------------------------------------------------------*/long	SquareRoot( const long n ){	long	g, b, pg;		// make a wild guess...		g = n >> 1;		// converge on the true answer by Newton's cool iterative method:		do	{			pg = g;		b = n / g;		g = ( b + g ) >> 1;	}	while( g < pg );		// I think you'll find that's pretty close ;-), bail...	return pg;}/*------------------------------***  NewFileTypesList  ***-----------------------------*//*access:			globaloverrides:		description: 	converts an array of OSType values to the internal format used by				ZApplication for its file types listins: 			<numTypes> number of values in the array				<types> array of OSType valuesouts: 			Handle to private format listnotes:			caller disposes of handle----------------------------------------------------------------------------------------*/Handle	NewFileTypesList( const short numTypes, const OSType* types ){	FTypeListHdl	fH = NULL;	short			i;		FailNIL( fH = (FTypeListHdl) NewHandleClear( sizeof( FTypeList ) + ( sizeof( OSType ) * ( numTypes - 1 ))));		(*fH)->appSignature = gAppSignature;	(*fH)->osTypeCount = numTypes;		for( i = 0; i < numTypes; i++ )		(*fH)->osType[i] = types[i];	return (Handle) fH;}/*----------------------------------***  GetRandom  ***---------------------------------*//*access:			globaloverrides:		description: 	return random integer between min and max inclusiveins: 			<min, max> range to return result inouts: 			random inetger within the rangenotes:			----------------------------------------------------------------------------------------*/short GetRandom( const short min, const short max ){#if _USE_URANDOMLIB	short	r = PRNG.UShort15();	r = r % ( max - min + 1 );#else		short	r = Random();	r = ABS( r ) % ( max - min + 1 );#endif		return r + min;}/*-----------------------------------***  DrawSICN  ***---------------------------------*//*access:			globaloverrides:		description: 	plot a small icon ('SICN' resource)ins: 			<SICNid> resource ID of SICN resource				<index> index of icon inresource (1..n)				<location> top left of icon will be plotted at this pointouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		DrawSICN( const short SICNid, const short index, const Point location ){	Handle		theSICN;	BitMap		theImage;	Rect		theBounds;	FailNILRes( theSICN = GetResource( 'SICN', SICNid ));			HLock( theSICN );	theImage.baseAddr = ((char*) *theSICN ) + ( index - 1 ) * 32;	theImage.rowBytes = 2;	SetRect( &theBounds, location.h, location.v,						 location.h + 16, location.v + 16 );	theImage.bounds = theBounds;	CopyBits( &theImage, CURRENTPORTPIXMAP, &theBounds, &theBounds, srcOr, NULL );	HUnlock( theSICN );	ReleaseResource( theSICN );}/*----------------------------------***  MZNewPort  ***---------------------------------*//*access:			globaloverrides:		description: 	create a new grafport structureins: 			noneouts: 			the portnotes:			does the right thing on Carbon and pre-carbon----------------------------------------------------------------------------------------*/CGrafPtr   MZNewPort(){	CGrafPtr	cp = NULL;	#if OPAQUE_TOOLBOX_STRUCTS	FailNIL( cp = CreateNewPort());#else	FailNIL( cp = (CGrafPtr) NewPtr( sizeof( CGrafPort )));		OpenCPort( cp );#endif	return cp;}/*--------------------------------***  MZDisposePort  ***-------------------------------*//*access:			globaloverrides:		description: 	dispose of a grafport created with MZNewPortins: 			<aPort> port to dispose ofouts: 			nonenotes:			does the right thing on Carbon and pre-carbon----------------------------------------------------------------------------------------*/void	MZDisposePort( CGrafPtr aPort ){#if OPAQUE_TOOLBOX_STRUCTS	DisposePort( aPort );#else	CloseCPort( aPort );	DisposePtr((Ptr) aPort );#endif}/*-----------------------------***  MZInvalWindowRect  ***-----------------------------*//*access:			globaloverrides:		description: 	invalidates a rectangle within a windowins: 			<window> window affected				<r> rectangle to invalidateouts: 			nonenotes:			does the right thing on Carbon and pre-carbon----------------------------------------------------------------------------------------*/void    MZInvalWindowRect( WindowPtr window, const Rect* r ){#if TARGET_API_MAC_CARBON    InvalWindowRect( window, r );#else    GrafPtr savePort;        GetPort( &savePort );    SETPORTTOWINDOW( window );    InvalRect( r );    SetPort( savePort );#endif}/*-----------------------------***  MZInvalWindowRect  ***-----------------------------*//*access:			globaloverrides:		description: 	invalidates a region within a windowins: 			<window> window affected				<rgn> region to invalidateouts: 			nonenotes:			does the right thing on Carbon and pre-carbon----------------------------------------------------------------------------------------*/void    MZInvalWindowRgn( WindowPtr window, const RgnHandle rgn ){#if TARGET_API_MAC_CARBON    InvalWindowRgn( window, rgn );#else    GrafPtr savePort;        GetPort( &savePort );    SETPORTTOWINDOW( window );    InvalRgn( rgn );    SetPort( savePort );#endif}/*-----------------------------***  MZInvalWindowRect  ***-----------------------------*//*access:			globaloverrides:		description: 	validates a rectangle within a windowins: 			<window> window affected				<r> rectangle to validateouts: 			nonenotes:			does the right thing on Carbon and pre-carbon----------------------------------------------------------------------------------------*/void    MZValidWindowRect( WindowPtr window, const Rect* r ){#if TARGET_API_MAC_CARBON    ValidWindowRect( window, r );#else    GrafPtr savePort;        GetPort( &savePort );    SETPORTTOWINDOW( window );    ValidRect( r );    SetPort( savePort );#endif}/*------------------------------***  MZValidWindowRgn  ***------------------------------*//*access:			globaloverrides:		description: 	validates a region within a windowins: 			<window> window affected				<rgn> region to validateouts: 			nonenotes:			does the right thing on Carbon and pre-carbon----------------------------------------------------------------------------------------*/void    MZValidWindowRgn( WindowPtr window, const RgnHandle rgn ){#if TARGET_API_MAC_CARBON    ValidWindowRgn( window, rgn );#else    GrafPtr savePort;        GetPort( &savePort );    SETPORTTOWINDOW( window );    ValidRgn( rgn );    SetPort( savePort );#endif}/*-----------------------------------***  MZTEKey  ***----------------------------------*//*access:			globaloverrides:		description: 	handles keystrokes in TextEdit recordins: 			<theKey> character typed				<te> TextEdit record				<modifiers> modifier keysouts: 			nonenotes:			overcomes limitations of TEKey, like handling forward delete, etc----------------------------------------------------------------------------------------*/void		MZTEKey( const char theKey, TEHandle te, const short modifiers ){	FailNILParam( te );		if ( theKey == FORWARD_DELETE_KEY )	{		if ((*te)->selStart == (*te)->selEnd )			TESetSelect((*te)->selStart, (*te)->selStart + 1, te );			TEDelete( te );	}	else	{		if (( modifiers & shiftKey ) == shiftKey )		{			long	end, start;						end = (*te)->selEnd;			start = (*te)->selStart;						switch( theKey )			{				case UP_ARROW_KEY:				case LEFT_ARROW_KEY:					TEKey( theKey, te );					TESetSelect((*te)->selStart, end, te ); 					break;									case DOWN_ARROW_KEY:				case RIGHT_ARROW_KEY:					TESetSelect( end, end, te );					TEKey( theKey, te );					TESetSelect( start, (*te)->selEnd, te );					break;									default:					TEKey( theKey, te );					break;			}		}		else			TEKey( theKey, te );	}}/*---------------------------------***  MZTEHeight  ***--------------------------------*//*access:			globaloverrides:		description: 	gets height of text in TextEdit recordins: 			<hTE> TextEdit recordouts: 			height occupied by textnotes:			works around bug in TEGetHeight----------------------------------------------------------------------------------------*/long		MZTEHeight( TEHandle hTE ){	long	result;	short	length;	result = TEGetHeight( 32767, 0, hTE );	length = (*hTE)->teLength;	// Text Edit doesn't return the height of the last character, if that	// character is a <cr>.  So if we see that, we go grab the height of	// that last character and add it into the total height.		if (( length ) && ((*(*hTE)->hText)[length - 1] == 0x0D ))	{		TextStyle	theStyle;		short		theHeight;		short		theAscent;		TEGetStyle( length, &theStyle, &theHeight, &theAscent, hTE );		result += theHeight;	}	return result;}/*-------------------------------***  MZWaitForMouseMove  ***---------------------------*//*access:			globaloverrides:		description: 	waits until mouse moved or button releasedins: 			<initialMouse> position of pouse to start withouts: 			TRUE if mouse moved, otherwise FALSEnotes:			similar to Drag Manager WaitMouseMoved, but doesn't care about coordinate				spaces, therefore much more useful within views----------------------------------------------------------------------------------------*/Boolean		MZWaitForMouseMove( Point initialMouse ){	Point	m;		do	{		GetMouse( &m );	}	while( DeltaPoint( m, initialMouse ) == 0 && StillDown());	return StillDown();	}/*---------------------------------***  MZTrackControl  ***-----------------------------*//*access:			globaloverrides:		description: 	TrackControl wrapper that deal with appearance conditionalins: 			<theControl> control to track				<startPt> local mouse position				<modifiers> modifier keys				<actionproc> action callback procouts: 			part code of control partnotes:			use wherever you would have used TrackControl----------------------------------------------------------------------------------------*/short		MZTrackControl( const ControlHandle theControl, const Point startPt, const short modifiers, ControlActionUPP actionProc ){#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )		return HandleControlClick( theControl, startPt, modifiers, actionProc );	else#endif		return TrackControl( theControl, startPt, actionProc );}/*-----------------------------***  GetIndStringFromResource  ***-----------------------*//*access:			globaloverrides:		description: 	obtain string from suitable resourceins: 			<aRes> res type of resource				<resID> ID of resource				<index> string index within resource (1..n)				<aStr> receives copy of stringouts: 			nonenotes:			this can extract strings from any resource similar to a 'STR#' where the				first word is the string count followed by a compact list of pascal				strings. This also includes 'DTIP' resources used in dialogs for tool tips----------------------------------------------------------------------------------------*/void	GetIndStringFromResource( ResType aRes, const short resID, const short index, Str255 aStr ){	Handle			rH;	Ptr				rP;	short			n, i;	unsigned char	s;		FailNILRes( rH = GetResource( aRes, resID ));		HLock( rH );	n = **(short**) rH;	rP = *rH + sizeof( short );	i = 1;		if ( index > 0 && index <= n )	{		// index in range, so walk the list and find it		do		{			s = (*rP) + 1;						if ( i == index )			{				BlockMoveData( rP, aStr, s );				break;			}					rP += s;		}		while( ++i <= n  );	}	else		aStr[0] = 0;			HUnlock( rH );	ReleaseResource( rH );}