/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			CursorUtilities.c			- cursor stuff- spinning watch, etc******			©1994 - 2000, Graham Cox**			This code was originally based on a VBL technique. Under Carbon, VBLs are personae*			non grata, so this code is revised to drive the animation using a time task, which*			is a supported Carbon technology***************************************************************************************************/#include	"MacZoop.h"#include	<LowMem.h>#include	<QDOffscreen.h>// globals:static long				gCursCount;static TMTaskWithA5Ptr	gCursorTask = NULL;static acurHdl			gWatchSpinner = NULL;static acurHdl			gBallSpinner = NULL;static acurHdl			gBusyArrowSpinner = NULL;static CCrsrHandle		gColourCursor = NULL;static Boolean			gCursorPaused = FALSE;static short			gLastCursorID = -1;#ifndef __POWERPC__	static TMTaskWithA5Ptr  GetTMRec() = 0x2049;	// MOVEA.L A1, A0	static pascal void 		TimerCursorSpin( void );#else	static pascal void		TimerCursorSpin( TMTaskPtr theTask );#endif/*-----------------------------***  InitAnimatedCursor  ***-----------------------------*//*access:			global	overrides:description: 	initialise an animated cursorins: 			<resID> resource ID of 'acur' resource to loadouts: 			Handle to animated cursor recordnotes:----------------------------------------------------------------------------------------*/acurHdl		InitAnimatedCursor( short resID ){	acurHdl		temp;	short		ccount;	CursHandle	aCursor;	CursHandle*	workPtr;		temp = (acurHdl) GetDetachedResource( 'acur', resID );		if (temp)	{		HNoPurge((Handle) temp );				ccount = (*temp)->numCursors;		(*temp)->index = 0;				HLock((Handle) temp);		workPtr = (*temp)->cursors;				while( ccount-- )		{			aCursor = (CursHandle) GetDetachedResource( 'CURS', *(short*) workPtr );			HNoPurge((Handle) aCursor );			*workPtr++ = aCursor; 		}			HUnlock((Handle) temp );	}		return temp;}/*---------------------------***  DisposeAnimatedCursor  ***----------------------------*//*access:			global	overrides:description: 	disposes of an animated cursorins: 			<cursH> animated cursor to get rid ofouts: 			nonenotes:----------------------------------------------------------------------------------------*/void		DisposeAnimatedCursor( acurHdl cursH ){	short ccount, mc;		mc = (*cursH)->numCursors;		for( ccount = 0; ccount < mc; ccount++ )		DisposeHandle((Handle) (*cursH)->cursors[ ccount ] );	DisposeHandle((Handle) cursH );}/*----------------------------***  StartCursorAnimation  ***----------------------------*//*access:			global	overrides:description: 	start a cursor animatingins: 			<period> frame period in ticks (approximately)				<theCursor> the cursor to animateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		StartCursorAnimation( short period, acurHdl theCursor ){	// primes the VBL/Timer queue to spin the cursor automatically	if ( theCursor )	{		LockCursorData( theCursor );				gCursCount = period * 16;	// 16.667 mS per tick		gCursorTask = (TMTaskWithA5Ptr) NewPtr( sizeof( TMTaskWithA5 ));		gCursorTask->theTask.qType = 0;		gCursorTask->theTask.tmAddr = NewTimerUPP( TimerCursorSpin );		gCursorTask->theTask.tmCount = 0;		gCursorTask->theTask.tmWakeUp = 0;		gCursorTask->theTask.tmReserved = 0;		#ifndef __POWERPC__		gCursorTask->A5 = (long) LMGetCurrentA5();	#endif				gCursorTask->theCursor = theCursor;			InsXTime((QElemPtr) gCursorTask );		PrimeTime((QElemPtr) gCursorTask, gCursCount );				gCursorPaused = FALSE;	}}/*-----------------------------***  StopCursorAnimation  ***----------------------------*//*access:			global	overrides:description: 	stop current cursor animatingins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		StopCursorAnimation(){	// removes spinning cursor task from the VBL/Timer queue	acurHdl		theCursor;		// force switch to default cursor:	if ( gCursorTask )	{		RmvTime((QElemPtr) gCursorTask );				theCursor = gCursorTask->theCursor;		DisposeTimerUPP( gCursorTask->theTask.tmAddr );				DisposePtr((Ptr) gCursorTask);		gCursorTask = NULL;		UnlockCursorData( theCursor );		gLastCursorID = -1;		SetCursorShape( ARROW_CURSOR );	}}/*----------------------------***  PauseCursorAnimation  ***----------------------------*//*access:			global	overrides:description: 	temporarily stop a cursor animating, setting a fixed shapeins: 			<tempFixedCursorID> temporary ID of fixed cursorouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		PauseCursorAnimation( short tempFixedCursorID ){	if ( CursorAnimating())	{		gCursorPaused = TRUE;		gLastCursorID = -1;	}	SetCursorShape( tempFixedCursorID );}/*----------------------------***  ResumeCursorAnimation  ***---------------------------*//*access:			global	overrides:description: 	resume animating a paused cursorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ResumeCursorAnimation(){	gCursorPaused = FALSE;}/*--------------------------------***  AnimateCursor  ***-------------------------------*//*access:			global	overrides:description: 	animate a cursor manuallyins: 			<increment> not used				<theCursor> the cursor to animateouts: 			nonenotes:			not required if using automatic animation----------------------------------------------------------------------------------------*/void		AnimateCursor( short increment, acurHdl theCursor ){	// used only for non-VBL cursor spinning		short		oldIndex,newIndex;	CursHandle	aCursor;		if ( theCursor && !gCursorPaused )	{		oldIndex = (*theCursor)->index;				(*theCursor)->index++;		(*theCursor)->index %= (*theCursor)->numCursors;				newIndex = (*theCursor)->index;				if ( newIndex != oldIndex )		{			aCursor = (*theCursor)->cursors[ newIndex ];			SetCursor(*aCursor);		}	}}/*-------------------------------***  LockCursorData  ***-------------------------------*//*access:			global	overrides:description: 	prepares the animated cursor for use by locking down internal handlesins: 			<theCursor> the cursor to animateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		LockCursorData( acurHdl theCursor ){	// locks the cursor and its internal data		short		ccount;	CursHandle	*workPtr;		ccount = (*theCursor)->numCursors;		HLockHi((Handle) theCursor);	workPtr = (*theCursor)->cursors;		while ( ccount-- )		HLockHi((Handle) *workPtr++);	}/*------------------------------***  UnlockCursorData  ***------------------------------*//*access:			global	overrides:description: 	cleans up after use by unlocking internal handlesins: 			<theCursor> the cursor to unlockouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		UnlockCursorData( acurHdl theCursor ){	// unlocks the cursor		short		ccount;	CursHandle	*workPtr;		ccount = (*theCursor)->numCursors;	workPtr = (*theCursor)->cursors;		while ( ccount-- )		HUnlock((Handle) *workPtr++);		HUnlock((Handle) theCursor);}/*-------------------------------***  TimerCursorSpin  ***------------------------------*//*access:			static callback	overrides:description: 	performs automatic animation when called back by a Time Manager taskins: 			<theTask> time manager task recordouts: 			nonenotes:			----------------------------------------------------------------------------------------*/#ifndef __POWERPC__    pascal void TimerCursorSpin( void )#else    pascal void	TimerCursorSpin( TMTaskPtr theTask )#endif{	TMTaskWithA5Ptr	tTask = NULL;#ifndef __POWERPC__	long			oldA5;		tTask = GetTMRec();	oldA5 = SetA5( tTask->A5 );		AnimateCursor( 1, tTask->theCursor );	PrimeTime((QElemPtr) tTask, gCursCount );	(void) SetA5( oldA5 );	#else		tTask = (TMTaskWithA5Ptr) theTask;		AnimateCursor( 1, tTask->theCursor );	PrimeTime((QElemPtr) tTask, gCursCount );	#endif	}/*--------------------------------***  SetWatchCursor  ***------------------------------*//*access:			global	overrides:description: 	simple call to start the watch cursor automatically animatingins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		SetWatchCursor(){	// HL call installs VBL spinner for watch, which should have been inited beforehand		if ( gCursorTask )		StopCursorAnimation();		if ( gWatchSpinner && ! gCursorTask )		StartCursorAnimation( 8, gWatchSpinner );}/*-----------------------------***  SetBeachBallCursor  ***-----------------------------*//*access:			global	overrides:description: 	simple call to start the beachball cursor automatically animatingins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		SetBeachBallCursor(){	if ( gCursorTask )		StopCursorAnimation();		if ( gBallSpinner && ! gCursorTask )		StartCursorAnimation( 4, gBallSpinner );}/*-----------------------------***  SetBusyArrowCursor  ***-----------------------------*//*access:			global	overrides:description: 	simple call to start the busy arrow cursor automatically animatingins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		SetBusyArrowCursor(){	if ( gCursorTask )		StopCursorAnimation();		if ( gBallSpinner && ! gCursorTask )		StartCursorAnimation( 4, gBusyArrowSpinner );}/*--------------------------------***  GetModifiers  ***--------------------------------*//*access:			global	overrides:description: 	returns current state of modifier keys without using eventsins: 			noneouts: 			modifier key statenotes:			----------------------------------------------------------------------------------------*/short		GetModifiers(){	// returns the current state of the modifier keys as if it was the modifier field in	// an event record. This can be called at any time, even when an event is not available.	// It is very useful for updating the cursor to show the modifier state.		short			modifiers = 0;	unsigned char	theKeys[16];	KeyMap*			pKeys;		pKeys = (KeyMap*) theKeys;		GetKeys( *pKeys );		((theKeys[0x37 >> 3] >> (0x37 & 7)) & 1)? modifiers |= cmdKey 	  : 0;	((theKeys[0x38 >> 3] >> (0x38 & 7)) & 1)? modifiers |= shiftKey   : 0;	((theKeys[0x39 >> 3] >> (0x39 & 7)) & 1)? modifiers |= alphaLock  : 0;	((theKeys[0x3A >> 3] >> (0x3A & 7)) & 1)? modifiers |= optionKey  : 0;	((theKeys[0x3B >> 3] >> (0x3B & 7)) & 1)? modifiers |= controlKey : 0;	(! Button())? modifiers |= btnState : 0;		return modifiers;}/*-------------------------------***  AppCursorInit  ***--------------------------------*//*access:			global	overrides:description: 	initialises the standard animated cursorsins: 			noneouts: 			nonenotes:			called at startup from ZApplication----------------------------------------------------------------------------------------*/void		AppCursorInit(){	// called once at application start-up to initialise the animated cursor globals.	gWatchSpinner = InitAnimatedCursor( kWatchResID );	gBallSpinner = InitAnimatedCursor( kBeachBallResID );	gBusyArrowSpinner = InitAnimatedCursor( kBusyArrowResID );		gLastCursorID = -1;	gColourCursor = NULL;}/*-------------------------------***  AppCursorFree  ***--------------------------------*//*access:			global	overrides:description: 	disposes the standard animated cursorsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		AppCursorFree(){	StopCursorAnimation();		DisposeAnimatedCursor( gWatchSpinner );	DisposeAnimatedCursor( gBallSpinner );	DisposeAnimatedCursor( gBusyArrowSpinner );}/*------------------------------***  CursorAnimating  ***-------------------------------*//*access:			global	overrides:description: 	query whether a cursor is animating nowins: 			noneouts: 			TRUE if a cursor is animating, FALSE if notnotes:			returns FALSE if cursor is temporarily paused----------------------------------------------------------------------------------------*/Boolean		CursorAnimating(){	return (( gCursorTask != NULL ) && !gCursorPaused );}/*-------------------------***  CursorAnimationVBLRunning  ***--------------------------*//*access:			global	overrides:description: 	query whether a cursor is animating nowins: 			noneouts: 			TRUE if a cursor is animating, FALSE if notnotes:			returns TRUE even if a cursor is temporarily paused----------------------------------------------------------------------------------------*/Boolean		CursorAnimationVBLRunning(){	return ( gCursorTask != NULL );}/*-------------------------------***  SetCursorShape  ***-------------------------------*//*access:			global	overrides:description: 	set a fixed cursorins: 			<resID> ID of teh cursorr to setouts: 			nonenotes:			will set a colour cursor if there is one, otherwise black and white one.				This should always be used to set cursors in MacZoop. Note - pass neg of				theme cursor ID to set a theme cursor.----------------------------------------------------------------------------------------*/void		SetCursorShape( short resID ){	if (( resID != gLastCursorID ) && ! CursorAnimating())	{		CCrsrHandle		ncH = NULL;					gLastCursorID = resID;		#if APPEARANCE_MGR_AWARE			if ( gMacInfo.hasAppearanceMgr && ( resID <= 0 ))		{			SetThemeCursor((ThemeCursor) -resID );		}		else		{	#endif			if ( resID == 0 )				SetCursor( QDARROWCURSOR );			else			{				// see if there's a colour cursor with that ID. We do not look for colour				// cursors with IDs less than 128 since for some reason Inside Mac says				// this is not allowed. Can't really see why this is!								if ( resID > 127 )				{					ncH = GetCCursor( resID );										if ( ncH )					{						// due to a subtle and undocumented side-effect of SetCCursor, we must be						// careful to preserve the GDevice around this call, or bad things can						// happen.												GDHandle	saveDevice;												saveDevice = GetGDevice();												SetCCursor( ncH );						SetGDevice( saveDevice );					}				}								// if no colour cursor, use a black and white one. This works with all				// cursor IDs, including the standard iBeamCursor, crossCursor, etc.								if ( ncH == NULL )				{					CursHandle	cH;										cH = GetCursor( resID );								if ( cH )					{						HLockHi((Handle) cH );						SetCursor( *cH );						HUnlock((Handle) cH );					}				}			}		#if APPEARANCE_MGR_AWARE			}	#endif				// dispose any old colour cursor				if ( gColourCursor )			DisposeCCursor( gColourCursor );				// keep track of new one or NULL				gColourCursor = ncH;	}}void		InvalidateCursor(){	gLastCursorID = -1;}