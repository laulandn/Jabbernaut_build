/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZObject.h			-- the root object (abstract class)******			© 1998, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZOBJECT__#define	__ZOBJECT__#include	"ZDefines.h"#include	<MacTypes.h>#include	<typeinfo.h>class	ZObject;class	ZStream;class	ZClassRegistry;typedef ZObject* (*ConstructorFunction)();/*If the following is defined TRUE, then all objects deriving from ZObject are kept in a linkedlist while they exist. This list can be used for debugging since it ignores relationshipsbetween objects- it just lists them in the order they were constructed in. Inspectors canuse this list to implement a dynamic run-time view of the app.*/#define	__OBJECT_DEBUG		1/*In order to permit MacZoop to implement object streaming (persistent objects), all objectsneed to have a common root. This is it- ZObject. Most classes ultimately derive from this andare thus streamable.ZObject relies on ZClassRegistry to store a table of class ID's, names and intantiationfunctions. Every class you wish to create from a stream must be registered with <gClasses> inorder to work- this is normally done at app startup time when ZApplication's RegisterClasses()method is called. The standard method only registers the required classes.Class ID's are four-char codes. MacZoop reserves all lower-case only codes for itself- forclasses of your own, use one or more upper case letters and make sure it's unique. The classIDmust be assigned in your constructor.In addition, all streamable classes must have a default constructor- i.e. one that has noparameters. You must also write a CONSTRUCTION FUNCTION, which just makes an object of thedeclared type using the default constructor. This goes like this:ZObject*	MyConstructorFunction(){	return new MyClass();}The function is passed to ZClassRegistry's RegisterClass() method, along with the classID andclass name.The following macros are provided to make all this setup much easier. They expand to the properclass ID and constructor function defeinitions so you can simply deploy them in your classes andforget about 'em.*/// This handy macro saves you having to do much work to create you class constructor functions. All// you have to do is put this at the top of your .cpp file where you want a constructor function,// passing the class name. This will be expanded into a constructor function of the correct type.// i.e. CLASSCONSTRUCTOR( ZWindow ); -> ZObject* CF_ZWindow() { return new ZWindow(); };#define		CLASSCONSTRUCTOR( x )		ZObject*	CF_##x##() { return new x(); }// to place a prototype for the constructor function, use this. NOte that normally this is unnecessary// since the DEFINECLASSID will also do this for you in the appropriate place.#define		CLASSCFPROTOTYPE( x )		ZObject*	CF_##x##()// to establish the proper class ID identifier for your class, put this in your class header:// x is the class identifier, e.g. ZWindow, id is the desired ID, e.g. 'zwin'.#define		DEFINECLASSID( x, id )		enum {	CLASS_##x = id }; CLASSCFPROTOTYPE( x )// to determine the name of the constructor function from your class identifier, use:#define		CONSTRUCTORFUNCTION( x )	CF_##x// to make a readable pascal style class name for your class:#define		CLASSNAME( x )	CLITERAL( \p##x )// handy way to get your class ID from your class name#define		CLASSID( x )	CLASS_##xenum{	kAllClasses		= 0};// So when registering a class, you need only do:// gClasses->RegisterClass( CLASSID( ZWindow ), CONSTRUCTORFUNCTION( ZWindow ), CLASSNAME( ZWindow ));// even better, ZClassRegistry has a macro that expands to this from a single class identifier:// e.g. REGISTERCLASS( ZWindow );DEFINECLASSID( ZObject, 'zobj' );// class definition:class	ZObject{private:    long			refCount;                           // reference countprotected:	OSType			classID;							// class ID of object- subclasses must set this	long			instanceID;							// instance ID. Reserved.	static long		sInstanceSeed;	static long		sObjectRefCount;	public:	ZObject();	virtual ~ZObject();	// info:	void			GetClassName( Str255 aName );	long			GetClassRef() { return classID; };	long			GetInstanceID() { return instanceID; };	void			SetClassID( OSType id ) { classID = id; };	// streaming:	virtual void	ReadFromStream( ZStream* aStream ) {};	virtual void	WriteToStream( ZStream* aStream ) {};	// ref counting:    void            Acquire() { refCount++; };    void            Release( Boolean autoDelete = TRUE );	Boolean         InUse() { return refCount > 0; };	virtual void	ReportFields();	#if __OBJECT_DEBUG	long			CountInstances( OSType ofClass = kAllClasses );	virtual void	GetDebugInfoString( Str255 s );	inline  long	GetObjectSize() { return sizeof( *this ); };	ZObject*			next;	ZObject*			prev;		static Boolean		sDisableObjectLink;	static ZObject*		sObjectDebugListHead;	static ZObject*		sObjectDebugListTail;	#endif};extern ZClassRegistry*	gClasses;// in order to support object inspectors, etc, we define two messages for indicating the// addition or deletion of objects from the debug list. Since ZObject is not a comrade, and// a central place is needed to send this info from, the application is "borrowed", so// listeners of the APP will get these.enum{	kMsgDebugObjectAdded		= 'obj+',	kMsgDebugObjectDeleted		= 'obj-',	kMsgDebugObjectFocusChanged = 'objf',	kMsgDebugObjectFieldReport	= 'obfr'};// more sophisticated inspectors can be supported using the ReportFields method. This method should// report every field in the object, after calling the inherited method. This will list the// object fields and their values for a selected object.// To make this easy, we provide a simple macro for doing the reporting, SHOWFIELD.// field types:enum{	ft_notype,	ft_boolean,	ft_signedchar,	ft_unsignedchar,	ft_signedshort,	ft_unsignedshort,	ft_signedlong,	ft_unsignedlong,	ft_fourcharcode,	ft_address,	ft_objectref,	ft_str255,	ft_cstr,	ft_Size,	ft_Rect,	ft_Point,	ft_EventRecord,	ft_CGrafPtr,	ft_RgnHandle,	ft_Handle,	ft_Ptr,	ft_FSSpec,	ft_RGBColor,	ft_FontID,	ft_FontStyle,	ft_binary8,	ft_binary16,	ft_binary32,	ft_float};typedef struct{	char*		name;	void*		field;	short		type;	char*		fieldType;	void*		theObject;}fieldReport;#if __OBJECT_DEBUGvoid		ShowField( const char* fName, void* field, const short type, char* fieldType, void* obj );#define		FSHOWFIELD( fName, field, type, fieldType )	ShowField( fName, &field, type, (char*) typeid( fieldType ).name(), this )#define		SHOWFIELD( fName, field, type )		ShowField( fName, &field, type, (char*) typeid( field ).name(), this )#define		XSHOWFIELD( field, type )			ShowField( CLITERAL( field ), &field, type, (char*) typeid( field ).name(), this )#else#define		FSHOWFIELD	#define		SHOWFIELD#define		XSHOWFIELD#endif// class for reporting globals:class	_Globals_	: public ZObject{public:	_Globals_() : ZObject() {};		virtual void	ReportFields();};#endif