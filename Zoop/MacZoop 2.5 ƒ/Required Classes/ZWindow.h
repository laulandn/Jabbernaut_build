/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZWindow.h		-- the window object******			© 1996, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZWINDOW__#define	__ZWINDOW__#include	"ZView.h"#include    "ZWindowManager.h"#include	"MTaskStack.h"#include	"ProjectSettings.h"#include	"ZChore.h"#include	<MacWindows.h>#include	<drag.h>#include	<StandardFile.h>#if _USE_NAVIGATION_SERVICES || TARGET_API_MAC_CARBON#include	<Navigation.h>extern NavEventUPP		gNavEventHandler;#endiftypedef enum{	kNoPosition,	kCentreOnParent,	kAlertPositionOnParent,	kStaggerOnParent,	kCentreOnScreen,	kAlertPositionOnScreen,	kStaggerOnScreen,	kCentreOnParentScreen,	kAlertOnParentScreen,	kStaggerOnParentScreen}WindowPlacing;class	ZFileHelper;// set up streaming stuff:DEFINECLASSID( ZWindow, 'zwin' );DEFINECLASSID( ZFileHelper, 'zfas' );// class definition:class	ZWindow : public ZView, public MTaskStack{	friend class ZWindowManager;	protected:	Rect			sizeRect;			// min and max sizes for window	short			windID;				// res ID of 'WIND' template	Boolean			isNamed;			// TRUE if window has a name other than "untitled"	Boolean			stationeryFile;		// TRUE if file opened was  stationery (template)	FSSpec			macFile;			// the file that corresponds to this window	OSType			macFType;			// file type last opened	Boolean			printable;			// TRUE if this window can be printed (default FALSE)	Boolean			isPrinting;			// TRUE if draw operation is to printer	Boolean			floating;			// TRUE if this is a floating window	Boolean			disableAutoClose;	// if TRUE, this window is skipped during Quit or Close All	Boolean			fResizeable;		// TRUE if window resizeable	Rect			zoomSource;			// global rect where window was zoomed from	SnapFlags   	windowSnap;         // snap behaviour for this windowprivate:	Boolean			dirty;				// TRUE if window needs to be saved	WindowPtr		macWindow;			// the mac window associated with this object	ZCommander*		fHandler;			// view or other object that starts the command chain for this window	ZView*			fPrintView;			// view to be printed by print command	ZFileHelper*	fFiler;				// attached file helper object (if any)	public:	ZWindow( ZCommander* aBoss, const short windowID );	ZWindow();	virtual ~ZWindow();// initialisation (MUST be called after construction)		virtual void		InitZWindow();	// drawing and clicking	virtual void		Draw();	virtual void		DrawGrow();	virtual void		Click( const Point mouse, const short modifiers);	virtual Boolean		ClickInSamePlace( const Point ptA, const Point ptB );	virtual void		SetBackColour( const RGBColor* aColour );	// top-level call to do an update	virtual void		PerformUpdate();	// window state manipulation	virtual void		Hide();	virtual void		Show();	virtual void		Select();	virtual void		Activate();	virtual void		Deactivate();	virtual Boolean		Close( const short phase );	virtual Boolean		CloseSubsidiaryWindows( const short phase );	virtual void		SendBehind( ZWindow* aWindow = NULL );		virtual void		DoWindowDrag( const Point mouse, const short modifiers );		// command handling	virtual void		HandleCommand( const ZoopCommand aCmd );	virtual void		HandleCommand( const short menuID, const short itemID ) { ZView::HandleCommand(menuID, itemID); }	virtual void		UpdateMenus();	virtual void		SetTask( ZUndoTask* aTask );	virtual void		Type( const char theKey, const short modifiers );	// sizing and zooming		virtual void		SetSizeRect( const Rect& szRect );	virtual void		GetSizeRect( Rect* szRect );	virtual void		Zoom( const short partCode );	virtual void		PlaceAt( const short hGlobal, const short vGlobal );	virtual void		Place();	virtual void		PlaceRelative( ZWindow* relWindow, WindowPlacing aPlacing );		virtual void		SetSize( const short width, const short height );	virtual void		SetStdZoomRect( const Rect& aRect );	virtual void		SetUserZoomRect( const Rect& aRect );	virtual void		GetIdealWindowZoomSize( Rect* idealSize );	virtual void		WindowResized() {};	virtual Boolean		IsResizeable() { return fResizeable; };	// file handling	virtual short		CheckForSave( const short phase );	virtual Boolean		Save( const Boolean forceSaveAs = FALSE );	virtual void		SaveFile();	virtual void		Revert();	virtual void		SetFile( const FSSpec& aFile );	virtual void		OpenFile( const OSType aFileType, Boolean isStationery = FALSE );	virtual	void		SetDirty( Boolean dState );	virtual void		OpenNew( OSType aType ) { macFType = aType; };	#if _USE_NAVIGATION_SERVICES || TARGET_API_MAC_CARBON	virtual void		PickFile( NavReplyRecord* navReply );#endif#if !TARGET_API_MAC_CARBON	virtual void		PickFile( StandardFileReply* macReply );#endif// file helpers (new)	virtual void			AttachFileHelper( ZFileHelper* aHelper );	virtual ZFileHelper*	GetFileHelper(){ return fFiler; }// print handling	virtual void		CalcPages( const Rect& paperRect, short* pagesH, short* pagesV );	virtual void		PrintOnePage( const short pageNum, const Rect& paperRect );	virtual void		PrintingStarting() { isPrinting = TRUE; };	virtual void		PrintingFinishing() { isPrinting = FALSE; };	inline	Boolean		IsPrintable() { return printable; };    void				SetPrintable( Boolean isPrintable ) { printable = isPrintable; };    virtual Boolean		IsPrinting() { return isPrinting; };	// other info	virtual void		SetTitle( Str255 aTitle );	virtual void		GetName( Str255 name );	virtual Boolean		IsVisible();	virtual void		GetDebugInfoString( Str255 s );	virtual void		ReportFields();// positioning and frame info:		virtual short		GetTitleBarHeight();	virtual void		GetStructureRegion( RgnHandle aRgn );	virtual void		GetContentRegion( RgnHandle aRgn );	virtual void		GetStructureFrameBorder( Rect* aRect );	virtual void		GetGlobalPosition( short* hGlobal, short* vGlobal );	virtual void		GetGrowBoxSize( short* width, short* height );	virtual GDHandle	GetMaxMonitor();// saving and restoring window position as resource in file or prefs:		virtual void		SavePosition( short id = 0 );	virtual void		RestorePosition( short id = 0 );// various inline getters & setters		virtual WindowPtr	GetMacWindow(){ return macWindow; };	inline	Boolean		Floats() { return floating; };	inline	Boolean		NoAutoClose() { return disableAutoClose; };	inline	void		GetFileSpec( FSSpec* aSpec ) { *aSpec = macFile; };	inline  Boolean		IsDirty() { return dirty; };	inline  OSType		GetFileType() { return macFType; };		inline  void        SetWindowZoomRectSource( Rect* zr ) { zoomSource = *zr; };	inline  void        GetWindowZoomRectSource( Rect* zr ) { *zr = zoomSource; };	// streaming:	virtual void		WriteToStream( ZStream* aStream );	virtual void		ReadFromStream( ZStream* aStream );// lowest level d+d handlers:	virtual void		DragDispatch( const DragTrackingMessage theMessage, const DragReference theDrag);	virtual void		DropHandler( const DragReference theDrag );	// help:	virtual void		ShowBalloonHelp( Rect* localRect, Point tip, HMMessageRecord* hm );	// windowsnap (see ZWindowManager.h for details of how this works):    virtual SnapFlags   GetSnap() { return windowSnap; };    virtual void        SetSnap( SnapFlags aSnap ) { windowSnap = aSnap; };// managing commander hierarchy:        virtual ZCommander*	GetHandler() { return fHandler; };    virtual void		SetHandler( ZCommander* aHandler ) { fHandler = aHandler; };    virtual void		SetPrintView( ZView* aView ) { fPrintView = aView; };    virtual void		SelectHandlingView( ZView* aView );    virtual ZView*		FindNextTabbingView( Boolean  searchBackwards );protected:// d+d installers		virtual void		InstallDragHandlers();	virtual void		RemoveDragHandlers();	// tracking handler methods		virtual void		EnteredHandler( const DragReference theDrag) {};	virtual void		LeftHandler( const DragReference theDrag) {};// constructing mac windows:		virtual void		MakeMacWindow( const short windID );	virtual void		MakeMacWindow( Rect* aRect, Str255 title, Boolean visible = FALSE, short varCode = 0, Boolean hasCloseBox = FALSE, void* userData = NULL );	virtual void		InitSizeFromResource( ResType aType );	virtual void		SetMacWindow( const WindowPtr w ) { macWindow = w; };		void				SetRootPort( CGrafPtr aPort );	static ZView*					sDropTargetView;	static DragTrackingHandlerUPP	sDragTrackProc;	static DragReceiveHandlerUPP	sDragReceiveProc;		static pascal OSErr	WindowTrackingHandler( DragTrackingMessage theMsg, WindowPtr theWindow, void* refCon, DragReference theDrag );	static pascal OSErr	WindowDropHandler( WindowPtr theWindow, void* refCon, DragReference theDrag );};// misc constants, messages:enum{	kNoFile							= -9999,	kRevertConfirmAlertID			= 135,	kSmallScrollbarWidth			= 13,	kVerySmallScrollbarWidth 		= 10,	kMsgWindowClosing				= 'winz',	kMsgRequestTemporaryFloatChain	= 'rqtf',	kMsgReleaseTemporaryFloatChain	= 'rqt-'};/* 	ZWindows manage Mac windows. The refCon of a macWindow in MacZoop is the object	reference. This class handles all types of non-dialog windows. For dialogs, use ZDialog,	which is a subclass of this. A ZWindow is really equivalent to a document, since it has	methods for reading and writing its contents to files. However, you can ignore this	facility for non-document windows. This approach simplifies the framework, since you don't	need separate classes for different types of windows.	*/// modifiers (aka "attachments" messages:enum{	kModifierWindowDraw		= 'mdrw',	kModifierWindowClick	= 'mclk',	kModifierWindowOpen		= 'mshw',	kModifierWindowClose	= 'mcls'};enum{	kInfinityWindoidDefinition	= 128};// we have a simple chore that will delete the window. This is created when the window is closed, and will delete the// window at a safe time.class	ZWindowCloseChore	: public ZChore{protected:	ZWindow*	wtc;	public:	ZWindowCloseChore( ZWindow* aWindow ) : ZChore( FALSE ) { wtc = aWindow; };		virtual void	Do() { FORGETOBJECT( wtc ); };};// structure of "WIND' resource- we need to take a peek here ourselves to determine if the// window is a floater or not#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endiftypedef struct{	Rect		bounds;	short		procID;	short		filler;	Boolean		visible;	Boolean		goAway;	long		refCon;	Str255		title;}WindTemplate, *WindTemplatePtr, **WindTemplateHdl;// for creating appearance-savvy windows, we define our own template,// since the 'wind' resource is excessively complex and difficult to// create using something like ResEdit.typedef struct{	Rect		bounds;				// window global bounds	short		wClass;				// window class	long		attribs;			// attributes flags	long		positioning;		// auto positioning info	RGBColor	backColour;			// window background colour	Str255		title;				// initial title string}MZWindowTemplate, *MZWindowTemplatePtr, **MZWindowTemplateHdl;#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif// definitions of WLIM and DLIM resources used to specify size rectsenum{	kWindowSizeLimitResType		= 'WLIM',	kDialogSizeLimitResType		= 'DLIM',	kMacZoopWindowTemplateType	= 'ZWIN',	kSpecialTooltipWindowClassID	= -1};// static proc used for handling "Dont Save" keyboard equivalent in alert:static pascal Boolean DSKeyProc( DialogPtr dlg, EventRecord* evt, short* item );enum{	kDontSaveButtonID       = 3};// ZFileHelper object can be attached to a window to help it open and save files. This can often avoid a subclass of ZWindow// which, now we have views, is much less needed than it used to beclass	ZFileHelper		: public ZComrade{public:	ZFileHelper() : ZComrade(){ classID = CLASS_ZFileHelper; }	virtual ~ZFileHelper(){}		virtual void		OpenFileForWindow( ZWindow* aWindow, const FSSpec* aFile, const OSType aFileType ){}	virtual void		SaveFileForWindow( ZWindow* aWindow, const FSSpec* aFile, const OSType aFileType ){}};#endif