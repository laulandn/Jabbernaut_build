/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			ZEventHandler.cpp		-- the event handler object******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZEventHandler.h"#include	<LowMem.h>#include	<MixedMode.h>#include	<DiskInit.h>#include	<processes.h>#include	<AppleEvents.h>// gSleep is the sleep period passed to WaitNextEventstatic short	gSleep = 0;// gCurHandler is the current ZCommander object that wants to handle commands. This will// usually be the active window or the applicationZCommander*		gCurHandler = NULL;// static UPP to AE callbackAEEventHandlerUPP	ZEventHandler::sAEUPP = NULL;/*-------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZEventHandler::ZEventHandler()	: ZComrade(){	classID = CLASS_ZEventHandler;		clicks = 0;	inBackground = FALSE;	epPPCYokeDown = 0;	fSavedHandler = NULL;		gCurHandler = gApplication;	ListenTo( gApplication );		// need to set the true state of <inBackground> by seeing if we're the front process		ProcessSerialNumber		PSN, fPSN;		gApplication->GetProcessSerialNumber( &PSN );	GetFrontProcess( &fPSN );	SameProcess( &PSN, &fPSN, &inBackground );		inBackground = !inBackground;		gSleep = gApplication->fFrontSleep;		sAEUPP = NewAEEventHandlerUPP( (AEEventHandlerProcPtr)AEHandler );}/*--------------------------***  EstablishCurrentHandler  ***---------------------------*//*access:			public	overrides:description: 	establish which object starts the application's command chainins: 			noneouts: 			nonenotes:			sets up gCurHandler----------------------------------------------------------------------------------------*/void	ZEventHandler::EstablishCurrentHandler(){	ZWindow*	zw;		if ( fSavedHandler == NULL  )		zw = gWindowManager->GetTopWindow();	else			zw = gWindowManager->GetTopFloater();		// we only dispatch Idle if the window is active.		if ( zw && zw->IsActive())		gCurHandler = zw->GetHandler();	// this method returns the handler within the window										// or the window itself.	else		gCurHandler = gApplication;}/*---------------------------------***  GetAnEvent  ***---------------------------------*//*access:			public	overrides:description: 	fetch the next event from the OS queueins: 			<theEvent> receives the event record				<mask> which events to returnnouts: 			nonenotes:			this method also dispatches the mouse poisiotn for setting the cursor,				handles idle processing and balloon help management. It is called as				required by ZApplication.----------------------------------------------------------------------------------------*/void	ZEventHandler::GetAnEvent( EventRecord* theEvent, const short mask ){	// gets an event from the event queue and sets "theEvent" to it. On the PowerPC, WNE is	// an emulated trap and performance can be enhanced by calling it much less frequently	// than once per loop. If we're running on PowerPC, we use the "epPPCYokeDown" variable	// to count our main loops. If we do not call WNE, we pretend that the event is a NULL	// event. The default is 32 loops per event.	#if GENERATINGPOWERPC	Boolean		isIdle;		// for some events, we want to immediately handle them. However, calling EventAvail	// offsets some of the advantage of doing this yokedown anyway, so we check this	// every four calls to try and keep the speed improvement as good as possible. As always	// this is a tradeoff between good responsiveness and fast execution.		if (( epPPCYokeDown % 4 ) == 0 )	{		if ( EventAvail( mDownMask + keyDownMask + updateMask, theEvent ))			epPPCYokeDown = 0;	}		if ( epPPCYokeDown <= 0 )	{		isIdle = ! WaitNextEvent( mask, theEvent, gSleep, NULL );		epPPCYokeDown = kPowerPCWNEYokeDown;	}	else	{		theEvent->what = nullEvent;		theEvent->message = 0;		theEvent->when = TickCount();				GetMouse( &theEvent->where );		LocalToGlobal( &theEvent->where );				theEvent->modifiers = GetModifiers();				// decrement loop counter				isIdle = TRUE;		epPPCYokeDown--;	}		if ( isIdle )		PassIdle();#else	if (! WaitNextEvent( mask, theEvent, gSleep, NULL ))		PassIdle();#endif		// if main screen has changed depth, send a message to tell any interested party	// about it. This is simply a useful service you can tap into, handy in particular	// for games and optimising graphics.		short	sd = GetMainScreenDepth();		if ( sd != gApplication->msDepth )	{		gApplication->msDepth = sd;		gApplication->SendMessage( msgMainScreenDepthChanged, &sd );	}	gApplication->HandleMBarHiding( theEvent->where );			// dispatch the cursor to the current window, so its shape can be set.		if ( !inBackground )	{		// if control key down, show contextual menu cursor and do NOT dispatch to window				if ( gMacInfo.hasContextualMenus && ( theEvent->modifiers & controlKey ) == controlKey )			SetCursorShape( CONTEXT_MENU_CURSOR );		else		{			ZWindow*	aZW = gWindowManager->LocateWindow( theEvent->where );						if ( aZW )			{				WindowPtr   w = aZW->GetMacWindow();				RgnHandle   wContentRgn;							// check to see that the window is not "windowshaded"- if				// it is, don't dispatch the cursor. If the window is shaded,				// its contRgn will be empty.								wContentRgn = NewRgn();				GetWindowContentRgn( w, wContentRgn );								if ( ! EmptyRgn( wContentRgn ))				{					Point		mouse;					GrafPtr		savePort;										mouse = theEvent->where;										GetPort( &savePort );					aZW->Focus();					GlobalToLocal( &mouse );					SetPort( savePort );										// handle balloon help for the window. We only need to consider the frontmost					// window or floaters since the system displays balloons for other windows										if ( aZW->Floats() ||						 aZW == gApplication->GetFrontWindow())						DoBalloons( aZW, theEvent->where );					// if the point is inside the window, dispatch to the window,					// otherwise reset the cursor to an arrow. If the window is not the top					// window, the cursor is not dispatched, but reset, unless the window is					// a floater, in which case we do dispatch it if there not a modal dialog					// in front of it. The result is correct for what the user expects.										if 	( PtInRect( mouse, WINDOWPORTRECT( w )) &&						( aZW == gApplication->GetFrontWindow() ||						( aZW->Floats() && ! gWindowManager->IsDialog( gApplication->GetFrontWindow()))))						aZW->AdjustCursor( mouse, theEvent->modifiers );					else						gApplication->MouseNotInAnyWindow( theEvent->where );				}				else					gApplication->MouseNotInAnyWindow( theEvent->where );			    			    DisposeRgn( wContentRgn );			}			else				gApplication->MouseNotInAnyWindow( theEvent->where );		}	}}/*------------------------------***  DispatchAnEvent  ***-------------------------------*//*access:			public	overrides:description: 	dispatch an event to the place it needs to goins: 			<theEvent> the event to processouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::DispatchAnEvent( EventRecord* theEvent ){	// dispatches the event according to its type, etc		Boolean		isAutoKey = FALSE;	char 		theKey;		FailNILParam( theEvent );	lastEvent = *theEvent;				// set up gCurHandler		EstablishCurrentHandler();	// dispatch the event to the handler		switch ( theEvent->what )	{		case mouseDown:			HandleMouseEvent( *theEvent );			break;				case activateEvt:						// following defined in Project Settings.h						#if _ACTIVATE_EVENTS_ARE_REAL || TARGET_API_MAC_CARBON			HandleWindowActivate(	(WindowPtr) theEvent->message,									(theEvent->modifiers & activeFlag) );			#endif			break;				case autoKey:			isAutoKey = TRUE;				case keyDown:			theKey = theEvent->message & charCodeMask;						if ( theKey == ANY_FUNCTION_KEY )			{			    UInt8   keyCode = (( theEvent->message & keyCodeMask ) >> 8 );			    			    gApplication->ProcessFunctionKey( keyCode );			}			else    			HandleKeyEvent( theKey, isAutoKey, theEvent );			break;				case updateEvt:			HandleWindowUpdate((WindowPtr) theEvent->message );			break;#if !TARGET_API_MAC_CARBON				case diskEvt:		{			Point dPt = {100,100};						if( HiWord( theEvent->message ) != 0)				DIBadMount( dPt, theEvent->message );			break;		}#endif				case kHighLevelEvent:			gApplication->ProcessHLEvent( *theEvent );			break;				case osEvt:			HandleOSEvent( *theEvent );			break;	}}/*-------------------------------***  HandleKeyEvent  ***-------------------------------*//*access:			protected	overrides:description: 	dispatch keyboard eventins: 			<theKey> character to dispatch				<isAutoKey> TRUE if character generated by auto key event				<theEvent> the event recordouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::HandleKeyEvent( const char theKey, const Boolean isAutoKey, EventRecord* theEvent ){	long 	mSelect;	short	modifiers = theEvent->modifiers;	#if __TOOLTIPS	if ( gTooltips )		gTooltips->HideTooltip();#endif	if ( modifiers & cmdKey )	{		// if this is a command-key combination, translate this to a		// menu command as if it were picked from the menu.				char k = theKey;				if ( modifiers & optionKey )		{			// to allow command-option menu items, translate to fundamental letter						switch( k )			{				case '·':					k = 'w';					break;									default:					break;			}		}				if (! isAutoKey)		{			gMenuBar->DimMenus();						// ask the command chain to reenable the relevant menu items						if ( gCurHandler )			{				if ( gCurHandler->ExecuteModifiers( kModifierUpdateMenus, NULL ))					gCurHandler->UpdateMenus();			}							// check for a keyboard shortcut. If there is one, dispatch it,			// otherwise pass the key to the command chain for processing				#if APPEARANCE_MGR_AWARE					if ( gMacInfo.hasAppearanceMgr )				mSelect = MenuEvent( theEvent );			else		#endif				mSelect = MenuKey( k );						if ( HiWord( mSelect ) != 0 )			{				gMenuBar->DispatchCommand( mSelect, modifiers );				return;			}		}	}		// add in autokey flag to modifiers, for the benefit of Type() methods...		if ( isAutoKey )		modifiers |= kFromAutoKeyEvent;	// the user is typing- send the characters to the current commander		if ( gCurHandler )	{		long	kk;				kk = ((long) theKey << 16 ) | modifiers;				if ( gCurHandler->ExecuteModifiers( kModifierKeyDown, &kk ))			gCurHandler->Type( kk >> 16, kk & 0xFFFF );	}}/*---------------------------------***  CountClicks  ***--------------------------------*//*access:			protected	overrides:description: 	detect double, triple and more clicksins: 			<target> target window of mouse down event				<clickTicks> time that click occurred				<globalMouse> click location (global)outs: 			nonenotes:			sets value of clicks member, obtained using GetClicks(). This queries				th etarget to ensure that the clicks occurred in the "same place"				logically so that rapid clicks are correctly detected as doubles, etc----------------------------------------------------------------------------------------*/void	ZEventHandler::CountClicks( const WindowPtr target, const long clickTicks, const Point globalMouse ){	static	WindowPtr 	prevTarget = NULL;	static	long		lastClickTicks = 0;	static	Point		lastClick = {0,0};		GrafPtr	savePort;	Point	gMouse;		gMouse = globalMouse;		GetPort( &savePort );	SetPortWindowPort( target );	GlobalToLocal( &gMouse );		if (target == prevTarget)	{		// the target window is the same as the last click, is the click		// within the double-click period set by the user?				if ( clickTicks < lastClickTicks + GetDblTime())		{			// yes, the click is in time. Finally, we ask the window			// whether we should consider the click as being in the same place.							ZWindow*	zW = GETZWINDOW( target );						if ( zW && zW->ClickInSamePlace( lastClick, gMouse ))				clicks++;			else				clicks = 1;		}		else			clicks = 1;	}	else		clicks = 1;		// store the click point, target and click time for the next time				lastClick = gMouse;	prevTarget = target;	lastClickTicks = clickTicks;	SetPort( savePort );}/*-------------------------------***  HandleMouseEvent  ***-----------------------------*//*access:			protected	overrides:description: 	dispatch mouse down to target window or otherwise handleins: 			<theEvent> event record to processouts: 			nonenotes:			implements basic window handling behaviour----------------------------------------------------------------------------------------*/void	ZEventHandler::HandleMouseEvent( const EventRecord& theEvent ){	WindowPtr		targetWindow;	short			partCode;	long			mSelect;	Point			mousePt;	ZWindow*		zappWindow;		// any click cancels a tooltip:	#if __TOOLTIPS	if ( gTooltips )		gTooltips->HideTooltip();#endif		// find out what part of the screen the mouse was clicked on		partCode = MacFindWindow( theEvent.where, &targetWindow );		// if it was any sort of window, get the ZWindow object associated with it, if any.		if ( targetWindow )		zappWindow = GETZWINDOW( targetWindow );		switch (partCode)	{			case inDesk:			SysBeep( 1 );			break;				case inMenuBar:			// the user clicked the menubar.			gMenuBar->ClickMenuBar( theEvent.where );			break;#if !TARGET_API_MAC_CARBON				case inSysWindow:			SystemClick( &theEvent, targetWindow );	// system will handle it (DA window)			break;#endif				case inContent:			if ( targetWindow )						// the user clicked in a window			{				// if control key down, do a contextual menu pop-up instead								if ( theEvent.modifiers & controlKey )				{					zappWindow->ContextualMenuClick( theEvent.where );				}				else				{					// if there's a modal dialog up, clicks in other windows result in a beep.										Boolean		dialogUp = gWindowManager->IsModalDialogActive();										CountClicks( targetWindow, theEvent.when, theEvent.where );	// double click?										// if the window is top window or top floater, pass the click to the window.										if( zappWindow &&						(zappWindow == gApplication->GetFrontWindow() ||						(zappWindow == gWindowManager->GetTopFloater() && ! dialogUp )))					{						if ( ! zappWindow->Floats())							ClearTemporaryFloatChain();												// if the window is already active, pass the click to the window object						// in its local coordinate system.												mousePt = theEvent.where;												zappWindow->Focus();						GlobalToLocal( &mousePt );						zappWindow->Click( mousePt, theEvent.modifiers );						}					else					{						// if the window wasn't active, make it active. If there is a modal dialog in						// front, then this action is not permitted.												if ( dialogUp )						{							SysBeep( 1 );							break;						}						// otherwise, process the click							if ( zappWindow )						{							// make this window the active one														zappWindow->Select();														// if the window is a floater, ask it to process the click as well- 							// floaters process "front" clicks even when they were not initially							// active, since floaters are all 'peers' of one another.													if ( zappWindow->Floats())							{								ClearTemporaryFloatChain();																mousePt = theEvent.where;																zappWindow->Focus();								GlobalToLocal( &mousePt );								zappWindow->Click( mousePt, theEvent.modifiers );							}						}					}				}			}			break;#if USE_PROXY_ICONS					case inProxyIcon:			if ( gMacInfo.hasModernWindowMgr )			{				OSStatus	err;				EventRecord	er = theEvent;								if ( ! IsWindowPathSelectClick( targetWindow, &er ))				{					err = TrackWindowProxyDrag( targetWindow, theEvent.where );								if ( err == noErr )						break;				}			}#endif				case inDrag:		{			// the user wants to drag the window. Only permit this if no			// modal dialog is in front of it, or the command key is down.						ZWindow*	zw = GETZWINDOW( targetWindow );						if ( gWindowManager->IsModalDialogActive() &&				 (gWindowManager->GetTopWindow() != zw ) &&				 ! ( theEvent.modifiers & cmdKey ))			{				SysBeep( 1 );				break;			}			zw->DoWindowDrag( theEvent.where, theEvent.modifiers );			break;		}				case inGrow:		{			// the user wants to resize the window						Rect szRect;						if ( zappWindow )			{				zappWindow->GetSizeRect( &szRect );								szRect.right++;				szRect.bottom++;								mSelect = GrowWindow( targetWindow, theEvent.where, &szRect );							if ( mSelect )				{					// if the command key was down, then we are attempting to override the					// current settings for sizerect. Thus we need to change the size rect					// to the desired size first:										if ( theEvent.modifiers & cmdKey )					{						szRect.right = MAX( LoWord( mSelect ), szRect.right - 1 );						szRect.bottom = MAX( HiWord( mSelect ), szRect.bottom - 1 );												zappWindow->SetSizeRect( szRect );					}										zappWindow->SetSize( LoWord( mSelect ), HiWord( mSelect ));				}			}			break;		}				case inGoAway:			if ( TrackGoAway( targetWindow, theEvent.where ))			{				// if the user clicks in the go-away box, the window will be closed. If the				// option key is down, we close all of the windows.								ClearTemporaryFloatChain();				if ( theEvent.modifiers & optionKey )					gApplication->CloseAll( zappWindow->Floats());				else				{					if ( zappWindow )						zappWindow->Close( gApplication->GetPhase());				}			}			break;				case inZoomIn:		case inZoomOut:			if( TrackBox( targetWindow, theEvent.where, partCode ))			{				// if the user clicked in the zoom box, the window will be zoomed								if( zappWindow )					zappWindow->Zoom( partCode );			}			break;	}}/*-----------------------------***  HandleWindowUpdate  ***-----------------------------*//*access:			public	overrides:description: 	process an update eventins: 			<theWindow> window to updateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::HandleWindowUpdate( const WindowPtr theWindow ){	ZWindow*		zappWindow = NULL;	Boolean			memState;		if ( theWindow )		zappWindow = GETZWINDOW( theWindow );		memState = gApplication->MemoryCrisis();		if ( zappWindow )		zappWindow->PerformUpdate();			// if the draw resulted in a memory shortage, suppress the warning, since	// that will trigger further updates, etc.			if ( gApplication->MemoryCrisis() != memState )		gApplication->userHasSeenAlert = TRUE;}/*----------------------------------***  PassIdle  ***----------------------------------*//*access:			protected	overrides:description: 	pass idle calls up the command chain and to floatersins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::PassIdle(){	// called repeatedly for null events. This passes idle messages to the current commander		EstablishCurrentHandler();	if ( gCurHandler )		gCurHandler->Idle();			// floaters may want idle time too, though they are not part of the command chain. We	// ask the window manager to give them time:		gWindowManager->FloatIdle();}/*----------------------------***  HandleWindowActivate  ***----------------------------*//*access:			public	overrides:description: 	activate and deactivate windows in response to eventsins: 			<theWindow> the window to be activated or deactivated				<state> TRUE to activate, FALSE to deactivateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::HandleWindowActivate( const WindowPtr theWindow, const Boolean state ){	// handles the activate and deactivate events.	ZWindow*		zw = NULL;		ClearTemporaryFloatChain();			if ( theWindow )		zw = GETZWINDOW( theWindow );		if ( zw )	{		zw->Focus();		if ( state )			zw->Activate();		else			zw->Deactivate();	}}/*-------------------------------***  ReceiveMessage  ***-------------------------------*//*access:			public	overrides:description: 	handle messages - specifically those to do with temp float chainins: 			outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	switch( msg )	{		case kMsgRequestTemporaryFloatChain:			SetTemporaryFloatChain((ZCommander*) msgData );			break;					case kMsgReleaseTemporaryFloatChain:			ClearTemporaryFloatChain();			break;	}}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			public	overrides:description: 	report data members to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::ReportFields(){	ZComrade::ReportFields();	XSHOWFIELD( clicks, ft_signedshort );	XSHOWFIELD( lastEvent, ft_EventRecord );	XSHOWFIELD( inBackground, ft_boolean );	XSHOWFIELD( epPPCYokeDown, ft_signedchar );}/*-------------------------------***  HandleOSEvent  ***--------------------------------*//*access:			protected	overrides:description: 	process an OS eventins: 			<theEvent> event to processouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::HandleOSEvent( const EventRecord& theEvent ){	if ((( theEvent.message & 0xFF000000 ) >> 24 ) == suspendResumeMessage )	{		if ( theEvent.message & resumeFlag )		{			inBackground = FALSE;			gSleep = gApplication->fFrontSleep;						if ( theEvent.message & convertClipboardFlag )					gClipboard->ConvertToPrivate();							gCurHandler->DoResume();							ResumeCursorAnimation();		}		else		{			inBackground = TRUE;			gSleep = gApplication->fBackSleep;			gMenuBar->ShowHideMenuBar( MBAR_SHOW );			gClipboard->ConvertFromPrivate();						gCurHandler->DoSuspend();						PauseCursorAnimation( 0 );		}				SetCursorShape( ARROW_CURSOR );		}}/*-------------------------***  InstallApplescriptHandlers  ***-------------------------*//*access:			public	overrides:description: 	install the apple event handlers you requireins: 			noneouts: 			nonenotes:			default method installs the required events only----------------------------------------------------------------------------------------*/void	ZEventHandler::InstallApplescriptHandlers(){	InstallAppleEventHandler( kCoreEventClass, kAEOpenApplication );	InstallAppleEventHandler( kCoreEventClass, kAEOpenDocuments );	InstallAppleEventHandler( kCoreEventClass, kAEPrintDocuments );	InstallAppleEventHandler( kCoreEventClass, kAEQuitApplication );		// MacOS 8 has a new core apple event for reopening the application...		if ( gMacInfo.systemVersion >= 0x0800 )		InstallAppleEventHandler( kCoreEventClass, kAEReopenApplication );}/*--------------------------***  InstallAppleEventHandler  ***--------------------------*//*access:			public	overrides:description: 	install a handler for a specific apple eventins: 			<pClass> the event class to handle				<pID> the event ID within the classouts: 			nonenotes:			all apple events are handled through the same callback, so this can be				used to register any you're interested in.----------------------------------------------------------------------------------------*/void	ZEventHandler::InstallAppleEventHandler( const AEEventClass pClass, const AEEventID pID ){	// installs the AppleEvent hook for the given apple event		if ( gMacInfo.hasAppleEvents )		FailOSErr( AEInstallEventHandler( pClass, pID, sAEUPP, (long) gApplication, FALSE ));}/*---------------------------------***  DoBalloons  ***---------------------------------*//*access:			protected	overrides:description: 	display help balloonsins: 			<aWindow> window object				<globMouse> global mouse positionouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::DoBalloons( ZWindow* aWindow, const Point globMouse ){#if TARGET_API_MAC_CARBON	// balloons are superseded under Carbon by MacHelp. TO DO	#else	HMMessageRecord		hm;	Rect				br;	Point				tip, lm;		if ( ! HMIsBalloon() && HMGetBalloons())	{		lm = globMouse;				aWindow->Focus();		GlobalToLocal( &lm );		if ( aWindow->GetBalloonHelp( lm, &br, &tip, &hm ))		{			if ( PtInRect( lm, &br ))				aWindow->ShowBalloonHelp( &br, tip, &hm );		}		else			HMRemoveBalloon();	}#endif}/*---------------------------***  SetTemporaryFloatChain  ***---------------------------*//*access:			protected	overrides:description: 	set up temporary command chain for a floaterins: 			<toThis> object within floater requesting the switchouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::SetTemporaryFloatChain( ZCommander* toThis ){	FailNILParam( toThis );		if ( fSavedHandler == NULL )	{		fSavedHandler = gCurHandler;		gCurHandler = toThis;		fSavedHandler->BecomeHandler( FALSE );		gCurHandler->BecomeHandler( TRUE );	}}/*---------------------------***  ClearTemporaryFloatChain  ***-------------------------*//*access:			protected	overrides:description: 	reset any temporary command chain for a floaterins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZEventHandler::ClearTemporaryFloatChain(){	if ( fSavedHandler )	{		ZCommander*	temp = gCurHandler;		gCurHandler = fSavedHandler;		fSavedHandler->BecomeHandler( TRUE );		temp->BecomeHandler( FALSE );		fSavedHandler = NULL;				// if the floating handler was a view, persuade its window		// to reset the handler. This is a bit of a hack, but it		// keeps complex code out of ZWindow				ZView*	tv = dynamic_cast<ZView*>( temp );				if ( tv )			tv->GetRootWindow()->SetHandler( tv->GetRootWindow());	}}#pragma mark -/*----------------------------------***  AEHandler  ***---------------------------------*//*access:			static protected	overrides:description: 	handle apple event callbackins: 			<aeEvt> the event				<reply> pointer to reply record				<refCon> reference valueouts: 			nonenotes:			----------------------------------------------------------------------------------------*/pascal OSErr	ZEventHandler::AEHandler( const AppleEvent* aeEvt, AppleEvent* reply, long refCon ){	// this is the global vector proc that is called for every apple event. This determines the	// event class and ID, then sends that info, plus the event, up the command chain, where,	// presumably, it will be handled.	AEEventClass	pClass;	AEEventID		pID;	DescType		returnedType;	long			returnedSize;	OSErr			theErr = noErr;		try	{		// determine the AE class and ID (this is laborious, so it's done here once and passed on)			FailOSErr( AEGetAttributePtr( 	aeEvt, keyEventClassAttr,								 		typeType, &returnedType,								 		&pClass, sizeof( AEEventClass ), &returnedSize ));		FailOSErr( AEGetAttributePtr( 	aeEvt, keyEventIDAttr,								 		typeType, &returnedType,								 		&pID, sizeof( AEEventID ), &returnedSize ));		if ( gCurHandler )		{			gCurHandler->HandleAppleEvent( pClass, pID, aeEvt, reply );			theErr = noErr;		}		else			theErr = errAEEventNotHandled;	}	catch( ZoopError err )	{		theErr = err;	}		return theErr;}			