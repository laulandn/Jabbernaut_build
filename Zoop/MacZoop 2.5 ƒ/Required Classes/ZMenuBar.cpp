/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZMenuBar.cpp		-- the menubar manager object******			© 1996, Graham Cox*****************************************************************************************************/#include	"MacZoop.h"#include	"ZCommander.h"#include	<LowMem.h>#include    <menus.h>#ifndef __BALLOONS__#include	<balloons.h>#endifextern	ZCommander*		gCurHandler;short		gFontMenuID = 0;/*--------------------------------***  DESTRUCTOR  ***---------------------------------*/ZMenuBar::~ZMenuBar(){	// menubar must be visible when we quit		if ( mbHiding == MBAR_HIDE )		ShowHideMenuBar( MBAR_SHOW );		if ( theMenuCmds )		FORGETOBJECT( theMenuCmds );			if ( theMenus )		FORGETOBJECT( theMenus );	ReleaseResource((Handle) mBarH );}	/*-------------------------------***  InitMenuBar  ***----------------------------------*//*access:			public	overrides:description: 	initialise the menusins: 			noneouts: 			nonenotes:			must be called after creating ZMenuBar object to actually load menus----------------------------------------------------------------------------------------*/void		ZMenuBar::InitMenuBar(){	// create an array for holding our command info		FailNIL( theMenuCmds = new ZArray( sizeof( MenuCmd )));	FailNIL( theMenus = new ZArray( sizeof( MenuInfRec )));		mbCount = 0;	miSeed = 1;	wmMenuID = 0;	rbPending = FALSE;	inDispatch = FALSE;		// initially menubar is visible		mBarHeight = GetMBarHeight();	mbHiding = MBAR_SHOW;		// load the MBAR resource		mBarH = (short**) GetResource( 'MBAR', mBarID );	FailOSErr( ResError());		HNoPurge((Handle) mBarH );		// read in menus from the MBAR resource		LoadMenus();		HPurge((Handle) mBarH );		// add the standard items (DA's) to the Apple menu (non-Carbon only)	#if !TARGET_API_MAC_CARBON		AppendStdItems( kAppleMenuID );	#endif		menuCheckChar = checkMark;		// note how many items are in the help menu so we can correctly	// identify any items we have added#if TARGET_API_MAC_CARBON	mHelpOffset = 0;#else		MenuHandle	helpMenuH;		FailOSErr( HMGetHelpMenuHandle( &helpMenuH )); 	mHelpOffset = COUNTMENUITEMS( helpMenuH );#endif	ReleaseResource((Handle) mBarH );}	/*------------------------------***  ClickMenuBar  ***----------------------------------*//*access:			public	overrides:description: 	process a click in the menu barins: 			<mousePt> mouse point in coordinates local to barouts: 			nonenotes:			keeps control until menu item chosen & command completes----------------------------------------------------------------------------------------*/void		ZMenuBar::ClickMenuBar( const Point mousePt ){	long		mSelect;		PrepareMenusForDisplay();		// now track and select the menus		mSelect = TrackMenuBar( mousePt );		// dispatch the command		DispatchCommand( mSelect );	}	/*-------------------------***  PrepareMenusForDisplay  ***-----------------------------*//*access:			public	overrides:description: 	set up menu item states ready for displayins: 			noneouts: 			nonenotes:			calls up command chain UpdateMenus()----------------------------------------------------------------------------------------*/void		ZMenuBar::PrepareMenusForDisplay(){	// initially disable all menu items		DimMenus();		// ask the command chain to reenable the relevant menu items	if ( gCurHandler )	{		if ( gCurHandler->ExecuteModifiers( kModifierUpdateMenus, NULL ))			gCurHandler->UpdateMenus();	}		SendMessage( kMsgMBarAboutToShowMenu, NULL );}/*-------------------------------***  TrackMenuBar  ***---------------------------------*//*access:			public	overrides:description: 	handle actual selection of menu itemsins: 			<mouse> local mouse pointouts: 			nonenotes:			default just calls toolbox MenuSelect----------------------------------------------------------------------------------------*/long		ZMenuBar::TrackMenuBar( const Point mouse )	{	PauseCursorAnimation( 0 );	return MenuSelect( mouse );}/*------------------------------***  UpdateMenuBar  ***---------------------------------*//*access:			public	overrides:description: 	update the menubar after changing titles, etcins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::UpdateMenuBar(){	if ( inDispatch || rbPending )		rbPending = TRUE;	else		DrawMenuBar();}/*-----------------------------***  DispatchCommand  ***--------------------------------*//*access:			public	overrides:description: 	look up and dispatch command based on menu selection chosenins: 			<mSelect> raw menu selection result				<modifiers> state of modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZMenuBar::DispatchCommand( const long mSelect, const short modifiers ){	MenuCmd		mCmd;	long        flashTime;		// if an item was chosen, look up the command and send it up the chain		mCmd.theCmd = noCommand;		// if the itemID indicates a torn-off menu, process that seperately	// by locating the tear-off drop point and asking the application to create it for us	if ( HiWord( mSelect) != 0 && gCurHandler )	{		// set the zoom source rect in case the command spawns a window	#if _ZOOM_RECT_FX				Rect	r;				GetMenuTitleRect( HiWord( mSelect ), &r );		InsetRect( &r, 20, 4 );		SetGlobalZoomSource( &r );	#endif				flashTime = TickCount();				// if the nominated windows menu, handle the window selection				if ( HiWord( mSelect ) == wmMenuID )			gWindowManager->SelectWindowFromMenu( LoWord( mSelect ));			FindMCmd( mSelect, &mCmd );				if ( mCmd.theCmd != parentCmd )		{			// if the command was found, pass it up the chain. If not found, we still pass it			// up the chain, but this time as the direct menuID and itemID chosen. Commander			// classes can choose which of the two methods (or perhaps both?) to adopt.						inDispatch = TRUE;			ZoopCommand	cmd;						if ( modifiers & optionKey )				cmd = mCmd.altCommand;			else			{				if ( modifiers & shiftKey )					cmd = mCmd.shiftCommand;				else					cmd = mCmd.theCmd;			}						if ( mCmd.theCmd != noCommand )			{				if ( gCurHandler->ExecuteModifiers( kModifierHandleCommand, &cmd ))					gCurHandler->HandleCommand( cmd );			}			else			{				long mcmd = mSelect;								if ( gCurHandler->ExecuteModifiers( kModifierHandleCmd2, &mcmd ))					gCurHandler->HandleCommand( HiWord( mcmd ), LoWord( mcmd ));				}				inDispatch = FALSE;				}                // hold the menu hilite for a few ticks:                flashTime = TickCount() - flashTime;                if ( flashTime < kMenuHiliteDelay )            MZDelay( kMenuHiliteDelay - flashTime );                // ...and then turn it off           		SetTitleHilite( 0, FALSE );				if ( rbPending )		{			rbPending = FALSE;			UpdateMenuBar();		}	}}	/*------------------------------***  EnableCommand  ***---------------------------------*//*access:			public	overrides:description: 	enable a menu commandins: 			<cmd> command to enableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::EnableCommand( const ZoopCommand cmd ){	short	m = 0, i = 0;		FindCommand( cmd, &m, &i );		if ( m && i )		EnableCommand( m, i );}	/*------------------------------***  EnableCommand  ***---------------------------------*//*access:			public	overrides:description: 	enable a menu commandins: 			<menuID, itemID> menu and item ID of item to enableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::EnableCommand( const short menuID, const short itemID ){	MenuHandle	mH = FindMenuID( menuID );		if ( mH )	{		ENABLEMENUITEM( mH, itemID );				if ( itemID == 0 )			UpdateMenuBar();	}}	/*------------------------------***  DisableCommand  ***--------------------------------*//*access:			public	overrides:description: 	disable a menu commandins: 			<cmd> command to disableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::DisableCommand( const ZoopCommand cmd ){	short	m = 0, i = 0;		FindCommand( cmd, &m, &i );		if ( m && i )		DisableCommand( m, i );}	/*------------------------------***  DisableCommand  ***--------------------------------*//*access:			public	overrides:description: 	disable a menu commandins: 			<menuID, itemID> menu and item ID of item to disableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::DisableCommand( const short menuID, const short itemID ){	MenuHandle	mH = FindMenuID( menuID );		if ( mH )	{		DISABLEMENUITEM( mH, itemID );				if ( itemID == 0 )			UpdateMenuBar();	}}/*-------------------------------***  CheckCommand  ***---------------------------------*//*access:			public	overrides:description: 	set a checkmark next to a commandins: 			<cmd> command to check or uncheck				<checkOnOff> TRUE to check, FALSE to uncheckouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::CheckCommand( const ZoopCommand cmd, const Boolean checkOnOff ){	short	m = 0, i = 0;		FindCommand( cmd, &m, &i );		if ( m && i )		CheckCommand( m, i, checkOnOff );}/*-------------------------------***  CheckCommand  ***---------------------------------*//*access:			public	overrides:description: 	set a checkmark next to a commandins: 			<menuID, itemID> menu and item ID of item to check				<checkOnOff> TRUE to check, FALSE to uncheckouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::CheckCommand( const short menuID, const short itemID, const Boolean checkOnOff ){	MenuHandle	mH = FindMenuID( menuID );		if ( mH )		SetItemMark( mH, itemID, checkOnOff? menuCheckChar : noMark );}/*-------------------------------***  CheckCommand  ***---------------------------------*//*access:			public	overrides:description: 	set a checkmark next to a commandins: 			<menuID> menu ID of menu				<itemString> th etext of the menu item				<checkOnOff> TRUE to check, FALSE to uncheckouts: 			nonenotes:			this version of CheckCommand is usually used with Fonts, etc----------------------------------------------------------------------------------------*/void		ZMenuBar::CheckCommand( const short menuID, Str255 itemString, const Boolean checkOnOff ){	// check the item with the text matching that passed (not case sensitive)		MenuHandle	mH = FindMenuID( menuID );	Str255		iMatch;		if ( mH )	{		short	m = CountMenuItems( mH );			do		{			GetMenuItemText( mH, m, iMatch );						if ( EqualString( itemString, iMatch, FALSE, TRUE ))			{				SetItemMark( mH, m, checkOnOff? menuCheckChar : noMark );				break;			}		}		while( --m );	}}/*---------------------------***  CheckCommandWithChar  ***-----------------------------*//*access:			public	overrides:description: 	set a check character next to a commandins: 			<cmd> command ID to check				<checkChar> character to place next to commandouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::CheckCommandWithChar( const ZoopCommand cmd, const char checkChar ){	short	m = 0, i = 0;		FindCommand( cmd, &m, &i );		if ( m && i )	{		MenuHandle	mH = FindMenuID( m );				if ( mH )			SetItemMark( mH, i, checkChar );	}}/*---------------------------***  CheckCommandWithChar  ***-----------------------------*//*access:			public	overrides:description: 	set a check character next to a commandins: 			<menuID> menu iD to check				<itemString> text of menu item				<checkChar> character to place next to itemouts: 			nonenotes:			usually used with Font menu----------------------------------------------------------------------------------------*/void		ZMenuBar::CheckCommandWithChar( const short menuID, Str255 itemString, const char checkChar ){	MenuHandle	mH = FindMenuID( menuID );	Str255		iMatch;		if ( mH )	{		short	m = CountMenuItems( mH );			do		{			GetMenuItemText( mH, m, iMatch );						if ( EqualString( itemString, iMatch, FALSE, TRUE ))			{				SetItemMark( mH, m, checkChar );				break;			}		}		while( --m );	}}/*------------------------------***  SetCommandText  ***--------------------------------*//*access:			public	overrides:description: 	set the text of a menu commandins: 			<cmd> command to set thetext of				<aText> the textouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetCommandText( const ZoopCommand cmd, Str255 aText ){	short	m = 0, i = 0;		FindCommand( cmd, &m, &i );		if ( m && i )		SetCommandText( m, i, aText );}/*------------------------------***  SetCommandText  ***--------------------------------*//*access:			public	overrides:description: 	set the text of a menu commandins: 			<menuID, itemID> menu and item to set the text of				<aText> the textouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetCommandText( const short menuID, const short itemID, Str255 aText ){	MenuHandle	mH;		mH = FindMenuID( menuID );		if ( mH )		SetMenuItemText( mH, itemID, aText );}/*------------------------------***  SetCommandText  ***--------------------------------*//*access:			public	overrides:description: 	set the text of a menu commandins: 			<cmd> menu command to set the text of				<strListID> resource ID of a STR# resource				<strIndex> index of the string in the resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetCommandText( const ZoopCommand cmd, const short strListID, const short strIndex ){	Str255	aText;		GetIndString( aText, strListID, strIndex );	if ( aText[0] > 0 )		SetCommandText( cmd, aText );}/*------------------------------***  SetCommandText  ***--------------------------------*//*access:			public	overrides:description: 	set the text of a menu commandins: 			<menuID, itemID> menu and item to set the text of				<strListID> resource ID of a STR# resource				<strIndex> index of the string in the resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetCommandText( const short menuID, const short itemID, const short strListID, const short strIndex ){	Str255	aText;		GetIndString( aText, strListID, strIndex );	if ( aText[0] > 0 )		SetCommandText( menuID, itemID, aText );}/*----------------------------***  SetCommandTextStyle  ***-----------------------------*//*access:			public	overrides:description: 	set the style of a menu commandins: 			<cmd> command to set				<aStyle> font style for the menu itemouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetCommandTextStyle( const ZoopCommand cmd, Style aStyle ){	short		m = 0, i = 0;	MenuHandle	mh;		FindCommand( cmd, &m, &i );		if ( m && i )	{		mh = FindMenuID( m );				if ( mh )			SetItemStyle( mh, i, aStyle );	}}/*------------------------------***  ShowHideMenuBar  ***-------------------------------*//*access:			public	overrides:description: 	show and hide the menubarins: 			<mHiding> show, hide, or depend on the mouse location				<gMouseLoc> mouse position, if it mattersouts: 			nonenotes:			Values you can pass in mHiding:				MBAR_SHOW	- show the menubar if hidden				MBAR_HIDE	- hide the menubar if visible				MBAR_HIDE_MOUSEAWARE	- hide the menubar if mouse not in bar area----------------------------------------------------------------------------------------*/void		ZMenuBar::ShowHideMenuBar( MBarHiding	mHiding, Point gMouseLoc ){	Boolean		showIt;	Rect		msRect;	GDHandle	theDevice;		if ( mHiding != mbHiding )	{		// state has changed, or we want to determine it from mouse position			theDevice = GetMainDevice();		msRect = (*theDevice)->gdRect;		msRect.bottom = msRect.top + mBarHeight;					if ( mHiding == MBAR_HIDE_MOUSEAWARE )		{			showIt = PtInRect( gMouseLoc, &msRect );						// if menubar already in indicated state, do nothing						if (( showIt  && ( mbHiding == MBAR_SHOW )) ||				( !showIt && ( mbHiding == MBAR_HIDE )))				return;		}		else			showIt = ( mHiding == MBAR_SHOW );		#if TARGET_API_MAC_CARBON		if ( showIt )		{			ShowMenuBar();			mbHiding = MBAR_SHOW;		}		else		{			HideMenuBar();			mbHiding = MBAR_HIDE;		}		#else			RgnHandle	temp;				FailNIL( temp = NewRgn());		RectRgn( temp, &msRect );		if ( showIt )		{			LMSetMBarHeight( mBarHeight );			DiffRgn(LMGetGrayRgn(), temp, LMGetGrayRgn());			UpdateMenuBar();						mbHiding = MBAR_SHOW;		}		else		{			LMSetMBarHeight( 0 );			UnionRgn(LMGetGrayRgn(), temp, LMGetGrayRgn());						mbHiding = MBAR_HIDE;		}				// calculate and refresh vis regions of windows				WindowPtr	fw = FrontWindow();				if ( fw )		{			PaintBehind( fw, temp );			CalcVisBehind( fw,  temp );		}		DisposeRgn( temp );	#endif	}}/*-------------------------------***  SHOWHIDEMENUBAR  ***-----------------------------*/void	ZMenuBar::ShowHideMenuBar( MBarHiding mHiding ){	Point unused = { 0, 0 };		ShowHideMenuBar( mHiding, unused );}/*----------------------------***  NominateWindowsMenu  ***-----------------------------*//*access:			public	overrides:description: 	nominate a menu to handle the list of app windowsins: 			<menuID> menu to nominateouts: 			nonenotes:			MacZoop will automatically keep track of app windows once you call this at				start-up.----------------------------------------------------------------------------------------*/void		ZMenuBar::NominateWindowsMenu( const short menuID )	{	if ( wmMenuID == 0 )	{		MenuHandle	mH = FindMenuID( menuID );				if ( mH )		{			wmMenuID = menuID;						SetMenuDimming( menuID, disableCmdsOnly );						// we need to work hand-in-hand with the window manager to			// keep track of the windows. The Window Manager is best placed to			// do all this, so we simply hand off the menu to it.						gWindowManager->SetWindowsMenu( mH );		}	}}/*-------------------------------***  AppendHelpItem  ***-------------------------------*//*access:			public	overrides:description: 	append a help item to the Help menuins: 			<itemText> text of item to appendouts: 			item ID of the itemnotes:			this is currently not supported in Carbon apps----------------------------------------------------------------------------------------*/short		ZMenuBar::AppendHelpItem( Str255 itemText )		{#if TARGET_API_MAC_CARBON	return 0;#else	short		i;	MenuHandle	helpMenuH;		FailOSErr( HMGetHelpMenuHandle( &helpMenuH ));		AppendMenu( helpMenuH, itemText );			i = COUNTMENUITEMS( helpMenuH );	return i;#endif}/*------------------------------***  AppendMenuToBar  ***-------------------------------*//*access:			public	overrides:description: 	append a menu to the barins: 			<menuID> resource ID of a menu to appendouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::AppendMenuToBar( const short menuID  ){	Handle	temp;		temp = GetResource( 'CMNU', menuID );		if ( temp )	{		LoadCMNUMenu( menuID );		ReleaseResource( temp );	}	else		LoadMenu( menuID );		mbCount++;			UpdateMenuBar();}/*-----------------------------***  RemoveMenuFromBar  ***------------------------------*//*access:			public	overrides:description: 	remove an appended menu from the barins: 			<menuID> ID of a menu to removeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::RemoveMenuFromBar( const short menuID ){	MenuHandle	mH;		FailNILParam( mH = GetMenuHandle( menuID ));			// remove the command entries for this menu and any submenus it is the parent of.		UnloadMenu( mH );	mbCount--;		UpdateMenuBar();}/*------------------------------***  UpdateStyleMenu  ***-------------------------------*//*access:			public	overrides:description: 	intelligently manages the standard style commandsins: 			<runInfo> text run info gathered from the active text view, etcouts: 			nonenotes:			checks styles that are common across the run, sets a dash against				mixed styles----------------------------------------------------------------------------------------*/void		ZMenuBar::UpdateStyleMenu( TEStyleRunInfo* runInfo ){	EnableCommand( kCmdPlainText );	EnableCommand( kCmdBoldText );	EnableCommand( kCmdItalicText );	EnableCommand( kCmdUnderlineText );	EnableCommand( kCmdOutlineText );	EnableCommand( kCmdShadowText );	EnableCommand( kCmdCondensedText );	EnableCommand( kCmdExtendedText );		Style	curStyle = runInfo->runStyles;	Style	cs = runInfo->contStyles;	Boolean continuousRun = ( cs == 0xFF );	if (( curStyle & 0x7F ) == 0 )		CheckCommand( kCmdPlainText, TRUE );	else	{		if ( curStyle & kPlainStyle )			CheckCommandWithChar( kCmdPlainText, '-' );				if ( curStyle & bold )			CheckCommandWithChar( kCmdBoldText, ( cs & bold ) == bold? checkMark : '-' );		if ( curStyle & italic )			CheckCommandWithChar( kCmdItalicText, ( cs & italic ) == italic? checkMark : '-' );				if ( curStyle & underline )			CheckCommandWithChar( kCmdUnderlineText, ( cs & underline ) == underline? checkMark : '-' );				if ( curStyle & outline )			CheckCommandWithChar( kCmdOutlineText, ( cs & outline ) == outline? checkMark : '-' );				if ( curStyle & shadow )			CheckCommandWithChar( kCmdShadowText, ( cs & shadow ) == shadow? checkMark : '-' );				if ( curStyle & condense )			CheckCommandWithChar( kCmdCondensedText, ( cs & condense ) == condense? checkMark : '-' );				if ( curStyle & extend )			CheckCommandWithChar( kCmdExtendedText, ( cs & extend ) == extend? checkMark : '-' );	}}/*------------------------------***  UpdateStyleMenu  ***-------------------------------*//*access:			public	overrides:description: 	much simpler way to set style menu (not recommended)ins: 			<aStyle> a style bitfieldouts: 			nonenotes:			checks styles that are in the passed style only----------------------------------------------------------------------------------------*/void		ZMenuBar::UpdateStyleMenu( Style aStyle ){	EnableCommand( kCmdPlainText );	EnableCommand( kCmdBoldText );	EnableCommand( kCmdItalicText );	EnableCommand( kCmdUnderlineText );	EnableCommand( kCmdOutlineText );	EnableCommand( kCmdShadowText );	EnableCommand( kCmdCondensedText );	EnableCommand( kCmdExtendedText );	if ( aStyle == normal )		CheckCommand( kCmdPlainText, TRUE );	else	{		CheckCommand( kCmdBoldText, 	 ( aStyle & bold ) 		== bold );		CheckCommand( kCmdItalicText, 	 ( aStyle & italic ) 	== italic );		CheckCommand( kCmdUnderlineText, ( aStyle & underline ) == underline );		CheckCommand( kCmdOutlineText, 	 ( aStyle & outline ) 	== outline );		CheckCommand( kCmdShadowText, 	 ( aStyle & shadow ) 	== shadow );		CheckCommand( kCmdCondensedText, ( aStyle & condense ) 	== condense );		CheckCommand( kCmdExtendedText,  ( aStyle & extend )	== extend );	}}/*----------------------------***  UpdateFontSizeMenu  ***------------------------------*//*access:			public	overrides:description: 	intelligently manages Font and Font Size menusins: 			<runInfo> text run info gathered from active text view, etcouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::UpdateFontSizeMenu( TEStyleRunInfo* runInfo ){	Boolean	contFont, contSize;		contFont = runInfo->fr & kFontIsContinuous;	contSize = runInfo->fr & kSizeIsContinuous;		long	fCmd;	short 	i;	Str255	fontName;		for ( fCmd = kCmdStdFontSize7; fCmd <= kCmdStdFontSize72; fCmd++ )	{		EnableCommand( fCmd );				if ( contFont && RealFont( runInfo->fonts[0], fCmd - kStdFontSizeBase ))			SetCommandTextStyle( fCmd, outline );		else			SetCommandTextStyle( fCmd, 0 );	}	if ( contSize )		CheckCommand( kStdFontSizeBase + runInfo->sizes[0], TRUE );	else	{		// non-continuous sizes, so mark all the listed sizes				for ( i = 0; i < runInfo->numSizes; i++ )			CheckCommandWithChar( runInfo->sizes[i] + kStdFontSizeBase, '-' );		}		if ( gFontMenuID )	{		if ( contFont )		{			GetFontName( runInfo->fonts[0], fontName );			CheckCommand( gFontMenuID, fontName, TRUE );		}		else		{			// non-continous fonts, so mark all the listed fonts						for ( i = 0; i < runInfo->numFonts; i++ )			{				GetFontName( runInfo->fonts[i], fontName );				CheckCommandWithChar( gFontMenuID, fontName, '-' );			}		}		}}/*--------------------------------***  LoadMenus  ***----------------------------------*//*access:			public	overrides:description: 	loads and optionally installs menusins: 			<autoInstall> TRUE to preinstall menus into MenuList.outs: 			nonenotes:			should not normally be used by applications----------------------------------------------------------------------------------------*/void		ZMenuBar::LoadMenus( const Boolean autoInstall ){	short		i, menuID;	Handle		temp;		// how many menus in MBAR resource? This is first item in resource.		mbCount = (*mBarH)[0];		// iterate through, looking for MENU or CMNU resources		for ( i = 1; i <= mbCount; i++ )	{		menuID = (*mBarH)[i];				// if CMNU resource is available, use that. Otherwise, use MENU resource,		// possibly parsing it for command numbers				temp = GetResource( 'CMNU', menuID );				if ( temp )		{			LoadCMNUMenu( menuID, FALSE, autoInstall );			ReleaseResource( temp );		}		else			LoadMenu( menuID, FALSE, autoInstall );	}}	/*---------------------------------***  DimMenus  ***----------------------------------*//*access:			public	overrides:description: 	dim all menu items that have an associated commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::DimMenus(){	// This originally operated by walking the low-memory global menuList, but that does	// not work when 3rd party extensions install extra menus. Thus we now use our private	// list of menus to do this operation so we only affect our own menus.		short		i;	MenuInfRec	mRec;		for ( i = 1; i <= theMenus->CountItems(); i++ )	{		// find this menu in our list, and dim it according to the		// flags there. (Thanks to Jean-Yves Pochez for the improvements to this method)				mRec.macMenu = NULL;		theMenus->GetArrayItem( &mRec, i );			if ( mRec.macMenu )		{			// menu is in our list, so dim it. Note that all menus, including all of			// the attached hierarchical menus are dimmed by iterating this list. Thus			// PredimMenu does not need to be recursive, and isn't.						PredimMenu( mRec.macMenu );		}	}	// if auto Windows menu in use, set that up as well	if ( wmMenuID > 0 )		gWindowManager->BuildWindowsMenu();	}/*------------------------------***  SetMenuDimming  ***--------------------------------*//*access:			public	overrides:description: 	set up how a menu should be dimmedins: 			<menuID> the menu in question				<dimOpts> the dimming options for the menuouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetMenuDimming( const short menuID, const DimmingOptions dimOpts ){	MenuInfRec	mr;	Boolean		bUpdate;		mr.macMenu = NULL;		FindMenuInfo( menuID, &mr );		if ( mr.macMenu )	{		// if this call will change the state of the dimTitle flag, we need to cause an		// update to the menubar so that the user sees the change				bUpdate = (( mr.mDimming ^ dimOpts ) & dimTitle ) != 0;				mr.mDimming = dimOpts;		theMenus->SetArrayItem( &mr, mr.mIndex );				// update the bar if necessary				if ( bUpdate )		{			if ( dimOpts & dimTitle )				DISABLEMENUITEM( mr.macMenu, 0 );			else				ENABLEMENUITEM( mr.macMenu, 0 );						UpdateMenuBar();		}	}}	/*---------------------------------***  LoadMenu  ***-----------------------------------*//*access:			public	overrides:description: 	load a menuins: 			<menuID> the menu to load				<isHMenu> menu should be placed in hierarchical section of list				<autoInstall> TRUE to actually install the menu, FALSE to defer itouts: 			nonenotes:			this extracts and sets up commands and any submenus attached----------------------------------------------------------------------------------------*/void		ZMenuBar::LoadMenu( const short menuID, Boolean isHMenu, Boolean autoInstall ){	short		i, mCount, cmdChar, subID;	MenuHandle	mH;	MenuCmd		mCmd;	MenuInfRec	mRec;	Str255		iText;		FailNILErr( mH = GetMenu( menuID ), kMacZoopLoadMenuErr );		// set up info record for this menu		mRec.menuID = menuID;	mRec.mIndex = miSeed++;	mRec.macMenu = mH;	mRec.mDimming = dimCommands;	mRec.mIsResource = TRUE;	mRec.mIsSubmenu = isHMenu;		theMenus->AppendItem( &mRec );		// look through the menu for submenus, and recursively add them		mCount = COUNTMENUITEMS( mH );		for( i = 1; i <= mCount; i++ )	{		GetMenuItemText( mH, i, iText );				if ( iText[1] != '-' )		{			// make a command entry for the item						mCmd.menuID = menuID;			mCmd.itemID = i;			mCmd.macMenu = mH;						ParseMenuItem( iText, &mCmd.theCmd );						mCmd.altCommand = kNoCmd;			mCmd.shiftCommand = kNoCmd;						// hack hack:			// if close command, set up close all as altCommand. We need a more general			// way to set this up						if ( mCmd.theCmd == kCmdClose )				mCmd.altCommand = kCmdCloseAll;						// menus created using GetMenu are resources, CMNU are not. This is flagged so			// we can dispose of it correctly.						mCmd.cmdFlags = autoUnCheck | ( isHMenu? 0 : isPrimaryMenu ) | menuIsResource;			mCmd.subMenuID = 0;						SetMenuItemText( mH, i, iText );			GetItemCmd( mH, i, &cmdChar );						if ( cmdChar == hMenuCmd )			{				// has a submenu, so load it:								GetItemMark( mH, i, &subID );								// need to determine if submenu is a MENU or CMNU resource:								Handle	cmnuH;								cmnuH = GetResource( 'CMNU', subID );								if ( cmnuH )				{					LoadCMNUMenu( subID, TRUE, autoInstall );					ReleaseResource( cmnuH );				}				else					LoadMenu( subID, TRUE, autoInstall );									mCmd.subMenuID = subID;				mCmd.theCmd = parentCmd;			}						theMenuCmds->AppendItem( &mCmd );		}	}		// add the menu to the system list		if ( autoInstall )		InsertMenu( mH, isHMenu? hierMenu : 0 );}	/*------------------------------***  LoadCMNUMenu  ***----------------------------------*//*access:			public	overrides:description: 	load a menu from 'CMNU' resourceins: 			<menuID> the menu to load				<isHMenu> menu should be placed in hierarchical section of list				<autoInstall> TRUE to actually install the menu, FALSE to defer itouts: 			nonenotes:			this extracts and sets up commands and any submenus attached----------------------------------------------------------------------------------------*/void		ZMenuBar::LoadCMNUMenu( const short menuID, Boolean isHMenu, Boolean autoInstall ){	CMNUResHdl	cH;	MenuCmd		mCmd;	MenuInfRec	mRec;	MenuHandle	mH;	Ptr			cmP, cmItemText;	short		itemID;		cH = ( CMNUResHdl ) GetResource( 'CMNU', menuID );		if ( cH )	{		HNoPurge((Handle) cH );				// we need to do two things with this menu- a) make a normal menu handle that		// can be inserted into the menu manager list, and b) a set of menuCmd records		// so that we can look up the command when an item is chosen.			FailNIL( mH = NewMenu( menuID, (ConstStr255Param) &(*cH)->mTitle ));				// set up info record for this menu				mRec.menuID = menuID;		mRec.mIndex = miSeed++;		mRec.macMenu = mH;		mRec.mDimming = dimCommands;		mRec.mIsResource = FALSE;				theMenus->AppendItem( &mRec );				HLock((Handle) cH );				// we need to iterate through the items in the CMNU and build our two structures		// as needed. To do this efficiently, we lock the handle and keep a running pointer.				cmItemText = cmP = &(*cH)->mTitle + (*cH)->mTitle + 1;		itemID = 0;				// we're now at the start of the first item's text. We now scan through each item		// building both the real menu and the command structure				while( *cmItemText != 0 )		{			itemID++;						cmP += *cmItemText + 1;		// point to top of "interesting" info						// add text of item, making sure meta-characters are ignored. Note that			// a dividing line still works correctly						AppendMenu( mH, "\px" );			SetMenuItemText( mH, itemID, (ConstStr255Param) cmItemText );						// add command entry if not a dividing line						if ( cmItemText[1] != '-' )			{				// make menu item match info								SetItemIcon	( mH, itemID, ((CMNUEntryPtr) cmP)->iconID );				SetItemCmd	( mH, itemID, ((CMNUEntryPtr) cmP)->keyEqu );				SetItemMark	( mH, itemID, ((CMNUEntryPtr) cmP)->markChar );				SetItemStyle( mH, itemID, ((CMNUEntryPtr) cmP)->iStyle );								mCmd.menuID = menuID;				mCmd.itemID = itemID;				mCmd.subMenuID = 0;				mCmd.macMenu = mH;				mCmd.cmdFlags = autoUnCheck | ( isHMenu? 0 : isPrimaryMenu );				mCmd.theCmd = noCommand;								// if there's a sub-menu, we'll need to find and load it too. This involves				// a recursion to this function or to LoadMenu.								if (((CMNUEntryPtr) cmP)->keyEqu == hMenuCmd )				{					mCmd.subMenuID = ((CMNUEntryPtr) cmP)->markChar;									// is this a CMNU or a MENU resource?										Handle	cmnuH = GetResource( 'CMNU', mCmd.subMenuID );										if ( cmnuH )					{						LoadCMNUMenu( mCmd.subMenuID, TRUE, autoInstall );						ReleaseResource( cmnuH );					}					else						LoadMenu( mCmd.subMenuID, TRUE, autoInstall );											mCmd.theCmd = parentCmd;				}				else				{					// set up the command entry for the item. The command number					// may follow a pad byte if it would otherwise be at an odd address, so the					// data lies 4 or 5 bytes away from where cmP is now:									if ((unsigned long) cmP & 1 )						mCmd.theCmd = *(long*)( cmP + sizeof( CMNUEntry ) + 1 );					else						mCmd.theCmd = *(long*)( cmP + sizeof( CMNUEntry ));				}				// add the item to our command array								theMenuCmds->AppendItem( &mCmd );			}							// set the pointers to the next item. This is 8 or 9 bytes away depending on			// whether the resulting address is odd or even						cmP += 8;			if ((unsigned long) cmP & 1 )				cmP++;							cmItemText = cmP;		}		HUnlock((Handle) cH );		HPurge((Handle) cH );		ReleaseResource((Handle) cH );				// insert the menu we just built into the system list				if ( autoInstall )			InsertMenu( mH, isHMenu? hierMenu : 0 );	}}/*-------------------------------***  UnloadMenu  ***-----------------------------------*//*access:			public	overrides:description: 	delete a menu completely from this objectins: 			<mH> the menu to deleteouts: 			nonenotes:			apps should not normally use this - potentially dangerous!----------------------------------------------------------------------------------------*/void		ZMenuBar::UnloadMenu( MenuHandle mH ){	long		m;	MenuCmd		mCmd;	MenuInfRec	mRec;	Boolean		resStatus = FALSE;	Boolean		isResMenu = FALSE;	for( m = theMenuCmds->CountItems(); m > 0; m-- )	{		theMenuCmds->GetArrayItem( &mCmd, m );				// if this is one pertaining to the menu, delete it from the array. Also		// if it's a parent item, call this again to delete the submenu too.			if ( mH == mCmd.macMenu )		{			theMenuCmds->DeleteItem( m );					// is this a parent?						if ( mCmd.theCmd == parentCmd &&				 mCmd.subMenuID != 0 )			{				// yes, so recurse and delete that too								MenuHandle	smH = GetMenuHandle( mCmd.subMenuID );								if ( smH )					UnloadMenu( smH );			}		}	}		// remove the menu from the <theMenus> array:		for( m = 1; m <= theMenus->CountItems(); m++ )	{		theMenus->GetArrayItem( &mRec, m );			if ( mRec.macMenu == mH )		{			theMenus->DeleteItem( m );			break;		}	}			// remove the menu from the system menu list		DeleteMenu( GETMENUIDFROMHANDLE( mH ));		// dispose or release the menu handle according to whether	// it was a resource or not		if ( mRec.mIsResource )		ReleaseResource((Handle) mH );	else		DisposeMenu( mH );}	/*-------------------------------***  PredimMenu  ***-----------------------------------*//*access:			protected	overrides:description: 	dim a menu based on its dimming optionsins: 			<theMenu> the menu to dimouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::PredimMenu( MenuHandle theMenu ){	short			m, i, cmd;	MenuInfRec		mi;		if ( theMenu )	{		// initially set all items to be dimmed except the title ( we make one		// exception- the apple menu only has the first item dimmed );				if ( GETMENUIDFROMHANDLE( theMenu ) == kAppleMenuID )			DISABLEMENUITEM( theMenu, 1 );		else		{			// get the info rec for this menu						FindMenuInfo( GETMENUIDFROMHANDLE( theMenu ), &mi );						// dim items according to dimming flags except title			// if title already dimmed, it is not re-enabled here.						if (( mi.mDimming & 0x0F ) != neverDim )			{			#if OPAQUE_TOOLBOX_STRUCTS				DisableAllMenuItems( theMenu );				ENABLEMENUITEM( theMenu, 0 );			#else					(*theMenu)->enableFlags &= 0x00000001;			#endif			}			// look through the items for submenus						m = COUNTMENUITEMS( theMenu );					for( i = 1; i <= m; i++ )			{				GetItemCmd( theMenu, i, &cmd );								if ( cmd == hMenuCmd )				{					// Enable the parent item if permitted										if (( mi.mDimming & dimParentItems ) == 0 )						ENABLEMENUITEM( theMenu, i );				}				else				{					// if the item has no command and we don't want these dimming, enable it										if ( mi.mDimming & dimCommands )					{						MenuCmd		mc;												mc.theCmd = 0;						FindMCmd((((long) GETMENUIDFROMHANDLE( theMenu )) << 16 ) | i, &mc );												if ( mc.theCmd == 0 )							ENABLEMENUITEM( theMenu, i );					}					// in case the item is checked, uncheck it										SetItemMark( theMenu, i, noMark );				}			}		}	}	}	/*-----------------------------***  ParseMenuItem  ***----------------------------------*//*access:			protected	overrides:description: 	extract a command ID from a menu item stringins: 			<iText> menu item text				<aCmd> receives extracted commandouts: 			nonenotes:			iText is adjusted to remove the command information----------------------------------------------------------------------------------------*/void		ZMenuBar::ParseMenuItem( Str255 iText, long* aCmd ){	*aCmd = noCommand;		// a valid command is associated with the item by appending a hash sysmbol (#),	// followed by the command number as a string. Here we extract the number and	// modify the string to exclude it.		unsigned char	i = 1;	Str15			subStr;		// search for # char		while((iText[i] != '#') && (i < iText[0]))		i++;		if ( i < iText[0] )	{		// extract substring which is command number in string form				BlockMoveData( &iText[i + 1], &subStr[1], iText[0] - i );		subStr[0] = iText[0] - i;				StringToNum( subStr, aCmd );				// truncate string				iText[0] = i - 1;	}}	 /*-----------------------------***  AppendStdItems  ***---------------------------------*//*access:			public	overrides:description: 	append standard items to a menu - used to build font and DA menusins: 			<menuID> menu iD to append to				<iType> what to doouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::AppendStdItems( const short menuID, const short iType ){	MenuHandle	mH;		mH = FindMenuID( menuID );		// NOTE: Under Carbon, this is unnecessary to set up the Apple Menu. ZMenuBar won't	// call this in a Carbon environment, but if your own code does, you may need to check	// why, and make it conditional on Carbon.		if ( mH )		AppendResMenu( mH, ( iType == kAppendDANames )? 'DRVR' : 'FONT' );		// if we are creating a font menu, record the menuID in a global so that classes that	// want to get info from the font menu can do so simply. ZTextWindow uses this, for example.		if ( mH && ( iType == kAppendFontNames ))	{		gFontMenuID = menuID;		SetMenuDimming( menuID, neverDim + dimTitle );	}}	/*---------------------------------***  FindMCmd  ***-----------------------------------*//*access:			protected	overrides:description: 	look up the internal command record associated with a raw menu resultins: 			<mSelect> compact menu and item ID				<aCmd> receives command recordouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::FindMCmd( const long mSelect, MenuCmd* aCmd ){	long		m;	MenuCmd		mCmd;		for( m = 1; m <= theMenuCmds->CountItems(); m++ )	{		theMenuCmds->GetArrayItem( &mCmd, m );			// is this the one we want?				if ( HiWord( mSelect ) == mCmd.menuID &&			 LoWord( mSelect ) == mCmd.itemID )		{			*aCmd = mCmd;			break;		}	}	}	/*--------------------------------***  FindCommand  ***---------------------------------*//*access:			public	overrides:description: 	look up the menu and item ID given a command numberins: 			<cmd> command to look up				<menuID> receives menu ID				<itemID> receives item IDouts: 			nonenotes:			if command not found, menu and item are unchanged, so it is up to you to				preset them to a sentinel value such as 0 to detect this----------------------------------------------------------------------------------------*/void		ZMenuBar::FindCommand( const long cmd, short* menuID, short* itemID )	{	long		m;	MenuCmd		mCmd;		for( m = 1; m <= theMenuCmds->CountItems(); m++ )	{		theMenuCmds->GetArrayItem( &mCmd, m );			// is this the one we want?				if ( cmd == mCmd.theCmd )		{			*menuID = mCmd.menuID;			*itemID = mCmd.itemID;			break;		}	}	}/*-------------------------------***  SetTitleHilite  ***-------------------------------*//*access:			public	overrides:description: 	hilite or unhilite the title of a menuins: 			<menuID> menu to hilite, or 0 to unhilite cuurrent one				<state> TRUE to hilite, FALSE to unhiliteouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetTitleHilite( const short menuID, const Boolean state ){	if ( state )		HiliteMenu( menuID );	else		HiliteMenu( 0 );}/*---------------------------------***  FindMenuID  ***---------------------------------*//*access:			public	overrides:description: 	return the MenuHandle for a given IDins: 			<menuID> menu to getouts: 			handle to menunotes:			unlike toolbox call alone, this works even if menu not inserted in list----------------------------------------------------------------------------------------*/MenuHandle	ZMenuBar::FindMenuID( const short menuID ){	// returns the handle of the menu with the given ID. This works whether or not the menu	// was actually installed in the system menu list. If so, we use the toolbox call. If not	// we use the slightly slower method of looking through our private array of commands to	// locate the menu.		MenuInfRec	mRec;		mRec.macMenu = GetMenuHandle( menuID );		if ( mRec.macMenu == NULL )		FindMenuInfo( menuID, &mRec );		return mRec.macMenu;}/*--------------------------------***  FindMenuInfo  ***--------------------------------*//*access:			protected	overrides:description: 	obtain the local information about a menuins: 			<menuID> menu to get info for				<mRec> receives information recordouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::FindMenuInfo( const short menuID, MenuInfRec* mRec )	{	short		n, i;	MenuInfRec	mr;		n = theMenus->CountItems();		for( i = 1; i<= n; i++ )	{		theMenus->GetArrayItem( &mr, i );				if ( mr.menuID == menuID )		{			*mRec = mr;			break;		}	}}/*------------------------------***  GetMenuTitleRect  ***------------------------------*//*access:			protected	overrides:description: 	obtain the title rectangle for a given menuins: 			<menuID> menu to get title of				<tRect> receives title rectangleouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZMenuBar::GetMenuTitleRect( short menuID, Rect* tRect ){	// return the title rect (in GLOBAL coordinates) of the menu in the main bar with the	// menu ID <menuID>. This returns the empty rect if no such menu was found or if the	// menu is not in the main bar.	Rect		tr = {0,0,0,0};#if ! TARGET_API_MAC_CARBON	// note- this technique is incompatible with Carbon. Solution sought (TO DO)		MenuHandle	mH;	mListHdl	mListH;	short		i, iMax, tLength;	GrafPtr		savePort, wPort;	char		mhState;		mListH = (mListHdl) LMGetMenuList();		if ( mListH )	{		FailNILParam( mH = GetMenuHandle( menuID ));				mhState = HGetState((Handle) mH );		HLock((Handle) mH );		// if this handle is in the menu list, then this must be in the main bar.		// ASSUMPTION: hierarchical menus etc. are stored elsewhere.			iMax = (((*mListH)->lastMOffset ) / sizeof( mListEntry )) - 2;				for ( i = 0; i < iMax; i++ )		{			if ( mH == (*mListH)->mListItem[i].theMenu )			{				// found it! Now set up the rect								tr.top = 1;				tr.bottom = GetMBarHeight();								tr.left = (*mListH)->mListItem[i].leftEdge;								// the right edge is tricky- we need to get the title and figure the length								GetPort( &savePort );				GetWMgrPort( &wPort );				SetPort( wPort );						#if OPAQUE_TOOLBOX_STRUCTS				Str255		mTitle;								GetMenuTitle( mH, mTitle );				tLength = StringWidth( mTitle ) + 10;			#else							tLength = StringWidth((*mH)->menuData ) + 10;			#endif				SetPort( savePort );				tr.right = tr.left + tLength;								break;			}		}				HSetState((Handle) mH, mhState );		}#endif		*tRect = tr;}/*---------------------------***  SetZoomSourceToCommand  ***---------------------------*//*access:			public	overrides:description: 	set zoom source rectangle to the title of the menu containg the commandins: 			<aCmd> a menu commandouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::SetZoomSourceToCommand( const long aCmd ){	short	menuID = 0, itemID = 0;		FindCommand( aCmd, &menuID, &itemID );		if ( menuID )	{		Rect	r;				GetMenuTitleRect( menuID, &r );		InsetRect( &r, 20, 4 );		SetGlobalZoomSource( &r );	}}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			public	overrides:description: 	return data member info to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZMenuBar::ReportFields(){	ZComrade::ReportFields();	XSHOWFIELD( mBarID, ft_signedshort );	XSHOWFIELD( mbCount, ft_signedshort );	XSHOWFIELD( miSeed, ft_signedshort );	XSHOWFIELD( mBarH, ft_address );	XSHOWFIELD( theMenuCmds, ft_objectref );	XSHOWFIELD( theMenus, ft_objectref );	XSHOWFIELD( menuCheckChar, ft_signedchar );	XSHOWFIELD( wmMenuID, ft_signedshort );	XSHOWFIELD( mBarHeight, ft_signedshort );	XSHOWFIELD( mbHiding, ft_signedshort );	XSHOWFIELD( rbPending, ft_boolean );	XSHOWFIELD( inDispatch, ft_boolean );}