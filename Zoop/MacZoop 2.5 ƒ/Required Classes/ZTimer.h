/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZTimer.h			-- simple timer object******			© 1998, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZTIMER__#define	__ZTIMER__#include 	"ZComrade.h"#include 	"ZObjectArray.h"#include	"ZDefines.h"#include	<Events.h>class	ZTimer;class	ZCommander;typedef ZObjectList ZTimerQueue;enum{	kOneSecond			= 60};DEFINECLASSID( ZTimer, 'ztim' );// class definition:class	ZTimer	: public	ZComrade{protected:	long			id;	unsigned long	interval;	unsigned long	lastTicks;	ZCommander*		wOwner;	Boolean			oneShot;	Boolean			ismSecTimer;		static long		sTimerIDSeed;	public:		ZTimer( unsigned long tRate = kOneSecond, long anID = 0, ZCommander* owner = NULL, Boolean isOneShot = FALSE );		inline long				GetID() { return id; };	inline ZCommander*		GetOwner() { return wOwner; };	inline unsigned long	GetElapsedTime() { return TickCount() - lastTicks; };	inline void				SetRate( unsigned long tRate ) { interval = tRate; };	inline Boolean			IsMillisecondTimer() { return ismSecTimer; };	inline unsigned long	GetTime() { return lastTicks; };	virtual void			Do( unsigned long ticksNow );	virtual void			GetDebugInfoString( Str255 s );	virtual void			ReportFields();		void					InitMSecTimer( unsigned long mSec );};// timer message if no window associated:enum{	kTimerMsgTimerTripped	= 'ttrp',	kTimerMillisecTripped	= 'ttms'};// timer message data is the id of the timer// timers are usually set up using the following global functions:ZTimer*		SetTimer( ZCommander* aCmdr = NULL, long id = 0, unsigned long interval = kOneSecond, Boolean isOneShot = FALSE );void		KillTimer( ZCommander* aCmdr, long id, Boolean whichQueue = FALSE );void		KillAllTimers( ZCommander* aCmdr );ZTimer*		SetMillisecondTimer( ZCommander* aCmdr = NULL, long id = 0, unsigned long interval = 1000, Boolean isOneShot = FALSE );#define		SetTickTimer	SetTimer/*ZTimer has a very similar functionality to the Windows timer concept- windows programmerswill see the similarity immediately. However, this is more flexible if lower resolution.You can associate one or more timers with a commander object, and that timer will call yourcommander's DoTimer() method at the interval you specify, within the resolution and frequencyof the current application.To set up a timer, call SetTimer, passing your commander reference, an interval and an ID. Yourcommander's DoTimer method will be called at the interval you specify. When you want to stopa timer, call KillTimer. When your commander is destroyed, you should call KillAllTimers, butthe standard ZCommander destructor will do this.All active timers are stored in a global queue, and this queue is managed by ZApplication.n.b. this queue is not directly accessible to your application or classes.Timers have a resolution of 1 tick, but you may get called less often if your main loop isslower than this, or your app is in the background. Your window is Focussed before theDoTimer call is made, for your convenience. Another way to use a timer if you don't want itto be associated with a window, is to pass NULL as the window reference and become a listenerof the timer, in which case you'll get kTimerMsgTimerTripped messages.If you pass 0 for the ID, one will be assigned dynamically.Note that unlike Windows, you can have as many timers as you want.Timers are synchronous with your application main loop. If your application is busy and doesnot call the main loop, or a menu is down, the timers are not triggered. Timers are triggeredif your lengthy procs use a progress bar however, since that calls back to the main loop. Therate in this case depends partly on how often your progress bar is updated so will probablydrop for timers that are set to a rapid rate.MILLISECOND TIMER:Now available from MacZoop 2.2, you can now have timers with millisecond resolution.Everything works identically, except you call SetMillisecondTimer instead of SetTimer, and the intervalis naturally in milliseconds.The millisecond timer is maintained by the Time Manager, but the timer queue itself is iterated as partof the main event loop processing. This is necessary to allow timers to drive normal code that accessesthe toolbox (i.e. without interrupt time restrictions). Because of this architechture, your main event loopmust run very fast indeed to get true millisecond accuracy. In practice, this ideal is unlikely to beapproached, but you should be able to obtain resolutions of below 10mS on fast Power PCs.*/#endif