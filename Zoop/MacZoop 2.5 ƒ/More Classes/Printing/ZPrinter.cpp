/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZPrinter.cpp			-- an object for doing printing******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZPrinter.h"#include	"ZWindow.h"#include	"MacZoop.h"#include <PMApplication.h>/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZPrinter::ZPrinter( ZWindow* aWindow ){	classID = CLASS_ZPrinter;		printWindow = aWindow;	printInited = FALSE;	SetRect( &paperRect, 0, 0, 0, 0 );		// create a handle for the print record. This will be initialised to	// the default print settings when the user first chooses Page Setup or Print.#if TARGET_API_MAC_CARBON    //FailOSStatus( PMCreatePageFormat( &prFormat ));     //FailOSStatus( PMCreatePrintSettings( &prSettings ));#else	fakeWindow = NULL;	FailNIL( macPrintH = (THPrint) NewHandleClear( sizeof( TPrint )));	// set default print record and paper size		SetDefault();	paperRect = (*macPrintH)->prInfo.rPage;	#endif}/*---------------------------------***  DESTRUCTOR  ***---------------------------------*/ZPrinter::~ZPrinter(){#if TARGET_API_MAC_CARBON    //FailOSStatus( PMRelease( prFormat ));    //FailOSStatus( PMRelease( prSettings ));#else	if ( macPrintH )		DisposeHandle((Handle) macPrintH );#endif}/*-----------------------------------***  PRINT  ***------------------------------------*//*	print the contents of the current window----------------------------------------------------------------------------------------*/void	ZPrinter::Print(){	// verify that the window is valid and printable	FailOSErr((printWindow == NULL)? kBadWindowPrintRefErr : noErr );	FailOSErr( printWindow->IsPrintable()? noErr : kBadWindowPrintRefErr );    SetWatchCursor();#if TARGET_API_MAC_CARBON    try    {        //FailOSStatus( PMCreateSession( &prSession ));        SetDefault();        FailOSStatus( PMGetAdjustedPaperRect( prFormat, &prRect ));        PMToQuickDrawRect( &prRect, &paperRect );        PrintLoop();        //FailOSStatus( PMRelease( prSession ));    }    catch( ZoopError err )    {        //(void) PMRelease( prSession );            throw err;    }#else		try	{		SetUpDocTitle( printWindow );					PrOpen();		FailOSErr( PrError());		PrintLoop();		PrClose();				if ( fakeWindow )			DisposeWindow( fakeWindow );				fakeWindow = NULL;	}	catch( ZoopError err )	{		PrClose();				if ( fakeWindow )			DisposeWindow( fakeWindow );				fakeWindow = NULL;		throw err;	}#endif}/*-----------------------------------***  PRINT  ***------------------------------------*//*	print the contents of the window passed----------------------------------------------------------------------------------------*/void	ZPrinter::Print( ZWindow* aWindow ){	printWindow = aWindow;	Print();}/*-------------------------------***  GETPAPERRECT  ***---------------------------------*//*	returns the paper rectangle. If not set up, this will be empty.----------------------------------------------------------------------------------------*/void	ZPrinter::GetPaperRect( Rect* aRect ){	*aRect= paperRect;}/*-----------------------------***  SETMACPRINTRECORD  ***------------------------------*//*	allows existing print record to be set for the printer----------------------------------------------------------------------------------------*/#if !TARGET_API_MAC_CARBONvoid	ZPrinter::SetMacPrintRecord( THPrint pRec ){	if ( pRec == NULL )		PrintDefault( macPrintH );	else	{		if ( macPrintH )			DisposeHandle((Handle) macPrintH );					macPrintH = pRec;		printInited = TRUE;				paperRect = (*macPrintH)->prInfo.rPage;		}}#endif/*---------------------------------***  PAGESETUP  ***----------------------------------*//*	display the page setup dialog----------------------------------------------------------------------------------------*/void	ZPrinter::PageSetUp(){    SetWatchCursor();	// display the page setup dialog#if TARGET_API_MAC_CARBON    Boolean     accepted;            //FailOSStatus( PMCreateSession( &prSession ));    SetDefault();        PauseCursorAnimation( ARROW_CURSOR );    //FailOSStatus( PMSessionPageSetupDialog( prSession, prFormat, &accepted ));    ResumeCursorAnimation();        if ( accepted )    {        FailOSStatus( PMGetAdjustedPaperRect( prFormat, &prRect ));        PMToQuickDrawRect( &prRect, &paperRect );    }        //FailOSStatus( PMRelease( prSession ));#else		try	{		PrOpen();		FailOSErr( PrError());			SetDefault();						StopCursorAnimation();		PrStlDialog( macPrintH );		PrClose();				paperRect = (*macPrintH)->prInfo.rPage;	}	catch( ZoopError err )	{		PrClose();		// show the print problem alert, but do not propagate				Str15	errStr;		NumToString( err, errStr );		ParamText( errStr, NULL, NULL, NULL );		if (err != userCanceledErr)			(void) NotifyAlert( kInitPrinterAlertID );	}#endif}/*---------------------------------***  PRINTLOOP ***-----------------------------------*//*	display the job dialog and print the range of pages selected----------------------------------------------------------------------------------------*/#if TARGET_API_MAC_CARBONvoid    ZPrinter::PrintLoop(){    Boolean     accepted, pgOpen;    UInt32      firstPage, lastPage;        PauseCursorAnimation( ARROW_CURSOR );    //FailOSStatus( PMSessionPrintDialog( prSession, prSettings, prFormat, &accepted ));	ResumeCursorAnimation();	    if ( accepted )    {        FailOSStatus( PMGetAdjustedPageRect( prFormat, &prRect ));        PMToQuickDrawRect( &prRect, &paperRect );        //FailOSStatus( PMGetCopies( prSettings, &copies ));        FailOSStatus( PMGetFirstPage( prSettings, &firstPage ));        FailOSStatus( PMGetLastPage( prSettings, &lastPage ));        		printWindow->PerformUpdate();        		printWindow->CalcPages( paperRect, &pH, &pV );        		// make sure the end page is sensible to the actual number of pages		// to print.				if ( lastPage > ( pH * pV ))		{			lastPage = ( pH * pV );			FailOSStatus( PMSetLastPage( prSettings, lastPage, FALSE ));		}			if ( firstPage < 1 )		{			 firstPage = 1;			 FailOSStatus( PMSetFirstPage( prSettings, firstPage, FALSE ));	    }        //FailOSStatus( PMSessionBeginDocument( prSession, prSettings, prFormat ));        printWindow->PrintingStarting();        		for ( pageNum = firstPage; pageNum <= lastPage; pageNum++ )		{            //( PMSessionBeginPage( prSession, prFormat, NULL ));            			pgOpen = TRUE;						// call the window to do the relevant rendering, etc.						printWindow->PrintOnePage( pageNum, paperRect );                        //FailOSStatus( PMSessionEndPage( prSession ));            pgOpen = FALSE;        }                printWindow->PrintingFinishing();        //FailOSStatus( PMSessionEndDocument( prSession ));    }}#elsevoid	ZPrinter::PrintLoop(){	// stick up the job dialog so the user can set copies, start, end, etc.		Boolean		pgOpen = FALSE;		StopCursorAnimation();	if ( PrJobDialog( macPrintH ))	{		// user OK'd the dialog, so set the page ranges and start printing them.		// set up the paper rect. Note we set the static watch cursor since the print		// driver may do its own animation. We also do a quick window update here because		// the print dialog just went away leaving an update area, but no events are handled		// until the print job is complete.				paperRect = (*macPrintH)->prInfo.rPage;		pageStart = (*macPrintH)->prJob.iFstPage;		pageEnd   = (*macPrintH)->prJob.iLstPage;		printWindow->PerformUpdate();		SetWatchCursor();				// OK, now do the real thing...				// calculate pagination. The window does this based on its content area and		// the paper area passed to it. Default pagination tiles first horizontally		// then vertically. pH and pV will be at least 1.				printWindow->CalcPages( paperRect, &pH, &pV );			// make sure the end page is sensible to the actual number of pages		// to print.				if (pageEnd > ( pH * pV ))			pageEnd = ( pH * pV );					if ( pageStart < 1 )			 pageStart = 1;		// make the magic fix for mac happiness:					(*macPrintH)->prJob.iFstPage = 1;		(*macPrintH)->prJob.iLstPage = 9999;		// if page start is later than page end, nothing to print (sanity check)			if ( pageStart <= pageEnd )		{			printPort = PrOpenDoc( macPrintH, NULL, NULL );			FailOSErr( PrError());						try			{				printWindow->PrintingStarting();								// for each page, open the page and print it				for ( pageNum = pageStart; pageNum <= pageEnd; pageNum++ )				{					PrOpenPage( printPort, NULL );					FailOSErr( PrError());										pgOpen = TRUE;										// call the window to do the relevant rendering, etc.										printWindow->PrintOnePage( pageNum, paperRect );								PrClosePage( printPort );					pgOpen = FALSE;					FailOSErr( PrError());				}								// the printing has finished, so inform the window								printWindow->PrintingFinishing();			}			catch( ZoopError err )			{				if ( pgOpen )					PrClosePage( printPort );									PrCloseDoc( printPort );								throw err;			}						PrCloseDoc( printPort );						FailOSErr( PrError());						// we may need to spool the file, so check the spool flag						TPrStatus  prStatus;						if ((*macPrintH)->prJob.bJDocLoop == bSpoolLoop )			{				PrPicFile( macPrintH, NULL, NULL, NULL, &prStatus);				FailOSErr( PrError());			}		}	}}#endifvoid	ZPrinter::SetUpDocTitle( ZWindow* aWindow ){	// mac print driver assums top window is the one we are printing. This is not true if we	// have floaters, so to make sure, we create a temporary front window hidden behind the	// menubar and make sure its title is set to the doc we are printing.		Rect	r = { 0, 0, 3, 3 };	Str31	title;		aWindow->GetName( title );	#if TARGET_API_MAC_CARBON		#else	fakeWindow = NewWindow( NULL, &r, title, TRUE, 0, (WindowPtr) -1L, FALSE, 0);	SelectWindow( fakeWindow );#endif}void	ZPrinter::SetDefault(){	if ( ! printInited )	{	#if TARGET_API_MAC_CARBON        //FailOSStatus( PMSessionDefaultPageFormat( prSession, prFormat ));        //FailOSStatus( PMSessionDefaultPrintSettings( prSession, prSettings ));	#else		PrOpen();		FailOSErr( PrError());				try		{			PrintDefault( macPrintH );			FailOSErr( PrError());						PrClose();						printInited = TRUE;		}		catch( ZoopError err )		{			PrClose();			throw err;		}	#endif	}}void	ZPrinter::ReportFields(){	ZObject::ReportFields();	XSHOWFIELD( paperRect, ft_Rect );	XSHOWFIELD( pageStart, ft_signedshort );	XSHOWFIELD( pageEnd, ft_signedshort );	XSHOWFIELD( pageNum, ft_signedshort );	XSHOWFIELD( pH, ft_signedshort );	XSHOWFIELD( pV, ft_signedshort );	XSHOWFIELD( printInited, ft_boolean );}#if TARGET_API_MAC_CARBONvoid    ZPrinter::PMToQuickDrawRect( PMRect* in, Rect* out ){    out->left   = rinttol( in->left );    out->top    = rinttol( in->top );    out->right  = rinttol( in->right );    out->bottom = rinttol( in->bottom );}#endif