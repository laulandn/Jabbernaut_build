/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZGWorld.cpp			-- an object for managing an offscreen GWorld******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZGWorld.h"#include	"MacZoop.h"#include	"PixMapUtils.h"#include	<FixMath.h>#include	<quickdraw.h>ColorSearchUPP	ZGWorld::sMaskProc = NewColorSearchUPP( ZGWorld::MaskSearchProc );CLASSCONSTRUCTOR( ZGWorld );/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZGWorld::ZGWorld( const Rect& aSize,				  const short aDepth,				  const CTabHandle aCTable,				  const Boolean makeTemp)	: ZObject(){	classID = CLASS_ZGWorld;		gw = NULL;	pState = 0;	lockLevel = 0;	inTempMem = makeTemp;		MakeMacGWorld(aSize, aDepth, aCTable, makeTemp);	Clear();}/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZGWorld::ZGWorld( const PicHandle aPicture, const Boolean makeTemp, const short depth )	: ZObject(){	classID = CLASS_ZGWorld;		gw = NULL;	pState = 0;	lockLevel = 0;	inTempMem = makeTemp;		FailNIL( aPicture );	MakeGWorldFromPicture( aPicture, makeTemp, depth );}/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZGWorld::ZGWorld( const short pictID, const Boolean makeTemp, const short depth )	: ZObject(){	classID = CLASS_ZGWorld;	gw = NULL;	pState = 0;	lockLevel = 0;	inTempMem = makeTemp;		PicHandle	p;		FailNILRes( p = GetPicture( pictID ));		try	{		MakeGWorldFromPicture( p, makeTemp, depth );	}	catch(ZoopError err)	{		ReleaseResource((Handle) p );			throw err;	}		ReleaseResource((Handle) p );}/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZGWorld::ZGWorld( ZGWorld* aGW, const Boolean makeTemp )	: ZObject(){	classID = CLASS_ZGWorld;	FailNILParam( aGW );		Rect		aSize;	short		aDepth; 	CTabHandle	aCTable;	gw = NULL;	pState = 0;	lockLevel = 0;	inTempMem = makeTemp;	aGW->GetSize( &aSize );	aDepth = aGW->GetDepth();	aCTable = aGW->GetColours();		MakeMacGWorld( aSize, aDepth, aCTable, makeTemp );	Copy( aGW );}/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZGWorld::ZGWorld()	: ZObject(){	classID = CLASS_ZGWorld;	gw = NULL;	pState = 0;	lockLevel = 0;	inTempMem = FALSE;}/*--------------------------------***  DESTRUCTOR  ***---------------------------------*/ZGWorld::~ZGWorld(){	// for safety, if the current port or device is part of this object,	// switch to a valid port and device before disposing		if ( gw )	{		CGrafPtr	curPort;		GDHandle	sDevice;				sDevice = GetGWorldDevice( gw );		GetPort((GrafPtr*) &curPort );				if ((CGrafPtr) gw == curPort ||			 sDevice == GetGDevice())		{ 			SetGWorld((CGrafPtr) FrontWindow(), GetMainDevice());		}			DisposeGWorld(gw);	}}/*-----------------------------------***  Lock  ***-------------------------------------*//*access:			public	overrides:description: 	lock a GWorld ready for drawing into it or copying itins: 			noneouts: 			nonenotes:			Calls to Lock and Unlock may be nested but must balance----------------------------------------------------------------------------------------*/void	ZGWorld::Lock(){	// locks the pixels so that you can draw to/from them		if (lockLevel == 0)	{		PixMapHandle	pp;				pp = GetGWorldPixMap(gw);				if (! LockPixels(pp))			FailOSErr(kGWPixelsPurgedErr);	}		lockLevel++;}/*----------------------------------***  Unlock  ***------------------------------------*//*access:			public	overrides:description: 	unlock a GWorld after drawing into it or copying itins: 			noneouts: 			nonenotes:			Calls to Lock and Unlock may be nested but must balance----------------------------------------------------------------------------------------*/void	ZGWorld::Unlock(){	// unlocks previously locked pixels		lockLevel--;		if (lockLevel <= 0)	{		PixMapHandle	pp;				pp = GetGWorldPixMap(gw);		UnlockPixels(pp);				lockLevel = 0;	}}/*-------------------------------***  SetPurgeable  ***---------------------------------*//*access:			public	overrides:description: 	allow a GWorld's pixels to ne purgeableins: 			<aPurgeState> TRUE to allow purging, FALSE to hold pixels in memoryouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::SetPurgeable( const Boolean aPurgeState ){	// sets pixels purgeable or unpurgeable according to state. Note that it is extremely wise to check	// whether the pixels are really in memory before setting them from purgeable to unpurgeable.		PixMapHandle	pp;		pp = GetGWorldPixMap(gw);		if (aPurgeState)		AllowPurgePixels(pp);	else		NoPurgePixels(pp);			pState = GetPixelsState(pp);}/*---------------------------------***  GetState  ***-----------------------------------*//*access:			public	overrides:description: 	return the current pixel state of the GWorldins: 			noneouts: 			the state flagsnotes:			----------------------------------------------------------------------------------------*/short	ZGWorld::GetState(){	return GetPixelsState( GetPixMap());}/*--------------------------------***  SetColours  ***----------------------------------*//*access:			public	overrides:description: 	set the colours used by a GWorldins: 			<aCTable> a table of new colours				<reMapColours> TRUE to remap existing image to new colours, FALSE to				recolour the image according to the new colour tableouts: 			nonenotes:			this copies the colour table - caller may dispose it----------------------------------------------------------------------------------------*/void	ZGWorld::SetColours( const CTabHandle aCTable, const Boolean reMapColours ){	// sets the colour table of the GWorld to the colour table passed in. The table remains the callers.	// This updates the GWorld, mapping it to the new colours. If you want to substitute a table without	// mapping the colours, pass a second parameter of FALSE.		if ( reMapColours )	{		// here we want to re-map the colours to the new table, so we actually completely update the		// GWorld, warts an' all.				GWorldFlags		gwFlags;		short			curDepth;		Rect			curSize;				curDepth = GetDepth();		GetSize( &curSize );				// set the flags so that the image is preserved				gwFlags = clipPix;				gwFlags = UpdateGWorld( &gw, curDepth, &curSize, aCTable, NULL, gwFlags );				if ( gwFlags & gwFlagErr )			FailOSErr( kGWCTableUpdtFailed );		}	else	{		// to change tables without re-mapping, the table is copied over the existing table, and the		// inverse table is re-built. This does not reallocate the pixels, so false colours may appear.		// This is presumably what you wanted!				CTabHandle		curTable;		long			tSize;				curTable = GetColours();				if ( curTable == aCTable )			FailOSErr( paramErr );					FailNILParam( aCTable );				// size the current table to the same as the passed one				SetHandleSize((Handle) curTable, tSize = GetHandleSize((Handle) aCTable));		FailOSErr(MemError());		// copy the table over				BlockMoveData(*aCTable, *curTable, tSize);			// force the inverse-table to get rebuilt next time				GDeviceChanged(GetGWorldDevice(gw));	}}/*---------------------------------***  SetDepth  ***-----------------------------------*//*access:			public	overrides:description: 	change the bitdepth of the GWorldins: 			<aDepth> the desired depth				<aCTable> optional new colour table for new depth				<dither> TRUE to dither the image when reducing the depthouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::SetDepth( const short aDepth, const CTabHandle aCTable, const Boolean dither){	// sets the GWorld's depth to that passed, also optionally setting the colour table. If the colour table	// is NULL, the default for the depth is used. If you only want to change the colour table, use SetColours.	// This preserves the pixels by clipping.		if  (aDepth != GetDepth())	{		GWorldFlags		gwFlags;		Rect			curSize;				GetSize(&curSize);				gwFlags = clipPix;				if (dither)			gwFlags |= ditherPix;				gwFlags = UpdateGWorld( &gw, aDepth, &curSize, aCTable, NULL, gwFlags );			if ( gwFlags & gwFlagErr )			FailOSErr( kGWChangeDepthFailed );	}}/*----------------------------------***  SetSize  ***-----------------------------------*//*access:			public	overrides:description: 	change the dimensions of the GWorldins: 			<aSize> the desired size				<scaleImage> TRUE to scale the image to the new size, FALSE to clip or fillouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::SetSize( const Rect& aSize, const Boolean scaleImage){	// sets the GWorlds bounds to that passed. The depth and colours remain the same.		Rect			curSize;	GWorldFlags		gwFlags;	short			curDepth;	CTabHandle		curCTab;		GetSize(&curSize);		if (! EqualRect( &aSize, &curSize))	{		CGrafPtr	savePort;		GDHandle	saveDevice;		curDepth = GetDepth();		curCTab = GetColours();		if (scaleImage)			gwFlags = stretchPix;		else			gwFlags = clipPix;					gwFlags = UpdateGWorld(&gw, curDepth, &aSize, curCTab, NULL, gwFlags);				if (gwFlags & gwFlagErr)			FailOSErr(kGWChangeSizeFailed);					// if the image was cropped and the GWorld is now larger than it was, we need to fill		// the excess area with white, otherwise it looks Õorrible.				if (! scaleImage)		{			if ((aSize.right > curSize.right) 	||				(aSize.bottom > curSize.bottom))			{				RgnHandle	old, xs, clipSave;								Lock();								RectRgn( old = NewRgn(), &curSize );				RectRgn( xs = NewRgn(), &aSize );								DiffRgn(xs, old, xs);								SetPortToGW(&savePort, &saveDevice);								GetClip( clipSave = NewRgn());				ClipRect( &aSize );				EraseRgn( xs );				SetClip( clipSave );				SetGWorld( savePort, saveDevice );								Unlock();								DisposeRgn(old);				DisposeRgn(xs);				DisposeRgn( clipSave );			}		}		else		{			SetPortToGW( &savePort, &saveDevice );			ClipRect( &aSize );			SetGWorld( savePort, saveDevice );		}	}}/*----------------------------------***  GetDepth  ***----------------------------------*//*access:			public	overrides:description: 	query the current bitdepth of the GWorldins: 			noneouts: 			current depthnotes:			----------------------------------------------------------------------------------------*/short	ZGWorld::GetDepth(){	PixMapHandle	pp;		pp = GetGWorldPixMap(gw);	return (*pp)->pixelSize;}/*---------------------------------***  GetColours  ***---------------------------------*//*access:			public	overrides:description: 	return the current colour tableins: 			noneouts: 			the colour tablenotes:			WARNING: returns the actual table - caller must not dispose of it----------------------------------------------------------------------------------------*/CTabHandle		ZGWorld::GetColours(){	// returns a handle to the colour table. Note- this handle belongs to this object, so	// do not dispose of it. If you modify it, call CTabChanged.		PixMapHandle	pp;		pp = GetGWorldPixMap(gw);	return (*pp)->pmTable;}/*-------------------------------***  GetColourInfo  ***--------------------------------*//*access:			public	overrides:description: 	return the current colcour table seed valueins: 			noneouts: 			the colour table seed, or -1 if the GWorld has no colour tablenotes:			----------------------------------------------------------------------------------------*/short	ZGWorld::GetColourInfo(){	CTabHandle	aCT = GetColours();	if (aCT)		return (*aCT)->ctSeed;	else		return -1;}/*--------------------------------***  GetRowOffset  ***--------------------------------*//*access:			public	overrides:description: 	return the rowbytes offset of the pixMapins: 			noneouts: 			row offset in bytesnotes:			----------------------------------------------------------------------------------------*/long	ZGWorld::GetRowOffset(){	long	rb = 0;		PixMapHandle	pp = GetPixMap( FALSE );		if ( pp )	{		long	result;		OSErr	err;				err = Gestalt( gestaltQuickdrawVersion, &result );				if ( result >= gestaltAllegroQD )			rb = GetPixRowBytes( pp );			else			rb = (*pp)->rowBytes & 0x3FFF;	}		return rb;}/*---------------------------------***  GetPixMap  ***----------------------------------*//*access:			public	overrides:description: 	return the PixMapHandle of teh GWorld, optionally locking it beforehandins: 			<lock> TRUE to lock the GWorld firstouts: 			the PixMapHandle of the GWorldnotes:			----------------------------------------------------------------------------------------*/PixMapHandle	ZGWorld::GetPixMap( const Boolean lock ){	// returns the GWorld's pixmap, optionally locking it first. If you want to copy to and from	// the GWorld, use the copy methods instead.		if (lock)		Lock();			return GetGWorldPixMap(gw);}/*-------------------------------***  ReallocPixMap  ***--------------------------------*//*access:			public	overrides:description: 	reallocate the image buffer for a purged GWorldins: 			noneouts: 			nonenotes:			WARNING: do not call unless you know for sure the image has been purged.				Also, this does not recreate the image - you must do that.----------------------------------------------------------------------------------------*/void		ZGWorld::ReallocPixMap(){	if (! InMemory())	{		GWorldFlags		gwFlags;		short			aDepth, attempts = 0;		Rect			aSize;		CTabHandle		aColours;		Boolean			mSuccess = FALSE;		long			mSize;		PixMapHandle	pp;				aDepth = GetDepth();		GetSize(&aSize);		aColours = GetColours();				do		{			attempts++;						gwFlags = UpdateGWorld(&gw, aDepth, &aSize, aColours, NULL, 0);					if (gwFlags & gwFlagErr)			{				// the attempt failed. try various things to get ourselves the memory.								pp = GetGWorldPixMap(gw);				mSize = ((aSize.bottom - aSize.top) * GetRowOffset()) + 32768L;								switch (attempts)				{					case 1:						PurgeMem(mSize);							break;					case 2:						PurgeMem(mSize);						CompactMem(mSize);						break;					case 3:						MaxMem(&mSize);						break;					default:						FailOSErr(kGWNoMemForPixels);				}			}			else				mSuccess = TRUE;		}		while(! mSuccess);	}}/*----------------------------------***  InMemory  ***----------------------------------*//*access:			public	overrides:description: 	query whether the GWorld's image exists in memoryins: 			noneouts: 			TRUE if the image exists, FALSE if it has been purgednotes:			Use before calling ReallocPixMap above----------------------------------------------------------------------------------------*/Boolean		ZGWorld::InMemory(){	// returns whether the pixmap is in memory or not. It will return false if the pixels have	// been purged. This works by trying to lock the pixels.		PixMapHandle	pp;	Boolean			result;		pp = GetGWorldPixMap(gw);	pState = GetPixelsState(pp);		result = LockPixels(pp);	SetPixelsState(pp, pState);		return result;}/*-----------------------------------***  GetSize  ***----------------------------------*//*access:			public	overrides:description: 	return current dimensions of the GWorldins: 			<aFrame> receives the GWorld portRectouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::GetSize( Rect* aFrame ){	// returns the GWorld's bounds rect		*aFrame = *PORTPORTRECT( gw );}/*-------------------------------***  GetImageMemSize  ***------------------------------*//*access:			public	overrides:description: 	return amount of memory occupied by the GWorld's imageins: 			noneouts: 			size in bytesnotes:			----------------------------------------------------------------------------------------*/long	ZGWorld::GetImageMemSize(){	long	aSize = 0;		if ( InMemory())	{		PixMapHandle pp = GetPixMap();		Rect	br = (*pp)->bounds;				aSize = (long)( br.bottom - br.top ) * GetRowOffset();		}		return aSize;}/*------------------------------------***  CopyIn  ***----------------------------------*//*access:			public	overrides:description: 	copy an image into the GWorldins: 			<srcBits> pointer to a bitMap (or a typecast PixMapHandle)				<src, dest> source and destination rectangles of the copy				<mode> transfer mode - srcCopy, srcOr, etc				<mask> optional mask region to apply to the copyouts: 			nonenotes:			This handles locking, unlocking and setup for you----------------------------------------------------------------------------------------*/void	ZGWorld::CopyIn( const BitMap* srcBits, const Rect* src, const Rect* dest, const short mode, RgnHandle mask ){	// This method is a single call to copy from a bitmap or pixmap (or other GWorld that is not	// managed by a wrapper like this) to this GWorld. This saves the port, locks the GWorld,	// then does a CopyBits with the parameters passed.		CGrafPtr		savePort;	GDHandle		saveDevice;	PixMapHandle	pp;	Rect			s, d;	if ( src == NULL )		GetSize( &s );	else		s = *src;			if ( dest == NULL )		GetSize( &d );	else		d = *dest;	Lock();	// may throw exception	SetPortToGW(&savePort, &saveDevice);		pp = GetGWorldPixMap(gw);	CopyBits(srcBits, (BitMap*) *pp, &s, &d, mode, mask);		Unlock();	SetGWorld(savePort, saveDevice);}/*-----------------------------------***  CopyOut  ***----------------------------------*//*access:			public	overrides:description: 	copy an image from the GWorld to some other PixMap or BitMapins: 			<destBits> pointer to a bitMap (or a typecast PixMapHandle)				<src, dest> source and destination rectangles of the copy				<mode> transfer mode - srcCopy, srcOr, etc				<mask> optional mask region to apply to the copyouts: 			nonenotes:			This handles locking, unlocking and setup for you----------------------------------------------------------------------------------------*/void	ZGWorld::CopyOut( const BitMap* destBits, const Rect* src, const Rect* dest, const short mode, RgnHandle mask){	// Copies pixel image data from this object to any other bitmap or pixmap. This assumes that	// the destination port is correctly set.		PixMapHandle	pp;	Rect			s, d;		if ( src == NULL )		GetSize( &s );	else		s = *src;			if ( dest == NULL )		GetSize( &d );	else		d = *dest;			Lock(); // may throw exception		pp = GetGWorldPixMap( gw );	CopyBits((BitMap*) *pp, destBits, &s, &d, mode, mask );		Unlock();	}/*-------------------------------------***  Copy  ***-----------------------------------*//*access:			public	overrides:description: 	copy an image from another ZGWorld object to this oneins: 			<aGW> ZGWorld object to copy				<mode> transfer mode - srcCopy, srcOr, etcouts: 			nonenotes:			This handles locking, unlocking and setup for you----------------------------------------------------------------------------------------*/void	ZGWorld::Copy( ZGWorld* aGW, const short mode ){	// copies the image from another object like this into this one. This scales the image from	// the source to the dest, applying the mode		PixMapHandle	pp;	Rect			src, dest;	char			hs;		FailNIL(aGW);		pp = aGW->GetPixMap(TRUE);		aGW->GetSize(&src);	GetSize(&dest);		hs = HGetState((Handle) pp );	HLock((Handle) pp );	CopyIn((BitMap*) *pp, &src, &dest, mode);	HSetState((Handle) pp, hs );		aGW->Unlock();	}/*------------------------------------***  CopyIn  ***----------------------------------*//*access:			public	overrides:description: 	copy an image into the GWorld from another ZGWorld objectins: 			<srcGW> a ZGWorld object containing the source image				<src, dest> source and destination rectangles of the copy				<mode> transfer mode - srcCopy, srcOr, etc				<mask> optional mask region to apply to the copyouts: 			nonenotes:			This handles locking, unlocking and setup for you----------------------------------------------------------------------------------------*/void	ZGWorld::CopyIn( ZGWorld* srcGW, const Rect* src, const Rect* dest, const short mode, RgnHandle mask){	// object version of CopyIn	PixMapHandle	pp;	char			hs;		FailNIL(srcGW);		pp = srcGW->GetPixMap(TRUE);	// locks the source GWorld		hs = HGetState((Handle) pp );	HLock((Handle) pp );	CopyIn((BitMap*) *pp, src, dest, mode, mask);	HSetState((Handle) pp, hs );		srcGW->Unlock();}/*-----------------------------------***  CopyOut  ***----------------------------------*//*access:			public	overrides:description: 	copy an image from this GWorld to some other ZGWorld objectins: 			<destGW> destination ZGWorld object				<src, dest> source and destination rectangles of the copy				<mode> transfer mode - srcCopy, srcOr, etc				<mask> optional mask region to apply to the copyouts: 			nonenotes:			This handles locking, unlocking and setup for you----------------------------------------------------------------------------------------*/void	ZGWorld::CopyOut( ZGWorld* destGW, const Rect* src, const Rect* dest, const short mode, RgnHandle mask ){	// object version of CopyOut. This actually operates by calling the destination's CopyIn method, since that	// is a more efficient and cunning way to do it!		FailNILParam( destGW );	destGW->CopyIn( this, src, dest, mode, mask );}/*------------------------------------***  Clear  ***-----------------------------------*//*access:			public	overrides:description: 	erase the GWorld to the current background colourins: 			noneouts: 			nonenotes:			This handles locking, unlocking and setup for you----------------------------------------------------------------------------------------*/void	ZGWorld::Clear(){	CGrafPtr	savePort;	GDHandle	saveDevice;	Rect		r;		Lock();	SetPortToGW( &savePort, &saveDevice );	GetSize( &r );	EraseRect( &r );	Unlock();	SetGWorld( savePort, saveDevice );}/*------------------------------***  CopyOutThroughMask  ***----------------------------*//*access:			public	overrides:description: 	copoy the image to another ZGWorld object, using a third as an alpha maskins: 			<destGW> resulting image end up in here				<maskGW> the "alpha channel" blend mask is in here				<src, dest> the source and destination rectangles of the copy				<mask> the mask rectangle				<mode> transfer mode (e.g. blend)outs: 			nonenotes:			This handles locking, unlocking and setup for you. The rectangle parameters				must all be the same size, but can have different offsets.----------------------------------------------------------------------------------------*/void	ZGWorld::CopyOutThroughMask( ZGWorld* destGW,									 ZGWorld* maskGW,									 const Rect* src,									 const Rect* mask,									 const Rect* dest,									 const short mode ){	PixMapHandle	dp;	CGrafPtr		savePort;	GDHandle		saveDev;		FailNILParam( destGW );	FailNILParam( maskGW );		dp = destGW->GetPixMap( TRUE );		destGW->SetPortToGW( &savePort, &saveDev );		CopyOutThroughMask((BitMap*) *dp, maskGW, src, mask, dest, mode );		destGW->Unlock();	SetGWorld( savePort, saveDev );}									 												/*------------------------------***  CopyOutThroughMask  ***----------------------------*//*access:			public	overrides:description: 	copy the image to a bitMap or PixMap, using a ZGWorld object as an alpha maskins: 			<destBits> resulting image ends up in here				<maskGW> the "alpha channel" blend mask is in here				<src, dest> the source and destination rectangles of the copy				<mask> the mask rectangle				<mode> transfer mode (e.g. blend)outs: 			nonenotes:			This handles locking, unlocking and setup for you. The rectangle parameters				must all be the same size, but can have different offsets.----------------------------------------------------------------------------------------*/void	ZGWorld::CopyOutThroughMask( const BitMap* destBits,									 ZGWorld* maskGW,									 const Rect* src,									 const Rect* mask,									 const Rect* dest,									 const short mode ){	Boolean			bitCopy;	PixMapHandle	sp, mp;		FailNILParam( maskGW );		bitCopy = ( maskGW->GetDepth() == 1 );	sp = GetPixMap( TRUE );	mp = maskGW->GetPixMap( TRUE );		if ( bitCopy )		CopyMask((BitMap*) *sp, (BitMap*) *mp, destBits, src, mask, dest );	else		CopyDeepMask((BitMap*) *sp, (BitMap*) *mp, destBits, src, mask, dest, mode, NULL );			Unlock();	maskGW->Unlock();}									 												/*--------------------------------***  CopyOutToMask  ***------------------------------*//*access:			public	overrides:description: 	create a 1-bit mask from an imageins: 			<destGW> mask created in this objectouts: 			nonenotes:			all colours except white set a 1 in the resulting mask.----------------------------------------------------------------------------------------*/void	ZGWorld::CopyOutToMask( ZGWorld* destGW ){	Rect	src, dest;		FailNILParam( destGW );		destGW->InstallSearchProc( sMaskProc );		GetSize( &src );	destGW->GetSize( &dest );		CopyOut( destGW, &src, &dest );		destGW->RemoveSearchProc( sMaskProc );}	/*----------------------------------***  MakePicture  ***-------------------------------*//*access:			public	overrides:description: 	convert the image into a Pictureins: 			<toFitRect> a bounding rectangle for the picture, or NULL				<withMaskRgn> if not NULL, apply this maskouts: 			a fully formed PicHandle containing the imagenotes:			if you do not pass arect, resulting image has original size. If you do,				image is scaled to fit this rect, preserving its aspect ratio----------------------------------------------------------------------------------------*/PicHandle	ZGWorld::MakePicture( const Rect* toFitRect, RgnHandle withMaskRgn ){	// turns the whole GWorld into a picture and returns it. Be prepared for this to fail!		PicHandle	p = NULL;	CGrafPtr	savePort;	GDHandle	saveDevice;	Rect		src, pr;	short		mode = srcCopy;		GetSize(&pr);	src = pr;		if ( toFitRect )	{		// we want to make a picture of the size passed in, but which contains the		// whole image. The image will be scaled to fit, preserving the aspect ratio		// of the original image. This is useful for making thumbnails.			Scale2Rects( &pr, toFitRect );		mode |= ditherCopy;	}		SetPortToGW( &savePort, &saveDevice );	SetPortBlackWhite();			try	{		FailNIL( p = OpenPicture( &pr ));			// copy the GWorld to itself- this records the CopyBits in the picture				CopyIn( this, &src, &pr, mode, withMaskRgn );	// this call will lock and unlock the GWorld as needed		ClosePicture();	}	catch( ZoopError err )	{		if ( p )		{			ClosePicture();			KillPicture( p );			p = NULL;		}		Unlock();		SetGWorld( savePort, saveDevice );				throw err;	}		Unlock();	SetGWorld( savePort, saveDevice );	// check that the picture is well-formed.		pr = (*p)->picFrame;		if ( EmptyRect( &pr ))	{		KillPicture( p );		FailOSErr( kGWBadPictureErr );	}		if ( GetHandleSize((Handle) p) <= sizeof( Picture ))	{		KillPicture( p );		FailOSErr( kGWBadPictureSizErr );	}		// only return a good picture, thanx!		return p;}/*----------------------------------***  MakePicture  ***-------------------------------*//*access:			public	overrides:description: 	convert the image into a Pictureins: 			<srcRect> portion of image to use				<destRect> bounding rectangle of resulting pictureouts: 			a fully formed PicHandle containing the imagenotes:			image will be scaled without preserving aspect ratio of src and dest				rects are different sizes----------------------------------------------------------------------------------------*/PicHandle		ZGWorld::MakePicture( const Rect* srcRect, const Rect* destRect ){	// makes picture of <srcRect> to fit <destRect>		PicHandle	p = NULL;	CGrafPtr	savePort;	GDHandle	saveDevice;	Rect		pr;	SetPortToGW( &savePort, &saveDevice );	SetPortBlackWhite();	try	{		FailNIL( p = OpenPicture( destRect ));			// copy the GWorld to itself- this records the CopyBits in the picture				CopyIn( this, srcRect, destRect );	// this call will lock and unlock the GWorld as needed		ClosePicture();	}	catch( ZoopError err )	{		if ( p )		{			ClosePicture();			KillPicture( p );			p = NULL;		}		Unlock();		SetGWorld( savePort, saveDevice );				throw err;	}		SetGWorld( savePort, saveDevice );			pr = (*p)->picFrame;		if ( EmptyRect( &pr ))	{		KillPicture( p );		FailOSErr( kGWBadPictureErr );	}		if ( GetHandleSize((Handle) p) <= sizeof( Picture ))	{		KillPicture( p );		FailOSErr( kGWBadPictureSizErr );	}		// only return a good picture, thanx!		return p;}/*----------------------------------***  CopyPicture  ***-------------------------------*//*access:			public	overrides:description: 	copy a pictur einto the GWorldins: 			<aPicture> the picture to draw				<destRect> where to draw the image within the GWorld (NULL for whole image)				<dither> TRUE to dither the picture if drawing to a shallower bitdepthouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZGWorld::CopyPicture( PicHandle aPicture, const Rect* destRect, Boolean dither ){	// draw the picture into the GWorld. If destRect is NULL, use the picture's frame, offset to	// 0,0 as the rect. This is a typical case.		Rect		dr;	CGrafPtr	savePort;	GDHandle	saveDevice;		if ( destRect == NULL )	{		dr = (*aPicture)->picFrame;		OffsetRect( &dr, -dr.left, -dr.top );	}	else		dr = *destRect;			// lock the GWorld and draw the picture		Lock();	SetPortToGW( &savePort, &saveDevice );		if ( dither )		InstallDitherProc((CGrafPtr) CURRENTPORT );		DrawPicture( aPicture, &dr );	Unlock();		if ( dither )		RemoveDitherProc((CGrafPtr) CURRENTPORT );		SetGWorld( savePort, saveDevice );}		 /*----------------------------------***  SetPortToGW  ***-------------------------------*//*access:			public	overrides:description: 	set the GWorld object as the current port, ready for drawing into itins: 			<savePort> receives the port set originally				<savedDevice> receives the GDevice set originallyouts: 			nonenotes:			after drawing, set the port and device back using SetGWorld and the				port and device returned from this method----------------------------------------------------------------------------------------*/void	ZGWorld::SetPortToGW( CGrafPtr* savedPort, GDHandle* savedDevice ){	// sets this object to be the current port, returning the previous setting. After a	// sequence of calls, you should call SetGWorld() with the saved items. The copy functions	// do this for you, so it is not required for those.		GetGWorld( savedPort, savedDevice );	SetGWorld( gw, NULL );		// also set the gdRefCon to point to this, in case anyone (such as a search proc)	// wants to find it		GDHandle	gdH = GetGWorldDevice( gw );	(*gdH)->gdRefCon = (long) this;}/*--------------------------------***  SetPortColours  ***------------------------------*//*access:			public	overrides:description: 	set the fore and back colours of the GWorld's portins: 			<aFore, aBack> colours to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::SetPortColours( const RGBColor* aFore, const RGBColor* aBack ){	// sets the GWorld's fore and back colours to those passed		CGrafPtr	savePort;	GDHandle	saveDevice;		SetPortToGW( &savePort, &saveDevice );	RGBForeColor( aFore );	RGBBackColor( aBack );	SetGWorld( savePort, saveDevice );}/*--------------------------------***  SetPortColours  ***------------------------------*//*access:			public	overrides:description: 	set the fore and back colours of the GWorld's port to black and whiteins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::SetPortColours(){	SetPortColours( &gBlack, &gWhite );}/*--------------------------------***  GetPortColours  ***------------------------------*//*access:			public	overrides:description: 	get the fore and back colours of the GWorld's portins: 			<aFore, aBack> receive current coloursouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::GetPortColours( RGBColor* aFore, RGBColor* aBack ){	// returns the current port colours.		CGrafPtr	savePort;	GDHandle	saveDevice;		SetPortToGW( &savePort, &saveDevice );	GetForeColor( aFore );	GetBackColor( aBack );	SetGWorld( savePort, saveDevice );}/*-----------------------------------***  CopyIcon  ***---------------------------------*//*access:			public	overrides:description: 	draw an icon into the GWorldins: 			<anIcon> colour icon to draw				<dest> where in the GWorld to draw it				<align> icon alignment to use				<transform> icon transform to useouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::CopyIcon( CIconHandle anIcon, const Rect* dest, const short align, const short transform ){	CGrafPtr	savePort;	GDHandle	saveDevice;		FailNILParam( anIcon );		Lock();	SetPortToGW( &savePort, &saveDevice );	PlotCIconHandle( dest, align, transform, anIcon );	Unlock();	SetGWorld( savePort, saveDevice );}/*-----------------------------------***  CopyIcon  ***---------------------------------*//*access:			public	overrides:description: 	draw an icon into the GWorldins: 			<iconID> resource ID of an icon family				<dest> where in the GWorld to draw it				<align> icon alignment to use				<transform> icon transform to useouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::CopyIcon( const short iconID, const Rect* dest, const short align, const short transform ){	CIconHandle		anIcon;		// is there a 'cicn' with this ID?		anIcon = GetCIcon( iconID );		if ( anIcon )	{		// yep- plot it			CopyIcon( anIcon, dest, align, transform );		DisposeCIcon( anIcon );	}	else	{		// no- is there an ICN# with this ID?				CGrafPtr		savePort;		GDHandle		saveDevice;		OSErr			theErr;							Lock();		SetPortToGW( &savePort, &saveDevice );				theErr = PlotIconID( dest, align, transform, iconID );				// if the error is not noErr, then the icon couldn't be found, so		// try looking for a plain ICON resource				if ( theErr )		{			Handle		iconH = GetIcon( iconID );						if ( iconH )			{				PlotIcon( dest, iconH );				ReleaseResource( iconH );			}		}				Unlock();			SetGWorld( savePort, saveDevice );	}}/*------------------------------------***  Invert  ***----------------------------------*//*access:			public	overrides:description: 	invert the imageins: 			<maskRgn> invert only this region, or NULL for whole imageouts: 			nonenotes:			WARNING: if image is indexed (<= 8 bits), maskRgn is ignored----------------------------------------------------------------------------------------*/void	ZGWorld::Invert( RgnHandle maskRgn ){	CGrafPtr		savePort;	GDHandle		saveDevice;	PixMapHandle	pp;	Rect			r;		// if depth is <16, invert colours in table rather than image		if ( GetDepth() < 16 && GetDepth() > 1 )	{		CTabHandle	ct;		short		i;				ct = GetColours();				for ( i = 0; i <= (*ct)->ctSize; i++ )		{			(*ct)->ctTable[i].rgb.red 	^= 0xFFFF;			(*ct)->ctTable[i].rgb.green ^= 0xFFFF;			(*ct)->ctTable[i].rgb.blue 	^= 0xFFFF;		}				CTabChanged( ct );	}	else	{		Lock();		SetPortToGW( &savePort, &saveDevice );					pp = GetPixMap();		GetSize(&r);				CopyBits((BitMap*) *pp, (BitMap*) *pp, &r, &r, notSrcCopy, maskRgn );				Unlock();		SetGWorld( savePort, saveDevice );	}}/*-------------------------------***  FlipHorizontal  ***-------------------------------*//*access:			public	overrides:description: 	flip the image horizontallyins: 			<maskRgn> flip this area only, or NULL for whole imageouts: 			nonenotes:			if you pass in a mask, the region itself will be flipped as well----------------------------------------------------------------------------------------*/void	ZGWorld::FlipHorizontal( RgnHandle maskRgn ){	if ( maskRgn )		FlipRegion( maskRgn, kFlipHorizontal );			Flip( kFlipHorizontal, maskRgn );		}/*--------------------------------***  FlipVertical  ***--------------------------------*//*access:			public	overrides:description: 	flip the image verticallyins: 			<maskRgn> flip this area only, or NULL for whole imageouts: 			nonenotes:			if you pass in a mask, the region itself will be flipped as well----------------------------------------------------------------------------------------*/void	ZGWorld::FlipVertical( RgnHandle maskRgn ){	if ( maskRgn )		FlipRegion( maskRgn, kFlipVertical );			Flip( kFlipVertical, maskRgn );		}/*------------------------------------***  Flip  ***------------------------------------*//*access:			public	overrides:description: 	flip the image vertically or horizontallyins: 			<flipDir> 1 = flip horizontal, 2 = flip vertical				<mask> flip only in this areaouts: 			nonenotes:			creates temorary copy of this, so may require mucho memory----------------------------------------------------------------------------------------*/ void	ZGWorld::Flip( const short flipDir, RgnHandle mask ){	Rect		src, dest, fr;	short		loops, i;		ZGWorld*	temp;		SetWatchCursor();	FailNIL( temp = new ZGWorld( this ));		// copy image back to this, one h or v strip at a time according to direction		GetSize( &fr );	src = dest = fr;		if ( flipDir == kFlipHorizontal )	{		src.right = src.left + 1;		dest.left = dest.right - 1;		loops = fr.right - fr.left;		}	else	{		src.bottom = src.top + 1;		dest.top = dest.bottom - 1;		loops = fr.bottom - fr.top;		}		for( i = 0; i < loops; i++ )	{		CopyIn( temp, &src, &dest, srcCopy, mask );				if ( flipDir == kFlipHorizontal )		{			OffsetRect( &src, 1, 0 );			OffsetRect( &dest, -1, 0 );		}		else		{			OffsetRect( &src, 0, 1 );			OffsetRect( &dest, 0, -1 );		}	}		FORGETOBJECT( temp );}/*-----------------------------***  InstallSearchProc  ***------------------------------*//*access:			public	overrides:description: 	install a colour search procedure into the GWorld's deviceins: 			<aSearchProc> UPP to the function to installouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::InstallSearchProc( ColorSearchUPP aSearchProc ){	CGrafPtr	savePort;	GDHandle	saveDevice;		SetPortToGW( &savePort, &saveDevice );	AddSearch( aSearchProc );	SetGWorld( savePort, saveDevice );}/*------------------------------***  RemoveSearchProc  ***------------------------------*//*access:			public	overrides:description: 	remove a colour search procedure into the GWorld's deviceins: 			<aSearchProc> UPP to the function to removeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::RemoveSearchProc( ColorSearchUPP aSearchProc ){	CGrafPtr	savePort;	GDHandle	saveDevice;		SetPortToGW( &savePort, &saveDevice );	DelSearch( aSearchProc );	SetGWorld( savePort, saveDevice );}/*--------------------------------***  SetOpColour  ***---------------------------------*//*access:			public	overrides:description: 	set the colour to use for arithmetic transfer operationsins: 			<rgb> op colour to useouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::SetOpColour( const RGBColor* rgb ){	CGrafPtr	savePort;	GDHandle	saveDevice;		SetPortToGW( &savePort, &saveDevice );	OpColor( rgb );	SetGWorld( savePort, saveDevice );}/*--------------------------------***  SetOpColour  ***---------------------------------*//*access:			public	overrides:description: 	set the colour to use for arithmetic transfer operationsins: 			<percentGray> make it gray based on 100 = white, 0 = blackouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::SetOpColour( const short percentGray ){	RGBColor	rgb;			rgb.red = rgb.green = rgb.blue = (( 65535L * (long) percentGray ) / 100L );	SetOpColour( &rgb );}/*-------------------------------***  MakeMacGWorld  ***--------------------------------*//*access:			protected	overrides:description: 	create toolbox GWorldins: 			<aSize> size to make it				<aDepth> bit depth to make it				<aCTable> the colours to use				<makeTemp> make it in temporary memory.outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::MakeMacGWorld( const Rect& aSize,								const short aDepth,								const CTabHandle aCTable,								const Boolean makeTemp ){	// creates the GWorld. Initially, the pixels are unlocked and non-purgeable.			GDHandle		gdH;	GWorldFlags		gwFlags = 0;	short           gwDepth;	Boolean         madeCTable = FALSE;	CTabHandle      ct;	RgnHandle       temp;		if ( makeTemp )		gwFlags = useTempMem;			// interpret the depth parameter- we can force grey by passing the appropriate depth,	// as long as the colour table has not been passed already		gwDepth = aDepth;	ct = aCTable;		if (( aDepth == ctSixteenGreys ||	     aDepth == ct256Greys ) && aCTable == NULL )	{	    gwDepth = aDepth - 32;		    ct = GetCTable( aDepth );	    madeCTable = TRUE;	}		FailOSErr( NewGWorld( &gw, gwDepth, &aSize, ct, NULL, gwFlags ));	pState = GetPixelsState( GetGWorldPixMap( gw ));		gdH = GetGWorldDevice( gw );	(*gdH)->gdRefCon = (long) this;		// set initial clip and vis regions to the bounds		FailNIL( temp = NewRgn());		RectRgn( temp, &aSize );	SETPORTVISRGN( gw, temp );	SETPORTCLIPRGN( gw, temp );		if ( madeCTable )	    DisposeCTable( ct );	    	DisposeRgn( temp );}/*----------------------------***  MakeGWorldFromPicture  ***---------------------------*//*access:			protected	overrides:description: 	create toolbox GWorld based on image stored in a pictureins: 			<aPic> picture to base it on				<makeTemp> make it in temporary memory.				<depth> desired depth (0 = use picture's depth)outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::MakeGWorldFromPicture( const PicHandle aPic, const Boolean makeTemp, const short depth ){	// makes a GWorld that matches the picture's dimensions and draws the picture there		char		pHState;	Rect		aSize;	short		aDepth;	CTabHandle	aCTable = NULL;	Boolean		dither = FALSE;		pHState = HGetState((Handle) aPic );	HNoPurge((Handle) aPic );		try	{		GetPicParams( aPic, &aSize, &aDepth, &aCTable );				// if depth less than picture, install dither proc		// passing a depth of 0 means use picture's depth				if (( depth < aDepth ) && ( depth != 0 ))		{			aDepth = depth;			dither = TRUE;						// need to use a different CTable in this case						if ( aCTable )			{				DisposeCTable( aCTable );				aCTable = NULL;			}						if ( depth < 16 )					aCTable = GetCTable( depth );		}				MakeMacGWorld( aSize, aDepth, aCTable, makeTemp );				// draw the picture in the GWorld				Clear();		CopyPicture( aPic, &aSize, dither );		}	catch( ZoopError err )	{		if ( aCTable )			DisposeCTable( aCTable );				HSetState((Handle) aPic, pHState );				throw err;	}	if ( aCTable )		DisposeCTable( aCTable );		HSetState((Handle) aPic, pHState );}/*---------------------------------***  SetMacGWorld  ***-------------------------------*//*access:			public	overrides:description: 	use the object interface to an existing toolbox GWorldins: 			<aGW> GWorld to take overouts: 			nonenotes:			rarely used - recommended not to unless you are sure----------------------------------------------------------------------------------------*/void	ZGWorld::SetMacGWorld( GWorldPtr aGW ){	gw = aGW;}/*--------------------------------***  WriteToStream  ***-------------------------------*//*access:			public	overrides:description: 	write complete offscreen image to a streamins: 			<aStream> stream to write toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::WriteToStream( ZStream* aStream ){	// in order to stream a GWorld, we need to save sufficient parameters from the pixMap	// to specify the image, plus the image data itself. This amounts to quite a lot!	#if _MACZOOP_STREAMS	PixMapHandle	pp;		pp = GetPixMap( TRUE );		try	{		aStream->WriteRect( &(*pp)->bounds );		aStream->WriteShort((*pp)->pixelSize );		aStream->WriteHandle((Handle)(*pp)->pmTable );		aStream->WriteChar( inTempMem );				// additional pixmap parameters		aStream->WriteShort((*pp)->rowBytes );		aStream->WriteShort((*pp)->pixelType );		aStream->WriteShort((*pp)->cmpCount );		aStream->WriteShort((*pp)->cmpSize );		aStream->WriteLong((long)(*pp)->hRes );		aStream->WriteLong((long)(*pp)->vRes );		// stream out the actual pixels				aStream->WriteData((*pp)->baseAddr, GetImageMemSize());	}	catch( ZoopError err )	{		Unlock();		throw err;	}		Unlock();#endif}/*-------------------------------***  ReadFromStream  ***-------------------------------*//*access:			public	overrides:description: 	read complete offscreen image from a streamins: 			<aStream> stream to readouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::ReadFromStream( ZStream* aStream ){#if _MACZOOP_STREAMS	Rect		br;	short		depth, rb, pt, cc, cs;	CTabHandle	ct;	long		ctm;	Fixed		hr, vr;		aStream->ReadRect( &br );	aStream->ReadShort( &depth );	aStream->ReadHandle((Handle*) &ct );	aStream->ReadChar((char*) &inTempMem );		MakeMacGWorld( br, depth, ct, inTempMem );		if ( ct )		DisposeHandle((Handle) ct );		// now check the parameters and stream in the pixel data		PixMapHandle	pp = GetPixMap( TRUE );		aStream->ReadShort( &rb );	aStream->ReadShort( &pt );	aStream->ReadShort( &cc );	aStream->ReadShort( &cs );	aStream->ReadLong((long*) &hr );	aStream->ReadLong((long*) &vr );		(*pp)->hRes = hr;	(*pp)->vRes = vr;		// the crucial thing is that the pixel data saved and the amount of space available	// in the GWorld to store them is the same. We can be sure about the bounds rect since	// we explicitly passed it, so we only need to compare rowBytes.		if ( rb == (*pp)->rowBytes )		aStream->ReadData((*pp)->baseAddr, &ctm );	else	{		// if the rowBytes didn't match, we're up a pole. However, in order to be as graceful		// as possible, we skip the image data in the stream in order to keep things going		// as best we can. OK, the image will be blank, but nothing very bad will happen. In		// normal use this should never occur.				aStream->ReadLong( &ctm );		aStream->Skip( ctm );	}		Unlock();#endif	}/*-----------------------------***  GetDebugInfoString  ***-----------------------------*//*access:			public	overrides:description: 	return basic info to insnpectorins: 			<a> receives stringouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::GetDebugInfoString( Str255 s ){	Rect	r;	short	d;	Str15	temp;		GetSize( &r );		NumToString( r.right - r.left, s );	ConcatPStrings( s, "\p x " );	NumToString( r.bottom - r.top, temp );	ConcatPStrings( s, temp );	ConcatPStrings( s, "\p; bit depth = " );	d = GetDepth();		NumToString( d, temp );	ConcatPStrings( s, temp );}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			public	overrides:description: 	report data members to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorld::ReportFields(){	ZObject::ReportFields();	XSHOWFIELD( gw, ft_CGrafPtr );	XSHOWFIELD( pState, ft_unsignedshort );	XSHOWFIELD( lockLevel, ft_signedshort );	XSHOWFIELD( inTempMem, ft_boolean );		Rect	r;	short	depth;	long	mem;			GetSize( &r );	SHOWFIELD( "->GetSize()", r, ft_Rect );		depth = GetDepth();	SHOWFIELD( "->GetDepth()", depth, ft_signedshort );		mem = GetImageMemSize();	SHOWFIELD( "->GetImageMemSize()", mem, ft_Size );		depth = GetColourInfo();	SHOWFIELD( "->GetColourInfo()", depth, ft_unsignedshort );		}#pragma mark -/*----------------------------------***  PPGetBits  ***---------------------------------*//*access:			static callback	overrides:description: 	bottleneck proc used to extract picture data from PicHandleins: 			outs: 			nonenotes:			----------------------------------------------------------------------------------------*/typedef struct{	Boolean		iValid;			// TRUE if bits proc was called at least once	short		iDepth;			// depth of the bitmap or pixmap	CTabHandle	iColours;		// the colour table of the pixmap (a copy)}PPicInfo;// global needed to communicate between method and bottleneck procstatic	PPicInfo	gPPInfo;// bottleneck proc to extract the infostatic  pascal void	PPGetBits( BitMap *srcBits, const Rect *srcRect, const Rect *dstRect, short mode, RgnHandle maskRgn );static  pascal void	PPGetBits( BitMap *srcBits, const Rect *srcRect, const Rect *dstRect, short mode, RgnHandle maskRgn ){	// first let's see if this is a colour pixmap or not		PixMapPtr	pp;	Boolean		isColour;		pp = (PixMapPtr) srcBits;		// if the top bit of rowBytes is set, this is a colour port		isColour = ((pp->rowBytes & 0x8000) != 0);		if (isColour)	{		// Set the depth of the global record if this pixmap's depth		// is greater than any seen so far				if (pp->pixelSize > gPPInfo.iDepth)			gPPInfo.iDepth = pp->pixelSize;					// if the record has not been previously set, set up the colour table				if (!gPPInfo.iValid && pp->pmTable)		{			gPPInfo.iColours = pp->pmTable;					// make a copy of the table					HandToHand((Handle*) &gPPInfo.iColours);			gPPInfo.iValid = TRUE;	// don't set the colours again		}	}		// note we do not call StdBits, since we are only interested in the information, and couldn't	// really care less about actually drawing it. This also results in much faster operation.}/*---------------------------------***  GetPicParams  ***-------------------------------*//*access:			global	overrides:description: 	get picture parameters (size, depth, colours)ins: 			<aPic> picture to analyse				<aDepth> receives bit depth of image				<aCTable> receives the colour table if anyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	GetPicParams(PicHandle aPic, Rect* aSize, short* aDepth, CTabHandle* aCTable){	// return the parameters of the picture. This can be problematic- the picture encapsulates its data in	// such a way that quickly getting depth and colours is not straightforward. Also, a given picture may	// not contain a pixmap and so such terms are meaningless. However, we do our best. This method works by	// installing a bottleneck procedure into a temporary port and looking for CopyBits opcodes. It then	// extracts the parameters passed to that call (depth and colours). If no colour pixmap is encountered,	// the depth returned is always 1, and the colours NULL. The size returned is always valid.		CGrafPtr	savePort, tPort;	CQDProcs	tProcs;	Rect		r;	RgnHandle   temp;		// the size is the one piece of info we can extract directly		r = (*aPic)->picFrame;	OffsetRect(&r, -r.left, -r.top);	*aSize = r;		// open a port		GetPort((GrafPtr*) &savePort);	tPort = MZNewPort();	SetPort((GrafPtr) tPort);		// make the clip and vis regions empty so that the call to draw picture doesn't draw anything on	// the screen by mistake		FailNIL( temp = NewRgn());	SETPORTVISRGN( tPort, temp );	SETPORTCLIPRGN( tPort, temp );	DisposeRgn( temp );		// install a bottleneck procedure for intercepting CopyBits		SetStdCProcs( &tProcs );		// make the StdBits pointer point to our function		tProcs.bitsProc = NewQDBitsUPP((QDBitsProcPtr) PPGetBits );	gPPInfo.iValid = FALSE;	gPPInfo.iDepth = 1;	gPPInfo.iColours = NULL;		// put it in the port#if OPAQUE_TOOLBOX_STRUCTS	SetPortGrafProcs( tPort, &tProcs );#else	tPort->grafProcs = &tProcs;#endif		// now draw the picture in the port, which should result in our bottleneck getting called at least once,	// provided the picture does contain a pixmap or bitmap.		DrawPicture( aPic, &r );		// now we should have the required info in the global gPPInfo record. First however, lets clean up.	#if OPAQUE_TOOLBOX_STRUCTS	SetPortGrafProcs( tPort, NULL );#else	tPort->grafProcs = NULL;#endif		DisposeQDBitsUPP( tProcs.bitsProc );	MZDisposePort( tPort );	SetPort((GrafPtr) savePort );		// now simply return the data		*aDepth = gPPInfo.iDepth;	*aCTable = gPPInfo.iColours;}/*----------------------------------***  FlipRegion  ***--------------------------------*//*access:			global	overrides:description: 	flip a regionins: 			<aRgn> region to flip				<flipDire> direction of flip: 1 = horiz, 2 = vertical.outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void	FlipRegion( RgnHandle aRgn, const short flipDir ){	// flip a region horizontally or vertically. Converts to a bitmap,	// flips it and converts back.		Rect		r;	ZGWorld*	rMap;	CGrafPtr	savePort;	GDHandle	saveDev;		FailNILParam( aRgn );		r = *REGIONBOUNDINGBOX( aRgn );	FailOSErr( EmptyRect( &r )? paramErr: noErr );		// if the region is rectangular, don't bother		if ( GetHandleSize((Handle) aRgn ) != 10 )	{			// make 1-bit world in temp memory				FailNIL( rMap = new ZGWorld( r, 1, NULL, TRUE ));				try		{			rMap->Lock();			rMap->SetPortToGW( &savePort, &saveDev );						PaintRgn( aRgn );						// flip it						if ( flipDir == kFlipHorizontal )				rMap->FlipHorizontal();			else				rMap->FlipVertical();							// convert back to region			PixMapHandle	pp = rMap->GetPixMap();			FailOSErr( BitMapToRegion( aRgn, (BitMap*) *pp ));						rMap->Unlock();			SetGWorld( savePort, saveDev );			FORGETOBJECT( rMap );		}		catch( ZoopError err )		{			rMap->Unlock();			SetGWorld( savePort, saveDev );			FORGETOBJECT( rMap );						throw err;		}	}}/*--------------------------------***  MaskSearchProc  ***------------------------------*//*access:			static callback	overrides:description: 	search proc used to create image maskins: 			<rgb> color to examine				<pos> position of colour in tableouts: 			TRUEnotes:			----------------------------------------------------------------------------------------*/pascal Boolean	ZGWorld::MaskSearchProc( RGBColor* rgb, long* pos ){	if ( rgb->red   == 0xFFFF &&		 rgb->green == 0xFFFF &&		 rgb->blue  == 0xFFFF )		*pos = 0;	else		*pos = 1;			return TRUE;}