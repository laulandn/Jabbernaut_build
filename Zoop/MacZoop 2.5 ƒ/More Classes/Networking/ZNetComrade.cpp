/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZNetComrade.cpp 	-- wrapper object for PPc Toolbox port******			© 1998, Graham Cox*****************************************************************************************************/#include	"ZNetComrade.h"#include	"MacZoop.h"#include	<gestalt.h>static pascal Boolean	StdBrowserFilter( LocationNamePtr name, PortInfoPtr port );static OSType			gBrowsePortType;static OSType			gBrowsePortCreator;static PPCFilterUPP		gStdBrowserFilter = NewPPCFilterProc( StdBrowserFilter );/*------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZNetComrade::ZNetComrade( OSType aPortType, OSType aPortCreator, Str31 friendlyName )	: ZComrade(){	portType = aPortType;		if ( aPortCreator == 0 )		portCreator = gAppSignature;	else		portCreator = aPortCreator;		sessionRefNum = 0;	userRefcon = 0;	localPortRefNum = 0;	rxBuffer = NULL;	status = ppcDormant;	ppcwr.ioResult = 0;		actAsServer = FALSE;	remoteInfoValid = FALSE;	writeChannelClear = TRUE;		CheckAndInitialisePPC();	OpenPort( friendlyName );		FailNIL( rxBuffer = NewPtr( kReceiveBufferSize ));}/*-------------------------------***  DESTRUCTOR  ***----------------------------------*/ZNetComrade::~ZNetComrade(){	ClosePort();		if ( rxBuffer )		DisposePtr( rxBuffer );}/*----------------------------***  WAITFORCONNECTION  ***-------------------------------*//*Establish a wait for a remote app to connect.----------------------------------------------------------------------------------------*/void		ZNetComrade::WaitForConnection(){	// If you're a server, call this to wait for a connection request from a client. This	// completes immediately, so you must make repeated calls to Poll() until the status changes	// to ppcConnected. Once connected, you can't call this again unless you disconnect first.		if ( status == ppcInitialised )	{		ppc.informParam.ioCompletion = NULL;		ppc.informParam.portRefNum = localPortRefNum;		ppc.informParam.autoAccept = TRUE;		ppc.informParam.portName = &remotePortInfo.name;		ppc.informParam.locationName = &remoteLocation;		ppc.informParam.userName = NULL;				FailOSErr( PPCInform((PPCInformPBRec*) &ppc, TRUE ));			status = ppcWaitingForConnection;		actAsServer = TRUE;	}}/*-----------------------------------***  POLL  ***-------------------------------------*//*Call continously to give time----------------------------------------------------------------------------------------*/void		ZNetComrade::Poll(){	// call repeatedly while waiting for a connection to occur, or for a read or write to	// complete. In other words, all the time.		switch ( status )	{		case ppcWaitingForConnection:			if ( ppc.informParam.ioResult != 1 )			{				// in case this failed:								status = ppcInitialised;								// something's happened- what is it?								FailOSErr( ppc.informParam.ioResult );								sessionRefNum = ppc.informParam.sessRefNum;				userRefcon = ppc.informParam.userData;						status = ppcConnected;								// as soon as we're connected, start listening for data								StartReading();								// tell anyone who's interested that we're now communicating:								writeChannelClear = TRUE;								ZComrade::SendMessage( kPPCMsgConnectionMade, NULL );				ZComrade::SendMessage( kPPCMsgClearToSend, NULL );			}			break;					case ppcReceiving:			if ( ppc.readParam.ioResult != 1 )			{				status = ppcConnected;								if ( ppc.readParam.ioResult == sessClosedErr )				{					// the session was terminated by the other party, so resume					// waiting for a new connection										Disconnect();										SendMessage( kPPCMsgConnectionBroken, NULL );									status = ppcInitialised;										if ( actAsServer )						WaitForConnection();				}				else				{					// what was received? We broadcast a message to say we have something,					// and tell the world how much data there is. The data can then be					// extracted as needed from the buffer. n.b. informants are expected					// to read this data in response, since the buffer could be overwritten					// straight away.										if ( ppc.readParam.ioResult == noErr )					{						RxDataInfo		ri;											ri.type   = ppc.readParam.blockType;						ri.length = ppc.readParam.actualLength;						ri.buffer = rxBuffer;											ZComrade::SendMessage( kPPCMsgDataReceived, (void*) &ri );						ZComrade::SendMessage( ri.type, (void*) rxBuffer ); 					}					// go back to listening for more input:										StartReading();				}			}			break;	}		// if a write operation has completed, check for errors:		if ( status >= ppcConnected )	{		if ( ppcwr.ioResult != 1 )		{			writeChannelClear = TRUE;						FailOSErr( ppcwr.ioResult );						// does anybody want to send anything? The channel is available...						ZComrade::SendMessage( kPPCMsgClearToSend, NULL );		}	}}/*----------------------------***  INITIATECONNECTION  ***------------------------------*//*try to connect to a server----------------------------------------------------------------------------------------*/void		ZNetComrade::InitiateConnection( Boolean useSecure ){	// If you're a client, call this to establish a connection with a server.		if ( status == ppcWaitingToConnect )	{		if ( ! remoteInfoValid )			FailOSErr( kRemoteInfoNotValidErr );				Str32	userName;		Boolean	isGuest;				ppc.startParam.ioCompletion = NULL;		ppc.startParam.portRefNum = localPortRefNum;		ppc.startParam.serviceType = ppcServiceRealTime;		ppc.startParam.resFlag = 0;		ppc.startParam.portName = &remotePortInfo.name;		ppc.startParam.locationName = &remoteLocation;		ppc.startParam.userData = portType;				ppc.startParam.userRefNum = 0;		userName[0] = 0;				if ( useSecure )			FailOSErr( StartSecureSession((PPCStartPBRec*) &ppc, userName, TRUE, TRUE, &isGuest, NULL ));		else			FailOSErr( PPCStart((PPCStartPBRec*) &ppc, FALSE ));					sessionRefNum = ppc.startParam.sessRefNum;		status = ppcConnected;				// as soon as we successfully connect, start listening for data:				StartReading();	}}/*--------------------------------***  DISCONNECT  ***----------------------------------*//*disconnect from server----------------------------------------------------------------------------------------*/void		ZNetComrade::Disconnect(){	if ( status > ppcWaitingForConnection )	{		ppc.endParam.ioCompletion = NULL;		ppc.endParam.sessRefNum = sessionRefNum;				PPCEnd((PPCEndPBRec*) &ppc, FALSE );				status = ppcWaitingToConnect;	}}/*----------------------------------***  BROWSE  ***------------------------------------*//*use PPC Browser to pick a server to connect to----------------------------------------------------------------------------------------*/Boolean		ZNetComrade::Browse( OSType portTypes, OSType portCreators ){	// browse for a remote application to connect to. If a type and creator	// is passed, only remote ports matching are displayed.		PPCFilterUPP	filter;	OSErr			err;		if ( portTypes != 0 &&		 portCreators != 0 )	{		gBrowsePortType = portTypes;		gBrowsePortCreator = portCreators;			filter = gStdBrowserFilter;	}	else		filter = NULL;		err = PPCBrowser( "\pChoose a MacZoop Server...", "\pServers",							FALSE, &remoteLocation, &remotePortInfo, filter, NULL );		if ( err == userCanceledErr )		return FALSE;			FailOSErr( err );		// flag that we could use the remote spec to connect	// if we wanted to using InitiateConnection		status = ppcWaitingToConnect;	remoteInfoValid = TRUE;		return TRUE;							}/*---------------------------------***  SENDDATA  ***-----------------------------------*//*pass some data to the remote connection----------------------------------------------------------------------------------------*/void		ZNetComrade::SendData( OSType dataType, Ptr buffer, long dLen ){	if ( status == ppcConnected ||	     status == ppcReceiving )	{		if ( ! writeChannelClear )			FailOSErr( kWriteChannelBusyErr );				ppcwr.ioCompletion = NULL;		ppcwr.sessRefNum = sessionRefNum;		ppcwr.bufferLength = dLen;		ppcwr.bufferPtr = buffer;		ppcwr.more = FALSE;		ppcwr.userData = userRefcon;		ppcwr.blockCreator = portCreator;		ppcwr.blockType = dataType;			FailOSErr( PPCWrite( &ppcwr, TRUE ));				// note that the status is not changed- sending data can occur at any time		// even if we're receiving, since it uses a separate param block.				writeChannelClear = FALSE;	}	}/*-------------------------------***  SENDMESSAGE  ***----------------------------------*//*send a message to the remote connection. This is just a more familiar API call toSendData.----------------------------------------------------------------------------------------*/void		ZNetComrade::SendMessage( long aMsg, void* msgData, long dataSize ){	// overrides ZComrade's SendMessage to send a message to the application previously	// linked to.		SendData( aMsg, (Ptr) msgData, dataSize );}/*-------------------------***  GETREMOTECONNECTIONINFO  ***----------------------------*//*packages the remote conneciton info so you can save it for later re-use.----------------------------------------------------------------------------------------*/Handle		ZNetComrade::GetRemoteConnectionInfo(){	// returns the connection info, if valid. If not, throws exception. This is used to	// save connection data so that you can remake the connection at a later time.		Handle		h;		if ( !remoteInfoValid )		FailOSErr( kRemoteInfoNotValidErr );			FailNIL( h = NewHandle( 0 ));		FailOSErr( PtrAndHand((Ptr) &remoteLocation, h, sizeof( LocationNameRec )));	FailOSErr( PtrAndHand((Ptr) &remotePortInfo, h, sizeof( PortInfoRec )));		return h;}/*-------------------------***  SETREMOTECONNECTIONINFO  ***----------------------------*//*sets the connection info from a previously stored handle----------------------------------------------------------------------------------------*/void		ZNetComrade::SetRemoteConnectionInfo( Handle rcInfo ){	FailNILParam( rcInfo );		// sanity check:		if ( GetHandleSize( rcInfo ) != sizeof( LocationNameRec ) + sizeof( PortInfoRec ))		FailOSErr( kRemoteInfoBadDataErr );			BlockMoveData( *rcInfo, &remoteLocation, sizeof( LocationNameRec ));	BlockMoveData( *rcInfo + sizeof( LocationNameRec ), &remotePortInfo, sizeof( PortInfoRec ));		status = ppcWaitingToConnect;	remoteInfoValid = TRUE;}/*--------------------------------***  OPENPORT  ***------------------------------------*//*Opens the port----------------------------------------------------------------------------------------*/void		ZNetComrade::OpenPort( Str31 friendlyName ){	if ( status == ppcDormant )	{		PPCPortRec		portName;				portName.nameScript = smRoman;				if ( friendlyName )			CopyPStringTrunc( friendlyName, portName.name, 31 );		else			gApplication->GetName( portName.name );				portName.portKindSelector = ppcByCreatorAndType;		portName.u.port.portCreator = portCreator;		portName.u.port.portType = portType;				ppc.openParam.ioCompletion = NULL;		ppc.openParam.serviceType = ppcServiceRealTime;		ppc.openParam.resFlag = 0;		ppc.openParam.portName = &portName;		ppc.openParam.locationName = NULL;		ppc.openParam.networkVisible = TRUE;			FailOSErr( PPCOpen((PPCOpenPBRec*) &ppc, FALSE ));				localPortRefNum = ppc.openParam.portRefNum;				status = ppcInitialised;	}}/*--------------------------------***  CLOSEPORT  ***-----------------------------------*//*ends the session if need be and closes the port----------------------------------------------------------------------------------------*/void	ZNetComrade::ClosePort(){	Disconnect();		if ( status != ppcDormant )	{		ppc.closeParam.ioCompletion = NULL;		ppc.closeParam.portRefNum = localPortRefNum;				PPCClose((PPCClosePBRec*) &ppc, FALSE );				status = ppcDormant;	}}/*-------------------------***  CHECKANDINITIALISEPPC  ***------------------------------*//*inits PPC Toolbox if needed.----------------------------------------------------------------------------------------*/void	ZNetComrade::CheckAndInitialisePPC(){	long	gsResponse;	OSErr	err;		err = Gestalt( gestaltPPCToolboxAttr, &gsResponse );		if ( err == noErr )	{		if ( gsResponse & gestaltPPCSupportsRealTime == 0 )		{			FailOSErr( PPCInit());						err = Gestalt( gestaltPPCToolboxAttr, &gsResponse );		}				// test for appletalk and program linking				if ( gsResponse & gestaltPPCSupportsOutGoing == 0 )			FailOSErr ( kAppletalkNotAvailErr );					if ( gsResponse & gestaltPPCSupportsIncoming == 0 )			FailOSErr( kProgramLinkingNotOnErr );	}}/*------------------------------***  STARTREADING  ***----------------------------------*//*kicks off an asynchronous read----------------------------------------------------------------------------------------*/void	ZNetComrade::StartReading(){	// this should be called to listen for data from the remote end whenever a read completes	// or a connection starts. A write can safely occur while a read is pending.		if ( status == ppcConnected )	{		ppc.readParam.ioCompletion = NULL;		ppc.readParam.sessRefNum = sessionRefNum;		ppc.readParam.bufferLength = GetPtrSize( rxBuffer );		ppc.readParam.bufferPtr = rxBuffer;				FailOSErr( PPCRead((PPCReadPBRec*) &ppc, TRUE ));				status = ppcReceiving;		}}#pragma mark -static pascal Boolean	StdBrowserFilter( LocationNamePtr name, PortInfoPtr port ){	return ( port->name.u.port.portType == gBrowsePortType &&			 port->name.u.port.portCreator == gBrowsePortCreator );	}