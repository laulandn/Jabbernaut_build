/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZPlugInHandler.cp	-- an object for managing plug-ins******			© 1997, Graham Cox*****************************************************************************************************/#include	"ZPlugInHandler.h"#include	"ZProgress.h"#include	"ZObjectArray.cpp"#include	"MacZoop.h"/*------------------------------***  CONSTRUCTOR  ***-----------------------------------*/ZPlugInHandler::ZPlugInHandler( const FSSpec& rootFolder )	: ZFolderScanner( rootFolder ){	FailNIL( itsPlugIns = new ZPlugInList());}/*-------------------------------***  DESTRUCTOR  ***-----------------------------------*/ZPlugInHandler::~ZPlugInHandler(){	if ( itsPlugIns )	{		// close them all, then dispose of them				ZPlugIn*	zp;		short		i;				for( i = 1; i<= itsPlugIns->CountItems(); i++ )		{			zp = itsPlugIns->GetObject( i );						if ( zp )				zp->ClosePlugIn();		}				itsPlugIns->DisposeAll();		ForgetObject( itsPlugIns );	}}/*------------------------------***  INITPLUGINS  ***-----------------------------------*//*	called after making the object to actually load and initialise the plug-ins. The standardbehaviour is to scan the nominated folder and pass each file to Process1File. For each filethe relevant ZPlugIn derived object is made and added to the plug-in list.----------------------------------------------------------------------------------------*/void		ZPlugInHandler::InitPlugIns(){	ScanFolder();		// after scanning, we have a list of raw unopened plug-ins. Now we need to	// initialise them and open them.		ZPlugIn*	zp;	short		i;		for( i = 1; i<= itsPlugIns->CountItems(); i++ )	{		zp = itsPlugIns->GetObject( i );				if ( zp )			zp->InitPlugIn();	}		// and open them all:		for( i = 1; i<= itsPlugIns->CountItems(); i++ )	{		zp = itsPlugIns->GetObject( i );				if ( zp )			zp->OpenPlugIn();	}}/*--------------------------***  SENDMESSAGETOPLUGIN  ***-------------------------------*//*	passes the message and data to the plug-in with id passed. Plug-in IDs range from 1 andare generally in alphabetical order.----------------------------------------------------------------------------------------*/void		ZPlugInHandler::SendMessageToPlugIn( const short plugID, const long message, void* msgData ){	ZPlugIn*	zp;		zp = itsPlugIns->GetObject( plugID );		if ( zp )		zp->CallPlugIn( message, msgData );}/*----------------------------***  SENDMESSAGETOALL  ***--------------------------------*//*sends the same message and data to all of the plug-ins.	----------------------------------------------------------------------------------------*/void		ZPlugInHandler::SendMessageToAll( const long message, void* msgData ){	short	i;		for( i = 1; i <= itsPlugIns->CountItems(); i++ )		SendMessageToPlugIn( i, message, msgData );}/*--------------------------***  BUILDMENUOFPLUGINS  ***--------------------------------*//*builds a menu of the names of the plug-ins. This is one (crude) way of making a user-interface to call the plug-ins from an application, though this is not recommended forsophisticated applications.	----------------------------------------------------------------------------------------*/void		ZPlugInHandler::BuildMenuOfPlugIns( MenuHandle aMenu ){	FailNILParam( aMenu );		if ( itsPlugIns->CountItems() > 0 )	{		ZPlugIn*	zp;		Str255		plName;		short		i, n = CountMenuItems( aMenu );				while( n )			DeleteMenuItem( aMenu, n-- );					for ( i = 1; i <= itsPlugIns->CountItems(); i++ )		{			zp = itsPlugIns->GetObject( i );						if ( zp )			{					zp->GetName( plName );								AppendMenu( aMenu, "\px" );				SetMenuItemText( aMenu, i, plName );			}		}	}}/*------------------------------***  PROCESS1FILE  ***----------------------------------*//*for each plug-in file, make a plug-in object and append to our list.	----------------------------------------------------------------------------------------*/void		ZPlugInHandler::Process1File( const FSSpec& aSpec, const OSType fType ){	// if using progress, set title to something suitable		Str255	phTitle;		if ( useProgressDialog )	{		GetIndString( phTitle, 202, 20 );				itsPD->SetTitle( phTitle );	}		// make a plug-in object and add it to the list		ZPlugIn*	zp = MakePlugIn( aSpec, fType );		if ( zp )	{		itsPlugIns->AppendItem( zp );				// inherit progress bar behaviour				ZFolderScanner::Process1File( aSpec, fType );	}}/*-------------------------------***  MAKEPLUGIN  ***-----------------------------------*//*Make the plug-in object associated with the passed file. You need to override this methodto make useful plug-in objects that implement your desired protocol and plug-in fileformat.	----------------------------------------------------------------------------------------*/ZPlugIn*	ZPlugInHandler::MakePlugIn( const FSSpec& aSpec, const OSType fType ){	ZPlugIn*	zp = NULL;		// make the plug-in object. You need to override this to make objects of your desired	// kind. This makes generic ZPlugIns but they do nothing. Normally you'll check fType	// at least to see if the filetype is what you wanted. It is advisable to make other	// sanity checks on the file format as part of your plug-in protocol.		FailNIL( zp = new ZPlugIn( aSpec ));		return zp;}