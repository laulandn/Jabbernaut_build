/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZCalendarView.cpp		-- view for picking dates******			©2000, Graham Cox*****************************************************************************************************/#include	"ZCalendarView.h"#include	"MacZoop.h"/*--------------------------------***  CONSTRUCTOR  ***-------------------------------*/ZCalendarView::ZCalendarView( ZView* aParent, Rect* aFrame, const Boolean isHandler )	: ZView( aParent, aFrame ){	classID = CLASS_ZCalendarView;		fMondayIsDay1 = FALSE;		SetFontInfo( kFontIDGeneva, 9, 0 );	SetBackColour( &gWhite );	SetForeColour( &gBlack );		Rect	r = *aFrame;	CalcCalendarFrame( &r );	SetSize( r.right, r.bottom );			// set the initial date to the current date		unsigned long	dtSecs;	DateTimeRec		dtRec;		GetDateTime( &dtSecs );	SecondsToDate( dtSecs, &dtRec );	fSelDate = dtRec;		fYear = dtRec.year;	fMonth = dtRec.month;		fDayCell.h = fDayCell.v = 0;		// find the resource ID of the itl1 we are going to use to look up	// the month and day names, etc.		dtSecs = GetScriptVariable( smCurrentScript, smScriptDate );	fItl1ResID = LoWord( dtSecs );		if ( isHandler )	{		SetCanBeHandler( TRUE );		SetStandardBorder( TRUE );	}}/*--------------------------------***  CONSTRUCTOR  ***-------------------------------*/ZCalendarView::ZCalendarView( ZView* aParent, const short viewResourceID )	: ZView( aParent ){	classID = CLASS_ZCalendarView;	fMondayIsDay1 = FALSE;		ViewResInit( viewResourceID );}/*---------------------------------*** DrawContent ***----------------------------------*//*access:			publicoverrides:		description: 	Update the view on demandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::DrawContent(){	Intl1Hndl		iH;	FontInfo		fi;	short			x, y;	Rect			cr, br;	Str15			yStr;	unsigned long	dtSecs, todaySecs;	DateTimeRec		dtRec, today;	unsigned char	dtCache[42], dt;	Style			dtStyle[42];		// precompute the dates for each cell. This allows the drawing to	// go faster, reducing flicker		dtRec.year = fYear;	dtRec.month = fMonth;	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );	dtRec.day -= dtRec.dayOfWeek - 1;	if ( fMondayIsDay1 )		dtRec.day++;			DateToSeconds( &dtRec, &dtSecs );	GetDateTime( &todaySecs );	SecondsToDate( todaySecs, &today );		// OK, we have the record set up for the page we are drawing, so	// calculate the date of each day on the page, plus the drawing	// style to apply for the item		for ( x = 0; x < 42; x++ )	{		SecondsToDate( dtSecs, &dtRec );		dtSecs += kSecondsIn1Day;		dtCache[x] = dtRec.day;				dtStyle[x] = 0;				if ( dtRec.month == fMonth )		{			dtStyle[x] = bold;						if ( dtRec.year  == today.year  &&			     dtRec.month == today.month &&			     dtRec.day   == today.day )			     dtStyle[x] += outline;		}		else		    dtStyle[x] = italic;	}		// set fonts, etc		PenNormal();	if ( IsActive() && IsEnabled())		TextMode( srcOr );	else	{		TextMode( grayishTextOr );		RGBForeColor( &gMidGray );	}	GetFontInfo( &fi );	DrawArrowIcon( 0, FALSE );	DrawArrowIcon( 1, FALSE );		// draw two lines to separate title from cells		GetBounds( &br );	MoveTo( br.left, br.top + kTitleAreaHeight );	Line( br.right - br.left, 0 );	Move( 0, 2 );	Line( -( br.right - br.left ), 0 );		// draw grid lines		RGBForeColor( &gLightGray );				for( x = 1; x < kCellsAcross; x++ )	{		MoveTo( br.left + ( fCellH * x ) - 1, br.top + kTitleAreaHeight + 3 );		LineTo( br.left + ( fCellH * x ) - 1, br.bottom - 1 );	}		for( x = 1; x < kCellsDown; x++ )	{		MoveTo( br.left, br.top + kTitleAreaHeight + ( fCellV * x ) + 2 );		LineTo( br.right - 1, br.top + kTitleAreaHeight + ( fCellV * x ) + 2 );	}		PenNormal();	PrepareForDrawing();		// draw the title above these lines. We obtain the month and day names from the	// current 'intl' resource that the system has set. This means we automatically	// adapt to foreign spellings, etc.		iH = ( Intl1Hndl ) GetResource( 'itl1', fItl1ResID );		if ( iH )	{		// let's detach it so we are safe			DetachResource(( Handle) iH );		FailOSErr( ResError());				// ok, lets build a string with <month>,<year>				Str32	ymStr;				CopyPString((*iH)->months[ fMonth - 1 ], ymStr );		ConcatPStrings( ymStr, "\p, " );		NumToString( fYear, yStr );		ConcatPStrings( ymStr, yStr );		TextFace( bold );		cr = br;		cr.bottom = cr.top + fi.ascent + fi.descent + fi.leading + 2;		InsetRect( &cr, 10, 0 );		TETextBox( &ymStr[1], ymStr[0], &cr, teJustCenter );				// now we draw the initials of the days of the week				TextFace( 0 );		GetFontInfo( &fi );				for ( x = 0; x < 7; x++ )		{			// get the day of the week						if ( fMondayIsDay1 )			{				if ( x == 6 )					CopyPString((*iH)->days[ 0 ], ymStr );				else					CopyPString((*iH)->days[ x + 1 ], ymStr );			}			else				CopyPString((*iH)->days[ x ], ymStr );					// we're only going to draw the first 3 letters, so calculate			// based on these characters only						ymStr[0] = MIN( 3, ymStr[0] );						MoveTo( br.left + ( fCellH * x) + fCellH / 2, br.top + kTitleAreaHeight - fi.descent - fi.leading );			Move( -StringWidth( ymStr ) / 2, 0 );						if (( x == 0 && ! fMondayIsDay1 ) ||				( x == 6 && fMondayIsDay1 ))				RGBForeColor( &gRed );			else				PrepareForDrawing();							DrawString( ymStr );		}				DisposeHandle((Handle) iH );	}		PrepareForDrawing();	SetRect( &cr, 0, 0, fCellH, fCellV );	OffsetRect( &cr, br.left, br.top + kTitleAreaHeight + 3 );	InsetRect( &cr, 1, 1 );		for ( y = 0; y < kCellsDown; y++ )	{		for ( x = 0; x < kCellsAcross; x++ )		{			// get the day corresponding to the cell we are drawing, and the text style			// both are precalculated at the top of this method for speed						dt = dtCache[ y * kCellsAcross + x ];			NumToString( dt, yStr );						if ( x == 0 )				RGBForeColor( &gRed );			else				PrepareForDrawing();			TextFace( dtStyle[ y * kCellsAcross + x ] );			TETextBox( &yStr[1], yStr[0], &cr, teJustCenter );			OffsetRect( &cr, fCellH, 0 );		}				OffsetRect( &cr, -kCellsAcross * fCellH, fCellV );	}		PenNormal();	PrepareForDrawing();		if ( SelectionVisible( TRUE ))		HiliteCell( fDayCell );}/*--------------------------------*** ClickContent ***---------------------------------*//*access:			publicoverrides:		description: 	handle mouse click in the viewins: 			<mouse>, point clicked				<modifiers> modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::ClickContent( const Point mouse, const short modifiers ){	Rect			cr;	Boolean			found = FALSE;	short			x, y;	Point			mp = mouse;		// are we in a hotspot?		if ( ! ClickHots( mouse ))	{		// no, so see if we clicked an item in the date area				do		{			SetRect( &cr, 0, 0, fCellH, fCellV );			OffsetRect( &cr, 0, kTitleAreaHeight + 3 );						// find which cell the mouse click is in						for( y = 0; !found && ( y < kCellsDown ) ; y++ )			{				for ( x = 0; x < kCellsAcross; x++ )				{					if ( PtInRect( mp, &cr ))					{						found = TRUE;						break;					}										OffsetRect( &cr, fCellH, 0 );				}				OffsetRect( &cr, -fCellH * kCellsAcross, fCellV );			}						// change the hilite to the clicked cell. To do this we need to figure out the			// day corresponding to the cell.						if ( found )			{			    Point c;			    			    c.h = x;			    c.v = y - 1;			    			    ChangeSelection( c );			    			    found = FALSE;			}						GetMouse( &mp );		}		while( WaitMouseUp());	}}/*------------------------------------*** Type ***-------------------------------------*//*access:			publicoverrides:		description: 	handle arrow keys in the viewins: 			<theKey>, character typed				<modifiers> modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZCalendarView::Type( const char theKey, const short modifiers ){    Point       c = fDayCell;    Boolean     command;        // preflight the key so we establish the correct context for ZGrafState -    // this is needed because the inherited Type may close the dialog,    // making the graf state restoration invalid.        Focus();    PrepareForDrawing();    FocusForContent();        command = ( modifiers & cmdKey ) == cmdKey;        switch( theKey )        {        case LEFT_ARROW_KEY:            if ( command )                SetPreviousMonth();            else            {                    c.h = MAX( c.h - 1, 0 );                ChangeSelection( c );            }            break;                    case RIGHT_ARROW_KEY:            if ( command )                SetNextMonth();            else            {                c.h = MIN( c.h + 1, 6 );                ChangeSelection( c );            }            break;                    case UP_ARROW_KEY:            c.v = MAX( c.v - 1, 0 );            ChangeSelection( c );            break;                    case DOWN_ARROW_KEY:            c.v = MIN( c.v + 1, 5 );            ChangeSelection( c );            break; 	}		ZView::Type( theKey, modifiers );}/*-----------------------------*** DoSelectionUpdate ***--------------------------------*//*access:			publicoverrides:		description: 	change border when we are made the handlerins: 			<state>, true if we are handling viewouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::DoSelectionUpdate( Boolean state ){	if ( GetParent())	{		GetParent()->Focus();		GetParent()->PrepareForDrawing();		GetParent()->FocusForContent();			Rect	br;			GetFrame( &br );		InsetRect( &br, -1, -1 );			DrawBorder( &br );	}		ZView::DoSelectionUpdate( state );}/*----------------------------------*** SetSize ***-------------------------------------*//*access:			publicoverrides:		description: 	recalc calendar metrics when size changedins: 			<width> new width of view				<height> new height of viewouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::SetSize( const short width, const short height ){	Rect	r;		GetContentRect( &r );		if ( width != r.right || height != r.bottom )	{		ZView::SetSize( width, height );		SetRect( &r, 0, 0, width, height );		CalcCalendarFrame( &r );		PostRefresh();	}}/*--------------------------------*** UpdateMenus ***-----------------------------------*//*access:			publicoverrides:		description: 	enable copy commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::UpdateMenus(){	gMenuBar->EnableCommand( kCmdCopy );		ZView::UpdateMenus();}/*----------------------------------*** DoCopy ***--------------------------------------*//*access:			publicoverrides:		description: 	copy current date to clipboard as 'date' itemins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::DoCopy(){	unsigned long	dt;	DateToSeconds( &fSelDate, &dt );		gClipboard->PutData('date', (Ptr) &dt, sizeof( unsigned long ));		// also put as text	Str255		dtStr;		DateString( dt, longDate, dtStr, NULL );	gClipboard->AppendData( 'TEXT', (Ptr) &dtStr[1], dtStr[0] );}/*--------------------------------*** SetCalendar ***-----------------------------------*//*access:			publicoverrides:		description: 	set the year and month displayedins: 			<aYear>, yesr to display				<aMonth> month to display				<redraw> refresh the viewouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::SetCalendar( const short aYear, const short aMonth, const Boolean reDraw ){	fYear = aYear;	fMonth = aMonth;		if ( reDraw )		PostRefresh();}/*------------------------------***  InitViewFromResource  ***--------------------------*//*access:			publicoverrides:		description: 	initialise the view from data in a 'View' resource handleins: 			<theRes> handle to 'View' resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::InitViewFromResource( Handle theRes ){	FailNILParam( theRes );		ZView::InitViewFromResource( theRes );		CalendarViewTemplateHdl		cvH = (CalendarViewTemplateHdl) theRes;	SetCalendar((*cvH)->year, (*cvH)->month, FALSE );}/*-------------------------------***  CreateViewResource  ***---------------------------*//*access:			publicoverrides:		description: 	Fills in the resource handle according to its templated structureins: 			<resHandle> valid handle of adequate sizeouts: 			nonenotes:			This method should only be used by the RAD tool to create View resources				(not for application use)----------------------------------------------------------------------------------------*/void		ZCalendarView::CreateViewResource( Handle resHandle ){	FailNILParam( resHandle );		if ( GetHandleSize( resHandle ) < sizeof( CalendarViewTemplate ))		FailOSErr( kViewTemplateHandleSizeTooSmallErr );			CalendarViewTemplateHdl		cvH = (CalendarViewTemplateHdl) resHandle;		(*cvH)->year = fYear;	(*cvH)->month = fMonth;	(*cvH)->day = 0;		ZView::CreateViewResource( resHandle );}/*---------------------------------*** CellToDay ***-----------------------------------*//*access:			protectedoverrides:		description: 	determine what date corresponds to the cellins: 			<cellx>, <celly> cell corrdinates				<dtr> receives full dateouts: 			day of weeknotes:			----------------------------------------------------------------------------------------*/short		ZCalendarView::CellToDay( const short cellx, const short celly, DateTimeRec* dtr ){	// return the day corresponding to the cell x,y for the current month and year.		unsigned long	dtSecs;	DateTimeRec		dtRec;		dtRec.year = fYear;	dtRec.month = fMonth;	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );		// the first cell may be several days before this date, so we need to figure out	// how many days so we know what date to use for cell 1.		dtRec.day -= dtRec.dayOfWeek - 1;	if ( fMondayIsDay1 )		dtRec.day++;			DateToSeconds( &dtRec, &dtSecs );		// how many days are we on from this day?		dtSecs += ( kSecondsIn1Day * ( celly * 7 + cellx ));	SecondsToDate( dtSecs, &dtRec );		if ( dtr )		*dtr = dtRec;		return dtRec.day;}/*----------------------------------*** ClickHots ***-----------------------------------*//*access:			protectedoverrides:		description: 	handle click in the arrow hotspotsins: 			<hitPos> mouse pointouts: 			TRUE if hit a hotspotnotes:			----------------------------------------------------------------------------------------*/Boolean		ZCalendarView::ClickHots( Point hitPos ){	Boolean inHot = FALSE;		if ( PtInRect( hitPos, &fHotLeft ))	{		inHot = TrackArrowIcon( hitPos, 0 );				if ( inHot )		{			fMonth--;						if ( fMonth < 1 )			{				fYear--;				fMonth = 12;			}		}	}	else	{		if ( PtInRect( hitPos, &fHotRight ))		{			inHot = TrackArrowIcon( hitPos, 1 );						if ( inHot )				fMonth++;		}	}		if ( inHot )	{		DateTimeRec 	dtRec;		unsigned long	dtSecs;				// validate date/time				dtRec.year = fYear;		dtRec.month = fMonth;		dtRec.day = 1;		dtRec.hour = 0;		dtRec.minute = 0;		dtRec.second = 0;		dtRec.dayOfWeek = 1;				DateToSeconds( &dtRec, &dtSecs );		SecondsToDate( dtSecs, &dtRec );				SendMessage( kMsgNewDaySelected, (void*) dtSecs );		fMonth = dtRec.month;		fYear = dtRec.year;				Focus();		DrawAll();	}	return inHot;}/*--------------------------------*** DrawArrowIcon ***---------------------------------*//*access:			protectedoverrides:		description: 	plot an arrow iconins: 			<which> which arrow to draw (left or right)				<state> pressed or notouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::DrawArrowIcon( const short which, const Boolean state ){	Rect			ir, sr;	unsigned short	arrow[7] = { 0x1818, 0x3C3C, 0x7E5A, 0xFF99, 0x7E5A, 0x3C3C, 0x1818 };	BitMap			abp;		SetRect( &abp.bounds, 0, 0, 16, 7 );	abp.rowBytes = 2;	abp.baseAddr = (Ptr) arrow;		SetRect( &sr, 0, 0, 4, 7 );	ir = sr;		if ( !state )		OffsetRect( &sr, 8, 0 );		if ( which )	{		Rect	br;				GetBounds( &br );				OffsetRect( &ir, br.right - kIconArrowWidth - 2, 2  );		OffsetRect( &sr, 4, 0 );	}	else		OffsetRect( &ir, 2, 2 );		CopyBits( &abp, CURRENTPORTPIXMAP, &sr, &ir, srcCopy, NULL );}/*--------------------------------*** TrackArrowIcon ***--------------------------------*//*access:			protectedoverrides:		description: 	track mousedown in arrow iconsins: 			<hitPt> mouse				<which> which arrow to trackouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean		ZCalendarView::TrackArrowIcon( const Point hitPt, const short which){	Boolean		wasIn = FALSE;	Boolean		isIn;	Rect		tr;	Point		mouse = hitPt;		if ( which )		tr = fHotRight;	else		tr = fHotLeft;			while( WaitMouseUp())	{		GetMouse( &mouse );				isIn = PtInRect( mouse, &tr );			if ( isIn != wasIn )		{			wasIn = isIn;					DrawArrowIcon( which, wasIn );		}	}	return wasIn;}/*------------------------------*** CalcCalendarFrame ***-------------------------------*//*access:			protectedoverrides:		description: 	compute bounds of view and other dimensionsins: 			<toFit> bounds sized to fit this rect (usually the frame passed)outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::CalcCalendarFrame( Rect* toFit ){	Rect	br, itsFrame = *toFit;		OffsetRect( &itsFrame, -itsFrame.left, -itsFrame.top );		// calculate the size of the cells		fCellH = ( itsFrame.right + 1 ) / kCellsAcross;	fCellV = ( itsFrame.bottom - kTitleAreaHeight - 2 ) / kCellsDown;		// the pane needs to be an exact multiple of the cell size, so tweak it:		itsFrame.right = fCellH * kCellsAcross - 1;	itsFrame.bottom = fCellV * kCellsDown + kTitleAreaHeight + 2;		// set up hotspots, etc		GetBounds( &br );	SetRect( &fHotLeft, br.left, br.top, br.left + kIconArrowWidth + 16, br.top + kIconArrowHeight + 8 );	fHotRight = fHotLeft;	OffsetRect( &fHotRight, br.right - kIconArrowWidth - 16, 0 );		*toFit = itsFrame;}/*---------------------------------*** HiliteCell ***-----------------------------------*//*access:			protectedoverrides:		description: 	hilite the cell passedins: 			<aCell> cell to highlightouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZCalendarView::HiliteCell( Point aCell ){	Rect	cr;		SetRect( &cr, 0, 0, fCellH - 1, fCellV - 1 );	OffsetRect( &cr, aCell.h * fCellH, ( aCell.v * fCellV ) + kTitleAreaHeight + 3 );	//InsetRect( &cr, 1, 1 );		SetHiliteMode();	InvertRect( &cr );}/*------------------------------*** SelectionVisible ***--------------------------------*//*access:			protectedoverrides:		description: 	determine if current data sek=lection visible in calendarins: 			<recompute> TRUE to recalculate selection cellouts: 			TRUE if date visiblenotes:			----------------------------------------------------------------------------------------*/Boolean		ZCalendarView::SelectionVisible( Boolean recompute ){	short	 		day1, dayN;	DateTimeRec		d1, dN;	unsigned long	t1, tN, tS;		day1 = CellToDay( 0, 0, &d1 );	dayN = CellToDay( kCellsAcross - 1, kCellsDown - 1, &dN );		DateToSeconds( &d1, &t1 );	DateToSeconds( &dN, &tN );	DateToSeconds( &fSelDate, &tS );		// if the cell is visible, compute its coordinates		if (( tS >= t1 ) && ( tS <= tN ))	{		if ( recompute )		{			fDayCell.h = fSelDate.dayOfWeek - 1;			fDayCell.v = ( tS - t1 ) / ( kSecondsIn1Day * kCellsAcross );		}		return TRUE;	}	else		return FALSE;	}/*-------------------------------*** ChangeSelection ***--------------------------------*//*access:			protectedoverrides:		description: 	switch current selection to the cell passedins: 			<toCell> cell to selectouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZCalendarView::ChangeSelection( Point toCell ){    if ( DeltaPoint( toCell, fDayCell ))    {		// unhilite current cell if visible				if ( SelectionVisible())			HiliteCell( fDayCell );				// hilite new cell				fDayCell = toCell;				HiliteCell( fDayCell );				// tell the world				CellToDay( fDayCell.h, fDayCell.v, &fSelDate );			unsigned long	dt;		DateToSeconds( &fSelDate, &dt );				SendMessage( kMsgNewDaySelected, (void*) dt );		SendMessage( kMsgSignalViewClicked, NULL );    }}/*--------------------------------*** SetNextMonth ***----------------------------------*//*access:			protectedoverrides:		description: 	increment calendar to following monthins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZCalendarView::SetNextMonth(){	DateTimeRec 	dtRec;	unsigned long	dtSecs;		// validate date/time		dtRec.year = fYear;	dtRec.month = ++fMonth;	if ( dtRec.month > 12 )	{	    dtRec.year++;	    dtRec.month = 1;	}	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );		SendMessage( kMsgNewDaySelected, (void*) dtSecs );	fMonth = dtRec.month;	fYear = dtRec.year;		Focus();	DrawAll();}/*-----------------------------*** SetPreviousMonth ***---------------------------------*//*access:			protectedoverrides:		description: 	decrement calendar to previous monthins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZCalendarView::SetPreviousMonth(){	DateTimeRec 	dtRec;	unsigned long	dtSecs;		// validate date/time		dtRec.year = fYear;	dtRec.month = --fMonth;		if ( dtRec.month < 1 )	{	    dtRec.year--;	    dtRec.month = 12;	}	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );		SendMessage( kMsgNewDaySelected, (void*) dtSecs );	fMonth = dtRec.month;	fYear = dtRec.year;		Focus();	DrawAll();}#pragma mark -/*-----------------------------*** CreateNewCalendarView ***----------------------------*//*access:			globaloverrides:		description: 	create calendar view from paramsins: 			<aParent> view's parent				<aFrame> view's frame				<pCount> count of parameters				<params> the paramsouts: 			the created viewnotes:			may be regeistered as dialog item constructor function, params as follows:				params[0] - month to display 1-12 (0 = current month)				params[1] - year to display 1904-2040 (0 = current year)----------------------------------------------------------------------------------------*/ZView*	CreateNewCalendarView( ZView* aParent, Rect* aFrame, const short pCount, long params[] ){	ZCalendarView*	cv;		FailNIL( cv = new ZCalendarView( aParent, aFrame ));		if ( pCount > 0 )		cv->SetCalendar( params[1], params[0] );	return cv;}