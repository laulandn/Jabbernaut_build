/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZTextView.cpp		-- view that implements text editor******			©2000-2001, Max Horn*****************************************************************************************************/#include	"MacZoop.h"#include	"ZTextView.h"#include	"ZUndoTextTask.h"#include	"ZWindow.h"#include	"TextStyleUtils.h"enum{	kTextViewInset	= 3,	kMaxTextSize	= 32767,		kFixedWidth		= 10000};TEClickLoopUPP		ZTextView::fClickLoopUPP = NewTEClickLoopUPP( ZTextView::TEClickLoopProc );ZTextView*			ZTextView::fClickedZTextView;static Boolean		MZTEIsFrontOfLine( short textOffset, TEHandle hTE );static short		MZTEGetLine( short textOffset, TEHandle hTE );static short		MZTEGetOffset(Point theLoc, TEHandle hTE);/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZTextView::ZTextView( ZView* aParent, Rect* aFrame,			const Boolean makeHBar,			const Boolean makeVBar,			const Boolean hasSizeBox )	: ZScrollView( aParent, aFrame, makeHBar, makeVBar, hasSizeBox ){	classID = CLASS_ZTextView;		fMacTE = NULL;		fFlags = kTVEditable | kTVSelectable | kTVGrayInactive;		// If we have a horizontal bar, we just assume that we are meant to be fixed width!	if( makeHBar )		fFlags |= kTVFixedWidth;		fCurrentTask = NULL;	TEViewInit();	SetStandardBorder( TRUE, TRUE );}	/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZTextView::~ZTextView(){	if ( fMacTE )		TEDispose( fMacTE );}	#pragma mark -/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	draw the content of this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::DrawContent(){	Rect	r;		GetTextRect( &r );	(*fMacTE)->txMode = srcOr;			if ( fFlags & kTVGrayInactive )	{		if (! ( IsEnabled() && IsActive()))			(*fMacTE)->txMode = grayishTextOr;	}		TEUpdate( &r, fMacTE );}	#pragma mark -/*------------------------------***  SetViewCursor  ***---------------------------------*//*access:			publicoverrides:		description: 	set the cursor for the viewins: 			<mouse> the point relative to the bounds				<modifiers> the modifier flagsouts: 			nonenotes:			this is only called if this view (and no child) contains the cursor----------------------------------------------------------------------------------------*/void		ZTextView::SetViewCursor( const Point mouse, const short modifiers ){	Rect	viewRect;		GetContentRect( &viewRect );	if ( IsEnabled() && (fFlags & kTVSelectable) && PtInRect( mouse, &viewRect ) )	{        if ( ShouldDrag( mouse, modifiers ))			SetCursorShape( DRAG_CURSOR );		else			SetCursorShape( iBeamCursor );	}	else		ZScrollView::SetViewCursor( mouse, modifiers );}/*--------------------------------***  ClickContent  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to a click in the viewins: 			<mouse> the mouse coordinates local to view				<modifiers> modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::ClickContent( const Point mouse, const short modifiers ){	if ( modifiers & cmdKey )		ClickScroll( mouse );	else if ( IsEnabled() && (fFlags & kTVSelectable) )	{		fClickedZTextView = this;		::TEClick( mouse, ( modifiers & shiftKey ) == shiftKey, fMacTE );		fClickedZTextView = NULL;	}}	/*------------------------------***  ClickInSamePlace  ***------------------------------*//*	check if two sequential clicks in the same view, and view agrees!----------------------------------------------------------------------------------------*/Boolean		ZTextView::ClickInSamePlace( const Point a, const Point b ){	short	offsetA = ::TEGetOffset( a, fMacTE );	short	offsetB = ::TEGetOffset( b, fMacTE );	return (offsetA != -1) && (offsetA == offsetB);}#pragma mark -/*----------------------------------***  Activate  ***----------------------------------*//*access:			publicoverrides:		description: 	view is becoming activeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::Activate(){	ZScrollView::Activate();	if ( IsInDirectCommandChain())		DoSelectionUpdate( TRUE );}/*----------------------------------***  Deactivate  ***--------------------------------*//*access:			publicoverrides:		description: 	view is becoming activeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::Deactivate(){	ZScrollView::Deactivate();	DoSelectionUpdate( FALSE );}#pragma mark -/*-----------------------------------*** SetSize ***------------------------------------*//*access:			publicoverrides:		description: 	set TE rects to match frameins: 			<aWidth> new width of frame				<aHeight> new height of frameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::SetSize( const short aWidth, const short aHeight ){	ZScrollView::SetSize( aWidth, aHeight );	Focus();	PrepareForDrawing();	FocusForContent();	RecalText( FALSE );	PostContentRefresh();}#pragma mark -/*------------------------------***  GetTextRect  ***--------------------------------*//*access:			publicoverrides:		description: 	returns the interior area of the text edit fieldins: 			<aRect>, receives the interior rectangleouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::GetTextRect( Rect* aRect ){	GetContentRect( aRect );	::InsetRect( aRect, kTextViewInset, kTextViewInset );}#pragma mark -/*---------------------------------***  ScrollTo  ***-----------------------------------*//*access:			publicoverrides:		description: 	scroll the view to the absolute offset passedins: 			<hPosition> horizontal positon of frame relative to bounds				<vPosition> vertical position of frame relative to boundsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::ScrollTo( const short hPosition, const short vPosition ){	// HACK: we assume hPosition/vPosition are *relative* not absolute	// since usually this is called with a value based on GetPosition(),	// which in turn always returns (0,0)	Focus();		ScrollView( -hPosition, -vPosition );		//	// Make sure the scroll bar value matches the text edit scroll position	//	if ( HasVBar() )		::SetControlValue( GetVBar(), (*fMacTE)->viewRect.top - (*fMacTE)->destRect.top );			if ( HasHBar() )		::SetControlValue( GetHBar(), (*fMacTE)->viewRect.left - (*fMacTE)->destRect.left );}/*---------------------------------*** GetPosition ***----------------------------------*//*access:			publicoverrides:		description: 	return scroll offset - since TextEdit handles this itself, we return 0.ins: 			<pH, pV> receives offsetouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::GetPosition( short* pH, short* pV ){	*pH = 0;	*pV = 0;}/*-------------------------------***  ScrollView  ***----------------------------------*//*access:			publicoverrides:		description: 	scroll the view by the deltas passed.ins: 			<dH, dV> horizontal and vertical distances to scrollouts: 			nonenotes:			TextEdit does it own scrolling----------------------------------------------------------------------------------------*/void		ZTextView::ScrollView( const short dH, const short dV ){	Focus();	PrepareForDrawing();		::TEPinScroll( dH, dV, fMacTE );}/*-------------------------------***  ClickScroll  ***----------------------------------*//*access:			publicoverrides:		description: 	scroll the view in a grabber-wise fashionins: 			<mousePt>, mouse location in bounds coordinatesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::ClickScroll( const Point mouse ){	Point	sp, old;	long	delta;	Rect	cr;		FocusForContent();	SetCursorShape( HAND_CURSOR_CLOSED );	GetContentRect( &cr );	sp = old = mouse;		while( WaitMouseUp())	{		GetMouse( &sp );		sp.h -= cr.left;		sp.v -= cr.top;				delta = DeltaPoint( sp, old );				if ( delta )		{//			ScrollTo( -LoWord( delta ), -HiWord( delta ));			ScrollTo( 0, -HiWord( delta ));						old = sp;						FocusForContent();			ClipViewsAbove();		}	}}#pragma mark -/*----------------------------------*** UpdateMenus ***---------------------------------*//*access:			publicoverrides:		description: 	enable fixed commands pertaining to this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::UpdateMenus(){	if ( fFlags & kTVSelectable )	{		if ( HasSelection())		{			gMenuBar->EnableCommand( kCmdCopy );			if ( fFlags & kTVEditable )				{				gMenuBar->EnableCommand( kCmdCut );				gMenuBar->EnableCommand( kCmdClear );			}		}		gMenuBar->EnableCommand( kCmdSelectAll );	}	if ( (fFlags & kTVEditable) && !(fFlags & kTVNoStyledText) )	{		gMenuBar->EnableCommand( kCmdSetLeftJustify );			gMenuBar->EnableCommand( kCmdSetCentreJustify );			gMenuBar->EnableCommand( kCmdSetRightJustify );					// check current alignment:		switch((*fMacTE)->just )		{			default:			case teJustLeft:				gMenuBar->CheckCommand( kCmdSetLeftJustify, TRUE );				break;			case teJustRight:				gMenuBar->CheckCommand( kCmdSetRightJustify, TRUE );				break;			case teJustCenter:				gMenuBar->CheckCommand( kCmdSetCentreJustify, TRUE );				break;		}		// Font/style menus:				TEStyleRunInfo	ri;				TEGetStyleRunInfo( &ri, fMacTE );					// check sizes, styles & font				gMenuBar->UpdateFontSizeMenu( &ri );		gMenuBar->UpdateStyleMenu( &ri );		gMenuBar->EnableCommand( kCmdSetColourBlack );		gMenuBar->EnableCommand( kCmdSetColourWhite );		gMenuBar->EnableCommand( kCmdSetColourRed );		gMenuBar->EnableCommand( kCmdSetColourGreen );		gMenuBar->EnableCommand( kCmdSetColourBlue );		gMenuBar->EnableCommand( kCmdSetColourCyan );		gMenuBar->EnableCommand( kCmdSetColourMagenta );		gMenuBar->EnableCommand( kCmdSetColourYellow );//		gMenuBar->EnableCommand( kCmdSetColourOther );	}		ZScrollView::UpdateMenus();}/*---------------------------------*** HandleCommand ***--------------------------------*//*access:			publicoverrides:		description: 	handle fixed commands pertaining to this viewins: 			<cmd> the command to processouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::HandleCommand( const ZoopCommand cmd ){	// handle font size and style commands		TextStyle		newStyle;	short			newMode = 0;		Focus();	PrepareForDrawing();	FocusForContent();	switch( cmd )	{		case kCmdPlainText:			newStyle.tsFace = normal;			newMode = doFace;			break;				case kCmdBoldText:			newStyle.tsFace = bold;			newMode = doFace;			break;				case kCmdItalicText:			newStyle.tsFace = italic;			newMode = doFace;			break;				case kCmdUnderlineText:			newStyle.tsFace = underline;			newMode = doFace;			break;				case kCmdOutlineText:			newStyle.tsFace = outline;			newMode = doFace;			break;				case kCmdShadowText:			newStyle.tsFace = shadow;			newMode = doFace;			break;				case kCmdCondensedText:			newStyle.tsFace = condense;			newMode = doFace;			break;				case kCmdExtendedText:			newStyle.tsFace = extend;			newMode = doFace;			break;				case kCmdSetColourRed:			newStyle.tsColor = gRed;			newMode = doColor;			break;						case kCmdSetColourGreen:			newStyle.tsColor = gGreen;			newMode = doColor;			break;						case kCmdSetColourBlue:			newStyle.tsColor = gBlue;			newMode = doColor;			break;						case kCmdSetColourBlack:			newStyle.tsColor = gBlack;			newMode = doColor;			break;						case kCmdSetColourWhite:			newStyle.tsColor = gWhite;			newMode = doColor;			break;						case kCmdSetColourCyan:			newStyle.tsColor = gCyan;			newMode = doColor;			break;						case kCmdSetColourMagenta:			newStyle.tsColor = gMagenta;			newMode = doColor;			break;						case kCmdSetColourYellow:			newStyle.tsColor = gYellow;			newMode = doColor;			break;					case kCmdSetLeftJustify:		case kCmdSetCentreJustify:		case kCmdSetRightJustify:			{				ZTextAlignmentTask*	aTask;				Str255				taskStr;				short				align;								if( cmd == kCmdSetLeftJustify )					align = teFlushLeft;				else if( cmd == kCmdSetCentreJustify )					align = teCenter;				else 					align = teFlushRight;								if( (*fMacTE)->just != align )				{					::GetIndString( taskStr, kTextTasksStrResID, kTextTask_Format );					FailNIL( aTask = new ZTextAlignmentTask( taskStr, this, align ));										// do the task initially					aTask->Do();										// send the task up to the app					GetRootWindow()->SetTask( aTask );				}			}			break;		default:			if ( cmd > kStdFontSizeBase && cmd <= 199 )			{				newStyle.tsSize = (short) cmd - kStdFontSizeBase;				newMode = doSize;			}			else			{				ZScrollView::HandleCommand( cmd );			}			break;	}		if( newMode != 0 )	{		ZTextStyleTask*	aTask;		Str255			taskStr;		::GetIndString( taskStr, kTextTasksStrResID, kTextTask_Style );		FailNIL( aTask = new ZTextStyleTask( taskStr, this, newMode, newStyle ));				// do the task initially		aTask->Do();				// send the task up to the app		GetRootWindow()->SetTask( aTask );	}}/*---------------------------------*** HandleCommand ***--------------------------------*//*access:			publicoverrides:		description: 	deal with font menu selectionsins: 			<menuID> menu ID				<itemID> index number of menu item selectedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::HandleCommand( const short menuID, const short itemID ){	Focus();	PrepareForDrawing();	FocusForContent();	if ( menuID == gFontMenuID )		// Found font menu! Select our font:	{		ZTextStyleTask*	aTask;		Str255			taskStr;		Str255			itemName;		TextStyle		newStyle;				GetMenuItemText( GetMenuHandle( gFontMenuID ), itemID, itemName );		GetFNum( itemName, &newStyle.tsFont );		GetIndString( taskStr, kTextTasksStrResID, kTextTask_Style );		FailNIL( aTask = new ZTextStyleTask( taskStr, this, doFont, newStyle ));				// do the task initially		aTask->Do();				// send the task up to the app		GetRootWindow()->SetTask( aTask );	}	else		ZScrollView::HandleCommand( menuID, itemID );}#pragma mark -/*-----------------------------------***  Type  ***-------------------------------------*//*access:			publicoverrides:		description: 	handle user typing when the field is activeins: 			<theKey> the character code of the key				<modifiers> state of modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::Type( const char theKey, const short modifiers ){    Boolean     command;	    command = ( modifiers & cmdKey ) == cmdKey;    	if ( theKey == TAB_KEY 		||		 theKey == ENTER_KEY 	||		 theKey == ESCAPE_KEY	||		 theKey == PAGE_UP_KEY	||		 theKey == PAGE_DOWN_KEY||		 theKey == END_KEY		||		 theKey == HELP_KEY		||		 command ||		 ((fFlags & kTVTreatReturnAsEnter) && (theKey == RETURN_KEY))		 )		ZScrollView::Type( theKey, modifiers );	else	{		if( theKey == HOME_KEY )		{			// we need to handle this here due to our ScrollTo/ScrollView-hack			ScrollTo(-32767,-32767);		}		else if ( fFlags & kTVEditable )		{			ZTextTypingTask*	aTask = dynamic_cast<ZTextTypingTask*>(GetRootWindow()->GetUndoOrRedoTask());			Str255				taskStr;			Boolean				createNewTask;						// If there is no current task, of if it is not a ZTextTypingTask, or if it is undone,			// we need to create a new task object.			createNewTask = (aTask == NULL) || aTask->IsUndone() || (aTask->GetUndoTarget() != this);						// If there is a suitable existing ZTextTypingTask, try passing the key to it.			if( !createNewTask )				createNewTask = !aTask->Type( theKey, modifiers );	// If Type() returns FALSE, we need a new task object						// Do we need a new task object? Create it, and fire it off.			if( createNewTask )			{				GetIndString( taskStr, kTextTasksStrResID, kTextTask_Typing );				FailNIL( aTask = new ZTextTypingTask( taskStr, this ));								// We safely can ignore the result of Type() here. Reason: for a brand new				// ZTextTypingTask, Type() always returns TRUE.				aTask->Type( theKey, modifiers );				GetRootWindow()->SetTask( aTask );			}		}			else			SysBeep( 1 );	}}/*------------------------------*** DoSelectionUpdate ***-------------------------------*//*access:			publicoverrides:		description: 	update the selection when the item becomes the handler, etcins: 			<state> the handler stateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::DoSelectionUpdate( Boolean state ){	Focus();	PrepareForDrawing();	FocusForContent();		if ( state )	{		if ( gFontMenuID && (fFlags & kTVEditable) )			gMenuBar->EnableCommand( gFontMenuID, 0 );				if ( fFlags & kTVSelectable )			TEActivate( fMacTE );	}	else	{		if ( fFlags & kTVSelectable )			TEDeactivate( fMacTE );		if ( gFontMenuID && (fFlags & kTVEditable) )			gMenuBar->DisableCommand( gFontMenuID, 0 );	}		ZScrollView::DoSelectionUpdate( state );}/*-------------------------------------*** Idle ***-------------------------------------*//*access:			publicoverrides:		description: 	blink caret when activeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::Idle(){	if ( (fFlags & kTVEditable) || (fFlags & kTVSelectable) )	{		Focus();		PrepareForDrawing();		FocusForContent();		TEIdle( fMacTE );	}}#pragma mark -/*-------------------------------***  CANPASTETYPE  ***---------------------------------*//*	 the window can accept TEXT data from the clipboard----------------------------------------------------------------------------------------*/Boolean	ZTextView::CanPasteType(){	return (fFlags & kTVEditable) && gClipboard->QueryType( 'TEXT' );}/*-----------------------------------***  DoCut  ***------------------------------------*//*access:			publicoverrides:		description: 	implement the "cur" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTextView::DoCut(){	ZTextModifyTask*	aTask;	Str255				taskStr;	gClipboard->Clear();		Focus();	PrepareForDrawing();	FocusForContent();		// this implicitly records the old state	GetIndString( taskStr, kTextTasksStrResID, kTextTask_Cut );	FailNIL( aTask = new ZTextModifyTask( taskStr, this ));	// record the old state	aTask->RecordOldState();	// Do the operation	TECut( fMacTE );	FailOSErr( TEToScrap());	// record the new state	aTask->RecordNewState();		// send the task up to the app	GetRootWindow()->SetTask( aTask );}/*-----------------------------------***  DoCopy  ***-----------------------------------*//*access:			publicoverrides:		description: 	implement the "copy" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTextView::DoCopy(){	gClipboard->Clear();	TECopy( fMacTE );	FailOSErr( TEToScrap());}/*----------------------------------***  DoPaste  ***-----------------------------------*//*access:			publicoverrides:		description: 	implement the "paste" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTextView::DoPaste(){	ZTextModifyTask*	aTask;	Str255				taskStr;		Focus();	PrepareForDrawing();	FocusForContent();	// this implicitly records the old state	GetIndString( taskStr, kTextTasksStrResID, kTextTask_Paste );	FailNIL( aTask = new ZTextModifyTask( taskStr, this ));	// record the old state	aTask->RecordOldState();	// Do the operation	FailOSErr( TEFromScrap());	if( fFlags & kTVNoStyledText )		TEPaste( fMacTE );	else		TEStylePaste( fMacTE );	// record the new state	aTask->RecordNewState();		// send the task up to the app	GetRootWindow()->SetTask( aTask );}/*----------------------------------***  DoClear  ***-----------------------------------*//*access:			publicoverrides:		description: 	implement the "clear" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTextView::DoClear(){	ZTextModifyTask*	aTask;	Str255				taskStr;	Focus();	PrepareForDrawing();	FocusForContent();	// this implicitly records the old state	GetIndString( taskStr, kTextTasksStrResID, kTextTask_Clear );	FailNIL( aTask = new ZTextModifyTask( taskStr, this ));	// record the old state	aTask->RecordOldState();	// Do the operation	TEDelete( fMacTE );	// record the new state	aTask->RecordNewState();		// send the task up to the app	GetRootWindow()->SetTask( aTask );}/*--------------------------------***  DoSelectAll  ***---------------------------------*//*access:			publicoverrides:		description: 	implement the "select all" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::DoSelectAll(){	Focus();	PrepareForDrawing();	FocusForContent();		TESetSelect( 0, 32767, fMacTE );}#pragma mark -/*---------------------------------*** ShouldDrag ***-----------------------------------*//*access:			publicoverrides:		description: 	should the mouse click be treated as a drag op?ins: 			<mouse> mouse location in bounds				<modifiers> modifier keysouts: 			TRUE if the click should be a dragnotes:			----------------------------------------------------------------------------------------*/Boolean		ZTextView::ShouldDrag( const Point mouse, const short modifiers ){	if ( fFlags & kTVSelectable )	{		TEGetHiliteRgn( gUtilRgn, fMacTE );		return PtInRgn( mouse, gUtilRgn );	}		return FALSE;}/*------------------------------*** MakeDragRegion ***----------------------------------*//*access:			publicoverrides:		description: 	create the drag outlineins: 			<aRgn> receives the local version of the regionouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::MakeDragRegion( RgnHandle aRgn ){	TEGetHiliteRgn( aRgn, fMacTE );}/*--------------------------------*** MakeDragData ***----------------------------------*//*access:			publicoverrides:		description: 	add drag data to the dragins: 			<theDrag> the drag to add to				<modifiers> modifiers keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::MakeDragData( const DragReference theDrag, const short modifiers ){	Handle	iData;	long	tLength;		// copy selected text to handle:		tLength = (*fMacTE)->selEnd - (*fMacTE)->selStart;		if ( tLength )	{		FailNIL( iData = NewHandle( tLength ));		HLock( iData );		BlockMoveData((Ptr)( *(*fMacTE)->hText ) + (*fMacTE)->selStart, *iData, tLength );		AddDragItemFlavor( theDrag, 1, 'TEXT', *iData, tLength, 0 );		HUnlock( iData );		DisposeHandle( iData );				// also the style data:				StScrpHandle	st = TEGetStyleScrapHandle( fMacTE );				if ( st )		{			HLock((Handle) st );			AddDragItemFlavor( theDrag, 1, 'styl', *st, GetHandleSize((Handle) st ), 0 );			HUnlock((Handle) st );			DisposeHandle((Handle) st );		}	}}/*-------------------------------*** AcceptsFlavour ***---------------------------------*//*access:			publicoverrides:		description: 	check if drag flavour is OK with usins: 			<aFlavour> one of the drag flaours to testouts: 			TRUE if we can receive this flavournotes:			----------------------------------------------------------------------------------------*/Boolean		ZTextView::AcceptsFlavour( const OSType aFlavour ){	return ( (fFlags & kTVEditable) && (( aFlavour == 'TEXT' ) || ( aFlavour == 'styl' )));}/*----------------------------------***  DDEnterView  ***-------------------------------*//*access:			publicoverrides:		description: 	a drag/drop has entered the viewins: 			<mouse> local mouse coordinates				<theDrag> the drag dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::DDEnterView( const DragReference theDrag ){	ZView::DDEnterView( theDrag );	fCaretTime   = TickCount();	fCaretOffset = fLastOffset = -1;	fCaretShow   = TRUE;	fAutoScrollTicks = 0;}/*------------------------------***  DDInsideView  ***----------------------------------*//*access:			publicoverrides:		description: 	called as long as mouse within view during a dragins: 			<mouse> local mouse point				<theDrag> the drag referenceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::DDInsideView( const Point mouse, const DragReference theDrag )	{	short			textOffset;	long			theTime = TickCount();	Focus();	PrepareForDrawing();	FocusForContent();	ClipViewsAbove();	if( !WillScroll( mouse, kTextViewInset ) )	{		fAutoScrollTicks = 0;	}	else	{		if( fAutoScrollTicks == 0 )		{			fAutoScrollTicks = theTime;		}		else // if (theTime - fAutoScrollTicks > 10)	// 10 ticks to start is what the H.I. doc says		{			// remove the drag-destination caret if it's showing			if( fCaretOffset != -1 )			{				DrawCaret( fCaretOffset );				fCaretOffset = -1;			}			AutoScroll( mouse, kTextViewInset );			ClipRect( &(*fMacTE)->viewRect );						fAutoScrollTicks = theTime - 7;	// let's wait 3 more ticks until next jump		}	}	textOffset = MZTEGetOffset(mouse, fMacTE);	//	If this view is the sender, do not allow tracking through	//	the selection in the window that sourced the drag.	if (this == GetDragSenderView())	{		if ((textOffset >= (**fMacTE).selStart) &&			(textOffset <= (**fMacTE).selEnd) &&			((**fMacTE).selStart != (**fMacTE).selEnd))		{				textOffset = -1;		}	}	fInsertPosition = textOffset;	//	Reset the flashing counter if the offset has moved. This makes the	//	caret blink only after the caret has stopped moving long enough.	if (textOffset != fLastOffset)	{		fCaretTime = theTime;		fCaretShow = TRUE;	}		fLastOffset = textOffset;	//	Flash the caret, blinky-blinky-blinky.	if (theTime - fCaretTime > GetCaretTime())	{		fCaretShow = !fCaretShow;		fCaretTime = theTime;	}		if (!fCaretShow)		textOffset = -1;	//	If the caret offset has changed, move the caret on the screen.	if (textOffset != fCaretOffset)	{		if (fCaretOffset != -1)			DrawCaret(fCaretOffset);		if (textOffset != -1)			DrawCaret(textOffset);	}	fCaretOffset = textOffset;}/*-----------------------------------***  DDExitView  ***-------------------------------*//*access:			publicoverrides:		description: 	a drag/drop has left the viewins: 			<mouse> local mouse coordinates				<theDrag> the drag dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::DDExitView( const DragReference theDrag ){	//	If the caret is on the screen, remove it.	if( fCaretOffset != -1 )	{		Focus();		PrepareForDrawing();		FocusForContent();		ClipViewsAbove();		DrawCaret( fCaretOffset );		fCaretOffset = -1;	}	ZView::DDExitView( theDrag );}Boolean		ZTextView::UnpackDrop( const DragReference theDrag ){	// We override this so we can send the fCurrentTask undo task if necessary.	// This is needed since Drop() can't know when it is finished.		Boolean		retVal;		fCurrentTask = NULL;	retVal =  ZScrollView::UnpackDrop( theDrag );	if( fCurrentTask )	{		// record the new state		fCurrentTask->RecordNewState();				// send the task up to the app		GetRootWindow()->SetTask( fCurrentTask );		fCurrentTask = NULL;	}		return retVal;}void		ZTextView::Drop( const OSType flavour, const Ptr data, const long dataSize, const DragReference theDrag ){	// we expect one or two calls here - one for plain text, two for styled. If styled, the style data	// is second and is simply applied to the selection.		Boolean			moveText = FALSE;	Boolean			wasActive = FALSE;	short			mouseDownModifiers, mouseUpModifiers;	short			selStart, selEnd;		if ( fInsertPosition == -1 )		FailOSErr( dragNotAcceptedErr );	if ((flavour != 'TEXT') && (flavour != 'styl'))		return;			if ( flavour == 'TEXT' )	{		// If the current length, plus the drag data would make the document too large, say so.		if( ((*fMacTE)->teLength + dataSize) > kMaxTextSize )			FailOSErr( dragNotAcceptedErr );	}		// draw in this window, and activate the text editing record so that selections	// happen properly	wasActive = (*fMacTE)->active != 0;	if (!wasActive)		TEActivate(fMacTE);		if ( flavour == 'TEXT' )	{		ASSERT( "fCurrentTask already set",  NULL == fCurrentTask, 0 )				// Allocate a task object for this drag		Str255	taskStr;		GetIndString( taskStr, kTextTasksStrResID, kTextTask_Drag );		FailNIL( fCurrentTask = new ZTextModifyTask( taskStr, this ));		// If this window is also the sender and the option key is not being held down,		// then we move instead of copy		GetDragModifiers( theDrag, 0L, &mouseDownModifiers, &mouseUpModifiers );		moveText = (this == GetDragSenderView()) &&				   (!((mouseDownModifiers | mouseUpModifiers) & optionKey));		//	If the caret or highlighting is on the screen, remove it/them.		if( fCaretOffset != -1 )		{			DrawCaret( fCaretOffset );			fCaretOffset = -1;		}				if( moveText )		{			// If we move text, then we need to record the old state *now*			fCurrentTask->RecordOldState();			selStart = (**fMacTE).selStart;			selEnd   = (**fMacTE).selEnd;						if (fInsertPosition > selStart)				fInsertPosition -= (selEnd - selStart);						TEDelete(fMacTE);			}				// Before we insert this text, make sure we set the selection range to a single character.		// This assures that we won't overwrite the text in the previous selection.				TESetSelect(fInsertPosition, fInsertPosition, fMacTE);		if( !moveText )		{			// If we did *not* move text, then we need to record the old state now			fCurrentTask->RecordOldState();		}		// We can finally insert the text and style data into our record.		TEInsert(data, dataSize, fMacTE);		// Select everything we've just inserted.		TESetSelect(fInsertPosition, fInsertPosition + dataSize, fMacTE);	}	else if( (flavour == 'styl') && !(fFlags & kTVNoStyledText) )	{		// style data is simply applied to the selection, see top of this func for an explanation				StScrpHandle	scrapH = (StScrpHandle) NewHandle( dataSize );		BlockMoveData( data, (Ptr) *scrapH, dataSize );		TEUseStyleScrap((*fMacTE)->selStart, (*fMacTE)->selEnd, scrapH, TRUE, fMacTE );		DisposeHandle((Handle) scrapH );	}		RecalText(FALSE);	// if we had to activate the edit record, deactivate it after we are all done	if (!wasActive)		TEDeactivate(fMacTE);}#pragma mark -/*------------------------------------*** SetText ***-----------------------------------*//*access:			publicoverrides:		description: 	set the text from an arbitrary text bufferins: 			<textBuf> pointer to text to copy				<txLength> length of text to copyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::SetText( Ptr textBuf, const long txLength ){	TESetText( textBuf, txLength, fMacTE );	TESetSelect( 0, 0, fMacTE );	RecalText(TRUE);	PostContentRefresh();}/*------------------------------------*** SetText ***-----------------------------------*//*access:			publicoverrides:		description: 	set the text from a handle and optionally, a style handleins: 			<textH> handle containing text				<styleH> optional style infoouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::SetText( Handle textH, Handle styleH ){	char hs = HGetState( textH );		HLock( textH );	SetText( *textH, GetHandleSize( textH ));	HSetState( textH, hs );		if ( styleH )		TEUseStyleScrap( 0, 32767, (StScrpHandle) styleH, FALSE, fMacTE );		TECalText( fMacTE );		RecalText(TRUE);	PostContentRefresh();	}/*------------------------------------*** SetText ***-----------------------------------*//*access:			publicoverrides:		description: 	set the text from resourceins: 			<textResID> resource ID of 'TEXT' resource to useouts: 			nonenotes:			if 'styl' resource with same ID, this is used too----------------------------------------------------------------------------------------*/void		ZTextView::SetText( const short textResID ){	Handle		textH, styleH = NULL;		FailNILRes( textH = GetResource( 'TEXT', textResID ));	styleH = GetResource( 'styl', textResID );	SetText( textH, styleH );		if ( styleH )		ReleaseResource( styleH );			ReleaseResource( textH );}/*------------------------------------*** SetFlags ***----------------------------------*//*access:			publicoverrides:		description: 	set whether editable, selectable, etcins: 			<editable> TRUE if view can be edited				<selectable> TRUE if view can be selected but not editedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::SetFlags( unsigned short flags ){	fFlags = flags;	if( fFlags & kTVEditable )		fFlags |= kTVSelectable;		SetCanBeHandler( fFlags & kTVSelectable );}/*--------------------------------*** SetFontAlignment ***------------------------------*//*access:			publicoverrides:		description: 	set whether text is left, right or centeredins: 			<align> alignment constantouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::SetFontAlignment( const short align ){	if( (*fMacTE)->just != align )	{		// if text centred, need to offset destRect by inset - not sure why, but it works.				// text was centred, hence subtract the offset		if ((*fMacTE)->just == teJustCenter )			OffsetRect( &(*fMacTE)->destRect, -kTextViewInset, 0 );		// text is being centred, hence add the offset		else if (align == teJustCenter )			OffsetRect( &(*fMacTE)->destRect, kTextViewInset, 0 );		TESetAlignment( align, fMacTE );		RecalText( TRUE );		PostContentRefresh();	}}/*--------------------------------*** SetForeColour ***---------------------------------*//*access:			publicoverrides:		description: 	sets the text to the colour passedins: 			<rgb> colour to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::SetForeColour( const RGBColor* rgb ){	ZScrollView::SetForeColour( rgb );		if ( fMacTE )	{		short		saveStart, saveEnd;		TextStyle	ts;				ts.tsColor = *rgb;		saveStart = (*fMacTE)->selStart;		saveEnd = (*fMacTE)->selEnd;				(*fMacTE)->selStart = 0;		(*fMacTE)->selEnd = (*fMacTE)->teLength;				TESetStyle( doColor, &ts, FALSE, fMacTE );				(*fMacTE)->selStart = saveStart;		(*fMacTE)->selEnd = saveEnd;				PostContentRefresh();		}}/*---------------------------------*** SetFontInfo ***----------------------------------*//*access:			publicoverrides:		description: 	sets font info for the viewins: 			<fontID> the font				<size> the font size				<aStyle> the font styleouts: 			nonenotes:			this sets the font, etc to be the same for the entire text----------------------------------------------------------------------------------------*/void		ZTextView::SetFontInfo( const short fontID, const short size, const Style aStyle ){	ZScrollView::SetFontInfo( fontID, size, aStyle );	if ( fMacTE )	{		TextStyle	ts;		short		ss, se;		Boolean		wasActive = FALSE;		ts.tsFont = fontID;		ts.tsFace = aStyle;		ts.tsSize = size;		ss = (*fMacTE)->selStart;		se = (*fMacTE)->selEnd;		wasActive = (*fMacTE)->active != 0;				if( wasActive )			TEDeactivate( fMacTE );		TESetSelect( 0, 32767, fMacTE );		TESetStyle( doFont + doFace + doSize, &ts, FALSE, fMacTE );		RecalText( FALSE );		TESetSelect( ss, se, fMacTE );		if ( wasActive )		  TEActivate( fMacTE );		  		PostContentRefresh();	}}/*------------------------------------*** GetText ***-----------------------------------*//*access:			publicoverrides:		description: 	return the text and style of the viewins: 			<textH> pointer to a Handle for text				<styleH> pointer to a Handle for style info (NULL if not required)outs: 			nonenotes:			Allocates the handles, caller disposes----------------------------------------------------------------------------------------*/void		ZTextView::GetText( Handle* textH, Handle* styleH ){	if ( textH )	{		*textH = (Handle) TEGetText( fMacTE );		FailOSErr( HandToHand( textH ));	}		if ( styleH )	{		short		savedStart = (*fMacTE)->selStart;		short		savedEnd   = (*fMacTE)->selEnd;				(*fMacTE)->selStart = 0;		(*fMacTE)->selEnd = (*fMacTE)->teLength;				StScrpHandle	styles = TEGetStyleScrapHandle( fMacTE );				(*fMacTE)->selStart = savedStart;		(*fMacTE)->selEnd = savedEnd;				*styleH = (Handle) styles;	}} /*---------------------------------*** GetTextLength ***--------------------------------*//*access:			publicoverrides:		description: 	return the number of characters in the textins: 			noneouts: 			the char countnotes:			----------------------------------------------------------------------------------------*/long		ZTextView::GetTextLength(){	return (*fMacTE)->teLength;}/*--------------------------------*** HasSelection ***----------------------------------*//*access:			publicoverrides:		description: 	is at least one character selected?ins: 			noneouts: 			TRUE if there is a selection of one or more charsnotes:			----------------------------------------------------------------------------------------*/Boolean		ZTextView::HasSelection(){	return (*fMacTE)->selEnd > (*fMacTE)->selStart;}/*---------------------------------*** ReportFields ***---------------------------------*//*access:			publicoverrides:		description: 	report data members to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::ReportFields(){	ZScrollView::ReportFields();		XSHOWFIELD( fMacTE, ft_Handle );	XSHOWFIELD( fFlags, ft_unsignedshort );	XSHOWFIELD( fCaretTime, ft_signedlong );	XSHOWFIELD( fCaretShow, ft_boolean );	XSHOWFIELD( fCaretOffset, ft_signedshort );	XSHOWFIELD( fLastOffset, ft_signedshort );	XSHOWFIELD( fInsertPosition, ft_signedshort );	XSHOWFIELD( fAutoScrollTicks, ft_unsignedlong );	XSHOWFIELD( fCurrentTask, ft_objectref );}#pragma mark -/*--------------------------------***  TEViewInit  ***----------------------------------*//*access:			protectedoverrides:		description: 	create the text edit recordins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::TEViewInit(){	Rect	viewRect, destRect;		// edit fields white by default		SetBackColour( &gWhite );		Focus();	PrepareForDrawing();		GetTextRect( &viewRect );	destRect = viewRect;	if (( fFlags & kTVFixedWidth ) == 0 )		destRect.right += kFixedWidth;		FailNIL( fMacTE = TEStyleNew( &destRect, &viewRect ));			if (( fFlags & kTVFixedWidth ) == 0 )		(*fMacTE)->crOnly = -1;	#if GENERATINGPOWERPC	TESetClickLoop( fClickLoopUPP, fMacTE );#else	(*fMacTE)->clickLoop = fClickLoopUPP;#endif		SetCanBeHandler( TRUE );		RecalText( FALSE );}/*---------------------------------***  RecalText  ***----------------------------------*//*access:			publicoverrides:		description: 	recalculate the TextEdit record, updates the scroll barsins: 			<scrollToCaret> whether we should scroll to the caretouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTextView::RecalText( Boolean scrollToCaret ){	static Boolean rtInProgress = FALSE;		if ( ! rtInProgress )	{		Rect	viewRect, destRect, boundsRect, frameRect;		short 	textHeight, lineHeight, diff, frameHeight;		rtInProgress = TRUE;				GetTextRect( &viewRect );		if ( fFlags & kTVFixedWidth )			(*fMacTE)->destRect.right = (*fMacTE)->destRect.left + kFixedWidth;		else			(*fMacTE)->destRect.right = (*fMacTE)->destRect.left + viewRect.right - viewRect.left;		(*fMacTE)->viewRect = viewRect;		TECalText( fMacTE );				//		// Calculate text & line height		//		lineHeight = TEGetHeight( 1, 1, fMacTE );		textHeight = MZTEHeight( fMacTE );				//		// Set the dest rect, depending on whether we are supposed to stay fixed width or auto-adjust		//		if( fFlags & kTVFixedWidth )			SetRect( &destRect, 0, 0, (*fMacTE)->destRect.right - (*fMacTE)->destRect.left, textHeight );		else			SetRect( &destRect, 0, 0, viewRect.right - viewRect.left, textHeight );				//		// "Magic" to get the scroll bounds right - we use an inset for text drawing, 		//  that's why we need to adjust by 2*kTextViewInset		//		destRect.bottom += 2*kTextViewInset;		{			boundsRect = destRect;			GetFrame(&frameRect);			frameHeight = frameRect.bottom - frameRect.top;			if( boundsRect.bottom < frameHeight )				boundsRect.bottom = frameHeight;			SetBounds( boundsRect );		}		destRect.bottom -= 2*kTextViewInset;						//		// Fix the destRect to reduce flicker & prevent some nasty (cosmetical) bugs		//		OffsetRect( &destRect, (*fMacTE)->destRect.left - destRect.left, (*fMacTE)->destRect.top - destRect.top );				diff = (*fMacTE)->viewRect.bottom - destRect.bottom;		if ( diff > 0 )			OffsetRect( &destRect, 0 , diff );		diff = (*fMacTE)->viewRect.top - destRect.top;		if ( diff < 0 )			OffsetRect( &destRect, 0, diff );				(*fMacTE)->destRect = destRect;				//		// If desired, scroll to the caret		//		if ( scrollToCaret )		{		    TEAutoView( TRUE, fMacTE );		    TESelView( fMacTE );		    TEAutoView( FALSE, fMacTE );        }						//		// Set the scroll amount (this also recalculates the maximum values of the scroll bar(s)		//		SetScrollAmount( 11, lineHeight );						//		// Make sure the scroll bar value matches the text edit scroll position		//		if ( HasVBar() )			SetControlValue( GetVBar(), (*fMacTE)->viewRect.top - (*fMacTE)->destRect.top );					if ( HasHBar() )			SetControlValue( GetHBar(), (*fMacTE)->viewRect.left - (*fMacTE)->destRect.left );				rtInProgress = FALSE;	}}/*----------------------------------*** TEClickLoop ***---------------------------------*//*access:			protectedoverrides:		description: 	do the auto scrollingins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZTextView::TEClickLoop(){	Point	mouse;	Focus();	PrepareForDrawing();	FocusForContent();	GetMouse( &mouse );	AutoScroll( mouse );	ClipRect( &(*fMacTE)->viewRect );}/*-----------------------------------*** DrawCaret ***----------------------------------*//*access:			protectedoverrides:		description: 	Fake a TextEdit caret.ins: 			<textOffset> offset where the caret should be drawnouts: 			nonenotes:			Draws a caret in a TextEdit field at the given offset by inverting the				image of the caret onto the screen. DrawCaret expects the port to be set				to the port that the TextEdit record is in.				This is used exclusively by the Drag & Drop code.----------------------------------------------------------------------------------------*/void	ZTextView::DrawCaret( short textOffset ){		Point theLoc;	short lineHeight, theLine;	//	//	Get the coordinates and the line of the offset to draw the caret.	//	theLoc  = TEGetPoint(textOffset, fMacTE);	theLine = MZTEGetLine(textOffset, fMacTE);			//	//	Always invert the caret when drawing.	//	PenMode(patXor);	//	//	Get the height of the line that the offset points to.	//	lineHeight = TEGetHeight(theLine, theLine, fMacTE);	//	//	Draw the appropriate caret image.	//	ClipRect( &(*fMacTE)->viewRect );	MoveTo(theLoc.h - 1, theLoc.v - 1);	Line(0, 1 - lineHeight);	PenNormal();}#pragma mark -#if GENERATINGPOWERPCpascal Boolean	ZTextView::TEClickLoopProc( TERec* tr ){	try	{		if ( fClickedZTextView )			fClickedZTextView->TEClickLoop();	}	catch(...)	{		// do NOT propagate	}		return TRUE;}#elsestatic void		Fixup68K() = { 0x1038, 0x0001 };	// MOVE.B TRUE, D0;pascal void	ZTextView::TEClickLoopProc(){	try	{		if ( fClickedZTextView )			fClickedZTextView->TEClickLoop();	}	catch(...)	{		// do NOT propagate	}	Fixup68K();}#endif#pragma mark -/*-------------------------------*** CreateNewTextView ***------------------------------*//*access:			globaloverrides:		description: 	create a new text view with a 'TEXT' resourceins: 			<aParent> the view's parent				<aFrame> view's frame				<textResID>	resource ID of TEXT/stylouts: 			nonenotes:			creates only vertical scrollbar----------------------------------------------------------------------------------------*/ZView*		CreateNewTextView( ZView* aParent, Rect* aFrame, const short textResID ){	ZTextView*		tv;		FailNIL( tv = new ZTextView( aParent, aFrame, FALSE, TRUE, FALSE ));		if ( textResID )		tv->SetText( textResID );		return tv;}/*--------------------------*** CreateNewTextViewWithParams ***-------------------------*//*access:			globaloverrides:		description: 	create a new text view with a 'TEXT' resourceins: 			<aParent> the view's parent				<aFrame> view's frame				<paramCount> count of parameters				<params> the parametersouts: 			nonenotes:			intended as dialog item constructor function to replace ZTextDialogItem				params[0] - ID of 'TEXT'/'styl' resource				params[1] - flags 1= editable, 2 = selectable				params[2] - font justification, 0 = left, 1 = centre, 2 = right				creates only vertical scrollbar, this is compatible with 'TEXT' magic string----------------------------------------------------------------------------------------*/ZView*		CreateNewTextViewWithParams( ZView* aParent, Rect* aFrame, const short paramCount, long params[] ){	ZTextView*		tv;		tv = (ZTextView*) CreateNewTextView( aParent, aFrame, params[0] );	if ( paramCount > 1 )	{		unsigned short		flags = 0;				if ( params[1] & 1 )			flags |= kTVEditable;		if ( params[1] & 2 )			flags |= kTVSelectable;		tv->SetFlags( flags + kTVGrayInactive );	}		if ( paramCount > 2 )		tv->SetFontAlignment( params[2] );			return tv;}/*----------------------------*** CreateNewEnhancedTextBox ***---------------------------*//*access:			globaloverrides:		description: 	create a new text view with a 'TEXT' resourceins: 			<aParent> the view's parent				<aFrame> view's frame				<paramCount> count of parameters				<params> the parametersouts: 			nonenotes:			intended as dialog item constructor function for 'TXT+' magic string				params[0] - flags (see below)				params[1] - 'TEXT/styl' ID				params[2] - font justification, 0 = left, 1 = centre, 2 = right				this allows more control over features than 'TEXT' items alone----------------------------------------------------------------------------------------*/ZView*		CreateNewEnhancedTextBox( ZView* aParent, Rect* aFrame, const short pCount, long params[] ){	ZTextView*	tv;	Boolean		hBar, vBar, szBox;		// flags are as per other scrollable type views, plus selectable and editable flags		if ( pCount > 0 )	{		vBar = ( params[0] & kScrollingViewHasVerticalBar ) == kScrollingViewHasVerticalBar;		hBar = ( params[0] & kScrollingViewHasHorizontalBar ) == kScrollingViewHasHorizontalBar;		szBox = ( params[0] & kScrollingViewHasSizeBox ) == kScrollingViewHasSizeBox;	}	else	{		hBar = FALSE;		vBar = TRUE;		szBox = TRUE;	}		FailNIL( tv = new ZTextView( aParent, aFrame, hBar, vBar, szBox ));		if ( pCount > 1 )		tv->SetText( params[1] );			// set whether editable, selectable, etc		if ( pCount > 0 )	{		unsigned short		flags = 0;				if ( ( params[0] & kTextViewNonEditable ) == 0 )			flags |= kTVEditable;		if ( ( params[0] & kTextViewSelectable ) == kTextViewSelectable )			flags |= kTVSelectable;		if ( hBar )			flags |= kTVFixedWidth;				tv->SetFlags( flags + kTVGrayInactive );	}		if ( pCount > 2 )		tv->SetFontAlignment( params[2] );			return tv;}#pragma mark -/*-----------------------------***  MZTEIsFrontOfLine  ***------------------------------*//*	Given a text offset and a TextEdit handle, returns TRUE if the given offset is at thebeginning of a line start.----------------------------------------------------------------------------------------*/Boolean MZTEIsFrontOfLine( short textOffset, TEHandle hTE ){	short theLine = 0;		if ((*hTE)->teLength == 0)		return TRUE;		if (textOffset >= (*hTE)->teLength)		return( (*((*hTE)->hText))[(*hTE)->teLength - 1] == 0x0D );		while ((*hTE)->lineStarts[theLine] < textOffset)		++theLine;		return( (*hTE)->lineStarts[theLine] == textOffset );}/*--------------------------------***  MZTEGetLine  ***---------------------------------*//*	Given an offset and a TextEdit handle, returns the line number that contains the offset.----------------------------------------------------------------------------------------*/short MZTEGetLine( short textOffset, TEHandle hTE ){		short theLine = 0;		if (textOffset >= (*hTE)->teLength)		return((*hTE)->nLines);	else	{		while ((*hTE)->lineStarts[theLine] <= textOffset)			++theLine;	}		return theLine;}/*------------------------------***  MZTEGetOffset  ***------------------------------*//*	 Given a point in local coordinates, MZTEGetOffset returns an offset into the text if the point is inside the given TERecord. If the point is not in the text, MZTEGetOffset returns -1.----------------------------------------------------------------------------------------*/short MZTEGetOffset(Point theLoc, TEHandle hTE){		short		textOffset = -1;		if (PtInRect(theLoc, &((** hTE).viewRect)))	{		textOffset = TEGetOffset(theLoc, hTE);		if ((MZTEIsFrontOfLine(textOffset, hTE)) && (textOffset) &&			((*((** hTE).hText))[textOffset - 1] != 0x0D) &&			(TEGetPoint(textOffset - 1, hTE).h < theLoc.h))		{			--textOffset;		}	}	return textOffset;}