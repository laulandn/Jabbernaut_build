/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZUndoTextTask.h		-- undo task for ZTextView*****			©2000-2001, Max Horn*****************************************************************************************************/#include	"MacZoop.h"#include	"ZUndoTextTask.h"#include	"ZTextView.h"#include	"ZGrafState.h"ZTextStyleTask::ZTextStyleTask( Str63 taskName, ZTextView* aView, short inMode, const TextStyle &inStyle )	: ZUndoTextTask( taskName, aView ),	fNewMode( inMode ),	fNewStyle( inStyle ){	TEHandle	TEh = GetTEHandle();	// Save current selection range and the style of the selected text,	// which will be changed by our Do() method.	fOldSelStart	= (*TEh)->selStart;	fOldSelEnd		= (*TEh)->selEnd;	fOldStyle		= ::TEGetStyleScrapHandle(TEh);}void	ZTextStyleTask::Do(){	TEHandle	TEh = GetTEHandle();		// Restore original selection	::TESetSelect( fOldSelStart, fOldSelEnd, TEh );		// Hack! For some reasons doToggle is not working for me as expected	if (( fNewMode == doFace ) && ( fNewStyle.tsFace != normal ))	{		TextStyle	style = fNewStyle;		short		mode = fNewMode;		if( ::TEContinuousStyle( &mode, &style, TEh ))			::TESetStyle( fNewMode + doToggle, &fNewStyle, FALSE, TEh );		else			::TESetStyle( fNewMode, &fNewStyle, FALSE, TEh );	}	else		::TESetStyle( fNewMode, &fNewStyle, FALSE, TEh );		// Recal the text layout	ForceViewRecal();		// Important! Call inherited Do to maintain state		ZUndoTask::Do();}void	ZTextStyleTask::Undo(){	TEHandle	TEh = GetTEHandle();		// Restore original style	::TEUseStyleScrap( fOldSelStart, fOldSelEnd, fOldStyle, FALSE, TEh );	// Restore original selection	::TESetSelect(fOldSelStart, fOldSelEnd, TEh);		// Recal the text layout	ForceViewRecal();	// Important! Call inherited Undo to maintain state		ZUndoTask::Undo();}#pragma mark -ZTextAlignmentTask::ZTextAlignmentTask( Str63 taskName, ZTextView* aView, short inJust )	: ZUndoTextTask( taskName, aView ),	fNewJust( inJust ){	TEHandle	TEh = GetTEHandle();	// Save current alignment mode	fOldJust	= (*TEh)->just;}void	ZTextAlignmentTask::Do(){	TEHandle	TEh = GetTEHandle();		// Set new alignment mode	ZTextView*	ztv = dynamic_cast<ZTextView*>(itsTarget);	ztv->SetFontAlignment( fNewJust );	// Important! Call inherited Do to maintain state		ZUndoTask::Do();}void	ZTextAlignmentTask::Undo(){	TEHandle	TEh = GetTEHandle();		// Set old alignment mode	ZTextView*	ztv = dynamic_cast<ZTextView*>(itsTarget);	ztv->SetFontAlignment( fOldJust );	// Important! Call inherited Undo to maintain state		ZUndoTask::Undo();}#pragma mark -ZTextModifyTask::ZTextModifyTask( Str63 taskName, ZTextView* aView )	: ZUndoTextTask( taskName, aView ){}void	ZTextModifyTask::RecordOldState(){	fOldState.Record( GetTEHandle() );}void	ZTextModifyTask::RecordNewState(){	ASSERT( "old state not yet recorded",  fOldState.IsInited(), 0 )	TEHandle	TEh = GetTEHandle();	short		bakSelStart;		bakSelStart		= (*TEh)->selStart;		// If the new selection range is empty, this might have been either a "Paste"	// or a "Cut"/"Clear" command. Now, if fNewSelStart == fOldSelStart then it	// must have been a Cut/Clear; otherwise it was a Paste. But if it was a Paste,	// we need to (temporarily) set the selection to contain all pasted text!	// To do so, we assume the begin of the pasted data is the same as the begin	// of the original data (which was overwritten), and the end is the current 	// selection position.	if( (*TEh)->selStart == (*TEh)->selEnd && fOldState.selStart < (*TEh)->selEnd)		(*TEh)->selStart = fOldState.selStart;	fNewState.Record( GetTEHandle() );		// Restore the selection start	(*TEh)->selStart = bakSelStart;}void	ZTextModifyTask::ApplyState( const TextState &srcState, const TextState &dstState ){	ASSERT( "srcState not yet recorded",  srcState.IsInited(), 0 )	ASSERT( "dstState not yet recorded",  dstState.IsInited(), 0 )	TEHandle	TEh = GetTEHandle();		// Delete the old data	::TESetSelect(srcState.selStart, srcState.selEnd, TEh);	::TEDelete(TEh);		// Insert the new data	::TESetSelect(dstState.selStart, dstState.selStart, TEh);	::HLock(dstState.textH);	::TEStyleInsert(*dstState.textH, ::GetHandleSize(dstState.textH), dstState.styleH, TEh);	::HUnlock(dstState.textH);	// Select the new range	::TESetSelect(dstState.selStart, dstState.selEnd, TEh);	// Recal the text layout	ForceViewRecal();}void	ZTextModifyTask::Do(){	// Move from the old state to the new state	ApplyState(fOldState, fNewState);		// Important! Call inherited Do to maintain state		ZUndoTask::Do();}void	ZTextModifyTask::Undo(){	// Restore the old state	ApplyState(fNewState, fOldState);	// Important! Call inherited Undo to maintain state		ZUndoTask::Undo();}#pragma mark -void	ZTextModifyTask::TextState::Record(TEHandle inTEh){	Release();		// Save current selection range	selStart		= (*inTEh)->selStart;	selEnd			= (*inTEh)->selEnd;		// Save the style data	styleH			= ::TEGetStyleScrapHandle(inTEh);	// Save the actual text	FailNIL( textH	= ::NewHandle(selEnd - selStart) );	::BlockMoveData(*((**inTEh).hText) + selStart, *textH,						selEnd - selStart);}void	ZTextModifyTask::TextState::Release(){	selStart = selEnd;	if( styleH )	{		::DisposeHandle( (Handle)styleH );		styleH = NULL;	}		if( textH )	{		::DisposeHandle( textH );		textH = NULL;	}}Boolean	ZTextModifyTask::TextState::IsInited() const{	return (textH != NULL);}#pragma mark -ZTextTypingTask::ZTextTypingTask( Str63 taskName, ZTextView* aView )	: ZTextModifyTask( taskName, aView ), fTypingPos(-1){}// return TRUE if we handled the key; return FALSE if another task object has to be made in order to handle this key event.Boolean	ZTextTypingTask::Type( const char theKey, const short modifiers ){	ZTextView*	ztv = dynamic_cast<ZTextView*>(itsTarget);	TEHandle	TEh = ztv->GetMacTextEdit();	Boolean		textChange;	ztv->Focus();	ztv->PrepareForDrawing();	ztv->FocusForContent();		// Determine whether it was a modifying key press or not.	switch( theKey )	{		case PAGE_UP_KEY:		case PAGE_DOWN_KEY:		case HOME_KEY:		case END_KEY:		case ESCAPE_KEY:		case UP_ARROW_KEY:		case DOWN_ARROW_KEY:		case LEFT_ARROW_KEY:		case RIGHT_ARROW_KEY:		case HELP_KEY:		case ANY_FUNCTION_KEY:			// The text will not be changed.			textChange = FALSE;			break;		default:			// The text will be changed.			textChange = TRUE;			break;	}	// We only have to take special measures if any text change will take place.	if( textChange )	{		// Check whether a state is already recorded or not.		if( !fOldState.IsInited() )		{			// No old state yet? Then record the old state.			RecordOldState();		}		else		{			// We already have an old state. We only accept modifying typing			// while there is no selection, otherwise we get strange results!			if( (*TEh)->selStart != (*TEh)->selEnd )				return FALSE;			// Now, are we still at the last typing position? If not, then a new			// undo task needs to be created, and we return FALSE to tell our boss.			if( (*TEh)->selStart != fTypingPos )				return FALSE;		}	}		// Do the actual "work" and pass the key to TextEdit	MZTEKey( theKey, TEh, modifiers );		// Since the text has been changed, we have to record the new state, and the new caret position	if( textChange )	{		RecordNewState();		fTypingPos = (*TEh)->selStart;	}		// Finally, recal the text and scroll to the caret	ztv->RecalText( TRUE );		// We handled the key press, therefore return TRUE.	return TRUE;}