/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZRulerView.h		-- view that draws a ruler******			©2000, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZRULERVIEW__#define	__ZRULERVIEW__#include	"ZView.h"#include	<fp.h>class	ZScrollView;DEFINECLASSID( ZRulerView, 'zrul' );// structure for setting up rulers:typedef struct{	double_t			majorDistance;				// ruler distance per major division	double_t			atomDistance;				// ruler distance per pixel	short				divsPerMajor;				// number of divisions between major (labelled) divisions	short				smallMarkLength;			// length of small mark	short				mediumMarkLength;			// length of medium mark	short				majorMarkLength;			// length of major mark			}RulerInfo;// the class:class	ZRulerView	: public ZView{protected:	double_t			fRulerOrigin;				// value of start of ruler	double_t			fAtomDistance;				// ruler distance per pixel	double_t			fMajorDistance;				// ruler distance of major marks (usually 1.0)	double_t			fMarkerPosition;			// position of marker	short				fPixelOrigin;				// position of ruler	short				fDivsPerMajor;				// number of marked divisions between major (labelled) divisions	short				fSmallMarkLength;			// length of small mark	short				fMediumMarkLength;			// length of medium mark	short				fMajorMarkLength;			// length of major mark		short				fDecimals;					// dec places			Boolean				fRulerVertical;				// TRUE if ruler is vertical	Boolean				fMarkerVis;					// TRUE if cursor marker shown	Rect				fLastMarker;				// current marker positionpublic:	ZRulerView( ZView* aParent, Rect* aFrame = NULL, const RulerInfo* ri = NULL );	ZRulerView( ZView* aParent, const short viewResourceID );	virtual void		DrawContent();	virtual void		SetSize( const short width, const short height );		virtual void		ShowMarker();	virtual void		HideMarker();	virtual void		SetMarkerPosition( const double_t markerPos );		void				SetRulerOrigin( const double_t anOrigin );	void				SetRulerZeroPosition( const short pixelOffset );	void				SetRulerCalibration( const double_t numer, const double_t denom );	void				SetPixelOrigin( const short pixOrigin );	void				SetRulerDivisions( const short divs );	void				SetRulerDecimals( const short decPlaces ) { fDecimals = decPlaces; };		double_t			GetRulerOrigin() { return fRulerOrigin; };	double_t			GetRulerCalibration() { return fAtomDistance; };	double_t			GetRulerMajorDistance() { return fMajorDistance; };	short				GetRulerPixelOrigin() { return fPixelOrigin; };	double_t			GetRulerMarkerPosition() { return fMarkerPosition; };	short				GetRulerDivisions() { return fDivsPerMajor; };		short				RulerToPixel( const double_t rPos );	double_t			PixelToRuler( const short aPixel );		virtual void		ReportFields();	protected:	void				DrawRulerH();	void				DrawRulerV();	virtual void		DrawRulerMajorLabel( Rect* labelBounds, const double_t labelValue );	virtual void		DrawMarker();};enum{	kStdRulerViewHeight				= 18,	kStdRulerViewWidth				= 18,	kMsgRulerDrawingMajorMark		= 'rulm'};const double_t	kInchRulerAtomDistance	= 90.0;const double_t  kCentimetreRulerAtomDistance = 35.43;// convenient registerable method for making this view:ZView*	CreateNewRulerView( ZView* aParent, Rect* aFrame, const short pCount, long params[] );#endif