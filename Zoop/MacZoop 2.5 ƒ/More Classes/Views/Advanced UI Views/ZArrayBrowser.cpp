/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZArrayBrowser.cpp		-- a view that can display the contents of an array*										as a columnar list, and select items therein.******			©2000, Graham Cox*****************************************************************************************************/#include	"ZArrayBrowser.h"#include	"MacZoop.h"#include	"ZWindow.h"#include	"ZPStrArray.h"#include	"ZScrollView.h"#include	"ZGrafState.h"#include	"MZListTypes.h"// globals:RgnHandle		ZArrayBrowser::sDragInsertRgn = NULL;Str15			ZArrayBrowser::sSearchStr = "\p";/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZArrayBrowser::ZArrayBrowser( ZView* aParent, Rect* aFrame, const short numColumns )	: ZScrollAwareView( aParent, aFrame ){	classID = CLASS_ZArrayBrowser;		fArray = NULL;	fViewer = NULL;	fOwnsArray = FALSE;	FailNIL( fSelection = NewRgn());	FailNIL( fColumnTabs = new ZArray( sizeof( short )));		InitStyle( kBrowserStyleAdoptSysAppearance );	fLastKeyTime = TickCount();	fSelFlags = kStandardMultiSelect + kAllowKeyboardAutoDelete;	fSelColumn = 0;	SetCanBeHandler( TRUE );	sSearchStr[0] = 0;	fThresh = MIN( 120, LMGetKeyThresh() * 2 );		// set default viewer to pascal string viewer, for your convenience.		FailNIL( fViewer = new ZPStrViewer());	CalcSizes();	SetColumns( numColumns );}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/// construct array browser based on 'ZARB' resource, etcZArrayBrowser::ZArrayBrowser( ZView* aParent, const short templateResID )	: ZScrollAwareView( aParent, NULL ){	BrowserTemplateHdl	bth;	CTabHandle			bch;	classID = CLASS_ZArrayBrowser;		FailNILRes( bth = (BrowserTemplateHdl) GetResource( kArrayBrowserTemplateResType, templateResID ));	HNoPurge((Handle) bth );		fArray = NULL;	fViewer = NULL;	fOwnsArray = FALSE;	fSelColumn = 0;	FailNIL( fSelection = NewRgn());	FailNIL( fColumnTabs = new ZArray( sizeof( short )));		fLastKeyTime = TickCount();	sSearchStr[0] = 0;	fThresh = MIN( 120, LMGetKeyThresh() * 2 );	fSelFlags = (*bth)->flags;	fFrame = (*bth)->frame;		if ((*bth)->initStyle == 0 )	{		bch = (CTabHandle) GetResource( kArrayBrowserColoursResType, templateResID );				if ( bch )		{			SetBackColour( &(*bch)->ctTable[kArrayBrowserBackColour].rgb );			SetForeColour( &(*bch)->ctTable[kArrayBrowserForeColour].rgb );			fBorderColour = (*bch)->ctTable[kArrayBrowserBorderColour].rgb;			fAltColour = (*bch)->ctTable[kArrayBrowserAlternateColour].rgb;						ReleaseResource((Handle) bch );		}		else		{			fBorderColour = gFeintBlue;			fAltColour = gLightGray;		}					fBorderWidth =(*bth)->borderWidth;		fColumnInset =(*bth)->columnInset;		fRowExtra =(*bth)->rowExtraHeight;		fDrawColBorder =(*bth)->drawColBorder;	}	else		InitStyle((*bth)->initStyle );			switch((*bth)->dataType )	{		case kBrowserPStringType:			// set viewer to pascal string viewer			FailNIL( fViewer = new ZPStrViewer());			SetArrayFromSTRList((*bth)->dataResID );			break;					case kBrowserIconType:			// this attaches a suitable viewer			SetArrayFromICLB((*bth)->dataResID );			break;					default:			break;	}			SetColumns((*bth)->numColumns );	SetCanBeHandler( TRUE );	CalcSizes();		HPurge((Handle) bth );	ReleaseResource((Handle) bth );}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/// construct array browser based on 'View' resource, etcZArrayBrowser::ZArrayBrowser( const short viewResourceID, ZView* aParent )	: ZScrollAwareView( aParent, NULL ){	classID = CLASS_ZArrayBrowser;		fArray = NULL;	fViewer = NULL;	fOwnsArray = FALSE;	FailNIL( fSelection = NewRgn());	FailNIL( fColumnTabs = new ZArray( sizeof( short )));	fLastKeyTime = TickCount();	sSearchStr[0] = 0;	fThresh = MIN( 120, LMGetKeyThresh() * 2 );			ViewResInit( viewResourceID );	CalcSizes();}	/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZArrayBrowser::~ZArrayBrowser(){	SendMessage( kMsgArrayBrowserCleanUp, NULL );		if ( fArray && fViewer && fOwnsArray )		fViewer->PerformArrayCleanUp( fArray );		if ( fArray && fOwnsArray )		FORGETOBJECT( fArray );			if ( fColumnTabs )		FORGETOBJECT( fColumnTabs );			if ( fSelection )		DisposeRgn( fSelection );			if ( fViewer )		FORGETOBJECT( fViewer );}	/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	draw the content of this viewins: 			noneouts: 			nonenotes:			draws the array browser view - actual data drawn by fViewer----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DrawContent(){	Rect		cr;	long		botLine, n, i;	Ptr			data;	RgnHandle	tcr;		if ( fArray )	{		GetClip( tcr = NewRgn());		cr = *REGIONBOUNDINGBOX( tcr );		DisposeRgn( tcr );				n = GetRowCount();		i = MAX( 1, ( cr.top / fLineHeight ) + 1 );		botLine = MIN( n, ( cr.bottom / fLineHeight ) + 1 );			if ( fSelColumn > 0 )		{			// if we have a selected column, paint its background in the			// alternate colour. This mimics the data browser, finder view, etc					Rect	scRect;						CalcSelectedColumnRect( &scRect );					#if APPEARANCE_MGR_AWARE			if ( gMacInfo.hasAppearanceMgr )				SetThemeBackground( kThemeBrushListViewSortColumnBackground, GetMainScreenDepth(), gMacInfo.supportsColour );			else		#endif					RGBBackColor( &fAltColour );			EraseRect( &scRect );			PrepareForDrawing();		}				FailNIL( data = NewPtr( fArray->GetBlockSize()));				// draw all the visible rows:				do		{			fArray->GetArrayItem( data, i );						// disabled or inactive views use greyed text by default - viewer may			// override this setting						if ( IsActive() && IsEnabled())				TextMode( srcOr );			else				TextMode( grayishTextOr );							Draw1Row( i, data );		}		while( ++i <= botLine );					DisposePtr( data );		DrawColBorders();	}		// redraw the selection			UpdateSelection( fSelection );		// if there are any child views in the array browser, ensure they're drawn.	// This is slightly unusual, but works - i.e. you could have a checkbox or other	// control on each row.		ZView::DrawContent();}	/*--------------------------------***  ClickContent  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to a click in the viewins: 			<mouse> the mouse coordinates local to view				<modifiers> modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::ClickContent( const Point mouse, const short modifiers ){	RgnHandle	tempRgn;	short		hitLine, ohl, top, mode;	Point		mp, omp = { -1, -1 };		if ( fArray == NULL )		return;	ohl = PtInColumnTab( mouse );			if ( ohl )		DragColumnTab( mouse, ohl );	else	{			FailNIL( tempRgn = NewRgn());				mp = mouse;		ohl = -1;		mode = kModeReplace;				hitLine = CalcSelection( mouse, NULL );				if ( gApplication->GetClicks() > 1 )			SendMessage( kMsgArrayBrowserDoubleClicked, &hitLine );					// if multiple selection allowed, examine modifier keys to establish a		// mode for manipulating the selection region				if ( fSelFlags & kStandardMultiSelect )		{			if ( modifiers & shiftKey )			{				mode = kModeAddRange;								// for shift-clicks, need to know current top of selection								Rect	selBox = *REGIONBOUNDINGBOX( fSelection );								top = (( selBox.top + ( fLineHeight / 2 )) / fLineHeight ) + 1;								// if click at or above top, use bottom as anchor								if ( hitLine <= top )					top = (( selBox.bottom - ( fLineHeight / 2 )) / fLineHeight ) + 1;			}			else			{				if ( modifiers & cmdKey )				{					if ( IsRowSelected( hitLine ))						mode = kModeInvert;					else						mode = kModeAddSingle;				}			}		}				// now track that mouse...				do		{			if ( DeltaPoint( mp, omp ))			{				hitLine = CalcSelection( mp, tempRgn );							if ( hitLine != ohl )				{					if ( mode == kModeAddRange )					{						// if selecting a range, calculate the region between where we clicked						// and the appropriate anchor												CalcSelectionRange( top, hitLine, tempRgn );						}										SetSelectionRgn( tempRgn, mode );										ohl = hitLine;				}								omp = mp;								AutoScroll( mp );				DragLoopHook( mp );			}						GetMouse( &mp );		}		while( WaitMouseUp());				DisposeRgn( tempRgn );	}}	/*------------------------------***  SetViewCursor  ***---------------------------------*//*access:			publicoverrides:		description: 	set the cursor for the viewins: 			<mouse> the point relative to the bounds				<modifiers> the modifier flagsouts: 			nonenotes:			this is only called if this view (and no child) contains the cursor----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetViewCursor( const Point mouse, const short modifiers ){	if ( PtInColumnTab( mouse ))		SetCursorShape( COLUMN_RESIZE_CURSOR );	else	{		if ( ShouldDrag( mouse, modifiers ))			SetCursorShape( DRAG_CURSOR );		else			SetCursorShape(( fSelFlags & kUseStdPlusCursor )? plusCursor : ARROW_CURSOR );	}}/*---------------------------------***  SetFontInfo  ***--------------------------------*//*access:			publicoverrides:		description: 	set the text characteristics for this viewins: 			<fontID> the font				<size> the size of the font				<style> the style of the fontouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetFontInfo( const short fontID, const short size, const Style style ){	ZView::SetFontInfo( fontID, size, style );	CalcSizes();	CalcBounds();	PostContentRefresh();}/*-----------------------------------***  Type  ***-------------------------------------*//*access:			publicoverrides:		description: 	change selection using arrow keysins: 			<theKey> the character code of the key				<modifiers> state of modifier keysouts: 			nonenotes:			changes selection in the view and sends message if changed----------------------------------------------------------------------------------------*/void		ZArrayBrowser::Type( const char theKey, const short modifiers ){	// arrow keys navigate the selection		long		row;	Boolean		cmd = (( modifiers & cmdKey ) == cmdKey );	short		mods = modifiers &~ cmdKey;		Focus();	ObscureCursor();		switch( theKey )	{		case DOWN_ARROW_KEY:			if ( cmd )				ChangeSelection( GetRowCount(), mods );			else 			{				row = FindLastSelection();				ChangeSelection( ++row, mods );			}			break;				case UP_ARROW_KEY:			if ( cmd )				ChangeSelection( 1, mods );			else			{			 	row = FindFirstSelection();			 	ChangeSelection( --row, mods );			}			break;					case LEFT_ARROW_KEY:			if ( fSelFlags & kAllowKeyboardColumnSwitch )				SelectColumn( fSelColumn - 1 );			break;					case RIGHT_ARROW_KEY:			if ( fSelFlags & kAllowKeyboardColumnSwitch )				SelectColumn( fSelColumn + 1 );			break;					case BACKSPACE_KEY:			if ( fSelFlags & kAllowKeyboardAutoDelete )			{				DeleteSelectedRows();				break;			}						// fall through to default			default:			if ( fSelFlags & kAutoTypeSelection )			{				if ( AutoTypeSelect( theKey ))					break;			}						ZScrollAwareView::Type( theKey, modifiers );			break;	}}/*--------------------------------***  UpdateMenus  ***---------------------------------*//*access:			publicoverrides:		description: 	enable appropriate menu commandsins: 			noneouts: 			nonenotes:			enables select all, but only if multiple selections allowed----------------------------------------------------------------------------------------*/void		ZArrayBrowser::UpdateMenus(){	if ( fSelFlags & kStandardMultiSelect )	{		gMenuBar->EnableCommand( kCmdSelectAll );	}		if ((( fSelFlags & kAllowCutAndPaste ) == kAllowCutAndPaste ) && HasSelection())	{		gMenuBar->EnableCommand( kCmdCut );		gMenuBar->EnableCommand( kCmdCopy );		gMenuBar->EnableCommand( kCmdClear );	}		ZView::UpdateMenus();}/*--------------------------------***  DoSelectAll  ***---------------------------------*//*access:			publicoverrides:		description: 	implement the "select all" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DoSelectAll(){	RgnHandle	temp;		FailNIL( temp = NewRgn());		SetWatchCursor();	Focus();	PrepareForDrawing();	FocusForContent();	ClipViewsAbove();		CalcSelectionRange( 1, GetRowCount(), temp );	SetSelectionRgn( temp, kModeAddRange );				DisposeRgn( temp );}/*-------------------------------***  DoSelectNone  ***---------------------------------*//*access:			publicoverrides:		description: 	implement the "select none" commandins: 			noneouts: 			nonenotes:			removes any selection----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DoSelectNone(){	RgnHandle	temp;		FailNIL( temp = NewRgn());		Focus();	PrepareForDrawing();	FocusForContent();	ClipViewsAbove();		SetSelectionRgn( temp, kModeReplace );				DisposeRgn( temp );}/*----------------------------------***  DoCopy  ***------------------------------------*//*access:			publicoverrides:		description: 	implement the "Copy" commandins: 			noneouts: 			nonenotes:			only copies the first selected item in a multiple selection----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DoCopy(){	OSType		dt;	Ptr			data;	Handle		h;		if ( fViewer )	{		dt = fViewer->GetClipboardDataType();			if ( fArray && !EmptyRgn( fSelection ))		{			long	row = 1;						FailNIL( data  = NewPtr( fArray->GetBlockSize()));						row = FindFirstSelection( row );					if ( row )			{				fArray->GetArrayItem( data, row );								h = fViewer->MakeClipboardData( row, data );								if ( h )				{					gClipboard->PutData( dt, h );					DisposeHandle( h );				}			}						DisposePtr( data );		}	}}/*---------------------------------***  DoClear  ***------------------------------------*//*access:			publicoverrides:		description: 	implement the "Clear" commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DoClear(){	if ( fSelFlags & kAllowCutAndPaste )		DeleteSelectedRows();}/*---------------------------------***  DoPaste  ***------------------------------------*//*access:			publicoverrides:		description: 	implement the "Paste" commandins: 			noneouts: 			nonenotes:			paste inserts in front of the first selected item, or at the end if none.				the pasted item is selected.----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DoPaste(){	OSType		dt;	Ptr			data;	Handle		h;		if ( fViewer )	{		dt = fViewer->GetClipboardDataType();			if ( fArray )		{			long	row;						FailNIL( data  = NewPtr( fArray->GetBlockSize()));						row = FindFirstSelection();						h = gClipboard->GetData( dt );						if ( h )			{				fViewer->ConvertClipboardData( row, h, data );				DisposeHandle( h );								if ( row )					fArray->InsertItem( data, row );				else				{					fArray->AppendItem( data );					row = GetRowCount();				}									// change the selection to the selected row								ChangeSelection( row, 0 );			}						DisposePtr( data );		}	}}/*-------------------------------***  CanPasteType  ***---------------------------------*//*access:			publicoverrides:		description: 	check if paste operation permittedins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::CanPasteType(){	if ((( fSelFlags & kAllowCutAndPaste ) == kAllowCutAndPaste ) && fViewer )		return gClipboard->QueryType( fViewer->GetClipboardDataType());	else		return FALSE;}/*------------------------------***  ClickInSamePlace  ***------------------------------*//*access:			publicoverrides:		description: 	test if two sequential clicks occurred in the same logical objectins: 			<a> first point				<b> second pointouts: 			TRUE if points in same placenotes:			same place here means same line and column----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::ClickInSamePlace( const Point a, const Point b ){	short lineA, lineB;		lineA = CalcSelection( a, NULL );	lineB = CalcSelection( b, NULL );		if ( lineA == lineB )	{		// on same line - in same column?				lineA = GetColumnHit( a );		lineB = GetColumnHit( b );			return lineA == lineB;	}		return FALSE;}/*----------------------------------***  SetArray  ***----------------------------------*//*access:			publicoverrides:		description: 	set which array this view is browsingins: 			<anArray> the array to browse				<viewOwnsIt> TRUE if view can dispose the array when necessaryouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetArray( ZArray* anArray, const Boolean viewOwnsIt ){	if ( fArray != anArray )	{		if ( fArray )		{			if ( fOwnsArray )			{				if ( fViewer )					fViewer->PerformArrayCleanUp( fArray );								FORGETOBJECT( fArray );			}			else				StopListeningTo( fArray );		}		fArray = anArray;			fOwnsArray = viewOwnsIt;				SetEmptyRgn( fSelection );		ListenTo( fArray );		CalcBounds();	}}	/*-----------------------------***  SetColumnPosition  ***------------------------------*//*access:			publicoverrides:		description: 	set the position of one columnins: 			<whichColumn> the column to adjust (columns start at 1)				<aPos> the position to set the columnouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetColumnPosition( const short whichColumn, const short aPos ){	short 	op, w = aPos;		if ( whichColumn > 0 && whichColumn <= GetColCount())	{		op = GetColumnPosition( whichColumn );		fColumnTabs->SetArrayItem( &w, whichColumn );				// if chain columns flag on, adjust following columns				if ( fSelFlags & kChainColumnTabs )		{			for( short i = whichColumn + 1; i <= GetColCount(); i++ )			{				w = GetColumnPosition( i ) + aPos - op;						fColumnTabs->SetArrayItem( &w, i );			}		}				if (( whichColumn == GetColCount()) || ( fSelFlags & kChainColumnTabs ))			CalcBounds();					SendMessage( kMsgArrayBrowserColumnMoved, NULL );	}}	/*------------------------------***  GetColumnPosition  ***-----------------------------*//*access:			publicoverrides:		description: 	get the position of one columnins: 			<whichColumn> the column to queryouts: 			the width of the columnnotes:			----------------------------------------------------------------------------------------*/short		ZArrayBrowser::GetColumnPosition( const short whichColumn ){	short 	w = 0;		fColumnTabs->GetArrayItem( &w, whichColumn );		return w;}/*-------------------------------***  SetColumnWidth  ***-------------------------------*//*access:			publicoverrides:		description: 	set the width of one columnins: 			<whichColumn> the column to queryouts: 			the width of the columnnotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetColumnWidth( const short whichColumn, const short aWidth){	short	pos = aWidth;		if ( whichColumn > 1 && whichColumn <= GetColCount())		pos += GetColumnPosition( whichColumn - 1 );			SetColumnPosition( whichColumn, pos );}	/*---------------------------------***  SetColumns  ***---------------------------------*//*access:			publicoverrides:		description: 	set the number of columns for the viewins: 			<numColumns> the number of desired columnsouts: 			nonenotes:			also resets the columns to default widths and does not refresh----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetColumns( const short numColumns ){	short	cw = kDefaultColumnWidth, i;		fColumnTabs->DeleteAll();		for( i = 1; i <= numColumns; i++ )	{		fColumnTabs->AppendItem( &cw );		cw += kDefaultColumnWidth;		}		}/*----------------------------------***  InitStyle  ***---------------------------------*//*access:			publicoverrides:		description: 	convenience method to set appearance to match particular styleins: 			<aStyle> style constantouts: 			nonenotes:			using a style does not mean you can't modify it afterwards anyway----------------------------------------------------------------------------------------*/void		ZArrayBrowser::InitStyle( const short aStyle ){	fAltColour = gLightGray;	fBorderColour = gFeintBlue;					switch ( aStyle )	{		case kBrowserStyleAdoptSysAppearance:#if APPEARANCE_MGR_AWARE						if ( gMacInfo.hasAppearanceMgr )			{				MakeEnvironment();								ZViewEnvironment*	env = GetEnvironment();								env->SetThemedFont( kThemeSystemFont );				env->SetThemedBack( kThemeBrushListViewBackground );				env->SetThemedInactiveBack( kThemeBrushListViewBackground );				env->SetThemedTextColour( kThemeTextColorListView );				GetThemeBrushAsColor( kThemeBrushListViewSeparator , GetMainScreenDepth(), TRUE, &fBorderColour );				GetThemeBrushAsColor( kThemeBrushListViewSortColumnBackground , GetMainScreenDepth(), TRUE, &fAltColour );				fRowExtra = 0;				fBorderWidth = 0;				fDrawColBorder = FALSE;				fColumnInset = 4;				CalcSizes();				break;			}#endif				case kBrowserStyleStdList:			fBorderWidth = 0;			SetBackColour( &gWhite );			SetForeColour( &gBlack );			fRowExtra = 0;			fDrawColBorder = FALSE;			fColumnInset = 4;			SetFontInfo( 0, 0, 0 );			break;			case kBrowserStyleSmallList:			fBorderWidth = 0;			SetBackColour( &gWhite );			SetForeColour( &gBlack );			fRowExtra = 2;			fDrawColBorder = FALSE;			fColumnInset = 4;			SetFontInfo( kFontIDGeneva, 9, 0 );			break;			case kBrowserStyleAdoptAppearance:#if APPEARANCE_MGR_AWARE						if ( gMacInfo.hasAppearanceMgr )			{				MakeEnvironment();								ZViewEnvironment*	env = GetEnvironment();				env->SetThemedFont( kThemeViewsFont );				env->SetThemedBack( kThemeBrushListViewBackground );				env->SetThemedInactiveBack( kThemeBrushListViewBackground );				env->SetThemedTextColour( kThemeTextColorListView );				GetThemeBrushAsColor( kThemeBrushListViewSeparator , GetMainScreenDepth(), TRUE, &fBorderColour );				GetThemeBrushAsColor( kThemeBrushListViewSortColumnBackground , GetMainScreenDepth(), TRUE, &fAltColour );				fRowExtra = 5;				fBorderWidth = 1;				fDrawColBorder = TRUE;				fColumnInset = 4;				CalcSizes();				break;			}#endif		case kBrowserStyleFinderView:			fSelFlags = kStandardMultiSelect + kAllowKeyboardColumnSwitch + kAllowCutAndPaste + kEnableDragSend + kEnableDragReceive;			fBorderWidth = 1;			SetBackColour( &gVeryLightGray );			SetForeColour( &gBlack );			fAltColour = gLightGray;			fBorderColour = gWhite;			fRowExtra = 5;			fDrawColBorder = FALSE;			fColumnInset = 4;			SetFontInfo( kFontIDGeneva, 10, 0 );			break;				}}	/*--------------------------------***  SelectColumn  ***--------------------------------*//*access:			publicoverrides:		description: 	set which column is considered "selected" - this column may be drawn with				a distinct background colour (fAltColour)ins: 			<whichColumn> the column to selectouts: 			nonenotes:			refreshes as needed----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SelectColumn( const short whichColumn ){	short col = MAX( 1, MIN( GetColCount(), whichColumn ));		if ( col != fSelColumn )	{		fSelColumn = col;				// this message may actually resort the list, so send it before		// we refresh the list.				SetArrayUpdates( FALSE );		SendMessage( kMsgArrayBrowserSelectColumn, &fSelColumn );		SetArrayUpdates( TRUE );	}}	/*------------------------------***  ChangeSelection  ***-------------------------------*//*access:			publicoverrides:		description: 	programmatically select a rowins: 			<whichRow> the row to select				<modifiers> modifiers flags that affect how the selection is modifiedouts: 			nonenotes:			selection is immediately redrawn----------------------------------------------------------------------------------------*/void		ZArrayBrowser::ChangeSelection( const long whichRow, const short modifiers ){	Point	mp;	short	row;		row = MAX( 1, MIN( whichRow, GetRowCount()));		mp.h = 0;	mp.v = (( row - 1 ) * fLineHeight );		Focus();	PrepareForDrawing();	FocusForContent();	ClipViewsAbove();		ClickContent( mp, modifiers );	ScrollAsNeeded( mp );}	/*-------------------------------***  IsRowSelected  ***--------------------------------*//*access:			publicoverrides:		description: 	query whether a given row is selectedins: 			<whichRow> the row to queryouts: 			TRUE if selected, else FALSEnotes:			----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::IsRowSelected( const long whichRow ){	Point	testPt;		testPt.v = (( whichRow - 1 ) * fLineHeight ) + 1;	testPt.h = 1;		return PtInRgn( testPt, fSelection );}/*----------------------------***  FindFirstSelection  ***------------------------------*//*access:			publicoverrides:		description: 	search for a selected row from the top downwardsins: 			<startingAt> the row to begin searchingouts: 			the row index of the next selected row found, or 0 if none foundnotes:			can be used to iterate through a multiple selection----------------------------------------------------------------------------------------*/long		ZArrayBrowser::FindFirstSelection( const long startingAt ){	long	row = startingAt;		if ( fArray )	{		while( row <= GetRowCount())		{			if ( IsRowSelected( row ))				return row;			else				++row;		}	}	return 0;}/*-----------------------------***  FindLastSelection  ***------------------------------*//*access:			publicoverrides:		description: 	search for a selected row from the bottom upwardsins: 			<startingAt> the row to begin searchingouts: 			the row index of the next selected row found, or 0 if none foundnotes:			can be used to iterate through a multiple selection in reverse----------------------------------------------------------------------------------------*/long		ZArrayBrowser::FindLastSelection( const long startingAt ){	long 	row = startingAt;		if ( fArray )	{		if ( row == -1 )			row = GetRowCount();					while( row > 0 )		{			if ( IsRowSelected( row ))				return row;			else				--row;		}	}	return 0;}/*----------------------------***  DeleteSelectedRows  ***------------------------------*//*access:			publicoverrides:		description: 	deletes all of the elements from the array corresponding to selected rowsins: 			noneouts: 			nonenotes:			updates the browser as necessary----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DeleteSelectedRows(){	// delete all of the array items that are selected		if ( fArray && !EmptyRgn( fSelection ))	{		// do not update as we go - it's too slow & cumbersome				SetArrayUpdates( FALSE );		long	row = GetRowCount();				do		{			row = FindLastSelection( row );					if ( row )				fArray->DeleteItem( row );							--row;		}		while( row > 0 );				SetEmptyRgn( fSelection );		SetArrayUpdates( TRUE );	}}/*------------------------------***  AutoTypeSelect  ***--------------------------------*//*access:			publicoverrides:		description: 	automatically select items by typoing the first few lettersins: 			<theKey> latest key to include in searchouts: 			nonenotes:			note this only works if the array data are pascal strings!!!----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::AutoTypeSelect( const char theKey ){	Boolean handled = FALSE;		// only alphanumeric chars significant:		if (( theKey >= 'a' && theKey <= 'z' ) ||		( theKey >= 'A' && theKey <= 'Z' ) ||		( theKey >= '0' && theKey <= '9' ))	{		long	theTime = TickCount();		// time to start a new string yet? If a while has passed or the string		// is getting too long, it is.				if (( theTime > fLastKeyTime + fThresh ) || ( sSearchStr[0] > 12 ))		{			// start a new string						sSearchStr[0] = 0;		}		fLastKeyTime = theTime;				// add typed chars to the search string				sSearchStr[++sSearchStr[0]] = theKey;		UpperString( sSearchStr, TRUE );				long row = FindArrayData((Ptr) &sSearchStr[1], sSearchStr[0] );		if ( row )		{			ChangeSelection( row, 0 );			handled = TRUE;		}	}		return handled;	}/*-------------------------------***  FindArrayData  ***--------------------------------*//*access:			publicoverrides:		description: 	find the first array item that matches the datains: 			<searchData> pointer to some arbitrary data				<searchLength> length of the search data				<searchOffset> offset from beginning of data to start testingouts: 			row number of first matching array element, or 0notes:			viewer actually does comparison based on the data format it understands----------------------------------------------------------------------------------------*/long		ZArrayBrowser::FindArrayData( Ptr searchData, long searchLength ){	long	row = 0, n;	Ptr		data;		if ( fArray && fViewer )	{		n = GetRowCount();				FailNIL( data = NewPtr( fArray->GetBlockSize()));				for ( row = 1; row <= n; row++ )		{			fArray->GetArrayItem( data, row );						if ( fViewer->TestDataEqual( data, searchData, searchLength ))				break;		}				DisposePtr( data );				if ( row > n )			row = 0;	}		return row;}/*-----------------------------***  DoForEachSelected  ***------------------------------*//*access:			publicoverrides:		description: 	iterator function calls the proc passed for each selected itemins: 			<aProc> the iteration procedure called by this				<ref> a constant passed through to the procouts: 			nonenotes:			iterates the array in reverse----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DoForEachSelected( IteratorProcPtr aProc, const long ref ){	if ( aProc &&  GetRowCount() > 0 )	{		long	i = GetRowCount();		Ptr		temp = NewPtr( fArray->GetBlockSize());				FailNIL( temp );				do		{			i = FindLastSelection( i );						fArray->GetArrayItem( temp, i);			(*aProc)( temp, ref );						// in case the proc changed the item, set it back						fArray->SetArrayItem( temp, i-- );		}		while( i > 0 );				DisposePtr( temp );	}}	/*--------------------------------***  AttachViewer  ***--------------------------------*//*access:			publicoverrides:		description: 	attach a browser viewer to the browserins: 			<aViewer> the viewer to attachouts: 			nonenotes:			only the viewer needs to understand the data format of array items----------------------------------------------------------------------------------------*/void		ZArrayBrowser::AttachViewer( ZBrowserViewer* aViewer ){	if ( fViewer  && ( fViewer != aViewer ))		FORGETOBJECT( fViewer );			fViewer = aViewer;	fViewer->SetOwner( this );}/*----------------------------------***  Draw1Row  ***----------------------------------*//*access:			publicoverrides:		description: 	draw a single rowins: 			<aViewer> the viewer to attachouts: 			nonenotes:			called by DrawContent as needed----------------------------------------------------------------------------------------*/void		ZArrayBrowser::Draw1Row( const long row, void* cellData ){	Rect		cellRect;	short		col, cTab;	Boolean		selected;		PrepareForDrawing();	cellRect.top = (( row - 1 ) * fLineHeight );	cellRect.bottom = cellRect.top + fLineHeight;	cellRect.left = 0;	selected = IsRowSelected( row );		for( col = 1; col <= GetColCount(); col++ )	{		cTab = GetColumnPosition( col );		cellRect.right = cTab - 1;		// as a convenience, position the pen in the usual place				MoveTo( cellRect.left + fColumnInset, cellRect.top + fAscent );				// call the viewer object to render the data here				if ( fViewer )			fViewer->DrawBrowserCell( &cellRect, row, col, cellData,										( fSelFlags & kCustomSelectionDrawing )? selected : FALSE );					cellRect.left = ++cTab;	}				// draw a border below the row				DrawRowBorder( &cellRect );	}/*-------------------------------***  DrawRowBorder  ***--------------------------------*//*access:			publicoverrides:		description: 	draw the border of a rowins: 			<theRow> bounding rect of the row being drawnouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DrawRowBorder( Rect* theRow ){	if ( fBorderWidth > 0 )	{		Rect	cr;				GetContentRectInBounds( &cr );				RGBForeColor( &fBorderColour );		PenSize( fBorderWidth, fBorderWidth );		MoveTo( cr.left, theRow->bottom - fBorderWidth );		LineTo( cr.right, theRow->bottom - fBorderWidth );		PenNormal();	}			}/*-------------------------------***  DrawColBorders  ***-------------------------------*//*access:			publicoverrides:		description: 	draw column borders, if enabledins: 			noneouts: 			nonenotes:		----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DrawColBorders(){	// draw column borders		if (( fBorderWidth > 0 ) && fDrawColBorder )	{		short 	i, c, cTab;		Rect	cr;				GetContentRectInBounds( &cr );		i = MIN( GetRowCount() * fLineHeight, cr.bottom );				RGBForeColor( &fBorderColour );		PenSize( fBorderWidth, fBorderWidth );				for( c = 1; c < GetColCount(); c++ )		{			cTab = GetColumnPosition( c );			MoveTo( cTab, cr.top );			LineTo( cTab, i );			}		PenNormal();	}}/*---------------------------------***  ShouldDrag  ***---------------------------------*//*access:			publicoverrides:		description: 	test if mouse click should start a dragins: 			<mouse> mouse point local to bounds				<modifiers> modifier keysouts: 			TRUE if the click should start a drag, FALSE if a normal clicknotes:		----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::ShouldDrag( const Point mouse, const short modifiers ){	Boolean		drag;		drag = 	gMacInfo.hasDragManager &&			PtInRgn( mouse, fSelection ) &&			(( fSelFlags & kEnableDragSend ) == kEnableDragSend ) &&			(( modifiers & ( cmdKey | optionKey | shiftKey )) == 0 ) &&			! PtInColumnTab( mouse );	return drag;}/*-------------------------------***  MakeDragRegion  ***-------------------------------*//*access:			publicoverrides:		description: 	form local region that will become the drag outlineins: 			<theRgn> receives formed regionouts: 			nonenotes:		----------------------------------------------------------------------------------------*/void		ZArrayBrowser::MakeDragRegion( RgnHandle theRgn ){	ZView::MakeDragRegion( theRgn );	SectRgn( fSelection, theRgn, theRgn );}/*--------------------------------***  MakeDragData  ***--------------------------------*//*access:			publicoverrides:		description: 	add data to the drag.ins: 			<theDrag> drag ref to add to				<modifiers> state of modifiers in case this affects what you dragouts: 			nonenotes:			this uses the viewer to translate array data and add it to the drag				also sets the flags for the drag as required----------------------------------------------------------------------------------------*/void		ZArrayBrowser::MakeDragData( DragReference theDrag, const short modifiers ){	OSType			dType;	long			row;	ItemReference	i;	Ptr				itemPtr;	Handle			iData;		if ( fViewer )	{		// this is the flavour we are going to add:				dType = fViewer->GetClipboardDataType();			row = GetRowCount() + 1;		i = 0;				FailNIL( itemPtr = NewPtr( fArray->GetBlockSize()));				do		{			row = FindLastSelection( --row );						if ( row )			{				fArray->GetArrayItem( itemPtr, row );				iData = fViewer->MakeClipboardData( row, itemPtr );							if ( iData )				{					HLock( iData );					AddDragItemFlavor( theDrag, ++i, dType, *iData, GetHandleSize( iData ), 0 );					HUnlock( iData );					DisposeHandle( iData );				}			}		}		while( row );			DisposePtr( itemPtr );	}		}/*------------------------------***  CanAcceptTheDrag  ***------------------------------*//*access:			publicoverrides:		description: 	determine if current drag is acceptableins: 			<theDrag> drag ref to check outouts: 			TRUE if drag acceptable, else FALSEnotes:			this accept drags that contains flavours matching the viewer's type. Also,				only accepts drags from self if flag set allowing it----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::CanAcceptTheDrag( const DragReference theDrag ){	if ( sCurTxDragSender == this )	{		// dragging to self - is this permitted?				if (( fSelFlags & kEnableDragReorder ) == 0 )			return FALSE;	}	else	{		// somebody else dragging here - is that permitted?			if (( fSelFlags & kEnableDragReceive ) == 0 )			return FALSE;	}			// yes, we can drag to self, or somebody else is dragging here legally, so test flavours	// in the normal way.		return ZView::CanAcceptTheDrag( theDrag );}/*-------------------------------***  AcceptsFlavour  ***-------------------------------*//*access:			publicoverrides:		description: 	determine if current drag flavour is acceptableins: 			<aFlavour> flovour to testouts: 			TRUE if flavour acceptable, else FALSEnotes:			----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::AcceptsFlavour( const OSType aFlavour ){	if ( fViewer )		return ( fViewer->GetClipboardDataType() == aFlavour );	else		return FALSE;}/*--------------------------------***  DDInsideView  ***--------------------------------*//*access:			publicoverrides:		description: 	highlight where a potential drop would occurins: 			<mouse> mouse local to bounds				<theDrag> the drag itselfouts: 			nonenotes:			draws "in between rows" highlight----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DDInsideView( const Point mouse, const DragReference theDrag ){	RgnHandle	hRgn;	Boolean		rChanged = TRUE;		FailNIL( hRgn = NewRgn());	CalcDragInsertRgn( mouse, hRgn );		if ( sDragInsertRgn )	{		XorRgn( hRgn, sDragInsertRgn, gUtilRgn );		rChanged = !EmptyRgn( gUtilRgn );	}	if ( sDragInsertRgn )	{		if ( rChanged )			EraseRgn( sDragInsertRgn );	}	else		sDragInsertRgn = hRgn;	AutoScroll( mouse, fLineHeight / 2 );		if ( rChanged )	{		CopyRgn( hRgn, sDragInsertRgn );		PaintRgn( sDragInsertRgn );	}		if ( hRgn != sDragInsertRgn )		DisposeRgn( hRgn );}/*---------------------------------***  DDExitView  ***---------------------------------*//*access:			publicoverrides:		description: 	the drag has left the viewins: 			<theDrag> the drag itselfouts: 			nonenotes:			removes any highlighting ther may have been----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DDExitView( const DragReference theDrag ){	if ( sDragInsertRgn )	{		Focus();		PrepareForDrawing();		FocusForContent();		ClipViewsAbove();		InvertRgn( sDragInsertRgn );		DisposeRgn( sDragInsertRgn );		sDragInsertRgn = NULL;	}		ZView::DDExitView( theDrag );}/*---------------------------------***  UnpackDrop  ***---------------------------------*//*access:			publicoverrides:		description: 	if dragging to self and option key not down, delete selection firstins: 			<theDrag> the drag itselfouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean		ZArrayBrowser::UnpackDrop( const DragReference theDrag ){	short			mf, insertHere;	unsigned short	rows;	Boolean			result;		GetDragModifiers( theDrag, &mf, NULL, NULL );		if ( sCurTxDragSender == this )	{		if (( mf & optionKey ) == 0 )		{			DeleteSelectedRows();		}	}		result =  ZView::UnpackDrop( theDrag );		DoSelectNone();	insertHere = ( REGIONBOUNDINGBOX( sDragInsertRgn )->top / fLineHeight ) + 2;	CountDragItems( theDrag, &rows );		ChangeSelection( insertHere, 0 );	ChangeSelection( insertHere + rows - 1, shiftKey );		return result;}/*------------------------------------***  Drop  ***------------------------------------*//*access:			publicoverrides:		description: 	called for each item dropped on the viewins: 			<flavour> the data type of the data				<data> pointer to the data in the drag				<dataSize> the size of the data				<theDrag> the drag itself if neededouts: 			nonenotes:			inserts the data into the list----------------------------------------------------------------------------------------*/void		ZArrayBrowser::Drop( const OSType flavour, const Ptr data, const long dataSize, const DragReference theDrag ){	long	insertHere;	Handle	rawData;	Ptr		itemData;		if ( sDragInsertRgn && fViewer && fArray )	{		insertHere = ( REGIONBOUNDINGBOX( sDragInsertRgn )->top / fLineHeight ) + 2;		FailNIL( itemData = NewPtr( fArray->GetBlockSize()));				FailOSErr( PtrToHand( data, &rawData, dataSize ));			// convert to native format & place in array				fViewer->ConvertClipboardData( insertHere, rawData, itemData );		fArray->InsertItem( itemData, insertHere );					// clean up				DisposePtr( itemData );		DisposeHandle( rawData );	}}/*-------------------------------***  ReceiveMessage  ***-------------------------------*//*access:			publicoverrides:		description: 	listen to messages from the array and update browser accordinglyins: 			<aSender> the sender of the message				<msg> the message				<msgData> data sent along with the messageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	if ( aSender == fArray )	{		// if array sends any message here, recalculate and refresh. Thus we automatically		// update as the array is changed				PostContentRefresh();		CalcBounds();	}	else	{		if ( msg == kMsgScrollViewAreaReveal )		{			// parent scroller has changed size - extend bounds to match content rect			// of the scroller						CalcBounds();		}	}}/*-----------------------------***  SetArrayFromSTRList  ***----------------------------*//*access:			publicoverrides:		description: 	create array from STR# resourceins: 			<strListID> resource ID of string listouts: 			nonenotes:			convenience method for building 1-column lists of strings----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetArrayFromSTRList( const short strListID ){	ZArray*		strArray;	short**		strH;	short		n, i;	Str255		s;		FailNILRes( strH = (short**) GetResource( 'STR#', strListID ));	n = **strH;	ReleaseResource((Handle) strH );		// n.b. a standard array is very wasteful for strings. Instead,	// ZPStrArray is used which is far more efficient in memory usage terms.	// It's a subclass of ZArray so works with the browser just the same.		FailNIL( strArray = new ZPStrArray());		for( i = 1; i <= n; i++ )	{		GetIndString( s, strListID, i );		strArray->AppendItem( s );	}		SetArray( strArray, TRUE );}	/*------------------------------***  SetArrayFromICLB  ***------------------------------*//*access:			publicoverrides:		description: 	create array from 'ICLB' resourceins: 			<resID> resource ID of 'ICLB' resourceouts: 			nonenotes:			convenience method for building 1-column lists of icons----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetArrayFromICLB( const short resID ){	ZArray*			iconArray;	ZIconViewer*	iconViewer;	IconListBoxHdl	lbH;	short			i;	IconInfo		info;		fRowExtra = 33;	fBorderWidth = 4;	fBorderColour = gWhite;	fSelFlags = kDisableSelectionHilite + kCustomSelectionDrawing + kAutoTypeSelection;	SetFontInfo( kFontIDGeneva, 9, 0 );		FailNIL( iconArray = new ZArray( sizeof( IconInfo )));	FailNIL( iconViewer = new ZIconViewer());	FailNILRes( lbH = (IconListBoxHdl) GetResource( kIconListTemplateResType, resID ));	iconViewer->SetShowTitles((*lbH)->addTitles );	iconViewer->SetIconHiliteStyle(( IconHilite ) (*lbH)->hiliteStyle );	for( i = 0; i < (*lbH)->numIcons; i++ )	{		// locate each icon and load it as needed				info.iconID = (*lbH)->icons[i].resID;		switch ((*lbH)->icons[i].iconType)		{			case 0:		// plain black & white icon				info.iType = IconPlain;				info.theIcon = GetIcon( info.iconID );				HNoPurge( info.theIcon );				break;						case 1:		// 'cicn' resource				info.iType = IconColour;				info.theIcon = (Handle) GetCIcon( info.iconID );				break;						case 2:		// indexed icon, etc			default:				info.iType = IconIndexed;				info.theIcon = NULL;				break;		}				// get the title string from the relevant string list, and prepend and append a space				GetIndString( info.title, (*lbH)->titleListResID, (*lbH)->icons[i].nameIndex );		BlockMoveData( &info.title[1], &info.title[2], info.title[0] );		info.title[1] = ' ';		info.title[0] += 2;		info.title[ info.title[0]] = ' ';		info.userData = 0;				iconArray->AppendItem( &info );	}		ReleaseResource((Handle) lbH );	AttachViewer( iconViewer );	SetArray( iconArray, TRUE );}/*-------------------------------***  SetArrayUpdates  ***------------------------------*//*access:			publicoverrides:		description: 	set whether changes to the array should affect the browser or notins: 			<wantUpdates> TRUE to listen, FALSE to ignoreouts: 			nonenotes:			normally, this should be TRUE, but if you ar making a lot of changes,				its can be quicker to set this to false, make changes, then set this				to true afterwards to update the browser----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetArrayUpdates( Boolean wantUpdates ){	if ( fArray )	{		if ( wantUpdates )		{			if ( ! fArray->IsAComradeOf( this ))			{				PostContentRefresh();				CalcBounds();				ListenTo( fArray );			}		}		else			StopListeningTo( fArray );	}}	/*--------------------------------***  CalcSelection  ***-------------------------------*//*access:			protectedoverrides:		description: 	convert mouse position to selection region and line numberins: 			<mouse> mouse point in the bounds				<aRgn> put computed region here (can be NULL)outs: 			the row number corresponding to the mousenotes:			pass NULL in the region parameter if you are not interested in this----------------------------------------------------------------------------------------*/short		ZArrayBrowser::CalcSelection( const Point mouse, RgnHandle aRgn ){	Rect	sr;	short	line = mouse.v / fLineHeight;		if ( fArray )	{		line = MAX( 0, MIN( GetRowCount() - 1, line ));				if ( aRgn )		{			GetBounds( &sr );						sr.top = line * fLineHeight;			sr.bottom = sr.top + fLineHeight - fBorderWidth;						RectRgn( aRgn, &sr );		}	}		return ++line;}/*------------------------------***  CalcSelectionRange  ***----------------------------*//*access:			protectedoverrides:		description: 	compute selection based on range of rowsins: 			<fromRow> starting row				<toRow> ending row				<aRgn> receives computed selection regionouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::CalcSelectionRange( const short fromRow, const short toRow, RgnHandle aRgn ){	Point		fp;	short		a, b;	RgnHandle	tempRgn;		FailNILParam( aRgn );		if ( toRow > fromRow )	{		a = fromRow;		b = toRow;	}	else	{		a = toRow;		b = fromRow;	}		SetEmptyRgn( aRgn );	FailNIL( tempRgn = NewRgn());		fp.h = 0;		for( short n = a; n <= b; n++ )	{		fp.v = ( n * fLineHeight ) - fBorderWidth - ( fLineHeight / 2 );				CalcSelection( fp, tempRgn );		UnionRgn( aRgn, tempRgn, aRgn );	}		DisposeRgn( tempRgn );}	/*-------------------------------***  SetSelectionRgn  ***------------------------------*//*access:			protectedoverrides:		description: 	modify the current selection with the region and modeins: 			<aRgn> newly computed selection region, or part of it				<mode> how to combine new and old regionsouts: 			nonenotes:			redraws selection immediately----------------------------------------------------------------------------------------*/void		ZArrayBrowser::SetSelectionRgn( RgnHandle aRgn, const short mode ){	RgnHandle	tr = NewRgn();		switch( mode )	{		case kModeAddRange:			default:			break;				case kModeAddSingle:			UnionRgn( aRgn, fSelection, aRgn );			break;					case kModeInvert:			DiffRgn( fSelection, aRgn, aRgn );			break;	}	XorRgn( aRgn, fSelection, tr );		UpdateSelection( tr );	CopyRgn( aRgn, fSelection );		// if custom hilite flag set, call the viewer to do the work	// the region <tr> indicates which rows need to be redrawn		if ( fSelFlags & kCustomSelectionDrawing )	{		if ( ! EmptyRgn( tr ))		{			MZInvalWindowRgn( GetRootWindowMacWindow(), tr );			GetRootWindow()->PerformUpdate();		}	}	DisposeRgn( tr );	SendMessage( kMsgArrayBrowserSelectionChanged, NULL );	SendMessage( kMsgSignalViewClicked, NULL );}	/*----------------------------------***  CalcBounds  ***--------------------------------*//*access:			protectedoverrides:		description: 	compute the bounds of the view based on the array count, etc.ins: 			<theBounds> optionally receives bounds calculated. May be NULL.outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::CalcBounds( Rect* theBounds ){	Rect	br;	long	n = GetRowCount();	short	nCols = GetColCount();	GetBounds( &br );	br.bottom = br.top + ( n * fLineHeight );	br.right = GetColumnPosition( nCols );	ZScrollView* par = dynamic_cast<ZScrollView*>( GetParent());		if ( par )	{		Rect	cr;				par->GetContentRect( &cr );		br.right = MAX( cr.right - cr.left, br.right );	}		SetBounds( br );		if ( theBounds )		*theBounds = br;}/*-----------------------------------***  CalcSizes  ***--------------------------------*//*access:			protectedoverrides:		description: 	compute the lineheights, etc when the drawing parameters are changedins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::CalcSizes(){	FontInfo	fi;			Focus();	PrepareForDrawing();		GetFontInfo( &fi );		fLineHeight = fi.ascent + fi.descent + fi.leading + fBorderWidth + fRowExtra;	fAscent = fi.ascent + ( fRowExtra / 2 );		SetScrollAmount( 16, fLineHeight, FALSE );}/*------------------------------***  InitViewFromResource  ***--------------------------*//*access:			publicoverrides:		description: 	initialise the view from data in a 'View' resource handleins: 			<theRes> handle to 'View' resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::InitViewFromResource( Handle theRes ){	FailNILParam( theRes );		ZView::InitViewFromResource( theRes );	}/*-------------------------------***  CreateViewResource  ***---------------------------*//*access:			publicoverrides:		description: 	Fills in the resource handle according to its templated structureins: 			<resHandle> valid handle of adequate sizeouts: 			nonenotes:			This method should only be used by the RAD tool to create View resources				(not for application use)----------------------------------------------------------------------------------------*/void		ZArrayBrowser::CreateViewResource( Handle resHandle ){	FailNILParam( resHandle );						ZView::CreateViewResource( resHandle );}	/*---------------------------------***  PtInColumnTab  ***------------------------------*//*access:			protectedoverrides:		description: 	check whether the point passed is close to a column edgeins: 			<mouse> mouse location relative to boundsouts: 			column number if close to the edge, or 0 if notnotes:			----------------------------------------------------------------------------------------*/short		ZArrayBrowser::PtInColumnTab( Point mouse )	{	short tab, i;		if (( fSelFlags & kDisableColumnDragging ) == 0 )	{		for( i = 1; i < GetColCount(); i++ )		{			tab = GetColumnPosition( i );						if ( ABS(  mouse.h - tab ) < 3 )				return i;		}	}	return 0;}/*---------------------------------***  DragColumnTab  ***------------------------------*//*access:			protectedoverrides:		description: 	adjust column positions interactively by draggingins: 			<mouse> mouse location relative to bounds				<whichColumn> the column we are modifyingouts: 			nonenotes:			performs all necessary drawing and updates----------------------------------------------------------------------------------------*/void		ZArrayBrowser::DragColumnTab( Point mouse, short whichColumn )	{	short		tabPos, tabMin, tabMax;	Rect		cr;	Point		om = mouse;	RgnHandle	tcr;		GetClip( tcr = NewRgn());	cr = *REGIONBOUNDINGBOX( tcr );	DisposeRgn( tcr );		cr.bottom = MIN( cr.bottom, GetRowCount() * fLineHeight );		tabPos = GetColumnPosition( whichColumn );		if ( whichColumn == 1 )		tabMin = 0;	else		tabMin = GetColumnPosition( whichColumn - 1 );			if ( whichColumn == GetColCount())		tabMax = cr.right;	else		tabMax = MIN( cr.right, GetColumnPosition( whichColumn + 1 ));				tabMin += 8;	tabMax -= 8;		if (( fSelFlags & kColumnDragsAreLive ) == 0 )	{		PenPat( QDGRAYPATTERN );		PenMode( patXor );		PenSize( 1, 1 );		MoveTo( tabPos, cr.top );		LineTo( tabPos, cr.bottom );	}		do	{		GetMouse( &mouse );				if ( DeltaPoint( mouse, om ))		{			if (( fSelFlags & kColumnDragsAreLive ) == 0 )			{				MoveTo( tabPos, cr.top );				LineTo( tabPos, cr.bottom );			}			tabPos = MAX( tabMin, MIN( tabMax, mouse.h ));						if ( fSelFlags & kColumnDragsAreLive )			{				SetColumnPosition( whichColumn, tabPos );				Focus();				DrawAll();				Focus();				PrepareForDrawing();				FocusForContent();				ClipViewsAbove();				}			else			{				MoveTo( tabPos, cr.top );				LineTo( tabPos, cr.bottom );			}							om = mouse;		}	}	while( WaitMouseUp());		if (( fSelFlags & kColumnDragsAreLive ) == 0 )	{		MoveTo( tabPos, cr.top );		LineTo( tabPos, cr.bottom );		if ( GetColumnPosition( whichColumn ) != tabPos )		{			SetColumnPosition( whichColumn, tabPos );						cr.left = tabMin - 8;						if (( fSelFlags & kChainColumnTabs ) == 0 )				cr.right = tabMax + 8;						Focus();			FocusForContent();			PostRefresh( &cr );		}	}}/*--------------------------------***  UpdateSelection  ***-----------------------------*//*access:			protectedoverrides:		description: 	draw the selection region in the viewins: 			<selRgn> the region to drawouts: 			nonenotes:			takes into account varying background colours, active state, etc.----------------------------------------------------------------------------------------*/void		ZArrayBrowser::UpdateSelection( const RgnHandle selRgn ){	if ( selRgn && ! IsPrinting() && ( fSelFlags & kDisableSelectionHilite ) == 0 )	{		RgnHandle	selTemp;				CopyRgn( selRgn, selTemp = NewRgn());				// if view inactive, use outline of region. For big arrays, the selection can get		// very close to being too large, and this operation will hang in the toolbox.		// However, for the inactive state, we don't care about unseen parts, so sect this		// with the content rect in inactive views to keep the region small				if ( ! IsActive())		{			Rect	cr;						GetContentRectInBounds( &cr );			RectRgn( gUtilRgn, &cr );			SectRgn( gUtilRgn, selTemp, selTemp );			SectRgn( gUtilRgn, selRgn, gUtilRgn );						InsetRgn( selTemp, 2, 2 );			DiffRgn( gUtilRgn, selTemp, selTemp );		}				// if there's a selected column, the row must also hilite on top of		// that colour, so handle that separately		if ( fSelColumn > 0 )		{			RgnHandle	temp;			Rect		scRect;						CalcSelectedColumnRect( &scRect );			RectRgn( temp = NewRgn(), &scRect );			SectRgn( selTemp, temp, temp );				#if APPEARANCE_MGR_AWARE			if ( gMacInfo.hasAppearanceMgr )				SetThemeBackground( kThemeBrushListViewSortColumnBackground, GetMainScreenDepth(), gMacInfo.supportsColour );			else		#endif					RGBBackColor( &fAltColour );			SetHiliteMode();			InvertRgn( temp );						DiffRgn( selTemp, temp, selTemp );			DisposeRgn( temp );			PrepareForDrawing();		}		//SetPortBlackWhite();		SetHiliteMode();		InvertRgn( selTemp );				DisposeRgn( selTemp );	}		// also update the drag hilite if there is one		if ( sDragInsertRgn )		InvertRgn( sDragInsertRgn );}/*----------------------------------***  GetRowCount  ***-------------------------------*//*access:			protectedoverrides:		description: 	get the number of rowsins: 			noneouts: 			the number of rowsnotes:			----------------------------------------------------------------------------------------*/long		ZArrayBrowser::GetRowCount()	{	if ( fArray )	{		long rMax = 32000L / (long) fLineHeight;		return MIN( fArray->CountItems(), rMax );	}	else		return 0;}/*----------------------------------***  GetColCount  ***-------------------------------*//*access:			protectedoverrides:		description: 	get the number of columnsins: 			noneouts: 			the number of columnsnotes:			----------------------------------------------------------------------------------------*/short		ZArrayBrowser::GetColCount()	{	return fColumnTabs->CountItems();}/*-----------------------------***  CalcSelectedColumnRect  ***-------------------------*//*access:			protectedoverrides:		description: 	calculate the rectangle of the selected columnins: 			<aRect> receives resultouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::CalcSelectedColumnRect( Rect* aRect ){	short	tab;		GetBounds( aRect );		tab = GetColumnPosition( fSelColumn );		aRect->right = MIN( aRect->right, tab );	aRect->bottom = GetRowCount() * fLineHeight;		if ( fSelColumn > 1 )	{		tab = GetColumnPosition( fSelColumn - 1 );		aRect->left = MAX( aRect->left, tab );	}}/*----------------------------------***  GetColumnHit  ***------------------------------*//*access:			protectedoverrides:		description: 	determine which column the mouse is inins: 			<mouse> mouse position relative to boundsouts: 			column number under mouse, or 0 if nonenotes:			----------------------------------------------------------------------------------------*/short		ZArrayBrowser::GetColumnHit( const Point mouse ){	short lastTab = 0, tab, i;		for( i = 1; i <= GetColCount(); i++ )	{		tab = GetColumnPosition( i );				if ( mouse.h >= lastTab && mouse.h < tab )			return i;	}		return 0;}/*-----------------------------***  CalcDragInsertRgn  ***------------------------------*//*access:			protectedoverrides:		description: 	form a region representing the "insert" feedback for drag and dropins: 			<mouse> the mouse point passed local to bounds				<aRgn> receives the regionouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::CalcDragInsertRgn( const Point mouse, RgnHandle aRgn ){	Rect		cr;	Point		cm;		FailNILParam( aRgn );		cm = mouse;	cm.v -= fLineHeight / 2;		short	line = CalcSelection( cm, NULL );		GetBounds( &cr );	InsetRect( &cr, 4, 0 );	cr.bottom = ( line * fLineHeight ) + 1;	cr.top = cr.bottom - 2;	RectRgn( aRgn, &cr );}/*----------------------------------***  ReportFields  ***------------------------------*//*access:			publicoverrides:		description: 	spew out data for inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZArrayBrowser::ReportFields(){	ZScrollAwareView::ReportFields();	XSHOWFIELD( fArray, ft_objectref );	XSHOWFIELD( fColumnTabs, ft_objectref );	XSHOWFIELD( fViewer, ft_objectref );	XSHOWFIELD( fSelection, ft_Handle );	XSHOWFIELD( fLastKeyTime, ft_unsignedlong );	XSHOWFIELD( fBorderColour, ft_RGBColor );	XSHOWFIELD( fAltColour, ft_RGBColor );	XSHOWFIELD( fSelFlags, ft_binary16 );	XSHOWFIELD( fLineHeight, ft_signedshort );	XSHOWFIELD( fAscent, ft_signedshort );	XSHOWFIELD( fColumnInset, ft_signedshort );	XSHOWFIELD( fRowExtra, ft_signedshort );	XSHOWFIELD( fBorderWidth, ft_signedshort );	XSHOWFIELD( fSelColumn, ft_signedshort );	XSHOWFIELD( fThresh, ft_signedshort );	XSHOWFIELD( fOwnsArray, ft_boolean );	XSHOWFIELD( fDrawColBorder, ft_boolean );}#pragma mark -/*-------------------------------***  DrawBrowserCell  ***------------------------------*//*access:			publicoverrides:		description: 	render array content in list rowins: 			<cellrect> the bounds of the cell to draw				<whichColumn> column number from 1 to #columns in list				<cellData> pointer to array data for this row				<selected> TRUE if this cell is selectedouts: 			nonenotes:			the string viewer assumes that the array data is a pascal string----------------------------------------------------------------------------------------*/void	ZPStrViewer::DrawBrowserCell( Rect* cellRect, short row, short column, void* cellData, Boolean selected ){	if ( column == 1 )	{		Str255	s;				CopyPString((StringPtr) cellData, s );				if ( StringWidth( s ) > ( cellRect->right - cellRect->left - 2 ))			TextFace( condense );		else			TextFace( 0 );					TruncString( cellRect->right - cellRect->left - 2, s, smTruncEnd );		DrawString( s );	}}/*------------------------------***  MakeClipboardData  ***-----------------------------*//*access:			publicoverrides:		description: 	return clipboard data for the cellins: 			<row> row being processed				<cellData> pointer to cell dataouts: 			handle containing public format of cell datanotes:			converts string to text----------------------------------------------------------------------------------------*/Handle	ZPStrViewer::MakeClipboardData( short row, void* cellData ){	Handle		h;	StringPtr	p = (StringPtr) cellData;		FailOSErr( PtrToHand( &p[1], &h, p[0] ));		return h;}/*----------------------------***  ConvertClipboardData  ***----------------------------*//*access:			publicoverrides:		description: 	convert clipboard data to correct array formatins: 			<row> row being processed				<dataIn> Handle containing clipboard format data				<dataOut> pointer to array format storageouts: 			nonenotes:			converts text to string----------------------------------------------------------------------------------------*/void	ZPStrViewer::ConvertClipboardData( short row, Handle dataIn, void* dataOut ){	StringPtr	s;		s = (StringPtr) dataOut;	s[0] = ( GetHandleSize( dataIn ) & 0xFF );	BlockMoveData( *dataIn, &s[1], s[0] );}/*-------------------------------***  TestDataEqual  ***--------------------------------*//*access:			publicoverrides:		description: 	test if search data matches array datains: 			<cellData> copy of data in array cell				<testData> pointer to search data				<testDataLen> length of search dataouts: 			TRUE if data matches, otherwise falsenotes:			called by FindArrayData, etc. Do what you need to do.----------------------------------------------------------------------------------------*/Boolean	ZPStrViewer::TestDataEqual( void* cellData, Ptr testData, long testDataLen ){	UpperString((StringPtr) cellData, TRUE );		return EqualMem((Ptr) cellData + 1, testData, testDataLen );}#pragma mark -/*-------------------------------***  DrawBrowserCell  ***------------------------------*//*access:			publicoverrides:		description: 	render array content in list rowins: 			<cellrect> the bounds of the cell to draw				<whichColumn> column number from 1 to #columns in list				<cellData> pointer to array data for this row				<selected> TRUE if this cell is selectedouts: 			nonenotes:			data is pointer to IconInfo----------------------------------------------------------------------------------------*/void	ZIconViewer::DrawBrowserCell( Rect* cellRect, short row, short column, void* cellData, Boolean selected ){	if ( column > 1 )		return;			IconInfo*			ii = (IconInfo*) cellData;	Rect				iconRect;	IconTransformType	iconTransform;		SetRect( &iconRect, 0, 0, 32, 32 );		// centre the icon's rect horizontally in the cell		OffsetRect( &iconRect, (( cellRect->left + cellRect->right ) / 2 ) - 16, cellRect->top + 1 );	// set up the icon transform based on the selection options set		if ( fOwner->IsEnabled() && fOwner->IsActive())	{		if ( selected && ( fHilite & iconHiliteDarken ))			iconTransform = kTransformSelected;		else			iconTransform = kTransformNone;	}	else		iconTransform = kTransformDisabled;		// plot the icon according to its type	 	switch ( ii->iType )	{		case IconIndexed:			PlotIconID( &iconRect, kAlignNone, iconTransform, ii->iconID );			break;				case IconPlain:			if ( ii->theIcon )			{				LoadResource( ii->theIcon );				PlotIcon( &iconRect, ii->theIcon );								if ( selected )					InvertRect( &iconRect );				}			break;				case IconColour:			if ( ii->theIcon)			{				// for these icons, the rect may not be 32 x 32, so we need to get the real				// size and centre it accordingly.								CIconHandle	ci = (CIconHandle) ii->theIcon; 								iconRect = (*ci)->iconPMap.bounds;				OffsetRect( &iconRect, -iconRect.left, -iconRect.top );				OffsetRect( &iconRect, (( cellRect->left + cellRect->right ) / 2 ) - (( iconRect.right - iconRect.left ) / 2 ),							cellRect->top + 33 - iconRect.bottom - iconRect.top );								PlotCIconHandle( &iconRect, kAlignNone, iconTransform, ci );			}			break;					default:			break;	}	// draw the icon title if required		if ( fShowTitles )	{		FontInfo	fi;		GetFontInfo( &fi );				short	tLen = StringWidth( ii->title );				MoveTo((( cellRect->left + cellRect->right ) / 2 ) - ( tLen / 2 ),  cellRect->top + 33 + fi.ascent );				if ( fOwner->IsEnabled() && fOwner->IsActive())		{			if ( selected && ( fHilite & iconHiliteInvertTitle ) == iconHiliteInvertTitle )				TextMode( notSrcCopy );			else				TextMode( srcOr );		}		else			TextMode( grayishTextOr );				DrawString( ii->title );	}}/*-------------------------------***  TestDataEqual  ***--------------------------------*//*access:			publicoverrides:		description: 	test if search data matches array datains: 			<cellData> copy of data in array cell				<testData> pointer to search data				<testDataLen> length of search dataouts: 			TRUE if data matches, otherwise falsenotes:			called by FindArrayData, etc. Do what you need to do.----------------------------------------------------------------------------------------*/Boolean		ZIconViewer::TestDataEqual( void* cellData, Ptr testData, long testDataLen ){	// allows type-selection of icon titles		Boolean	result = FALSE;		if ( fShowTitles )	{		IconInfo*	ii = (IconInfo*) cellData;				UpperString( ii->title, TRUE );					// search from 2nd char because we prepended a space				result = EqualMem( &ii->title[2], testData, testDataLen );	}		return result;}/*----------------------------***  PerformArrayCleanUp  ***-----------------------------*//*access:			publicoverrides:		description: 	perform any necessary clean up before arrray discardedins: 			<theArray> array to clean upouts: 			nonenotes:			only viewer interprets data in array, so if it allocates storage, it				must be deleted here. Icon viewer must dispose icon handles----------------------------------------------------------------------------------------*/void	ZIconViewer::PerformArrayCleanUp( ZArray* theArray ){	IconInfo	ii;	long		n, i;		n = theArray->CountItems();		for( i = 1; i <= n; i++ )	{		theArray->GetArrayItem( &ii, i );				if ( ii.theIcon )		{			switch ( ii.iType )			{				case IconColour:					DisposeCIcon((CIconHandle) ii.theIcon );					break;									case IconPlain:					ReleaseResource( ii.theIcon );					break;					default:					DisposeHandle( ii.theIcon );					break;			}		}	}}#pragma mark -/*-----------------------***  CreateNewScrollingArrayBrowser  ***-----------------------*//*access:			globaloverrides:		description: 	make a browser in a scrollviewins: 			<aParent> the parent view				<aFrame> the frame of the scroller				<hScroll> TRUE if there is to be a horizontal scrollbar				<vScroll> TRUE if there is to be a vertical scrollbar				<numColumns> number of columns the list should have				<flags> browser behaviour flagsouts: 			the browser objectnotes:			this is a convenience for you, since nearly all browsers will be				used within a scroll view. To get at the scrollview, call the browser's				GetParent() method.----------------------------------------------------------------------------------------*/ZArrayBrowser*		CreateNewScrollingArrayBrowser( ZView* aParent,													Rect* aFrame,													Boolean hScroll,													Boolean vScroll,													const short numColumns,													unsigned short flags ){	ZScrollView*	scroller;	ZArrayBrowser*	arrb;	FailNIL( scroller = new ZScrollView( aParent, aFrame, hScroll, vScroll ));	FailNIL( arrb = new ZArrayBrowser( scroller, NULL, numColumns ));		arrb->SetSelectionFlags( flags );	scroller->SetStandardBorder( TRUE, TRUE );		// if no frame was passed, fit to parent		if ( aFrame == NULL )	{		scroller->FitToParent();		scroller->SetAutoSizing( kStdScrollViewSizing );	}		// fit the last column to the edge of the visible area of the scroller		Rect	br;		scroller->GetContentRect( &br );	arrb->SetColumnPosition( numColumns, br.right );	arrb->ListenTo( scroller );		return arrb;}/*-------------------------***  CreateArrayBrowserForDialog  ***------------------------*//*access:			publicoverrides:		description: 	build array browser as a dialog itemins: 			<aParent> parent dialog				<aFrame> item bounds rect				<pCount> count of parameters				<params> parameters extracted from original "magic" stringouts: 			browser viewnotes:			param[0] is LIST resource ID				param[1] is STR# resource ID if first param is 0				register this function with dialog item registry to use LIST items in dialogs----------------------------------------------------------------------------------------*/ZView*				CreateArrayBrowserForDialog( ZView* aParent, Rect* aFrame, short pCount, long params[] ){	ListTemplateHdl		th = NULL;	unsigned short		flags = 0;	Boolean				hScroll, vScroll;	short				stringsID, cols;	ZArrayBrowser*		arb;		if ( pCount >= 1 && params[0] != 0 )	{		// there is not an exact correspondence between the old 'LIST' features and		// the array browser, but for most types of list we can handle it. For other		// arrangements, you may have to roll your own solution.				FailNILRes( th = (ListTemplateHdl) GetResource( 'LIST', params[0] ));				HNoPurge((Handle) th );				hScroll = (*th)->hasHorizScroll;		vScroll = (*th)->hasVertScroll;		stringsID = (*th)->stringsListID;				if ( stringsID == 0 )			stringsID = params[1];					cols = (*th)->columns;				if ((*th)->disableType == 0 )			flags |= kAutoTypeSelection;	}	else	{		// first param is 0, so use default 1-column simple list				hScroll = FALSE;		vScroll = TRUE;		stringsID = params[1];		cols = 1;	}		FailNIL( arb = CreateNewScrollingArrayBrowser( aParent, aFrame, hScroll, vScroll, cols, flags ));		// install strings:		if ( stringsID )		arb->SetArrayFromSTRList( stringsID );		// set font, etc		if ( th )	{		GetFNum((*th)->fontName, &cols );		arb->SetFontInfo( cols, (*th)->fontSize, 0 );				if ((*th)->whiteBk )			arb->SetBackColour( &gWhite );					ReleaseResource((Handle) th );	}	else		arb->SetFontInfo( 0, 0, 0 );		arb->TweakHeight();		return arb;}/*-----------------------***  CreateIconArrayBrowserForDialog  ***----------------------*//*access:			publicoverrides:		description: 	build icon array browser as a dialog itemins: 			<aParent> parent dialog				<aFrame> item bounds rect				<pCount> count of parameters				<params> parameters extracted from original "magic" stringouts: 			browser viewnotes:			param[0] is ICLB and LIST resource ID				param[1] is STR# resource ID if LIST resource contains 0 or if first param 0				register this function with dialog item registry to use ICLB items in dialogs----------------------------------------------------------------------------------------*/ZView*		CreateIconArrayBrowserForDialog( ZView* aParent, Rect* aFrame, short pCount, long params[] ){	ZArrayBrowser*	arb;		FailNIL( arb = (ZArrayBrowser*) CreateArrayBrowserForDialog( aParent, aFrame, pCount, params ));	arb->SetArrayFromICLB( params[0] );	arb->TweakHeight();				return arb;}/*------------------------***  CreateArrayBrowserFromResource  ***-----------------------*//*access:			publicoverrides:		description: 	build icon array browser from ZARB resourceins: 			<aParent> parent dialog				<aFrame> item bounds rect				<pCount> count of parameters				<params> magic string parametersouts: 			browser viewnotes:			param[0] is 'ZARB' resource ID				register this function with dialog item registry to use ZARB items in dialogs----------------------------------------------------------------------------------------*/ZView*		CreateArrayBrowserFromResource( ZView* aParent, Rect* aFrame, short pCount, long params[] ){	BrowserTemplateHdl	bth;	ZArrayBrowser*		arb;	ZScrollView*		scroller = NULL;	short				nCols;		// preload resource to see if we need to make an enclosing scroller (n.b. constructor releases resource)		FailNILRes( bth = (BrowserTemplateHdl) GetResource( kArrayBrowserTemplateResType, params[0] ));		if ((*bth)->makeScroller )	{		FailNIL( scroller = new ZScrollView( aParent, aFrame, (*bth)->hasHScroll, (*bth)->hasVScroll ));				scroller->SetStandardBorder( TRUE, TRUE );		nCols = (*bth)->numColumns;		FailNIL( arb = new ZArrayBrowser( scroller, params[0] ));				arb->FitToParent();				// fit the last column to the edge of the visible area of the scroller			Rect	br;			scroller->GetContentRect( &br );		arb->SetColumnPosition( nCols, br.right );		arb->ListenTo( scroller );	}	else	{		FailNIL( arb = new ZArrayBrowser( aParent, params[0] ));			if ( aFrame != NULL  )		{			arb->SetSize( aFrame->right - aFrame->left, aFrame->bottom - aFrame->top );			arb->PlaceAt( aFrame->left, aFrame->top );		}	}	return arb;}