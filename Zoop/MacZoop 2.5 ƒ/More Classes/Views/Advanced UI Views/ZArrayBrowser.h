/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZArrayBrowser.h		-- a view that can display the contents of an array*										as a columnar list, and select items therein.******			©2000, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZARRAYBROWSER__#define __ZARRAYBROWSER__#include	"ZScrollAwareView.h"#include	"MZIconListTypes.h"#include	<drag.h>class	ZArrayBrowser;DEFINECLASSID( ZArrayBrowser, 'zarb' );DEFINECLASSID( ZPStrViewer, 'zpsv' );DEFINECLASSID( ZIconViewer, 'zicv' );// this class is a small attachment that actually draws the list data for each column. It also can provide// a translation of the array data for cut and paste operations if you wish, but supporting this// is not required. Note this is a pure abstract calss - you MUST subclass it to make real viewer objects,// and you MUST implement the DrawBrowserCell method.class	ZBrowserViewer{public:	ZBrowserViewer(){ fOwner = NULL; };	virtual void	DrawBrowserCell( Rect* cellRect, short row, short column, void* cellData, Boolean selected ) = 0;	virtual OSType	GetClipboardDataType() { return '????'; };	virtual Handle	MakeClipboardData( short row, void* cellData ) { return NULL; };	virtual void	ConvertClipboardData( short row, Handle dataIn, void* dataOut ) {};	virtual Boolean	TestDataEqual( void* cellData, Ptr testData, long testDataLen ) { return FALSE; };	void			SetOwner( ZArrayBrowser* anOwner ) { fOwner = anOwner; };	virtual void	PerformArrayCleanUp( ZArray* theArray ) {}protected:	ZArrayBrowser*	fOwner;};// selection flags, modes and other sundry constants:enum{	kStandardMultiSelect 		= 1,			// if set, normal multiple selection rules apply	kAllowKeyboardAutoDelete 	= 2,			// if set, delete key deletes selected data from array	kCustomSelectionDrawing 	= 4,			// if set, viewer called during selection changes	kDisableSelectionHilite		= 8,			// if set, standard hiliting is turned off	kChainColumnTabs			= 16,			// if set, moving a column shifts those to its right as well	kAllowKeyboardColumnSwitch	= 32,			// if set, left and right arrows switch column selection	kDisableColumnDragging		= 64,			// if set, user can't drag columns	kUseStdPlusCursor			= 128,			// if set, plus cursor shown in view, otherwise arrow	kAutoTypeSelection			= 256,			// if set, typing the first few chars of a string selects it	kAllowCutAndPaste			= 512,			// if set, you can cut and paste list items - viewer defines data type	kColumnDragsAreLive			= 1024,			// if set, column dragging is live, like Finder (PPC only, and requires ZGWorld)	kEnableDragSend				= 2048,			// if set, items can be dragged off	kEnableDragReceive			= 4096,			// if set, items can be dragged in	kEnableDragReorder			= 8192			// if set, item can be reordered by dragging (effectively drag to self)};enum{	kModeReplace 					= 0,		// selection replaced by new one	kModeAddSingle					= 1,		// selected extended by new one	kModeAddRange					= 2,		// selection replaced by precalculated range selection	kModeInvert						= 3,		// selection modified by inverting new one	kBrowserStyleStdList			= 1,		// pass to InitStyle to preset parameters	kBrowserStyleSmallList			= 2,		// small font (geneva 9)	kBrowserStyleFinderView			= 3,		// OS 8/9 Finder style		kBrowserStyleAdoptAppearance	= 4,		// adopt current theme colours, metrics and fonts (uses views font)		kBrowserStyleAdoptSysAppearance = 5			// as above, but uses system large font};// this class can render the data from any ZArrayclass	ZArrayBrowser	: public ZScrollAwareView{protected:	ZArray*				fArray;					// array to display	ZArray*				fColumnTabs;			// list of column tab positions	ZBrowserViewer*		fViewer;				// viewer object	RgnHandle			fSelection;				// selection region	unsigned long		fLastKeyTime;			// time last key was typed	RGBColor			fBorderColour;			// colour of row & column borders	RGBColor			fAltColour;				// alternate colour for selected columns	unsigned short		fSelFlags;				// selection behaviour flags	short				fLineHeight;			// line height of each row	short				fAscent;				// font ascent for list's font	short				fColumnInset;			// offset from edge of column to draw text	short				fRowExtra;				// extra pixels added to each row	short				fBorderWidth;			// extra pixels for border below each row	short				fSelColumn;				// which column is selected	short				fThresh;				// reset threshold for type selection	Boolean				fOwnsArray;				// TRUE if array deleted when view is	Boolean				fDrawColBorder;			// TRUE if border drawn between columnspublic:	ZArrayBrowser( ZView* aParent, Rect* aFrame, const short numColumns = 1 );	ZArrayBrowser( ZView* aParent, const short templateResID );	ZArrayBrowser( const short viewResourceID, ZView* aParent );	virtual ~ZArrayBrowser();// view methods:		virtual void		DrawContent();	virtual void		ClickContent( const Point mouse, const short modifiers );	virtual void		SetViewCursor( const Point mouse, const short modifiers );	virtual void		SetFontInfo( const short fontID, const short size, const Style style );	virtual Boolean		ClickInSamePlace( const Point a, const Point b );// commander methods:		virtual void		Type( const char theKey, const short modifiers );	virtual void		UpdateMenus();		virtual void		DoSelectAll();	virtual void		DoSelectNone();	virtual void		DoCopy();	virtual void		DoClear();	virtual void		DoPaste();	virtual Boolean		CanPasteType();// array that we are browsing:	virtual void		SetArray( ZArray* anArray, const Boolean viewOwnsIt = TRUE );			inline	ZArray*		GetArray() { return fArray; };	virtual void		ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData );	virtual void		SetArrayFromSTRList( const short strListID );	virtual void		SetArrayFromICLB( const short resID );	virtual void		SetArrayUpdates( Boolean wantUpdates );// browser settings:		virtual void		SetColumnPosition( const short whichColumn, const short aPos );	virtual short		GetColumnPosition( const short whichColumn = 1 );	virtual void		SetColumnWidth( const short whichColumn, const short aWidth);	virtual void		SetColumns( const short numColumns );	virtual short		GetRowHeight() { return fLineHeight; };	virtual short		GetSelectedColumn() { return fSelColumn; }; 		void				SetSelectionFlags( const unsigned short flags ) { fSelFlags = flags; };	void				SetBorderWidth( const short aWidth ) { fBorderWidth = aWidth; };	void				SetDrawColumnBorder( const Boolean drawIt ) { fDrawColBorder = drawIt; };	void				SetAlternateColour( const RGBColor* aColour ) { fAltColour = *aColour; };	void				SetCellInset( const short hInset, const short vExtra ) { fColumnInset = hInset; fRowExtra = vExtra; };	virtual void		InitStyle( const short aStyle );	long				GetRowCount();	short				GetColCount();		inline void			GetAltColour( RGBColor* rgb ){ *rgb = fAltColour; }		inline void			GetBorderColour( RGBColor* rgb ){ *rgb = fBorderColour; }// manipulating the selection:		virtual void		SelectColumn( const short whichColumn );	virtual void		ChangeSelection( const long whichRow, const short modifiers = 0 );	virtual Boolean		AutoTypeSelect( const char theKey );	virtual Boolean		HasSelection() { return ! EmptyRgn( fSelection ); };	virtual Boolean		IsRowSelected( const long whichRow );	virtual long		FindFirstSelection( const long startingAt = 1 );	virtual long		FindLastSelection( const long startingAt = -1 );	virtual long		FindArrayData( Ptr searchData, long searchLength );// grovelling over the items	virtual void		DoForEachSelected( IteratorProcPtr aProc, const long ref );	virtual void		DeleteSelectedRows();// attaching the viewer:		virtual void		AttachViewer( ZBrowserViewer* aViewer );	ZBrowserViewer*		GetViewer() { return fViewer; };	// other drawing methods:	virtual void		Draw1Row( const long row, void* cellData );	virtual void		DrawRowBorder( Rect* theRow );	virtual void		DrawColBorders();	virtual void		DragLoopHook( const Point mouse ) {};	// d+d:	virtual Boolean		ShouldDrag( const Point mouse, const short modifiers );	virtual void		MakeDragRegion( RgnHandle theRgn );	virtual void		MakeDragData( DragReference theDrag, const short modifiers );	virtual Boolean		CanAcceptTheDrag( const DragReference theDrag );	virtual Boolean		AcceptsFlavour( const OSType aFlavour );	virtual void		DDEnterView( const DragReference theDrag ){ DoSelectNone(); ZScrollAwareView::DDEnterView( theDrag ); };	virtual void		DDInsideView( const Point mouse, const DragReference theDrag );	virtual void		DDExitView( const DragReference theDrag );	virtual Boolean		UnpackDrop( const DragReference theDrag );	virtual void		Drop( const OSType flavour, const Ptr data, const long dataSize, const DragReference theDrag );			virtual void		ReportFields();	virtual void		CalcBounds( Rect* theBounds = NULL );	virtual void		CalcSizes();// RAD support:	virtual void		InitViewFromResource( Handle theRes );	virtual void		CreateViewResource( Handle resHandle );protected:	virtual short		CalcSelection( const Point mouse, RgnHandle aRgn );	virtual void		CalcSelectionRange( const short fromRow, const short toRow, RgnHandle aRgn );	virtual void		SetSelectionRgn( RgnHandle aRgn, const short mode = kModeReplace );	virtual void		DragColumnTab( Point mouse, short whichColumn );	virtual void		UpdateSelection( const RgnHandle selRgn );	void				CalcSelectedColumnRect( Rect* aRect );	short				GetColumnHit( const Point mouse );	short				PtInColumnTab( Point mouse );	void				CalcDragInsertRgn( const Point mouse, RgnHandle aRgn );		static RgnHandle	sDragInsertRgn;		// when dragging items into a list	static Str15		sSearchStr;	 		// for auto items in a list};// messages:enum{	kMsgArrayBrowserSelectColumn		= 'absc',	kMsgArrayBrowserDoubleClicked		= 'abkk',	kMsgArrayBrowserSelectionChanged 	= 'absx',	kMsgArrayBrowserCleanUp				= 'abcu',	kMsgArrayBrowserColumnMoved			= 'abcm'};// all columns are initialised to this width:enum{	kDefaultColumnWidth			= 160};// this class is a default viewer that will draw a single pascal string. This makes it// closely compatible with List Manager default behaviour.class	ZPStrViewer	: public ZBrowserViewer{public:	ZPStrViewer() : ZBrowserViewer(){}		virtual void	DrawBrowserCell( Rect* cellRect, short row, short column, void* cellData, Boolean selected );	virtual OSType	GetClipboardDataType() { return 'TEXT'; };	virtual Handle	MakeClipboardData( short row, void* cellData );	virtual void	ConvertClipboardData( short row, Handle dataIn, void* dataOut );	virtual Boolean	TestDataEqual( void* cellData, Ptr testData, long testDataLen );};// this class is a viewer this draws icons in the same manner as the old ZIconListDialogItem// class. Each element in the array is a IconInfo recordclass	ZIconViewer : public ZBrowserViewer{private:	IconHilite		fHilite;	Boolean			fShowTitles;public:	ZIconViewer() : ZBrowserViewer() { fHilite = iconDefaultHilite; fShowTitles = TRUE; }		virtual void	DrawBrowserCell( Rect* cellRect, short row, short column, void* cellData, Boolean selected );	virtual Boolean	TestDataEqual( void* cellData, Ptr testData, long testDataLen );	void			SetIconHiliteStyle( IconHilite aStyle ) { fHilite = aStyle; };	void			SetShowTitles( Boolean showEm ) { fShowTitles = showEm; };	virtual void	PerformArrayCleanUp( ZArray* theArray );};// global utility to assist in making practical browsers - builds both browser and enclosing scroller// in one glorious call. Can be used to place a scrolling browser in any window, dialog or view.ZArrayBrowser*		CreateNewScrollingArrayBrowser( ZView* aParent,													Rect* aFrame,													Boolean hScroll = FALSE,													Boolean vScroll = TRUE,													const short numColumns = 1,													unsigned short flags = kStandardMultiSelect );// global utility functions to build browser in various ways specified by dialog item (DITL). These are registered// with the new dialog code to build a list view in a dialog. These functions allow older dialogs to create array browsers// rather than ZListDialogItems seamlessly, based on LIST, ICLB and the new ZARB resource types.ZView*		CreateArrayBrowserForDialog( ZView* aParent, Rect* aFrame, short pCount, long params[] );ZView*		CreateIconArrayBrowserForDialog( ZView* aParent, Rect* aFrame, short pCount, long params[] );ZView*		CreateArrayBrowserFromResource( ZView* aParent, Rect* aFrame, short pCount, long params[]  );#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif// structure of 'View' resource for ZArrayBrowser:typedef struct{	ScrollViewTemplate	svt;						// scroll view parameters	Boolean				multiSelect; 				// if set, normal multiple selection rules apply	Boolean				allowKeyboardAutoDelete; 	// if set, delete key deletes selected data from array	Boolean				customSelectionDrawing; 	// if set, viewer called during selection changes	Boolean				disableSelectionHilite;		// if set, standard hiliting is turned off	Boolean				chainColumnTabs;			// if set, moving a column shifts those to its right as well	Boolean				allowKeyboardColumnSwitch;	// if set, left and right arrows switch column selection	Boolean				disableColumnDragging;		// if set, user can't drag columns	Boolean				useStdPlusCursor;			// if set, plus cursor shown in view, otherwise arrow	Boolean				autoTypeSelection;			// if set, typing the first few chars of a string selects it	Boolean				allowCutAndPaste;			// if set, you can cut and paste list items - viewer defines data type	Boolean				columnDragsAreLive;			// if set, column dragging is live, like Finder (PPC only, and requires ZGWorld)	Boolean				enableDragSend;				// if set, items can be dragged off	Boolean				enableDragReceive;			// if set, items can be dragged in	Boolean				enableDragReorder;			// if set, item can be reordered by dragging (effectively drag to self)	Boolean				drawColBorder;				// draw the column border	short				numColumns;					// number of columns	short				columnWidth;				// default width of columns	short				initStyle;					// browser style, or if 0...	short				rowExtraHeight;				// extra height to add to row	short				columnInset;				// inset for each column	short				borderWidth;				// borderWidth	short				auxResID;					// ID of auxiliary resource - STR#, etc	OSType				auxResType;					// type of aux resource - string, icons, etc}ArrayBrowserTemplate, *ArrayBrowserTemplatePtr, **ArrayBrowserTemplateHdl;#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif/*This view is a powerful and useful object-oriented class for doing similar sorts ofthings as the List Manager.It has several important differences though. It uses a ZArray as its data storage,so can display a list based on any ZArray that you care to set up. Also, it doesnot have separate columns like the list manager, but instead has one row per arrayelement, and one column per field within that element. This is a more generallyuseful way to implement this kind of user-interface object.Columns are draggable to resize them, and you can specify any number of columns.Because the actual drawing of each row is handed off to a small helper object,This class is highly reusable without needing to be subclassed.*/#endif