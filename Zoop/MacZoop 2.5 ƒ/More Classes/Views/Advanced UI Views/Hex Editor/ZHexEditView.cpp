/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZHexEditView.cpp		-- view edits a block of memory as hex******			©2000, Graham Cox*****************************************************************************************************/#include	"ZHexEditView.h"#include	"MacZoop.h"#include	"ZWindow.h"// global line cache speeds up hex dump drawingchar		ZHexEditView::sLineCache[ ( BYTES_PER_LINE * 3 ) + ( BYTES_PER_LINE / COLUMN_GROUP_SIZE ) + 1 ];char* 		ZHexEditView::sHex = "0123456789ABCDEF";/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZHexEditView::ZHexEditView( ZView* aParent, Rect* aFrame )	: ZScrollAwareView( aParent, aFrame ){	classID = CLASS_ZHexEditView;		FailNIL( fEditHandle = NewHandle( 0 ));	fSelStart = fSelEnd = 0;	FailNIL( fSelectionRgn = NewRgn());	fEdited = FALSE;	fCaretPhase = FALSE;	fNibPhase = FALSE;	fHalfOff = FALSE;	fTextMode = srcOr;	SetBackColour( &gWhite );	SetForeColour( &gBlack );	SetCanBeHandler( TRUE );		FontInfo	fi;		SetFontInfo( kFontIDMonaco, 9, 0 );	Focus();	PrepareForDrawing();	GetFontInfo( &fi );		fLineHeight = fi.ascent + fi.descent + fi.leading;	fAscent = fi.ascent;	fEmSpace = fi.widMax;	fHdStart = ( fEmSpace * 9 ) + 20;	fHdEnd = fHdStart + ( fEmSpace * (( BYTES_PER_LINE * 3 ) + ( BYTES_PER_LINE / COLUMN_GROUP_SIZE ) - 2 ));	fMaxDisplayLength = ( 32000L * BYTES_PER_LINE ) / fLineHeight;	SetScrollAmount( fEmSpace, fLineHeight );	CalcBounds();}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZHexEditView::~ZHexEditView(){	if ( fSelectionRgn )			DisposeRgn( fSelectionRgn );	if ( fEditHandle )		DisposeHandle( fEditHandle );}/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	draw the content of this viewins: 			noneouts: 			nonenotes:			you can draw as if the view was always at 0,0----------------------------------------------------------------------------------------*/void	ZHexEditView::DrawContent(){	register short	lineStart;	register long	loop, excess, hs, he, dl;	register Ptr	base;	Boolean	 		bSup;	Ptr				dumpArea;	long			dumpLength;    RgnHandle   	temp;	Rect	    	cr, r;			if ( fEditHandle == NULL )		return;		HLock( fEditHandle );	dumpArea = *fEditHandle;	dumpLength = GetLength();	TextMode( srcCopy );	// we are only going to draw what's visible, so get the current clip rect to find out	// what that is. This is essential if you want the view to print properly.    	FailNIL( temp = NewRgn());	GetClip( temp );		r = *REGIONBOUNDINGBOX( temp );		// start on a whole line boundary:		r.top -= r.top % fLineHeight;	lineStart = r.top + fAscent + 1;		// compute the offset of the visible area start and end		hs = GetOffset( fHdStart, r.top );		bSup = ( hs > dumpLength );		// make sure drawn area is constrained to the dump limits		hs = MAX( 0, MIN( dumpLength, hs ));	he = MAX( 0, MIN( dumpLength, GetOffset( fHdStart, r.bottom ) + BYTES_PER_LINE ));		// figure looping parameters:		dl = he - hs;		excess = dl % BYTES_PER_LINE;	loop = dl / BYTES_PER_LINE;	base = dumpArea + hs;		// hex is dumped 16 bytes at a time (one line) so we loop through <dumpLength / 16>	// draw the bulk of the dump:		TextMode( fTextMode );	while( loop-- )	{		MoveTo( 6, lineStart );		DrawHexLine( base );				lineStart += fLineHeight;		base += BYTES_PER_LINE;	}		// if there's any data in the trailing line, draw that as well:		MoveTo( 6, lineStart );		if ( excess )	{		DrawHexLine( base, excess );		lineStart += fLineHeight;	}		HUnlock( fEditHandle );	// draw the hilite region		if ( ! IsPrinting())	{		SetHiliteMode();		InvertRgn( fSelectionRgn );				// if not active, knock out the middle of the seleciton				if (! IsActive())		{			CopyRgn( fSelectionRgn, gUtilRgn );			InsetRgn( gUtilRgn, 1, 1 );			SetHiliteMode();			InvertRgn( gUtilRgn );		}	}	// clear the remainder of the window if we drew the last line	if ( he == dumpLength )	{		GetBounds( &cr );		cr.top = lineStart - fAscent;		EraseRect( &cr );				// if last line is completely filled, draw the starting address of the next line			if (( excess == 0 ) && ! bSup )		{		#if HD_USE_COLOUR			RGBForeColor( &gDarkRed );		#endif				#if SHOW_ABSOLUTE_ADDRESS			DrawLongAsHex((long) base );		#else			DrawLongAsHex( base - dumpArea );		#endif			DrawChar( ':' );		}	}	DisposeRgn( temp );}/*--------------------------------***  ClickContent  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to a click in the viewins: 			<mouse> the mouse coordinates local to view				<modifiers> modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::ClickContent( const Point mouse, const short modifiers ){	// click and drag in the editor. This sets up the selection.		Point		pt, oldMouse = { -1, -1 };	long		hs, he, dumpLength;	RgnHandle	selRgn;	short		dblClick = gApplication->GetClicks();	Boolean		shiftClick = ( modifiers & shiftKey ) == shiftKey;		FailNIL( selRgn = NewRgn());		DrawCaret( FALSE );	fNibPhase = FALSE;	fHalfOff = FALSE;	dumpLength = GetLength();		// If shift-click, extend selection. If double-click, select a byte, triple selects a line,	// four clicks selects the whole lot.		he = MIN( dumpLength, MAX( 0, GetOffset( mouse.h, mouse.v )));		if ( shiftClick )	{		if ( he < fSelStart )			hs = fSelEnd;		else			hs = fSelStart;	}	else		hs = he;			if ( dblClick > 1 )	{		if ( dblClick == 2 )			he = hs + 1;		else		{			if ( dblClick == 3 )			{				hs -= hs % BYTES_PER_LINE;				he = hs + BYTES_PER_LINE;			}			else			{					hs = 0;				he = dumpLength;			}		}		CalcSelection( hs, he, selRgn );		SetSelectionRgn( selRgn );	}		if ( !shiftClick )		oldMouse = pt = mouse;		// wait for some movement of the mouse before continuing if it's still down.		if ( !shiftClick && StillDown() && !DeltaPoint( pt, oldMouse ))	{		GetMouse( &pt );	}		// track the mouse drag, setting the selection accordingly		if ( dblClick < 4 )	{		do		{			GetMouse( &pt );						// depending on whether a double or triple-click, modify end point						if ( dblClick == 3 )				pt.h = fHdEnd + fEmSpace + fEmSpace;						if ( DeltaPoint( pt, oldMouse ))			{				he = MAX( 0, MIN( dumpLength, GetOffset( pt.h, pt.v )));								CalcSelection( hs, he, selRgn );				SetSelectionRgn( selRgn );							oldMouse = pt;								AutoScroll( pt );			}		}		while( WaitMouseUp());				if ( hs == he )		{			SetEmptyRgn( selRgn );			SetSelectionRgn( selRgn );		}	}	DisposeRgn( selRgn );		fSelStart = MIN( hs, he );	fSelEnd = MAX( hs, he );}/*------------------------------------***  Type  ***------------------------------------*//*access:			publicoverrides:		description: 	respond to user typing into the viewins: 			<theKey> character to process				<modifiers> modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::Type( const char theKey, const short modifiers ){	Focus();	PrepareForDrawing();	FocusForContent();	TextMode( srcCopy );		Boolean		shift, option;		shift  = ( modifiers & shiftKey )  == shiftKey;	option = ( modifiers & optionKey ) == optionKey;		switch ( theKey )	{		case BACKSPACE_KEY:			if ( fSelEnd != fSelStart )				DoClear();			else			{				if ( fSelStart > 0 )				{					if ( fNibPhase )						MoveCaret( right );					MoveCaret( left );					fNibPhase = FALSE;					fSelEnd = fSelStart + 1;					Munge( NULL, 0 );					RedrawOnType( fSelStart );					CalcBounds();					GetRootWindow()->SetDirty( TRUE );				}			}			break;					case LEFT_ARROW_KEY:			fNibPhase = FALSE;			MoveCaret( option? toBeginningOfLine : left, shift );			break;					case RIGHT_ARROW_KEY:			fNibPhase = FALSE;			MoveCaret( option? toEndOfLine : right, shift );			break;					case UP_ARROW_KEY:			fNibPhase = FALSE;			MoveCaret( option? toBeginning : up, shift );			break;					case DOWN_ARROW_KEY:			fNibPhase = FALSE;			MoveCaret( option? toEnd : down, shift );			break;					default:			if ( ! TypeInData( theKey ))				ZScrollAwareView::Type( theKey, modifiers );			break;		}}/*----------------------------------***  Activate  ***----------------------------------*//*access:			publicoverrides:		description: 	view becoming active - make selection solidins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::Activate(){	ZScrollAwareView::Activate();	if ( ! EmptyRgn( fSelectionRgn ))	{		Focus();		PrepareForDrawing();		FocusForContent();		SetHiliteMode();		CopyRgn( fSelectionRgn, gUtilRgn );		InsetRgn( gUtilRgn, 1, 1 );		InvertRgn( gUtilRgn );	}}/*----------------------------------***  Activate  ***----------------------------------*//*access:			publicoverrides:		description: 	view becoming inactive - make selection outlinedins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::Deactivate(){	ZScrollAwareView::Deactivate();		Focus();	PrepareForDrawing();	FocusForContent();		if ( ! EmptyRgn( fSelectionRgn ))	{		SetHiliteMode();		CopyRgn( fSelectionRgn, gUtilRgn );		InsetRgn( gUtilRgn, 1, 1 );		InvertRgn( gUtilRgn );	}	DrawCaret( FALSE );}/*------------------------------------***  Idle  ***------------------------------------*//*access:			publicoverrides:		description: 	blink caret in viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::Idle(){	static long		blinkTime = 0;	long			bkt;		bkt = TickCount();		if ( bkt > blinkTime + GetCaretTime())	{		blinkTime = bkt;				if ( fSelStart == fSelEnd && IsActive())		{			// blink the "caret"			Focus();			PrepareForDrawing();			FocusForContent();			DrawCaret( !fCaretPhase );			}	}}/*-----------------------------***  ClickInSamePlace  ***-------------------------------*//*access:			publicoverrides:		description: 	detect double clickins: 			<a,b> successive click locationsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean	ZHexEditView::ClickInSamePlace( const Point a, const Point b ){	long	oa, ob;		oa = GetOffset( a.h, a.v );	ob = GetOffset( b.h, b.v );		return ( oa == ob );}/*-------------------------------***  SetViewCursor  ***--------------------------------*//*access:			publicoverrides:		description: 	set cursor to i-beam in this viewins: 			<mouse> mouse point				<modifiers> modifier key stateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::SetViewCursor( const Point mouse, const short modifiers ){	if ( ShouldDrag( mouse, modifiers ))		SetCursorShape( DRAG_CURSOR );	else		SetCursorShape( iBeamCursor );}/*----------------------------***  DoSelectionUpdate  ***-------------------------------*//*access:			publicoverrides:		description: 	hide caret when leaving viewins: 			<state> TRUE if becoming focussed, FALSE if notouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::DoSelectionUpdate( Boolean state ){	if ( ! state )	{		Focus();		PrepareForDrawing();		FocusForContent();				DrawCaret( FALSE );	}		ZScrollAwareView::DoSelectionUpdate( state );}/*--------------------------------***  UpdateMenus  ***---------------------------------*//*access:			publicoverrides:		description: 	enable edit menu commandsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::UpdateMenus(){	gMenuBar->EnableCommand( kCmdSelectAll );		if ( fSelEnd != fSelStart )	{		gMenuBar->EnableCommand( kCmdCut );		gMenuBar->EnableCommand( kCmdCopy );		gMenuBar->EnableCommand( kCmdClear );	}		ZCommander::UpdateMenus();}/*--------------------------------***  DoSelectAll  ***---------------------------------*//*access:			publicoverrides:		description: 	select the entire contents of the viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::DoSelectAll(){	RgnHandle	temp = NewRgn();		Focus();	PrepareForDrawing();	FocusForContent();	DrawCaret( FALSE );		fSelStart = 0;	fSelEnd = GetLength();		CalcSelection( fSelStart, fSelEnd, temp );	SetSelectionRgn( temp );		DisposeRgn( temp );}/*-----------------------------------***  DoCopy  ***-----------------------------------*//*access:			publicoverrides:		description: 	copy selection to clipboardins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::DoCopy(){	Handle	temp;	long	range = fSelEnd - fSelStart;	Ptr		dumpArea;		if ( range > 0 )	{		FailNIL( temp = NewHandle( range ));				HLock( fEditHandle );		dumpArea = *fEditHandle;				BlockMoveData( dumpArea + fSelStart, *temp, range );				HUnlock( fEditHandle );					gClipboard->PutData( 'TEXT', temp );				DisposeHandle( temp );	}	}/*----------------------------------***  DoClear  ***-----------------------------------*//*access:			publicoverrides:		description: 	delete selectionins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::DoClear(){	Focus();	PrepareForDrawing();	FocusForContent();		Munge( NULL, 0 );	RecalcBoundsAndSelection();	ScrollToCaret();		GetRootWindow()->SetDirty( TRUE );}/*----------------------------------***  DoPaste  ***-----------------------------------*//*access:			publicoverrides:		description: 	paste clipboard contents into viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::DoPaste(){	Handle	t;		// look for text first, to get expected results when copying and pasting from styled TextEdit		t = gClipboard->GetData( 'TEXT' );		if ( t == NULL )		t = gClipboard->GetData( Wild_Card );		if ( t )	{		Focus();		PrepareForDrawing();		FocusForContent();			DrawCaret( FALSE );		fNibPhase = FALSE;		fHalfOff = FALSE;				HLock( t );		Munge( *t, MIN( fMaxDisplayLength - GetLength(), GetHandleSize( t )));		HUnlock( t );		DisposeHandle( t );				fSelStart = fSelEnd;		RecalcBoundsAndSelection();			ScrollToCaret();				GetRootWindow()->SetDirty( TRUE );	}	else		SysBeep( 1 );}/*--------------------------------***  CanPasteType  ***--------------------------------*//*access:			publicoverrides:		description: 	check if clipboard contains anything pasteableins: 			noneouts: 			TRUE if clipboard has some datanotes:			----------------------------------------------------------------------------------------*/Boolean	ZHexEditView::CanPasteType(){	return gClipboard->QueryType( Wild_Card );}/*-------------------------------***  SetDumpMemory  ***--------------------------------*//*access:			publicoverrides:		description: 	set editor to contents of handle passedins: 			<aHandle> some data to editouts: 			nonenotes:			editor makes a copy of the data to edit----------------------------------------------------------------------------------------*/void	ZHexEditView::SetDumpMemory( Handle aHandle ){	if ( aHandle == NULL )		SetHandleSize( fEditHandle, 0 );	else	{		long	hs = GetHandleSize( aHandle );				SetHandleSize( fEditHandle, hs );		FailMemError();				BlockMoveData( *aHandle, *fEditHandle, hs );	}		CalcBounds();}/*-------------------------------***  SetDumpMemory  ***--------------------------------*//*access:			publicoverrides:		description: 	set editor to contents of arbitrary bufferins: 			<dumpThis> pointer to arbitrarry buffer of data				<dumpBytes> length of bufferouts: 			nonenotes:			editor makes a copy of the data to edit----------------------------------------------------------------------------------------*/void	ZHexEditView::SetDumpMemory( Ptr dumpThis, const long dumpBytes ){	if ( dumpBytes > fMaxDisplayLength )		FailOSErr( kTooMuchDataToEditErr );		if ( dumpThis == NULL )		SetHandleSize( fEditHandle, 0 );	else		PtrToXHand( dumpThis, fEditHandle, dumpBytes );		FailMemError();		CalcBounds();	}/*-------------------------------***  GetDumpMemory  ***--------------------------------*//*access:			publicoverrides:		description: 	copy data from editor into handleins: 			<aHandle> receives the editor's data, replacing anything in handle alreadyouts: 			nonenotes:			use this to return edited data from editor----------------------------------------------------------------------------------------*/void	ZHexEditView::GetDumpMemory( Handle aHandle ){	FailNILParam( aHandle );		SetHandleSize( aHandle, GetLength());	BlockMoveData( *fEditHandle, *aHandle, GetLength());}/*--------------------------------***  SetSelection  ***--------------------------------*//*access:			publicoverrides:		description: 	change selection to the start and end offsets passedins: 			<start, end> offsets in data to set the selectionouts: 			nonenotes:			end must be >= start----------------------------------------------------------------------------------------*/void	ZHexEditView::SetSelection( const long start, const long end ){	fSelStart = MAX( 0, MIN( GetLength(), start ));	fSelEnd = MIN( GetLength(), MAX( 0, end ));		RgnHandle temp = NewRgn();		Focus();	PrepareForDrawing();	FocusForContent();	CalcSelection( fSelStart, fSelEnd, temp );	SetSelectionRgn( temp );	ScrollToCaret();		DisposeRgn( temp );}/*---------------------------------***  DumpChanged  ***--------------------------------*//*access:			publicoverrides:		description: 	query if user has edited the data at allins: 			noneouts: 			TRUE if data edited since SetDumpMemory last callednotes:			----------------------------------------------------------------------------------------*/Boolean	ZHexEditView::DumpChanged(){	return fEdited;}/*----------------------------------***  GetLength  ***---------------------------------*//*access:			publicoverrides:		description: 	get length of data in editor, in bytesins: 			noneouts: 			count of bytes in editor's handlenotes:			----------------------------------------------------------------------------------------*/long	ZHexEditView::GetLength(){	if ( fEditHandle )		return GetHandleSize( fEditHandle );	else		return 0;}/*---------------------------------***  ShouldDrag  ***---------------------------------*//*access:			publicoverrides:		description: 	can the user drag?ins: 			<mouse> local mouse point				<modifiers> modifier key stateouts: 			TRUE if draggablenotes:			----------------------------------------------------------------------------------------*/Boolean	ZHexEditView::ShouldDrag( const Point mouse, const short modifiers ){	return PtInRgn( mouse, fSelectionRgn );}/*-------------------------------***  MakeDragRegion  ***-------------------------------*//*access:			publicoverrides:		description: 	create drag regionins: 			<aRgn> region to createouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::MakeDragRegion( RgnHandle aRgn ){	Rect	r;		CopyRgn( fSelectionRgn, aRgn );	GetContentRectInBounds( &r );	RectRgn( gUtilRgn, &r );	SectRgn( aRgn, gUtilRgn, aRgn );}/*--------------------------------***  MakeDragData  ***--------------------------------*//*access:			publicoverrides:		description: 	add current selection to dragins: 			<theDrag> drag to add data to				<modifiers> state of modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::MakeDragData( DragReference theDrag, const short modifiers ){	long	tLength;		tLength = fSelEnd - fSelStart;	HLock( fEditHandle );		AddDragItemFlavor( theDrag, 1, 'TEXT', *fEditHandle + fSelStart, tLength, 0 );	HUnlock( fEditHandle );}/*------------------------------------***  Drop  ***------------------------------------*//*access:			publicoverrides:		description: 	insert data at current insertion pointins: 			<flavour> flavour of data being dropped				<data> pointer to the data				<dataSize> size of data				<theDrag> the drag refouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::Drop( const OSType flavour, const Ptr data, const long dataSize, const DragReference theDrag ){	DDHiliteView( FALSE, theDrag );		Munge( data, MIN( fMaxDisplayLength - GetLength(), dataSize ));		fSelStart = fSelEnd;	RecalcBoundsAndSelection();		ScrollToCaret();		GetRootWindow()->SetDirty( TRUE );	DDHiliteView( TRUE, theDrag );}/*----------------------------------***  GetOffset  ***---------------------------------*//*access:			protectedoverrides:		description: 	get byte offset of pixel location in bounds given by hLoc, vLocins: 			<hLoc> horizontal position				<vLoc> vertical positionouts: 			byte offset of positionnotes:			----------------------------------------------------------------------------------------*/long	ZHexEditView::GetOffset( short hLoc, short vLoc ){	// returns the offset address for the coordinate given. The offset starts at 0 and to	// compute an absolute address add <dumpArea>. The point passed in could be a mouse	// location or line offset, depending on the intended use. The horizontal point is	// treated as being to the right of the displayed byte.		Boolean inAscii = hLoc >= ( fHdEnd + ASCII_OFFSET );	short	hOffset, hm, lineNum;		lineNum = vLoc / fLineHeight;	if ( inAscii )	{		hLoc = MAX( fHdEnd + ASCII_OFFSET, MIN( fHdEnd + ASCII_OFFSET + ( fEmSpace * BYTES_PER_LINE ), hLoc ));		hOffset = ( hLoc - ( fHdEnd + ASCII_OFFSET ) + ( fEmSpace / 2 )) / fEmSpace;	}	else	{		hLoc = MAX( fHdStart, MIN( fHdEnd + ASCII_OFFSET - 1, hLoc ));				// to allow for grouping, hLoc needs to be corrected to allow one emSpace per group.		// the number of groups to the left of hLoc is given by:				hm = (( hLoc - fHdStart - ( fEmSpace / 2 )) / ( fEmSpace * 3 )) / COLUMN_GROUP_SIZE;		hLoc -= ( hm * fEmSpace );				hOffset = ( hLoc - fHdStart + fEmSpace + ( fEmSpace / 2 )) / ( fEmSpace * 3 );	}		return (long) lineNum * BYTES_PER_LINE + hOffset;}/*--------------------------------***  CalcSelection  ***-------------------------------*//*access:			protectedoverrides:		description: 	form selection region from byte offset values defining rangeins: 			<offsetStart> start of range				<offsetEnd> end of range				<aRgn> receives the selection region formed in bounds coordinatesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::CalcSelection( long offsetStart, long offsetEnd, RgnHandle aRgn ){	long		swap;	Rect		a, b, c;	RgnHandle	temp, aTemp;	short		sTop, eTop;		if ( offsetEnd <= offsetStart )	{		swap = offsetStart;		offsetStart = offsetEnd;		offsetEnd = swap;	}	// selection consists of a region made up from three rectangles- first line, central	// block and last line. Some of these may be empty.		FailNIL( temp = NewRgn());	FailNIL( aTemp = NewRgn());		sTop = ( offsetStart / BYTES_PER_LINE ) * fLineHeight;	eTop = ( offsetEnd / BYTES_PER_LINE ) * fLineHeight;	SetRect( &a, CalcCaretHOffset( offsetStart ),				 sTop,				 fHdEnd,				 sTop + fLineHeight );		SetRect( &c, fHdStart,				 eTop,				 CalcCaretHOffset( offsetEnd ),				 eTop + fLineHeight );		SetRect( &b, fHdStart, a.bottom, fHdEnd, c.top );		// if the selection is within a single line, build it from a and c by forcing a	// empty and making c the whole selection:		if ( sTop == eTop )		a.right = c.left = a.left;		RectRgn( aRgn, &b );	RectRgn( temp, &a );	UnionRgn( temp, aRgn, aRgn );	RectRgn( temp, &c );	UnionRgn( temp, aRgn, aRgn );		// now compute the same selection within the ascii dump area...		SetRect( &a, fHdEnd + ASCII_OFFSET + (( offsetStart % BYTES_PER_LINE ) * fEmSpace ),				 sTop,				 fHdEnd + ASCII_OFFSET + ( fEmSpace * BYTES_PER_LINE ),				 sTop + fLineHeight );		SetRect( &c, fHdEnd + ASCII_OFFSET,				 eTop,				 fHdEnd + ASCII_OFFSET + (( offsetEnd % BYTES_PER_LINE ) * fEmSpace ),				 eTop + fLineHeight );		SetRect( &b, c.left, a.bottom, a.right, c.top );	if ( sTop == eTop )		a.right = c.left = a.left;		RectRgn( aTemp, &b );	RectRgn( temp, &a );	UnionRgn( temp, aTemp, aTemp );	RectRgn( temp, &c );	UnionRgn( temp, aTemp, aTemp );	UnionRgn( aRgn, aTemp, aRgn );	InsetRgn( aTemp, 2, 2 );	DiffRgn( aRgn, aTemp, aRgn );		// finally add in a small region on the left representing the range of addresses covered		SetRect( &a, 2, a.top, 7, EmptyRect( &c )? b.bottom : c.bottom );	RectRgn( temp, &a );	UnionRgn( temp, aRgn, aRgn );	InsetRect( &a, 2, 2 );	a.right += 2;	RectRgn( temp, &a );	DiffRgn( aRgn, temp, aRgn );		DisposeRgn( aTemp );	DisposeRgn( temp );		if ( ! EmptyRgn( aRgn ))		OffsetRgn( aRgn, 0, 1 );}/*----------------------------------***  DrawCaret  ***---------------------------------*//*access:			protectedoverrides:		description: 	draw the caretins: 			<state> TRUE to draw, FALSE to eraseouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::DrawCaret( Boolean state ){	Rect	r;		if ( state != fCaretPhase )	{		SetRect( &r, CalcCaretHOffset( fSelStart ) - CARET_WIDTH,					 ( fSelStart / BYTES_PER_LINE ) * fLineHeight,					 CalcCaretHOffset( fSelStart ),					 (( fSelStart / BYTES_PER_LINE ) * fLineHeight ) + fLineHeight + 2 );					 		if ( fHalfOff )			OffsetRect( &r, fEmSpace, 0 );					PenNormal();		 		if ( state )			PenMode( patCopy );		else			PenMode( patBic );		PaintRect( &r );				fCaretPhase = state;	}}/*------------------------------------***  Munge  ***-----------------------------------*//*access:			protectedoverrides:		description: 	core method of editor - performs insert/replace/append of data in editorins: 			<dataToInsert> pointer to data to insert				<dataLength> length of data to insertouts: 			nonenotes:			operation depends on position of selection (see comment below)----------------------------------------------------------------------------------------*/void	ZHexEditView::Munge( Ptr dataToInsert, long dataLength ){	// replaces or appends data in the <fEditHandle> handle with the data passed. This is the	// basic method for doing all kinds of edits. If selStart == selEnd, the data is inserted	// at that point. If a range is covered, the range is replaced with the data. If <data> is	// NULL or length is 0, the selection is deleted. This may modify selEnd (but never	// selStart), but does not change the selection region- you need to recompute that. This	// doesn't recompute the bounds.		FailNILParam( fEditHandle );		if ( dataToInsert == NULL )		dataLength = 0;		long	ss, se;		ss = MIN( fSelStart, fSelEnd );	se = MAX( fSelStart, fSelEnd );			long	dumpLength, newSize, deltaSize, selRange = se - ss;		// handle may need to change size- work out by how much, pos or neg.		dumpLength = GetLength();	deltaSize = dataLength - selRange;	newSize = dumpLength + deltaSize;		// if zero, there's no moving to do, since the range is the same length as the inserted data,	// so it can simply be copied over it.		if ( deltaSize != 0 )	{		if ( deltaSize > 0 )		{			// we're getting bigger, so existing data is moved after resizing						SetHandleSize( fEditHandle, newSize );			FailMemError();						// data from <selEnd> to the end of the array is moved to the end						BlockMoveData( *fEditHandle + se, *fEditHandle + se + deltaSize, dumpLength - se ); 				}		else		{			// we're getting smaller, so existing data is moved before resizing					BlockMoveData( *fEditHandle + se, *fEditHandle + se + deltaSize, dumpLength - se );						SetHandleSize( fEditHandle, newSize );			FailMemError();		}		}			fSelStart = ss;	fSelEnd = ss + dataLength;		if ( dataLength )		BlockMoveData( dataToInsert, *fEditHandle + ss, dataLength );			fEdited = TRUE;}/*---------------------------***  RecalcBoundsAndSelection  ***-------------------------*//*access:			protectedoverrides:		description: 	recompute selection region and bounds on demandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::RecalcBoundsAndSelection(){	RgnHandle	temp = NewRgn();		CalcSelection( fSelStart, fSelEnd, temp );	SetSelectionRgn( temp );	DisposeRgn( temp );		CalcBounds();}/*----------------------------------***  MoveCaret  ***---------------------------------*//*access:			protectedoverrides:		description: 	move caret when typing, etcins: 			<cDirection> opcode for moving the caret				<shifted> TRUE if shift key down, else FALSEouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::MoveCaret( short cDirection, Boolean shifted ){	// implements cursor key movement of caret and caret motion when typing, etc.		DrawCaret( FALSE );	fHalfOff = FALSE;		// if a range is selected, kill the selection:		if ( ! EmptyRgn( fSelectionRgn ))	{		SetHiliteMode();		InvertRgn( fSelectionRgn );		SetEmptyRgn( fSelectionRgn );	}		// modify selStart according to the direction, constrain it to the overall limits of	// the dump and make selEnd the same:		switch ( cDirection )	{		case left:			fSelStart--;			break;					case right:			fSelStart++;			break;					case up:			fSelStart -= BYTES_PER_LINE;			break;					case down:			fSelStart += BYTES_PER_LINE;			break;					case halfRight:			fHalfOff = TRUE;			break;					case toEnd:			fSelStart = GetLength();			break;					case toEndOfLine:			fSelStart += BYTES_PER_LINE - ( fSelStart % BYTES_PER_LINE );			break;					case toBeginning:			fSelStart = 0;			break;					case toBeginningOfLine:			fSelStart -= fSelStart % BYTES_PER_LINE;			break;	}	fSelStart = MAX( 0, MIN( GetLength(), fSelStart ));		if ( ! shifted )		fSelEnd = fSelStart;			// if the caret has gone out of view, scroll so it's in view		ScrollToCaret();		if ( ! shifted )		DrawCaret( TRUE );	else	{		RgnHandle temp;				FailNIL( temp = NewRgn());				CalcSelection( fSelStart, fSelEnd, temp );		SetSelectionRgn( temp );		DisposeRgn( temp );	}}/*---------------------------------***  RedrawOnType  ***-------------------------------*//*access:			protectedoverrides:		description: 	perform partial redraw of editor when data inserted by typingins: 			<offset> position affected by typing, etc.outs: 			nonenotes:			redraws visible lines following offset passed----------------------------------------------------------------------------------------*/void	ZHexEditView::RedrawOnType( long offset ){	// redraws one byte at the given offset		Rect		cont, cr;	short		pH, pV;		GetContentRect( &cont );	GetPosition( &pH, &pV );	OffsetRect( &cont, pH, pV );		CalcSelection( offset, GetLength(), gUtilRgn );		if ( ! EmptyRgn( gUtilRgn ))	{		cr = *REGIONBOUNDINGBOX( gUtilRgn );		cr.right = cont.right;		cr.left = cont.left;				SectRect( &cont, &cr, &cr );	}	else	{		// must be deleting the very last byte, so set <cr> accordingly.				cr = cont;		cr.top = ( GetLength() / BYTES_PER_LINE ) * fLineHeight;		cr.bottom = cr.top + fLineHeight;	}		RgnHandle	temp;		GetClip( temp = NewRgn());	RectRgn( gUtilRgn, &cr );	SectRgn( temp, gUtilRgn, temp );	SetClip( temp );	DisposeRgn( temp );		fTextMode = srcCopy;	DrawContent();	fTextMode = srcOr;}/*----------------------------------***  TypeInData  ***--------------------------------*//*access:			protectedoverrides:		description: 	convert typing into insertion data and perform insertionins: 			<theKey> character typedouts: 			TRUE if typed character raccepted, FALSE if illegal characternotes:			0-9 and A-F are legal. Character pairs are converted to a byte and				inserted using Munge----------------------------------------------------------------------------------------*/Boolean	ZHexEditView::TypeInData( char theKey ){	if (( theKey >= '0' && theKey <= '9' ) ||		( theKey >= 'A' && theKey <= 'F' ) ||		( theKey >= 'a' && theKey <= 'f' ))	{		char					k;		Boolean					replaceRange = ( fSelEnd != fSelStart );				// hide the cursor until the mouse is moved again (normal practice):				ObscureCursor();				// we need to accumulate two keystrokes for every byte, so we use binCount to		// tell us whether were editing the high or low nibble. Since the caret advances		// to the right as we type, the high nibble is written first.				if ( theKey <= '9' )			k = theKey - 0x30;		else		{			if ( theKey <= 'F' )				k = theKey - 0x37;			else				k = theKey - 0x57;		}				Ptr 		dumpArea = *fEditHandle;		Ptr			p = dumpArea + fSelStart;		static char	c;			if ( fNibPhase )			*p = ( c & 0xF0 ) | k;				// low nibble		else		{			c =  k << 4 ;						// high nibble			Munge( &c, 1 );		}				if ( replaceRange )		{			if ( fNibPhase )				fSelStart = fSelEnd;			RecalcBoundsAndSelection();		}		else		{			DrawCaret( FALSE );			RedrawOnType( fSelStart );			MoveCaret( fNibPhase? right : halfRight );			CalcBounds();		}				fNibPhase = !fNibPhase;					GetRootWindow()->SetDirty( TRUE );		return TRUE;	}	else		return FALSE;}/*--------------------------------***  ScrollToCaret  ***-------------------------------*//*access:			protectedoverrides:		description: 	scroll view to show caretins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::ScrollToCaret(){	short	ctop, dh, dv;	Point	pt;		ctop =  (( fSelStart / BYTES_PER_LINE ) * fLineHeight );		GetPosition( &dh, &dv );	pt.h = dh;	pt.v = ctop;		fTextMode = srcCopy;	ScrollAsNeeded( pt );	fTextMode = srcOr;	}/*-------------------------------***  SetSelectionRgn  ***------------------------------*//*access:			protectedoverrides:		description: 	change selection to region passedins: 			<aRgn> new selection regionouts: 			nonenotes:			selection immediately redrawn as needed----------------------------------------------------------------------------------------*/void	ZHexEditView::SetSelectionRgn( RgnHandle aRgn ){	FailNILParam( aRgn );		// if the window is inactive, the selection will be outlined. To allow the following to	// draw properly, we need to form the correct outline region.		if ( ! IsActive())	{		RgnHandle	temp;			CopyRgn( fSelectionRgn, temp = NewRgn());		InsetRgn( temp, 1, 1 );		DiffRgn( fSelectionRgn, temp, gUtilRgn );				CopyRgn( aRgn, temp );		InsetRgn( temp, 1, 1 );		DiffRgn( aRgn, temp, temp );				XorRgn( gUtilRgn, temp, gUtilRgn );				DisposeRgn( temp );	}	else		XorRgn( fSelectionRgn, aRgn, gUtilRgn );		PenNormal();	SetHiliteMode();	InvertRgn( gUtilRgn );		CopyRgn( aRgn, fSelectionRgn );}/*------------------------------***  CalcCaretHOffset  ***------------------------------*//*access:			protectedoverrides:		description: 	compute the horizontal position of the caretins: 			<offset> byte offset of caretouts: 			horizontal pixel offset of caretnotes:			----------------------------------------------------------------------------------------*/short	ZHexEditView::CalcCaretHOffset( long offset ){	return MIN( fHdEnd, fHdStart +					   (( offset % BYTES_PER_LINE ) * fEmSpace * 3 ) +					   (( offset % BYTES_PER_LINE ) / COLUMN_GROUP_SIZE * fEmSpace ));}/*---------------------------------***  DrawHexLine  ***--------------------------------*//*access:			protectedoverrides:		description: 	draw a complete line of hex data at the current pen locationins: 			<lineStartAddr> offset into data buffer where line begins				<bytesInLine> number of bytes to dump per lineouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZHexEditView::DrawHexLine( register Ptr lineStartAddr, register char bytesInLine ){	// draw a hex dump line 16 bytes long, starting at the current pen position		register Ptr 			p = lineStartAddr;	register unsigned char	c, pc;	register unsigned char	i = 0, t = 0;	Ptr						dumpArea;		dumpArea = *fEditHandle;		// first draw the line address offset. We do this by comparing <lineStartAddr> with	// <dumpArea>#if HD_USE_COLOUR	RGBForeColor( &gDarkRed );#endif	#if SHOW_ABSOLUTE_ADDRESS	DrawLongAsHex((long) lineStartAddr );#else	DrawLongAsHex( lineStartAddr - dumpArea );#endif	DrawChar( ':' );	// move to the horizontal position <hdStart>		MoveTo( fHdStart, PORTPENLOCATION( CURRENTPORT )->v );		// we build a cache of the line to be drawn since DrawString is much faster than	// repeated calls to DrawChar.		sLineCache[0] = BYTES_PER_LINE * 3 + ( BYTES_PER_LINE / COLUMN_GROUP_SIZE );		do	{		// convert byte pointed to by p to hex display.				if ( i < bytesInLine )		{			pc = *p++;			sLineCache[ ++t ] = sHex[( pc & 0xF0 ) >> 4];			sLineCache[ ++t ] = sHex[ pc & 0x0F ];		}		else		{			sLineCache[ ++t ] = ' ';			sLineCache[ ++t ] = ' ';		}		sLineCache[ ++t ] = ' ';				// add extra space between grouped columns				if ((( i + 1 ) % COLUMN_GROUP_SIZE ) == 0 )			sLineCache[ ++t ] = ' ';	}	while( ++i < BYTES_PER_LINE );	#if HD_USE_COLOUR	RGBForeColor( &gDarkBlue );#endif	DrawString((ConstStr255Param) sLineCache );		// dump line as ascii text (unprintable characters drawn as a dot)		MoveTo( fHdEnd + ASCII_OFFSET, PORTPENLOCATION( CURRENTPORT )->v );	i = t = 0;	sLineCache[0] = BYTES_PER_LINE;	p = lineStartAddr;		do	{		if ( i < bytesInLine )		{			c = *p++;			sLineCache[ ++t ] = ( c > 0xD9 || c < 0x20 )? '.' : c; 		}		else			sLineCache[ ++t ] = ' ';	}	while( ++i < BYTES_PER_LINE );	#if HD_USE_COLOUR	RGBForeColor( &gDarkGreen );#endif		DrawString((ConstStr255Param) sLineCache );}/*----------------------------------***  CalcBounds  ***--------------------------------*//*access:			protectedoverrides:		description: 	calculate the bounds rectins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZHexEditView::CalcBounds(){	Rect	cr, r;		SetRect( &r, 0, 0,				fHdEnd + ASCII_OFFSET + 6 + ( BYTES_PER_LINE * fEmSpace ),				1 + ((( GetLength() / BYTES_PER_LINE ) + 1 ) * fLineHeight ));					if ( fParentViewIsScroller )	{		GetParent()->GetContentRect( &cr );		r.bottom = MAX( cr.bottom - cr.top, r.bottom );	}		SetBounds( r );	Focus();	PrepareForDrawing();	FocusForContent();		fTextMode = srcCopy;	DrawContent();	fTextMode = srcOr;}#pragma mark -/*-----------------------***  CreateNewScrollinsHexEditorView  ***----------------------*//*access:			globaloverrides:		description: 	create a view with a scroller and a hex editorins: 			<aParent> parent view of compound view				<aFrame> frame of scrollerouts: 			The viewnotes:			may be registered as dialog item constructor function----------------------------------------------------------------------------------------*/ZView*	CreateNewScrollingHexEditorView( ZView* aParent, Rect* aFrame ){	ZScrollView*	parent;	ZHexEditView*	hexed;		FailNIL( parent = new ZScrollView( aParent, aFrame, TRUE, TRUE, TRUE ));	FailNIL( hexed = new ZHexEditView( parent, NULL ));		parent->SetStandardBorder( TRUE );	return hexed;}