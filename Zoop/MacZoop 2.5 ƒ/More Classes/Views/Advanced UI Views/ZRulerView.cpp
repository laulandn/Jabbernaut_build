/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZRulerView.cpp		-- view that draws a ruler******			©2000, Graham Cox*****************************************************************************************************/#include	"ZRulerView.h"#include	"MacZoop.h"#include	"ZScrollView.h"/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZRulerView::ZRulerView( ZView* aParent, Rect* aFrame, const RulerInfo* ri )	: ZView( aParent, aFrame ){	classID = CLASS_ZRulerView;		fRulerOrigin = 0.0;	fMarkerVis = TRUE;	fMarkerPosition = 0.0;	fPixelOrigin = 0;	fDecimals = 0;		if ( ri )	{		fMajorDistance = ri->majorDistance;		fAtomDistance = ri->atomDistance;		fDivsPerMajor = ri->divsPerMajor;		fSmallMarkLength = ri->smallMarkLength;				fMediumMarkLength = ri->mediumMarkLength;				fMajorMarkLength = ri->majorMarkLength;	}	else	{		// default ruler settings give an inches ruler based on a screen resolution of 90 dpi,		// divided into eighths.				fMajorDistance = 1.0;		fAtomDistance = fMajorDistance / kInchRulerAtomDistance;		fDivsPerMajor = 8;		fSmallMarkLength = 4;		fMediumMarkLength = 8;		fMajorMarkLength = kStdRulerViewHeight;	}		fRulerVertical = ( aFrame->bottom - aFrame->top ) > ( aFrame->right - aFrame->left );	SetFontInfo( kFontIDGeneva, 9, 0 );	SetForeColour( &gBlack );	SetBackColour( &gVeryLightGray );/*	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ZViewEnvironment* env = GetEnvironment();			env->SetThemedBack( kThemeBrushDialogBackgroundInactive );	}#endif*/	SetAcceptsMouseClicks( FALSE );}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZRulerView::ZRulerView( ZView* aParent, const short viewResourceID )	: ZView( aParent ){	classID = CLASS_ZRulerView;	fRulerOrigin = 0.0;	fMarkerVis = TRUE;	fMarkerPosition = 0.0;	fPixelOrigin = 0;	fDecimals = 0;		ViewResInit( viewResourceID );}/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	render the rulerins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::DrawContent(){	Rect	br;			GetBounds( &br );		if ( fRulerVertical )	{		MoveTo( br.right - 1, br.top );		LineTo( br.right - 1, br.bottom );				if ( IsActive() && IsEnabled())		{			RGBForeColor( &gWhite );			MoveTo( br.left, br.top );			LineTo( br.left, br.bottom );			RGBForeColor( &gMediumGray );			MoveTo( br.right - 2, br.top );			LineTo( br.right - 2, br.bottom );		}	}	else	{		MoveTo( br.left, br.bottom - 1 );		LineTo( br.right, br.bottom - 1 );				if ( IsActive() && IsEnabled())		{			RGBForeColor( &gWhite );			MoveTo( br.left, br.top );			LineTo( br.right, br.top );			RGBForeColor( &gMediumGray );			MoveTo( br.left, br.bottom - 2 );			LineTo( br.right, br.bottom - 2 );		}	}			if ( IsActive() && IsEnabled())	{		TextMode( srcOr );		PrepareForDrawing();	}	else	{		TextMode( grayishTextOr );		RGBForeColor( &gMidGray );	}		if ( fRulerVertical )		DrawRulerV();	else		DrawRulerH();		SetRect( &fLastMarker, 0, 0, 0, 0 );	DrawMarker();}/*-----------------------------------***  SetSize  ***----------------------------------*//*access:			publicoverrides:		description: 	set the view's sizeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::SetSize( const short width, const short height ){	fRulerVertical = height > width;		ZView::SetSize( width, height );}/*----------------------------------***  ShowMarker  ***--------------------------------*//*access:			publicoverrides:		description: 	show the ruler cursorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::ShowMarker(){	if ( ! fMarkerVis )	{		fMarkerVis = TRUE;		Focus();		PrepareForDrawing();		FocusForContent();		SetRect( &fLastMarker, 0, 0, 0, 0 );		DrawMarker();	}}/*----------------------------------***  HideMarker  ***--------------------------------*//*access:			publicoverrides:		description: 	hide the ruler cursorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::HideMarker(){	if ( fMarkerVis )	{		fMarkerVis = FALSE;				if ( IsVisible())		{			Focus();			PrepareForDrawing();			FocusForContent();			InvertRect( &fLastMarker );		}		SetRect( &fLastMarker, 0, 0, 0, 0 );	}}/*------------------------------***  SetMarkerPosition  ***-----------------------------*//*access:			publicoverrides:		description: 	set the ruler cursor's positionins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::SetMarkerPosition( const double_t markerPos ){	if ( markerPos != fMarkerPosition )	{		Focus();		PrepareForDrawing();		FocusForContent();				fMarkerPosition = markerPos;		DrawMarker();	}}/*--------------------------------***  SetRulerOrigin  ***------------------------------*//*access:			publicoverrides:		description: 	set the rulers origin (the value of the ruler at the top or				left edge of the view)ins: 			<anOrigin> ruler value at the start of the rulerouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::SetRulerOrigin( const double_t anOrigin ){	fRulerOrigin = anOrigin;	fMarkerPosition = 0.0;		Focus();	DrawAll();}/*-----------------------------***  SetRulerZeroPosition  ***---------------------------*//*access:			publicoverrides:		description: 	sets the rulers origin such that its zero mark is at the given				pixel positionins: 			<pixelOffset> pixel offset where zero is alignedouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::SetRulerZeroPosition( const short pixelOffset ){	SetRulerOrigin((double_t) pixelOffset * -fAtomDistance );}/*------------------------------***  SetRulerCalibration  ***---------------------------*//*access:			publicoverrides:		description: 	sets the ruler calibrationins: 			<pixelDistance> distance along ruler represented by one pixelouts: 			nonenotes:			example - if ruler major divisions are 1 inch apart and ruler measures				a view with 72 pixels per inch, pass in 1/72.0 as pixelDistance.----------------------------------------------------------------------------------------*/void		ZRulerView::SetRulerCalibration( const double_t numer, const double_t denom ){	fMajorDistance = numer;	fAtomDistance = ( numer / denom );	PostRefresh();}/*--------------------------------***  SetPixelOrigin  ***------------------------------*//*access:			publicoverrides:		description: 	sets the starting pixel of the rulerins: 			<pixOrigin> position of rulerouts: 			nonenotes:			used to scroll rulers as part of ZRulerScrollView----------------------------------------------------------------------------------------*/void		ZRulerView::SetPixelOrigin( const short pixOrigin ){	if ( pixOrigin != fPixelOrigin )	{		fPixelOrigin = pixOrigin;				Focus();		DrawAll();	}}/*------------------------------***  SetRulerDivisions  ***-----------------------------*//*access:			publicoverrides:		description: 	sets the number of subdivisions of each major unitins: 			<divs> number of divisionsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::SetRulerDivisions( const short divs ){	if ( divs != fDivsPerMajor )	{		fDivsPerMajor = divs;		PostRefresh();	}}/*---------------------------------***  RulerToPixel  ***-------------------------------*//*access:			publicoverrides:		description: 	get pixel offset from origin of bounds for given ruler valueins: 			<rPos> position in ruler's unitsouts: 			position to nearest pixelnotes:			----------------------------------------------------------------------------------------*/short		ZRulerView::RulerToPixel( const double_t rPos ){	return rinttol(( rPos - fRulerOrigin ) / fAtomDistance ) - fPixelOrigin;}/*---------------------------------***  PixelToRuler  ***-------------------------------*//*access:			publicoverrides:		description: 	get ruler value for a given pixel positionins: 			<aPixel> pixel offset from start of rulerouts: 			equivalent ruler positionnotes:			----------------------------------------------------------------------------------------*/double_t	ZRulerView::PixelToRuler( const short aPixel ){	return ((double_t)( aPixel + fPixelOrigin ) * fAtomDistance ) + fRulerOrigin;}/*---------------------------------***  PixelToRuler  ***-------------------------------*//*access:			publicoverrides:		description: 	report info to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::ReportFields(){	ZView::ReportFields();	XSHOWFIELD( fRulerOrigin, ft_float );	XSHOWFIELD( fAtomDistance, ft_float );	XSHOWFIELD( fMarkerPosition, ft_float );	XSHOWFIELD( fPixelOrigin, ft_signedshort );	XSHOWFIELD( fDivsPerMajor, ft_signedshort );	XSHOWFIELD( fSmallMarkLength, ft_signedshort );	XSHOWFIELD( fMediumMarkLength, ft_signedshort );	XSHOWFIELD( fMajorMarkLength, ft_signedshort );	XSHOWFIELD( fRulerVertical, ft_boolean );	XSHOWFIELD( fMarkerVis, ft_boolean );	XSHOWFIELD( fLastMarker, ft_Rect );}/*----------------------------------***  DrawRulerH  ***--------------------------------*//*access:			protectedoverrides:		description: 	draw horizontal ruler divisions and labelsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::DrawRulerH(){	// how many major divisions are visible (even if only partly)?		Rect		cr, tr;	short		majors, n, k, p;	double_t	stm, divSpan, ro;	Point		ps;		GetContentRectInBounds( &cr );	majors = rinttol((double_t)( cr.right - cr.left ) * fAtomDistance ) + 1;		// figure out where to start. We always start on a major division, and this will	// be at or to the left of the left edge of the visible area of the view.		ro 		= floor( PixelToRuler( cr.left )) - ( fMajorDistance / 2 );	stm 	= ro - fmod( ro, fMajorDistance );				// stm is the starting major division	divSpan = fMajorDistance / (double_t) fDivsPerMajor;	// distance per minor division		// outer loop - draw major divisions		for( n = 0; n <= majors; n++ )	{		PenNormal();		p = RulerToPixel( stm );		MoveTo( p, cr.bottom );		Line( 0, -fMajorMarkLength );		SendMessage( kMsgRulerDrawingMajorMark, &p );				// draw label here				GetPen( &ps );		tr.bottom = cr.bottom - fMediumMarkLength;		tr.top = cr.top + 2;		tr.right = ps.h - 1;		tr.left = tr.right - 20;		DrawRulerMajorLabel( &tr, stm );				// inner loop - draw minor divisions				for( k = 0; k < fDivsPerMajor; k++ )		{				stm += divSpan;			MoveTo( RulerToPixel( stm ), cr.bottom );			Line( 0, -fSmallMarkLength );		}				// draw median mark				MoveTo( RulerToPixel( stm - ( fMajorDistance / 2 )), cr.bottom );		Line( 0, -fMediumMarkLength );	}}/*----------------------------------***  DrawRulerV  ***--------------------------------*//*access:			protectedoverrides:		description: 	draw vertical ruler divisions and labelsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::DrawRulerV(){	// how many major divisions are visible (even if only partly)?		Rect		cr, tr;	short		majors, n, k, p;	double_t	stm, divSpan, ro;	Point		ps;	FontInfo	fi;		GetFontInfo( &fi );	GetContentRectInBounds( &cr );	majors = rinttol((double_t)( cr.bottom - cr.top ) * fAtomDistance ) + 1;		// figure out where to start. We always start on a major division, and this will	// be at or above the top edge of the visible area of the view.		ro 		= floor( PixelToRuler( cr.top )) - ( fMajorDistance / 2 );	stm 	= ro - fmod( ro, fMajorDistance );				// stm is the starting major division	divSpan = fMajorDistance / (double_t) fDivsPerMajor;	// distance per minor division		// outer loop - draw major divisions		for( n = 0; n <= majors; n++ )	{		PenNormal();		p = RulerToPixel( stm );		MoveTo( cr.right - 2, p );		Line( -( fMajorMarkLength - 2 ), 0 );		SendMessage( kMsgRulerDrawingMajorMark, &p );				// draw label here				GetPen( &ps );		tr.bottom = ps.v - 1;		tr.top = tr.bottom - ( fi.ascent + fi.descent + fi.leading );		tr.left = cr.left + 2;		tr.right = cr.right - fSmallMarkLength;		DrawRulerMajorLabel( &tr, stm );				// inner loop - draw minor divisions				for( k = 0; k < fDivsPerMajor; k++ )		{				stm += divSpan;			MoveTo( cr.right - 2, RulerToPixel( stm ));			Line( -( fSmallMarkLength - 2 ), 0 );		}				// draw median mark				MoveTo( cr.right - 2, RulerToPixel( stm - ( fMajorDistance / 2 )));		Line( -( fMediumMarkLength - 2 ), 0 );	}}/*------------------------------***  DrawRulerMajorLabel  ***---------------------------*//*access:			protectedoverrides:		description: 	draw label for value passedins: 			<labelBounds> draw label in this rectangle				<labelValue> the value of the labelouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::DrawRulerMajorLabel( Rect* labelBounds, const double_t labelValue ){	FontInfo	fi;	RGBColor	sc;	Str15		s;	short		w, k;		GetFontInfo( &fi );	RealToString( labelValue, (Str255&) s, fDecimals );	GetForeColor( &sc );	//RGBForeColor( &fFore );	k = 9; //fFontSize;		w = labelBounds->right - StringWidth( s );	if ( w < labelBounds->left )	{		TextFace( condense );		w = labelBounds->right - StringWidth( s );	}		MoveTo( w, labelBounds->bottom );				DrawString( s );	RGBForeColor( &sc );}/*----------------------------------***  DrawMarker  ***--------------------------------*//*access:			protectedoverrides:		description: 	draw marker at current position if visibleins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerView::DrawMarker(){	if ( fMarkerVis && IsActive() && IsEnabled() && IsVisible())	{		Rect		br, mr;		RgnHandle	temp;				GetBounds( &br );		mr = br;		mr.right--;		mr.bottom--;				if ( fRulerVertical )		{			mr.top = mr.bottom = RulerToPixel( fMarkerPosition );			InsetRect( &mr, 0, -1 );			mr.bottom++;		}		else		{			mr.left = mr.right = RulerToPixel( fMarkerPosition );			InsetRect( &mr, -1, 0 );			mr.right++;		}				RectRgn( temp = NewRgn(), &mr );		RectRgn( gUtilRgn, &fLastMarker );		XorRgn( gUtilRgn, temp, temp );		InvertRgn( temp );		DisposeRgn( temp );				fLastMarker = mr;	}}#pragma mark -/*------------------------------***  CreateNewRulerView  ***----------------------------*//*access:			globaloverrides:		description: 	create ruler view with parametersins: 			<aParent> parent view				<aFrame> view's frame				<pCount> count of parameters				<params> list of parameters, given belowouts: 			nonenotes:			can be registered as dialog item constructor function				params[0] = pixels between major divisions (n.b. reciprocal of usual param)				params[1] = number of minor divisions per major division----------------------------------------------------------------------------------------*/ZView*	CreateNewRulerView( ZView* aParent, Rect* aFrame, const short pCount, long params[] ){	RulerInfo		ri;	ZRulerView*		rv;		if ( pCount > 0 )	{		ri.majorDistance = 1.0;		ri.atomDistance = 1.0 / (double_t) params[0];		ri.divsPerMajor = params[1];		ri.smallMarkLength = 5;		ri.mediumMarkLength = 8;		ri.majorMarkLength = 9;				FailNIL( rv = new ZRulerView( aParent, aFrame, &ri ));	}	else		FailNIL( rv = new ZRulerView( aParent, aFrame ));			return rv;}