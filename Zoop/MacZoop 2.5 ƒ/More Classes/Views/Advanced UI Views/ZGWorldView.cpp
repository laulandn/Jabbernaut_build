/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZGWorldView.cpp		-- view for displaying an image******			©2000, Graham Cox*****************************************************************************************************/#include	"ZGWorldView.h"#include	"ZScrollView.h"#include	"MacZoop.h"#include	"ZDiskGWorld.h"/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZGWorldView::ZGWorldView( ZView* aParent, Rect* aFrame, const short bitDepth, const short clutID, Boolean makeDiskBased )	: ZScrollAwareView( aParent, aFrame ){	fWorld = NULL;	fScale = 100;	fFatBits = FALSE;	fToolMode = kGWorldNoTool;		MakeGWorld( aFrame, bitDepth, clutID, makeDiskBased );	CalcBounds();	SetCanBeHandler( TRUE );	AttachBorder( new ZDropShadowBorder());	SetRefreshOnActivate( FALSE );	SetNoBackgroundErase( TRUE );}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZGWorldView::ZGWorldView( ZView* aParent, const short picResID, Boolean makeDiskBased )	: ZScrollAwareView( aParent, NULL ){	fWorld = NULL;	fScale = 100;	fFatBits = FALSE;	fToolMode = kGWorldNoTool;			InstallImage( picResID, makeDiskBased );	SetCanBeHandler( TRUE );	AttachBorder( new ZDropShadowBorder());	SetRefreshOnActivate( FALSE );	SetNoBackgroundErase( TRUE );}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZGWorldView::ZGWorldView( ZView* aParent, PicHandle aPicture, Boolean makeDiskBased )	: ZScrollAwareView( aParent, NULL ){	fWorld = NULL;	fScale = 100;	fFatBits = FALSE;	fToolMode = kGWorldNoTool;			InstallImage( aPicture, makeDiskBased );	SetCanBeHandler( TRUE );	AttachBorder( new ZDropShadowBorder());	SetRefreshOnActivate( FALSE );	SetNoBackgroundErase( TRUE );}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZGWorldView::ZGWorldView( ZView* aParent, ZGWorld* aGWorld, Boolean makeDiskBased )	: ZScrollAwareView( aParent, NULL ){	fWorld = NULL;	fScale = 100;	fFatBits = FALSE;	fToolMode = kGWorldNoTool;			InstallImage( aGWorld, makeDiskBased );	SetCanBeHandler( TRUE );	AttachBorder( new ZDropShadowBorder());	SetRefreshOnActivate( FALSE );	SetNoBackgroundErase( TRUE );}/*--------------------------------***  DESTRUCTOR  ***---------------------------------*/ZGWorldView::~ZGWorldView(){	if ( fWorld )		FORGETOBJECT( fWorld );}/*------------------------------***  DrawContent  ***-----------------------------------*//*access:			publicoverrides:		description: 	draw the gworld to the view apertureins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::DrawContent(){	Rect		dr, br, sr;	RgnHandle	maskRgn = NULL, temp;		if ( fWorld )	{		GetBounds( &br );		fWorld->GetSize( &sr );		if ( IsPrinting())		{			dr = sr;			OffsetRect( &dr, -dr.left, -dr.top );		}		else			dr = br;				SetPortBlackWhite();		fWorld->CopyOut( CURRENTPORTPIXMAP, &sr, &dr, srcCopy + ditherCopy, maskRgn );				if ( maskRgn )			DisposeRgn( maskRgn );						// if window bigger than image, erase the remainder                FailNIL( temp = NewRgn());        GETCURRENTPORTVISRGN( temp );        		RectRgn( gUtilRgn, &dr );		DiffRgn( temp, gUtilRgn, gUtilRgn );		EraseRgn( gUtilRgn );				DisposeRgn( temp );	}}/*-------------------------------***  ClickContent  ***---------------------------------*//*access:			publicoverrides:		description: 	click in the view. This may call zoom methods according to tool modeins: 			<mouse> point relative to bounds				<modifiers> modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::ClickContent( const Point mouse, const short modifiers ){	if ( modifiers & cmdKey )		ClickScroll( mouse );	else	{		switch( fToolMode )		{			case kGWorldZoomTool:				ZoomToPoint( mouse, ( modifiers & optionKey ) == optionKey );				break;							default:				break;		}	}}/*------------------------------***  SetViewCursor  ***---------------------------------*//*access:			publicoverrides:		description: 	set the cursorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::SetViewCursor( const Point mouse, const short modifiers ){	if ( modifiers & cmdKey )		SetCursorShape( HAND_CURSOR );	else		SetCursorShape( ARROW_CURSOR );}/*------------------------------***  HandleCommand  ***---------------------------------*//*access:			publicoverrides:		description: 	respond to menu commandsins: 			<theCommand> the command to processouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::HandleCommand( const ZoopCommand theCommand ){	switch( theCommand )	{		case kCmd_ZoomIn:			ZoomToCentre( FALSE );			break;					case kCmd_ZoomOut:			ZoomToCentre( TRUE );			break;					case kCmd_FlipHorizontal:			if ( fWorld )			{				fWorld->FlipHorizontal();				PostContentRefresh();			}			break;				case kCmd_FlipVertical:			if ( fWorld )			{				fWorld->FlipVertical();				PostContentRefresh();			}			break;					case kCmd_Invert:			if ( fWorld )			{				fWorld->Invert();				PostContentRefresh();			}			break;			default:			ZScrollAwareView::HandleCommand( theCommand );			break;	}}/*--------------------------------***  UpdateMenus  ***---------------------------------*//*access:			publicoverrides:		description: 	enable menu commands that pertain to this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::UpdateMenus(){	if ( fWorld )	{		gMenuBar->EnableCommand( kCmdCut );		gMenuBar->EnableCommand( kCmdCopy );		gMenuBar->EnableCommand( kCmdClear );		gMenuBar->EnableCommand( kCmd_ZoomIn );		gMenuBar->EnableCommand( kCmd_ZoomOut );		gMenuBar->EnableCommand( kCmd_Invert );		gMenuBar->EnableCommand( kCmd_FlipHorizontal );		gMenuBar->EnableCommand( kCmd_FlipVertical );	}		ZScrollAwareView::UpdateMenus();}/*----------------------------------***  DoCopy  ***------------------------------------*//*access:			publicoverrides:		description: 	copy image to clipboard as a PICTins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::DoCopy(){	if ( fWorld )	{		PicHandle	p;				p = fWorld->MakePicture();		gClipboard->PutData( p );	}}/*---------------------------------***  DoPaste  ***------------------------------------*//*access:			publicoverrides:		description: 	paste PICT data as image into this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::DoPaste(){	PicHandle	p;		p = (PicHandle) gClipboard->GetData( 'PICT' );		if ( p )	{		SetScale( 100 );		InstallImage( p );		KillPicture( p );	}}/*---------------------------------***  DoClear  ***------------------------------------*//*access:			publicoverrides:		description: 	remove (erase) the imageins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::DoClear(){	if ( fWorld )		FORGETOBJECT( fWorld );			Rect	r = { 0, 0, 1, 1 };			MakeGWorld( &r, 1, 0 );	CalcBounds();	PostContentRefresh();}/*-------------------------------***  CanPasteType  ***---------------------------------*//*access:			publicoverrides:		description: 	see if clipboard can be pastedins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean	ZGWorldView::CanPasteType(){	return gClipboard->QueryType( 'PICT' );}/*---------------------------------***  SetScale  ***-----------------------------------*//*access:			publicoverrides:		description: 	set the magnification of the imageins: 			<aScale> new scale, in percent. 1:1 is therefore 100outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::SetScale( const short aScale ){	short	sc = MAX( 25, MIN( aScale, 3200 ));		if ( sc != fScale )	{		//scale can be from 25% to 3,200%				fScale = sc;		CalcBounds();		PostRefresh();	}}/*--------------------------------***  SetFatBits  ***----------------------------------*//*access:			publicoverrides:		description: 	set whether fatbits enabled. This is only shown above 400%ins: 			<fat> whether fatbits are to be shown or notouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::SetFatBits( Boolean fat ){	fFatBits = fat;	PostRefresh();}/*-------------------------------***  ZoomToPoint  ***----------------------------------*//*access:			publicoverrides:		description: 	zooms the image up or down, changing magnificationins: 			<clickPt> this point will be centred in zoomed image (bounds relative)				<isZoomOut> TRUE to make scale smaller, false for largerouts: 			nonenotes:			used to implement magnifier tool----------------------------------------------------------------------------------------*/void	ZGWorldView::ZoomToPoint( const Point clickPt, Boolean isZoomOut ){	Rect	cont, br, obr;	short	scrollH, scrollV, newScale;	Point	cPt;		Focus();	FocusForContent();	GetContentRectInBounds( &cont );	newScale = isZoomOut? ( fScale >> 1 ) : ( fScale << 1 );		// if drag manager is available, perform a zoom effect		newScale = MAX( 25, MIN( newScale, 3200 ));		if ( newScale != fScale )	{		if ( gMacInfo.hasDragManager )		{			Rect	zSrc, zDest;						zDest = cont;			Pt2Rect( clickPt, clickPt, &zSrc );			InsetRect( &zSrc, -2, -2 );						LocalToGlobal( &TOPLEFTPOINT( zSrc ));			LocalToGlobal( &BOTTOMRIGHTPOINT( zSrc ));			LocalToGlobal( &TOPLEFTPOINT( zDest ));			LocalToGlobal( &BOTTOMRIGHTPOINT( zDest ));						if ( isZoomOut )				FailOSErr( ZoomRects( &zDest, &zSrc, 10, kZoomDecelerate ));			else				FailOSErr( ZoomRects( &zSrc, &zDest, 10, kZoomAccelerate ));		}				GetBounds( &obr );		SetScale( newScale );		GetBounds( &br );				// scroll to position the view such that <clickPt> is centred				cPt = clickPt;		MapPt( &cPt, &obr, &br );				scrollH = cPt.h - (( cont.right - cont.left ) / 2 );		scrollV = cPt.v - (( cont.bottom - cont.top ) / 2 );				ScrollTo( scrollH, scrollV );	}}/*------------------------------***  ZoomToCentre  ***----------------------------------*//*access:			publicoverrides:		description: 	zooms the image up or down, changing magnificationins: 			<isZoomOut> TRUE to make scale smaller, false for largerouts: 			nonenotes:			used to implement magnification commands----------------------------------------------------------------------------------------*/void	ZGWorldView::ZoomToCentre( Boolean isZoomOut ){	Rect	br;	Point	clickPt;		GetContentRectInBounds( &br );		clickPt.h = ( br.left + br.right ) / 2;	clickPt.v = ( br.top + br.bottom ) / 2;		ZoomToPoint( clickPt, isZoomOut );}/*------------------------------***  InstallImage  ***----------------------------------*//*access:			publicoverrides:		description: 	installs the given picture as the imageins: 			<aPic> an existing picture to installouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::InstallImage( PicHandle aPic, Boolean makeDiskBased ){	if ( fWorld )		FORGETOBJECT( fWorld );			if ( makeDiskBased )		FailNIL( fWorld = new ZDiskGWorld( aPic, 0 ));	else		FailNIL( fWorld = new ZGWorld( aPic, FALSE, 0 ));	CalcBounds();	PostContentRefresh();	}/*------------------------------***  InstallImage  ***----------------------------------*//*access:			publicoverrides:		description: 	installs the a picture from a resource as the imageins: 			<picResourceID> the id of a PICT resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::InstallImage( const short picResourceID, Boolean makeDiskBased ){	if ( fWorld )		FORGETOBJECT( fWorld );			if ( makeDiskBased )		FailNIL( fWorld = new ZDiskGWorld( picResourceID, 0 ));	else		FailNIL( fWorld = new ZGWorld( picResourceID, FALSE, 0 ));	CalcBounds();		PostContentRefresh();	}/*------------------------------***  InstallImage  ***----------------------------------*//*access:			publicoverrides:		description: 	installs the another ZGWorld as the imageins: 			<aGWorld> the ZGWorld objectouts: 			nonenotes:			note that the ZGWorld passed is COPIED----------------------------------------------------------------------------------------*/void	ZGWorldView::InstallImage( ZGWorld* aGWorld, Boolean makeDiskBased ){	if ( fWorld )		FORGETOBJECT( fWorld );			if ( makeDiskBased )		FailNIL( fWorld = new ZDiskGWorld( aGWorld ));	else		FailNIL( fWorld = new ZGWorld( aGWorld, FALSE ));	CalcBounds();		PostContentRefresh();	}/*-------------------------------***  MakeGWorld  ***-----------------------------------*//*access:			protectedoverrides:		description: 	creates a GWorld with the size and depth requestedins: 			<size> the dimensions of the image				<bitDepth> bit depth of the imageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::MakeGWorld( Rect* size, short bitDepth, short clutID, Boolean makeDiskBased ){	Rect			r;	CTabHandle		ct = NULL;		r = *size;	OffsetRect( &r, -r.left, -r.top );		if ( clutID )		ct = GetCTable( clutID );		if ( makeDiskBased )		FailNIL( fWorld = new ZDiskGWorld( r, bitDepth, ct ));	else		FailNIL( fWorld = new ZGWorld( r, bitDepth, ct, FALSE ));		if ( ct )		DisposeCTable( ct );}/*-------------------------------***  CalcBounds  ***-----------------------------------*//*access:			protectedoverrides:		description: 	caculates bounds of view based on image size and scaleins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::CalcBounds(){	Rect	r;		if ( fWorld )	{		fWorld->GetSize( &r );				r.right = ((long) r.right * (long) fScale ) / 100;		r.bottom = ((long) r.bottom * (long) fScale ) / 100;				SetBounds( r );		SetScrollAmount( fScale / 10, fScale / 10 );	}}/*-------------------------------***  CalcSourceRect  ***-------------------------------*//*access:			protectedoverrides:		description: 	calculates the portion of the GWorld that is visible in the viewins: 			<aSrcRect> receives the rectouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::CalcSourceRect( Rect* aSrcRect ){	Rect 	sr, br, fr;		GetContentRectInBounds( &sr );	GetBounds( &br );	fWorld->GetSize( &fr );		MapRect( &sr, &br, &fr );		*aSrcRect = sr;}/*---------------------------------***  ReportFields  ***-------------------------------*//*access:			publicoverrides:		description: 	report member states to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZGWorldView::ReportFields(){	ZScrollAwareView::ReportFields();		XSHOWFIELD( fWorld, ft_objectref );	XSHOWFIELD( fScale, ft_signedshort );	XSHOWFIELD( fToolMode, ft_signedshort );	XSHOWFIELD( fFatBits, ft_boolean );}#pragma mark -/*------------------------***  CreateNewScrollingGWorldView  ***------------------------*//*access:			globaloverrides:		description: 	creates a GWorldView with enclosing scrollerins: 			<aParent> view's parent				<aFrame> view's frame				<pCount> count of parameters				<params> the parameters, as follows:outs: 			nonenotes:			params[0] - flags, bit 0 = v bar, 1 = hbar, 2 = sizebox				params[1] - ID of PICT resource to display, or 0 if...				params[2] - width of image (if no PICT)				params[3] - height of image (if no PICT)				params[4] - depth of image ( 0 = same as screen )				params[5] - CLUT ID ( 0 = system palette )				params[6] - more flags, bit 0 = disk based GWorld----------------------------------------------------------------------------------------*/ZView*		CreateNewScrollingGWorldView( ZView* aParent, Rect* aFrame, short pCount, long params[] ){	ZGWorldView*	gw;	ZScrollView*	scroller;	Boolean			hBar, vBar, szBox;		if ( pCount > 0 )	{		vBar = ( params[0] & kScrollingViewHasVerticalBar ) == kScrollingViewHasVerticalBar;		hBar = ( params[0] & kScrollingViewHasHorizontalBar ) == kScrollingViewHasHorizontalBar;		szBox = ( params[0] & kScrollingViewHasSizeBox ) == kScrollingViewHasSizeBox;	}	else		hBar = vBar = szBox = FALSE;		FailNIL( scroller = new ZScrollView( aParent, aFrame, hBar, vBar, szBox ));	scroller->SetStandardBorder( TRUE );	scroller->SetNoBackgroundErase( TRUE );		if ( pCount > 1 )	{		short pictID = params[1];			if ( pictID == 0 )		{			Rect	r;			short	depth, clut;						r.left = r.top = 0;			r.right = params[2];			r.bottom = params[3];						if ( pCount > 4 )				depth = params[4];			else				depth = 8;						if ( pCount > 5 )					clut = params[5];			else				clut = 0;					FailNIL( gw = new ZGWorldView( scroller, &r, depth, clut, params[6] & 1 ));		}		else			FailNIL( gw = new ZGWorldView( scroller, pictID, params[6] & 1 ));	}	else		FailOSErr( kMoreParametersExpectedErr );	return gw;}