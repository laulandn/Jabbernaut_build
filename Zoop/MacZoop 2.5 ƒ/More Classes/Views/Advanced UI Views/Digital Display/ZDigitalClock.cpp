/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZDigitalClock.cpp		-- implements a simulated electronic digital clock******			©2000, Graham Cox*****************************************************************************************************/#include	"ZDigitalClock.h"#include	"MacZoop.h"/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZDigitalClock::ZDigitalClock( ZView* aParent, Rect* aFrame )	: ZDigitalView( aParent, aFrame, 6, kDVLeadingZeroBlanking ){	classID = CLASS_ZDigitalClock;		fColonExtra = 4;	fColonPhase = FALSE;	GetDateTime( &fTimeBaseRegister ); 	fCountRegister = 0;	fElapsedRegister = 0;	fMode = kDVClock24HourTimeMode;	fRunning = TRUE;	fLastSec = -1;		// set a timer to update the display as time elapses. This calls	// us twice per second		SetFontInfo( kFontIDGeneva, 9, 0 );	SetTimer( this, 2, 30 );}/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	update the displayins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalClock::DrawContent(){	ZDigitalView::DrawContent();		if ( fMode == kDVClockStdTimeMode )	{		// draw am/pm indicator in this mode only				DateTimeRec	dtr;				::GetTime( &dtr );		MoveTo( 3, 8 + kDVDigitVSpacing );				if ( dtr.hour >= 12 )			DrawString("\ppm"); 		else			DrawString( "\pam" );	}}/*-----------------------------------***  DoTimer  ***----------------------------------*//*access:			publicoverrides:		description: 	timer callback - update display as time changesins: 			<id> timer IDouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalClock::DoTimer( long id ){	ZDigitalView::DoTimer( id );		if ( id == 2 )	{		BCD_32 tod = GetTimeAsBCD();				switch ( fMode )		{				case kDVClockStdTimeMode:			case kDVClock24HourTimeMode:				break;							case kDVClockElapsedMode:				unsigned long t;								GetDateTime( &t );				fElapsedRegister = t - fTimeBaseRegister;				tod = SecondsToBCD( fElapsedRegister );				break;							case kDVClockLapCountMode:				tod = SecondsToBCD( fElapsedRegister );				break;							case kDVClockUpCountingMode:				if ( fColonPhase && fRunning )					++fCountRegister;				tod = SecondsToBCD( fCountRegister );				break;							case kDVClockDownCountingMode:				if ( fColonPhase && fRunning )					--fCountRegister;				tod = SecondsToBCD( fCountRegister );				if ( fCountRegister <= 0 )				{					AlarmAction();					fRunning = FALSE;				}				break;		}					SetValueDirect( tod );	}}/*-----------------------------------***  SetMode  ***----------------------------------*//*access:			publicoverrides:		description: 	set clock operating modeins: 			<aMode> clock mode to setouts: 			nonenotes:			kDVClockStdTimeMode = 12 hour time of day				kDVClock24HourTimeMode = 24 hour time of day				kDVClockElapsedMode = records elapsed time since reset (non-pausable)				kDVClockLapCountMode = display held in elapsed mode				kDVClockUpCountingMode = counts up in seconds (pausable)				kDVClockDownCountingMode = counts down in seconds (pausable)----------------------------------------------------------------------------------------*/void	ZDigitalClock::SetMode( const short aMode ){	fMode = aMode;	PostRefresh();}/*-------------------------------***  ControlCounter  ***-------------------------------*//*access:			publicoverrides:		description: 	control clock in counting & elapsed modesins: 			ctrlOp - operation codeouts: 			nonenotes:			kDVClockCtrlStartCount = start counting				kDVClockCtrlHoldCount = stop counting (time not reset, display held)				kDVClockCtrlReset = stop and reset to zero----------------------------------------------------------------------------------------*/void	ZDigitalClock::ControlCounter( const short ctrlOp ){	if ( fMode == kDVClockUpCountingMode ||		 fMode == kDVClockDownCountingMode )	{		switch ( ctrlOp )		{			case kDVClockCtrlStartCount:				fRunning = TRUE;				break;							case kDVClockCtrlHoldCount:				fRunning = FALSE;				break;							case kDVClockCtrlReset:				fRunning = FALSE;				fCountRegister = 0;				SetValueDirect( 0 );				break;		}	}}/*--------------------------------***  PresetCounter  ***-------------------------------*//*access:			publicoverrides:		description: 	presets the counter to a given number of secondsins: 			<aCount> number of seconds initially setouts: 			nonenotes:			most useful in down count mode----------------------------------------------------------------------------------------*/void	ZDigitalClock::PresetCounter( const long aCount ){	fCountRegister = aCount;	SetValueDirect( SecondsToBCD( fCountRegister ));}/*--------------------------------***  GetTimeAsBCD  ***--------------------------------*//*access:			protectedoverrides:		description: 	returns time of day formatted as BCD, and controls colon phaseins: 			noneouts: 			current time in BCD formatnotes:			must be called in all modes twice per second----------------------------------------------------------------------------------------*/BCD_32	ZDigitalClock::GetTimeAsBCD(){	DateTimeRec		dtr;	long			sTime;		::GetTime( &dtr );		// manage the colon blink here, so it stays correctly synched	// with the changing of the time display itself		if ( fLastSec != dtr.second )		fColonPhase = TRUE;	else		fColonPhase = FALSE;		fLastSec = dtr.second;		if ( fMode == kDVClockStdTimeMode )	{		if ( dtr.hour == 12 )			sTime = 1200 + dtr.minute;		else			sTime = (( dtr.hour % 12 ) * 100 ) + dtr.minute;	}	else		sTime = ( dtr.hour * 100 ) + dtr.minute;		if ( fDigits >= 6 )	{		// show seconds as well				sTime *= 100;		sTime += dtr.second;	}		return LongToBCD( sTime );		}/*--------------------------------***  SecondsToBCD  ***--------------------------------*//*access:			protectedoverrides:		description: 	returns time value in seconds formatted as BCD in HH:MM:SSins: 			<sec> basic count of secondsouts: 			BCD formatnotes:			----------------------------------------------------------------------------------------*/BCD_32	ZDigitalClock::SecondsToBCD( long secs ){	BCD_32	bcd = 0;	long	mask, x;	short	k = 10;		mask = 1L;		while( secs > 0 )	{		x = secs % k;		secs /= k;				k = ( k == 10 )? 6 : 10;				bcd += ( x * mask );		mask <<= 4;	}	return bcd;}/*---------------------------------***  DrawColons  ***---------------------------------*//*access:			protectedoverrides:		description: 	draws the display colonsins: 			<hPosition> horizontal display offset to draw the colonouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalClock::DrawColons( short hPosition ){	Rect	cr;		SetRect( &cr, 0, 0, kDVPointSize, kDVPointSize );	OffsetRect( &cr, hPosition, kDVDigitVSpacing + 4 );		if ( fColonPhase )		PaintRect( &cr );	else		EraseRect( &cr ); 		OffsetRect( &cr, 0, 6 );	if ( fColonPhase )		PaintRect( &cr );	else		EraseRect( &cr ); }/*---------------------------------***  AlarmAction  ***--------------------------------*//*access:			protectedoverrides:		description: 	perform alarm activity when requiredins: 			noneouts: 			nonenotes:			default sends message - note, currently only called for down counter				reaching 0.----------------------------------------------------------------------------------------*/void	ZDigitalClock::AlarmAction(){	SendMessage( kMsgDVClockTimeOut, NULL );}/*---------------------------------***  CalcLZBMask  ***--------------------------------*//*access:			protectedoverrides:		description: 	calculate a mask for blanking leading zeroesins: 			noneouts: 			a mask with 1's where the digit should be drawn, 0's elsewherenotes:			----------------------------------------------------------------------------------------*/BCD_32		ZDigitalClock::CalcLZBMask(){	if ( fMode == kDVClockStdTimeMode )	{		DateTimeRec		dtr;			::GetTime( &dtr );		short			cr = ( dtr.hour % 12 );				if ( cr < 10 && cr != 0 )			return 0x000FFFFF;		else			return 0x00FFFFFF;	}	else		return ZDigitalView::CalcLZBMask();}#pragma mark -/*---------------------------***  CreateNewDigitalClock  ***----------------------------*//*access:			globaloverrides:		description: 	create digital clock viewins: 			<aParent> view's parent view				<aFrame> view's frameouts: 			the created viewnotes:			can be registered as dialog item constructor function----------------------------------------------------------------------------------------*/ZView*		CreateNewDigitalClock( ZView* aParent, Rect* aFrame, short param ){	ZDigitalClock*	dc;		FailNIL( dc = new ZDigitalClock( aParent, aFrame ));		dc->SetMode( param );	return dc;}