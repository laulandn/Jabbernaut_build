/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZDigitalView.cpp		-- implements a simulated electronic digital display******			©2000, Graham Cox*****************************************************************************************************/#include	"ZDigitalView.h"#include	"ZGWorld.h"#include	"MacZoop.h"#include	<Palettes.h>// these colours have been chosen to be useful for ZDigitalView when trying to// mimic real-world displays, but you are free to use any colours you wish.// foregrounds:const RGBColor LED_RED 					= {0xFFFF,0x3333,0x3333};const RGBColor LED_LIGHTYELLOW			= {0xFFFF,0xCCCC,0};const RGBColor BLUEGREEN_FLUORESCENT	= {0x6666,0xFFFF,0xCCCC};const RGBColor LED_GREEN				= {0xC0C0,0xFFFF,0};const RGBColor LED_BLUE					= {0x4C4C,0xB3B3,0xFFFF};// backgrounds:const RGBColor LCD_GRAYBACKLIGHT		= {0x9999,0xBBBB,0x9999};const RGBColor LCD_ORANGEBACKLIGHT		= {0xFFFF,0xA6A6,0x3333};const RGBColor LCD_COLDCATHODE			= {0xB3B3,0xFFFF,0xE6E6};const RGBColor LED_RED_BACKGND			= {0x3333,0,0x2626};const RGBColor LED_GREEN_BACKGND		= {0,0x4C4C,0x3333};const RGBColor LED_BLUE_BACKGND			= {0,0,0x6666};// static members:ZGWorld*	ZDigitalView::sDisplayDigits = NULL;/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZDigitalView::ZDigitalView( ZView* aParent, Rect* aFrame, const short numDigits, const char flags )	: ZItemView( aParent, aFrame ){	classID = CLASS_ZDigitalView;		fValue = 0;	fOpFlags = flags;	fDigits = numDigits;	fDecimalPos = 0;	fBCDBuffer = 0;	fIsNegative = FALSE;	fOutOfRange = FALSE;	fBlink = FALSE;	fBlinkPhase = FALSE;	fColonExtra = 0;		CalcMaxAndMin();		// set up shared graphic object that supplies the digits. This is a black and white	// GWorld created from a PICT resource. The digits are coloured on the fly as they	// are blitted to the window.		if ( sDisplayDigits == NULL )		FailNIL( sDisplayDigits = new ZGWorld( kDVGraphicsResID ));		sDisplayDigits->Acquire();		SetStandardBorder( TRUE );	SetForeColour( &LED_GREEN );	SetBackColour( &LED_GREEN_BACKGND );}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZDigitalView::ZDigitalView( ZView* aParent, const short viewResourceID )	: ZItemView( aParent ){	classID = CLASS_ZDigitalView;		fValue = 0;	fOpFlags = 0;	fDigits = 0;	fDecimalPos = 0;	fBCDBuffer = 0;	fIsNegative = FALSE;	fOutOfRange = FALSE;	fBlink = FALSE;	fBlinkPhase = FALSE;	fColonExtra = 0;		// set up shared graphic object that supplies the digits. This is a black and white	// GWorld created from a PICT resource. The digits are coloured on the fly as they	// are blitted to the window.		if ( sDisplayDigits == NULL )		FailNIL( sDisplayDigits = new ZGWorld( kDVGraphicsResID ));		sDisplayDigits->Acquire();	ViewResInit( viewResourceID );	SetTimer( this, 1, kDVBlinkTicks );}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZDigitalView::~ZDigitalView(){	if ( sDisplayDigits )	{		sDisplayDigits->Release( FALSE );			if ( ! sDisplayDigits->InUse())			FORGETOBJECT( sDisplayDigits );	}}/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	update the displayins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalView::DrawContent(){	if ( ! IsVisible())		return;		FailNILParam( sDisplayDigits );		Rect		src, dest, br, negDest;	BCD_32		temp, lzMask;	Boolean		negPosFlag = FALSE;	short		hPos;		SetRect( &src, 0, 0, kDVDigitWidth, kDVDigitHeight );	dest = src;	if ( fOpFlags & kDVUseHexadecimalCharset )		OffsetRect( &src, 0, kDVDigitHeight );			GetBounds( &br );	if ( fOpFlags & kDVCentreDigitsInBounds )		hPos = (( br.left + br.right ) / 2 ) + GetDisplayWidth() / 2;	else		hPos = br.right;			OffsetRect( &dest, hPos - kDVDigitWidth - kDVDigitSpacing, kDVDigitVSpacing );	temp = fBCDBuffer;	lzMask = CalcLZBMask();		// if inactive or disabled, use dimmer colour:		if (! ( IsActive() && IsEnabled()))	{		ZViewEnvironment*	env = GetEnvironment();				if ( env )		{			RGBColor	dim, back;						env->GetForeColour( &dim );			env->GetBackColour( &back );						GetGray( GetMainDevice(), &back, &dim );			RGBForeColor( &dim );		}	}		// plot the digits from right to left, LSD to MSD		for( short n = 0; n < fDigits; n++ )	{		if ( fBlink && fBlinkPhase )			EraseRect( &dest );		else		{			if ( lzMask & 0x0F )			{				OffsetRect( &src, kDVDigitWidth * ( temp & 0x0F ), 0 );					sDisplayDigits->CopyOut( CURRENTPORTPIXMAP, &src, &dest );			}			else				EraseRect( &dest );						OffsetRect( &src, -src.left, 0 );					temp >>= 4;			lzMask >>= 4;		}		OffsetRect( &dest, -( kDVDigitWidth + kDVDigitSpacing ), 0 );				if ( fColonExtra && ( n < fDigits - 1 ) && (( n + 1 ) % 2 ) == 0 )		{			DrawColons( dest.right - ( fColonExtra / 2 ) + 1 );			OffsetRect( &dest, -fColonExtra, 0 );		}				if ((( lzMask & 0x0F ) == 0 ) && !negPosFlag )		{			negDest = dest;			negPosFlag = TRUE;		}	}		if ( fIsNegative )	{		if ( negPosFlag )			dest = negDest;		// - symbol is character 'E' in charset 1.				if ( fBlink && fBlinkPhase )			EraseRect( &dest );		else		{			OffsetRect( &src, ( kDVDigitWidth * 14 ) - src.left, -src.top );			sDisplayDigits->CopyOut( CURRENTPORTPIXMAP, &src, &dest );		}	}		// plot decimal point if there is one		if ( fDecimalPos )	{		SetRect( &dest, 0, 0, kDVPointSize, kDVPointSize );		OffsetRect( &dest, hPos - kDVDigitSpacing - (( kDVDigitWidth + kDVDigitSpacing ) * fDecimalPos ) + 1 - ( fColonExtra / 2 ),							 kDVDigitVSpacing + kDVDigitHeight - 1 );				if ( fBlink && fBlinkPhase )			EraseRect( &dest );		else			PaintRect( &dest );	}}/*-----------------------------------***  SetValue  ***---------------------------------*//*access:			publicoverrides:		description: 	set the display's valueins: 			<aValue> the value to displayouts: 			nonenotes:			immediately updates the display; also detects overrange----------------------------------------------------------------------------------------*/void	ZDigitalView::SetValue( const long aValue ){	fValue = MAX( fMin, MIN( aValue, fMax ));		fBCDBuffer 	= LongToBCD( ABS( fValue ));	fIsNegative = ( fValue < 0 );	fOutOfRange = ( fValue != aValue );		if ( fOpFlags & kDVOverrangeBlinkEnable )	{		SetBlinking( fOutOfRange );	}		Focus();	PrepareForDrawing();	FocusForContent();	DrawContent();}/*-------------------------------------***  Reset  ***----------------------------------*//*access:			publicoverrides:		description: 	sets the value to 0, and clears any blinking, etcins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalView::Reset(){	fValue = 0;	fBCDBuffer = 0;	fIsNegative = FALSE;	SetBlinking( FALSE );	Focus();	PrepareForDrawing();	FocusForContent();	DrawContent();}/*---------------------------------***  InvertDisplay  ***------------------------------*//*access:			publicoverrides:		description: 	swaps fore and back colours and redrawsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalView::InvertDisplay(){	ZViewEnvironment*	env;		env = GetEnvironment();		if ( env )	{		RGBColor	f, b;				env->GetForeColour( &f );		env->GetBackColour( &b );		SetForeColour( &b );		SetBackColour( &f );				Focus();		PrepareForDrawing();		FocusForContent();		DrawContent();	}}/*----------------------------------***  SetDigits  ***---------------------------------*//*access:			publicoverrides:		description: 	set the number of digits in the displayins: 			<numDigits> the number of digitsouts: 			nonenotes:			digits are drawn from the right, and their number affects range detection----------------------------------------------------------------------------------------*/void	ZDigitalView::SetDigits( const short numDigits ){	fDigits = numDigits;	CalcMaxAndMin();	PostRefresh();}/*------------------------------***  SetDecimalPosition  ***----------------------------*//*access:			publicoverrides:		description: 	set the position of the decimal point, if anyins: 			<pos> number of decimal places in the displayouts: 			nonenotes:			0 = no point----------------------------------------------------------------------------------------*/void	ZDigitalView::SetDecimalPosition( const short pos ){	fDecimalPos = pos;	PostRefresh();}/*--------------------------------***  SetValueDirect  ***------------------------------*//*access:			publicoverrides:		description: 	set the display's value directly using a BCD formatted valueins: 			<aBCDValue> BCD value to displayouts: 			nonenotes:			allows you to have finer control over the display----------------------------------------------------------------------------------------*/void	ZDigitalView::SetValueDirect( const BCD_32 aBCDValue ){	fValue = 0;	fBCDBuffer = aBCDValue;	Focus();	PrepareForDrawing();	FocusForContent();	DrawContent();}/*----------------------------------***  SetBlinking  ***-------------------------------*//*access:			publicoverrides:		description: 	turn blinking on or off - called automatically on overrange if flag setins: 			<blinkOnOff> TRUE to set blinking, FALSE to stop itouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalView::SetBlinking( Boolean blinkOnOff ){	if ( blinkOnOff != fBlink )	{		fBlink = fBlinkPhase = blinkOnOff;		if ( fBlink )			SetTimer( this, 1, 10 );		else			KillTimer( this, 1 );	}}/*-------------------------------***  GetDisplayWidth  ***------------------------------*//*access:			publicoverrides:		description: 	get the actual width occupied by the display (not bounds width)ins: 			noneouts: 			width in pixelsnotes:			----------------------------------------------------------------------------------------*/short	ZDigitalView::GetDisplayWidth(){	return (( fDigits + 1 ) * ( kDVDigitWidth + kDVDigitSpacing ) + kDVDigitSpacing ) + ( fColonExtra * ( fDigits / 2 ));}/*------------------------------***  InitViewFromResource  ***--------------------------*//*access:			publicoverrides:		description: 	initialise the view from data in a 'View' resource handleins: 			<theRes> handle to 'View' resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalView::InitViewFromResource( Handle theRes ){	FailNILParam( theRes );		ZItemView::InitViewFromResource( theRes );		DigitalViewTemplateHdl		dvH = (DigitalViewTemplateHdl) theRes;		fDigits = (*dvH)->numDigits;	fOpFlags = 0;		if ((*dvH)->zeroBlanking )		fOpFlags |= kDVLeadingZeroBlanking; 	if ((*dvH)->blankOnZero )		fOpFlags |= kDVUnblankOnExactZero; 	if ((*dvH)->overrangeBlink )		fOpFlags |= kDVOverrangeBlinkEnable; 	if ((*dvH)->useAltCharset )		fOpFlags |= kDVUseHexadecimalCharset; 	if ((*dvH)->centreDigits )		fOpFlags |= kDVCentreDigitsInBounds;			CalcMaxAndMin(); }/*-------------------------------***  CreateViewResource  ***---------------------------*//*access:			publicoverrides:		description: 	Fills in the resource handle according to its templated structureins: 			<resHandle> valid handle of adequate sizeouts: 			nonenotes:			This method should only be used by the RAD tool to create View resources				(not for application use)----------------------------------------------------------------------------------------*/void	ZDigitalView::CreateViewResource( Handle resHandle ){	FailNILParam( resHandle );		if ( GetHandleSize( resHandle ) < sizeof( DigitalViewTemplate ))		FailOSErr( kViewTemplateHandleSizeTooSmallErr );			DigitalViewTemplateHdl		dvH = (DigitalViewTemplateHdl) resHandle;		(*dvH)->numDigits = fDigits;		(*dvH)->zeroBlanking 	= (fOpFlags & kDVLeadingZeroBlanking )?		TRUE : FALSE;	(*dvH)->blankOnZero 	= (fOpFlags & kDVUnblankOnExactZero )?		TRUE : FALSE;	(*dvH)->overrangeBlink 	= (fOpFlags & kDVOverrangeBlinkEnable )?	TRUE : FALSE;	(*dvH)->useAltCharset 	= (fOpFlags & kDVUseHexadecimalCharset )?	TRUE : FALSE;	(*dvH)->centreDigits 	= (fOpFlags & kDVCentreDigitsInBounds )?	TRUE : FALSE;		ZItemView::CreateViewResource( resHandle );}/*-----------------------------------***  DoTimer  ***----------------------------------*//*access:			publicoverrides:		description: 	timer callback - if display blinking, perform the blinkins: 			<id> timer IDouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalView::DoTimer( long id ){	if ( fBlink )	{		fBlinkPhase = !fBlinkPhase;		Focus();		PrepareForDrawing();		FocusForContent();		DrawContent();	}}/*---------------------------------***  ReportFields  ***-------------------------------*//*access:			publicoverrides:		description: 	report member states to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZDigitalView::ReportFields(){	ZItemView::ReportFields();		XSHOWFIELD( fBCDBuffer, ft_address );	XSHOWFIELD( fValue, ft_signedlong );	XSHOWFIELD( fOpFlags, ft_binary8 );	XSHOWFIELD( fDigits, ft_unsignedchar );	XSHOWFIELD( fDecimalPos, ft_unsignedchar );	XSHOWFIELD( fColonExtra, ft_unsignedchar );	XSHOWFIELD( fIsNegative, ft_boolean );	XSHOWFIELD( fOutOfRange, ft_boolean );	XSHOWFIELD( fBlink, ft_boolean );}/*----------------------------------***  LongToBCD  ***---------------------------------*//*access:			protectedoverrides:		description: 	convert a standard value to BCD notation for displayins: 			<aValue> the value to convertouts: 			the BCD representation of the value, up to 8 digits widenotes:			----------------------------------------------------------------------------------------*/BCD_32	ZDigitalView::LongToBCD( const long aValue ){	BCD_32	bcd = 0;	long	aLong, mask, x;		mask = 1L;	aLong = aValue;		while( aLong > 0 )	{		x = aLong % 10;		aLong /= 10;				bcd += ( x * mask );		mask <<= 4;	}	return bcd;}/*---------------------------------***  CalcLZBMask  ***--------------------------------*//*access:			protectedoverrides:		description: 	calculate a mask for blanking leading zeroesins: 			noneouts: 			a mask with 1's where the digit should be drawn, 0's elsewherenotes:			----------------------------------------------------------------------------------------*/BCD_32	ZDigitalView::CalcLZBMask(){	BCD_32		m, mask = 0;	Boolean		seenNonZero = FALSE;		// cast below necessary to force 68K compiler to generate correct code :-(		m = (unsigned long) 0x0000000F << (( fDigits - 1 ) << 2 );		if ( fOpFlags & kDVLeadingZeroBlanking )	{		while( m )		{			if (( fBCDBuffer & m ) || seenNonZero )			{				mask |= m;				seenNonZero = TRUE;			}								m = m >> 4;		}						if ( mask == 0 )		{			if ( fOpFlags & kDVUnblankOnExactZero )				mask = 0xFFFFFFFF;			else				mask = 0x0000000F;		}	}	else		mask = 0xFFFFFFFF;				return mask;}/*--------------------------------***  CalcMaxAndMin  ***-------------------------------*//*access:			protectedoverrides:		description: 	calculate range limits for dsiplay based on number of digitsins: 			noneouts: 			nonenotes:			sets fMax and fMin----------------------------------------------------------------------------------------*/void	ZDigitalView::CalcMaxAndMin(){	long 	m = fDigits;		fMax = 10;		while( --m )		fMax *= 10;		fMax--;	fMin = -fMax;}#pragma mark -/*----------------------------***  CreateNewDigitalView  ***----------------------------*//*access:			globaloverrides:		description: 	create digital view objectins: 			<aParent> view's parent view				<aFrame> view's frame				<param> lower byte - number of digits; upper byte - flagsouts: 			created viewnotes:			can be registered as dialog item constructor function----------------------------------------------------------------------------------------*/ZView*		CreateNewDigitalView( ZView* aParent, Rect* aFrame, short param ){	ZDigitalView*	dv;		FailNIL( dv = new ZDigitalView( aParent, aFrame, param & 0xFF, ( param & 0xFF00 ) >> 8 ));	return dv;}