/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			ZMouseTracker.cpp			-- handles mouse tracking in a window******			© 1998, Graham Cox*****************************************************************************************************/#include	"ZMouseTracker.h"#include	"MacZoop.h"#include	"ZScrollView.h"#include	"ZScrollAwareView.h"/*------------------------------***  CONSTRUCTOR  ***-----------------------------------*/ZMouseTracker::ZMouseTracker( ZView* anOwner, Rect* pin, Boolean willScroll )	: ZComrade(){	FailNILParam( anOwner );	FailNIL( selection = NewRgn());		wOwner = anOwner;	autoScroll = willScroll;		if ( pin == NULL )		wOwner->GetBounds( &constraint );	else		constraint = *pin;		// work around PinRect bug:			constraint.right++;	constraint.bottom++;		// check if owned by a scroller		inScrollView = ( dynamic_cast<ZScrollView*>( anOwner ) != NULL ) ||					( dynamic_cast<ZScrollAwareView*>( anOwner ) != NULL );		start.h = start.v = 0;	current = start;		fWidth = kDefaultTrackPenWidth;	gridH = gridV = 0;		GetIndPattern( &trackPat, sysPatListID, kDefaultTrackPenPat );	//SetTrackPattern( 128 );		// our owner receives messages from this as we track		wOwner->ListenTo( this );}/*-------------------------------***  DESTRUCTOR  ***-----------------------------------*/ZMouseTracker::~ZMouseTracker(){	if ( selection )		DisposeRgn( selection );}/*---------------------------------***  TRACK  ***--------------------------------------*//*	handle mouse drag in the owning view----------------------------------------------------------------------------------------*/void	ZMouseTracker::Track( const Point startPt ){	Point		lastPt;	PenState	ps;	long		cpt;	RgnHandle	bRgn, temp;		start = current = lastPt = startPt;		FailNIL( bRgn = NewRgn());	FailNIL( temp = NewRgn());		StartAction( start );	SendMessage( msgMouseTrackStarting, &start );		GetPenState( &ps );	PenMode( patXor );	PenPat( &trackPat );	GetPenState( &nps );		while ( WaitMouseUp())	{		GetMouse( &current );				// move the point to the nearest grid position, if enabled				if ( gridH > 1 &&			 gridV > 1 )		{			short	jH, jV;						jH = current.h % gridH;			jV = current.v % gridV;						if ( jH < ( gridH >> 1 ))				current.h -= jH;			else				current.h += gridH - jH;						if ( jV < ( gridV >> 1 ))					current.v -= jV;			else				current.v += gridV - jV;		}				// pin it within the constraint rectangle				cpt = PinRect( &constraint, current );				current = *(Point*) &cpt;				// has it moved since last time?				if ( DeltaPoint( current, lastPt ))		{			if ( inScrollView && autoScroll )			{				if ((( ZScrollView*) wOwner )->AutoScroll( current ))				{					// after a scroll, <gUtilRgn> contains the last update rgn. This					// is the area that was updated, so we remove it from <bRgn>										DiffRgn( bRgn, gUtilRgn, bRgn );					SendMessage( msgMouseTrackScrolledView, &current );				}			}						MakeDragRegion( selection );						XorRgn( selection, bRgn, temp );			CopyRgn( selection, bRgn );						DrawDragRegion( temp );			TrackAction( current );			SendMessage( msgMouseTrackNewPosition, &current );						lastPt = current;		}	}		DrawDragRegion( selection );	CompletionAction( current );	SendMessage( msgMouseTrackComplete, &current );	SetPenState( &ps );	DisposeRgn( bRgn );	DisposeRgn( temp );}/*-----------------------------***  DRAWDRAGREGION  ***---------------------------------*//*	draws the region passed in in the chosen pattern----------------------------------------------------------------------------------------*/void	ZMouseTracker::DrawDragRegion( RgnHandle aRgn ){	SetPenState( &nps );	PaintRgn( aRgn );}/*---------------------------***  GETSELECTIONBOUNDS  ***-------------------------------*//*	returns the bounding rect of the dragged area----------------------------------------------------------------------------------------*/void	ZMouseTracker::GetSelectionBounds( Rect* aRect ){	Pt2Rect( start, current, aRect );}/*----------------------------***  SETTRACKPATTERN  ***---------------------------------*//*	set the pattern for the drag outline (default is 50% gray)----------------------------------------------------------------------------------------*/void	ZMouseTracker::SetTrackPattern( Pattern aPat ){	trackPat = aPat;}/*----------------------------***  SETTRACKPATTERN  ***---------------------------------*//*	set the pattern for the drag outline (default is 50% gray)----------------------------------------------------------------------------------------*/void	ZMouseTracker::SetTrackPattern( const short patID ){	PatHandle	pH;		FailNILRes( pH = GetPattern( patID ));		trackPat = **pH;		ReleaseResource((Handle) pH );}/*-----------------------------***  MAKEDRAGREGION  ***---------------------------------*//*	build the region for dragging, based on current bounds. Note, the entire region mustrepresent the painted outline, so if you override this, make sure you knock out thecentre of the shape!----------------------------------------------------------------------------------------*/void	ZMouseTracker::MakeDragRegion( RgnHandle aRgn ){	Rect	r;		GetSelectionBounds( &r );		RectRgn( aRgn, &r );	InsetRect( &r, fWidth, fWidth );	RectRgn( gUtilRgn, &r );		DiffRgn( aRgn, gUtilRgn, aRgn );}/*----------------------------***  UPDATEDRAGREGION  ***--------------------------------*//*	redraw the selection when <affectedRgn> has been redrawn or erased during tracking, toensure that the selection marquee is correctly updated. n.b. <affectedRgn> is changedby this method.----------------------------------------------------------------------------------------*/void	ZMouseTracker::UpdateDragRegion( RgnHandle affectedRgn ){	RgnHandle	saveClip;		FailNILParam( affectedRgn );	FailNIL( saveClip = NewRgn ());		GetClip( saveClip );	SectRgn( affectedRgn, saveClip, affectedRgn );	SetClip( affectedRgn );		DrawDragRegion( selection );		SetClip( saveClip );	DisposeRgn( saveClip );	SetEmptyRgn( affectedRgn );}/*-----------------------------***  UPDATEDRAGRECT  ***---------------------------------*//*	redraw the selection when <affectedRect> has been redrawn or erased during tracking, toensure that the selection marquee is correctly updated.----------------------------------------------------------------------------------------*/void	ZMouseTracker::UpdateDragRect( Rect* affectedRect ){	RgnHandle	temp;		FailNIL( temp = NewRgn());		RectRgn( temp, affectedRect );		UpdateDragRegion( temp );	DisposeRgn( temp );}	