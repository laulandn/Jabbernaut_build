/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZTabSelectorView.cpp		-- general purpose view for handling tabbed panes******			©2000, Graham Cox*****************************************************************************************************/#include	"ZTabSelectorView.h"#include	"MacZoop.h"#include	"ZPStrArray.h"#include	"ZGWorld.h"#include	"ZViewDialog.h"#include	"ZEditFieldView.h"#include	<Palettes.h>#if APPEARANCE_MGR_AWAREThemeTabTitleDrawUPP	ZTabSelectorView::sTabUPP = NewThemeTabTitleDrawUPP( ThemeTabCallback );#endifextern ZCommander* gCurHandler;/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZTabSelectorView::ZTabSelectorView( ZView* aParent, Rect* aFrame, const short numTabs, const short tabTitleResID, const Boolean drawTabs )	: ZView( aParent, aFrame ){	classID = CLASS_ZTabSelectorView;		fTabsDrawn = drawTabs;	fNumTabs = MAX( numTabs, 1 );	fCurrentTab = 1;	FailNIL( fTabRects = new ZArray( sizeof( TabInfo )));	FailNIL( fTitles = new ZPStrArray());	InitTabView( tabTitleResID );}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZTabSelectorView::ZTabSelectorView( ZView* aParent, const short viewResourceID )	: ZView( aParent ){	classID = CLASS_ZTabSelectorView;		FailNIL( fTabRects = new ZArray( sizeof( TabInfo )));	FailNIL( fTitles = new ZPStrArray());	ViewResInit( viewResourceID );}/*---------------------------------***  DESTRUCTOR  ***----------------------------------*/ZTabSelectorView::~ZTabSelectorView(){	SendMessage( kMsgTabSelectorViewGoodbye, NULL );		if ( fTabRects )		FORGETOBJECT( fTabRects );		if ( fTitles )		FORGETOBJECT( fTitles );}/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	update this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::DrawContent(){	// draw the interior border		Rect	r, ir;		GetTabRect( fCurrentTab, &r );	GetBounds( &ir );		if ( fTabsDrawn )		ir.top = r.bottom - 3;	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )		DrawThemeTabPane( &ir, ( IsActive() && IsEnabled())? kThemeStateActive : kThemeStateInactive );	else#endif	FrameRect( &ir );	DrawTabsHeader();		// draw views enclosed in this one:		ZView::DrawContent();}/*--------------------------------***  ClickContent  ***--------------------------------*//*access:			publicoverrides:		description: 	handle mouse click in this viewins: 			<mouse> the mouse position local to the view bounds				<modifiers> the modifier keysouts: 			nonenotes:			switches views as needed when tab hit----------------------------------------------------------------------------------------*/void	ZTabSelectorView::ClickContent( const Point mouse, const short modifiers ){	short	ti = FindTab( mouse );		if ( ti > 0  && ti != fCurrentTab )	{		// a unselected tab hit - track it & select it				if ( TrackTab( mouse, ti ))			SelectTab( ti );	}}/*------------------------------***  EraseBackground  ***-------------------------------*//*access:			publicoverrides:		description: 	handle mouse click in this viewins: 			<mouse> the mouse position local to the view bounds				<modifiers> the modifier keysouts: 			nonenotes:			switches views as needed when tab hit----------------------------------------------------------------------------------------*/void	ZTabSelectorView::EraseBackground(){	Rect	br, tr;		GetBounds( &br );	GetTabRect( fCurrentTab, &tr );	br.top = tr.bottom - 3;	EraseRect( &br );}/*------------------------------***  ReceiveMessage  ***--------------------------------*//*access:			publicoverrides:		description: 	receive messages from any sender objects linked to this oneins: 			<aSender> object sending the message				<msg> the message identifier				<msgData> data sent along with the message, if anyouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	if ( msg == kMsgRequireSelectionForValidation ||		 msg == kMsgTabAutoSelectView )	{		// an edit field or other view has failed validation (or whatever), and needs selecting.		// If it's under a tab that isn't selected, switch to the right tab.			short efTab = GetTabContaining((ZView*) aSender );				if ( efTab && efTab != fCurrentTab )		{			SelectTab( efTab );						// update immediately since caller may put up an alert straight away.						GetRootWindow()->PerformUpdate();			}	}	ZView::ReceiveMessage( aSender, msg, msgData );}/*--------------------------------***  SetTabTitle  ***---------------------------------*//*access:			publicoverrides:		description: 	set title of tabins: 			<whichTab> the tab which title to set				<aTitle> title to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::SetTabTitle( const short whichTab, Str255 aTitle ){	fTitles->SetArrayItem( aTitle, whichTab );	CalcTabRects();	PostRefresh();}/*--------------------------------***  GetTabTitle  ***---------------------------------*//*access:			publicoverrides:		description: 	get title of tabins: 			<whichTab> the tab which title to get				<aTitle> receives titleouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::GetTabTitle( const short whichTab, Str255 aTitle ){	fTitles->GetArrayItem( aTitle, whichTab );}/*---------------------------------***  SelectTab  ***----------------------------------*//*access:			publicoverrides:		description: 	switch views and tab to that passedins: 			<whichTab> the tab to selectouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::SelectTab( const short whichTab ){	if (( whichTab != fCurrentTab ) &&		( whichTab > 0 ) &&		( whichTab <= fNumTabs ) &&		IsTabEnabled( whichTab ))	{		Rect		r;		ZView* 		parView;		Boolean		refocusKeyboard = FALSE;				Focus();		PrepareForDrawing();				GetTabRect( fCurrentTab, &r );		PostRefresh( &r );		SendMessage( kMsgTabSelectorViewSwitchingOut, &fCurrentTab );				parView = GetParentViewForTab( fCurrentTab );				if ( parView )			parView->Hide();		// check if current focus was among the items switched out. If so,		// perform a refocus at the end of this method				if ( ! ((ZView*) GetRootWindow()->GetHandler())->IsVisible())			refocusKeyboard = TRUE;				fCurrentTab = whichTab;			SendMessage( kMsgTabSelectorViewSwitchingIn, &fCurrentTab );		parView = GetParentViewForTab( fCurrentTab );				Focus();		PrepareForDrawing();				if ( parView )			parView->Show();				GetTabRect( fCurrentTab, &r );		Focus();		PostRefresh( &r );		if ( refocusKeyboard )			gCurHandler->Type( TAB_KEY, 0 );	}}/*---------------------------***  GetParentViewForTab  ***------------------------------*//*access:			publicoverrides:		description: 	returns the view that the tab pane switchesins: 			<whichTab> the tab whose tab view we want to obtainouts: 			the view for the tabnotes:			the returned view should be specified as the parent for all items				shown by the tab----------------------------------------------------------------------------------------*/ZView*	ZTabSelectorView::GetParentViewForTab( const short whichTab ){	return FindChildViewByUserID( kTabSelectorBaseTabID + whichTab );}/*-------------------------------***  SetFontInfo  ***----------------------------------*//*access:			publicoverrides:		description: 	set font for the tab viewins: 			<fontID> the font				<size> the size				<style> the styleouts: 			nonenotes:			affects metrics of tabs----------------------------------------------------------------------------------------*/void	ZTabSelectorView::SetFontInfo( const short fontID, const short size, const Style style ){	ZView::SetFontInfo( fontID, size, style );	CalcTabRects();	PostRefresh();}/*---------------------------------***  EnableTab  ***----------------------------------*//*access:			publicoverrides:		description: 	enable the tab with the given IDins: 			<whichTab> the tab to enableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::EnableTab( const short whichTab ){	if ( ! IsTabEnabled( whichTab ))	{		TabInfo		ti;				fTabRects->GetArrayItem( &ti, whichTab );		ti.tabEnabled = TRUE;		fTabRects->SetArrayItem( &ti, whichTab );				Focus();		PostRefresh( &ti.tabRect );	}}/*---------------------------------***  DisableTab  ***---------------------------------*//*access:			publicoverrides:		description: 	query whether given tab is enabledins: 			<whichTab> the tab to queryouts: 			nonenotes:			disabled tabs are drawn grey and can't be selected----------------------------------------------------------------------------------------*/void	ZTabSelectorView::DisableTab( const short whichTab ){	if ( IsTabEnabled( whichTab ))	{		TabInfo		ti;				fTabRects->GetArrayItem( &ti, whichTab );		ti.tabEnabled = FALSE;		fTabRects->SetArrayItem( &ti, whichTab );				Focus();		PostRefresh( &ti.tabRect );	}}/*--------------------------------***  IsTabEnabled  ***--------------------------------*//*access:			publicoverrides:		description: 	disable the tab with the given IDins: 			<whichTab> the tab to disableouts: 			TRUE if tab enabled, else FALSEnotes:			----------------------------------------------------------------------------------------*/Boolean	ZTabSelectorView::IsTabEnabled( const short whichTab ){	TabInfo		ti;		fTabRects->GetArrayItem( &ti, whichTab );	return ti.tabEnabled;}/*---------------------------------***  GetTabRect  ***---------------------------------*//*access:			publicoverrides:		description: 	return rect occupied by the tab (local to frame)ins: 			<whichTab> the tab to obtain				<aRect> receives tab's rectangleouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::GetTabRect( const short whichTab, Rect* aRect ){	TabInfo		ti;		fTabRects->GetArrayItem( &ti, whichTab );	*aRect = ti.tabRect;}/*-------------------------------***  GetTabContaining  ***----------------------------*//*access:			publicoverrides:		description: 	find out which tab contains the given viewins: 			<aView> a view that is in here somewhereouts: 			the ID of the tab that contains the view, or 0 if view not found herenotes:			view must be immediate child of the substrate view----------------------------------------------------------------------------------------*/short	ZTabSelectorView::GetTabContaining( ZView* aView ){	long id = 0;		FailNILParam( aView );		ZView*	parView = aView->GetParent();		if ( parView )		id = parView->GetUserID() - kTabSelectorBaseTabID;		if (( id < 1 ) || ( id > fNumTabs ))		return 0;	else		return id;}/*------------------------------***  InitViewFromResource  ***--------------------------*//*access:			publicoverrides:		description: 	initialise the view from data in a 'View' resource handleins: 			<theRes> handle to 'View' resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::InitViewFromResource( Handle theRes ){	FailNILParam( theRes );		ZView::InitViewFromResource( theRes );		TabSelectorViewTemplateHdl		tsH = (TabSelectorViewTemplateHdl) theRes;		fTabsDrawn = (*tsH)->tabsDrawn;	fNumTabs = MAX( 1, (*tsH)->numTabs );	fCurrentTab = (*tsH)->initialTab;	InitTabView((*tsH)->titleResID );}/*-------------------------------***  CreateViewResource  ***---------------------------*//*access:			publicoverrides:		description: 	Fills in the resource handle according to its templated structureins: 			<resHandle> valid handle of adequate sizeouts: 			nonenotes:			This method should only be used by the RAD tool to create View resources				(not for application use)----------------------------------------------------------------------------------------*/void	ZTabSelectorView::CreateViewResource( Handle theRes ){	FailNILParam( theRes );	if ( GetHandleSize( theRes ) < sizeof( TabSelectorViewTemplate ))		FailOSErr( kViewTemplateHandleSizeTooSmallErr );			TabSelectorViewTemplateHdl		tsH = (TabSelectorViewTemplateHdl) theRes;		(*tsH)->numTabs = fNumTabs;	(*tsH)->initialTab = fCurrentTab;	(*tsH)->titleResID = 0;		ZView::CreateViewResource( theRes );}/*---------------------------------***  ReportFields  ***-------------------------------*//*access:			publicoverrides:		description: 	report member states to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::ReportFields(){	ZView::ReportFields();		XSHOWFIELD( fNumTabs, ft_signedshort );	XSHOWFIELD( fCurrentTab, ft_signedshort );	XSHOWFIELD( fTabRects, ft_objectref );	XSHOWFIELD( fTitles, ft_objectref );}/*-------------------------------***  DrawTabsHeader  ***------------------------------*//*access:			publicoverrides:		description: 	draw the tabs that head this viewins: 			noneouts: 			nonenotes:			tab metrics are all precalculated by CalcTabRects----------------------------------------------------------------------------------------*/void	ZTabSelectorView::DrawTabsHeader(){	Rect	tr;	short	tab;		if ( fTabsDrawn )	{		for( tab = 1; tab <= fNumTabs; tab++ )		{			GetTabRect( tab, &tr );			DrawOneTab( &tr, tab, tab == fCurrentTab, FALSE );		}	}}/*---------------------------------***  DrawOneTab  ***---------------------------------*//*access:			publicoverrides:		description: 	draw a single tabins: 			<tabBounds> the tab bounding reactangle				<tabID> the tab being drawn				<isSelected> is this tab the one currently selected?				<pressed> is the mouse down in this tab?outs: 			nonenotes:			uses appearance if available, else emulates it----------------------------------------------------------------------------------------*/void	ZTabSelectorView::DrawOneTab( Rect* tabBounds, const short tabID, const Boolean isSelected, const Boolean pressed ){	Str255		title;		GetTabTitle( tabID, title );#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ThemeTabStyle		tabStyle;		ThemeTabDirection	tabDir;		if ( IsActive() && IsEnabled() && IsTabEnabled( tabID ))			tabStyle = isSelected? kThemeTabFront : pressed? kThemeTabNonFrontPressed : kThemeTabNonFront;		else			tabStyle = isSelected? kThemeTabFrontInactive : kThemeTabNonFrontInactive;		tabDir = kThemeTabNorth;		TextMode( srcOr );		DrawThemeTab( tabBounds, tabStyle, tabDir, sTabUPP, (UInt32) title );	}	else	{#endif				// draw our own tabs. These are less sophisticated than the appearance ones, but do		// the job.				RgnHandle	tabRgn = NewRgn();		RgnHandle	clip;		RGBColor	hilite;				PrepareForDrawing();		MakeTabRegion( tabBounds, tabRgn );				if ( pressed )			hilite = gMidGray;		else		{			if ( ! isSelected )				hilite = gMediumGray;			else				hilite = gVeryLightGray;			}				RGBBackColor( &hilite );				if ( isSelected )			EraseRgn( tabRgn );		// manipulate clip region so that tabs abut content area correctly				GetClip( clip = NewRgn());		Rect	cr = *tabBounds;		cr.bottom -= 3;		RectRgn( gUtilRgn, &cr );		SectRgn( clip, gUtilRgn, gUtilRgn );		SetClip( gUtilRgn );				if ( !isSelected )			EraseRgn( tabRgn );				FrameRgn( tabRgn );				if ( IsActive() && IsEnabled())		{			cr.right -= kFontExtraTabWidthAllowance / 2;			RectRgn( gUtilRgn, &cr );			SectRgn( clip, gUtilRgn, gUtilRgn );			SetClip( gUtilRgn );						if ( pressed )			{				hilite = gDarkGray;				InsetRgn( tabRgn, 1, 1 );			}			else			{				InsetRgn( tabRgn, 2, 2 );				GetGray( GetMainDevice(), &gWhite, &hilite );			}			RGBForeColor( &hilite );			FrameRgn( tabRgn );		}				SetClip( clip );		FontInfo	fi;			GetFontInfo( &fi );				if ( IsActive() && IsEnabled() && IsTabEnabled( tabID ))			TextMode( srcOr );		else			TextMode( grayishTextOr );					MoveTo(( tabBounds->left + tabBounds->right ) / 2 - StringWidth( title ) / 2, tabBounds->top + fi.ascent + kFontExtraTabHeightAllowance );				if ( pressed )			RGBForeColor( &gWhite );		else			PrepareForDrawing();					DrawString( title );			DisposeRgn( tabRgn );		DisposeRgn( clip );#if APPEARANCE_MGR_AWARE	}#endif}/*--------------------------------***  InitTabView  ***---------------------------------*//*access:			publicoverrides:		description: 	initialise the viewins: 			<strListID> resource ID of STR# resource to get titles fromouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::InitTabView( const short strListID ){	short		i;	Str255		s;		// set the tab titles from STR# resource		for( i = 1; i <= fNumTabs; i++ )	{		GetIndString( s, strListID, i );		fTitles->AppendItem( s );	}	SetForeColour( &gBlack );	SetBackColour( &gVeryLightGray );		// default font is system font - metrics based on font size	// override to SetFontInfo calls CalcTabRects		SetFontInfo( 0, 0, 0 );		// set the environment up so that the correct themed background is used	// within the tab view#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )	{		ZViewEnvironment* env = GetEnvironment();			env->SetThemedBackKind( kThemeBackgroundTabPane );	}#endif		// create the views that we show and hide to do the useful work. These	// are just there to provide a substrate for the actual views that the	// tab panes switch. They do not draw anything of their own and indeed	// are set to not even erase		Rect	tr, vr;	ZView*	tabView;		GetTabRect( fCurrentTab, &tr );		// the substrate view bounds are inset from the tab view bounds to allow	// for the border and tabs		GetBounds( &vr );	vr.top = tr.bottom - 3;	InsetRect( &vr, kTabContentAreaMarginWidth, kTabContentAreaMarginWidth );		for( i = 1; i <= fNumTabs; i++ )	{		FailNIL( tabView = new ZView( this, &vr ));				// all tab views initially hidden				if ( i > 1 )			tabView->Hide();		tabView->SetUserID( kTabSelectorBaseTabID + i );		tabView->SetNoBackgroundErase( TRUE );				// substrate views will follow any change of size of the tab view:				tabView->SetAutoSizing( AUTOSIZE( NONE, NONE, FIXEDBOTTOM, FIXEDRIGHT ));				// set ourselves as a proxy listener of the substrate views - that way we can		// eavesdrop on messages sent by embedded items, and take action if needed. This		// is actually done to facilitate autoselection of the right tab when a field		// is validated. Without proxies, we'd have to have a special view class for		// the substrate, which is otherwise unnecessary.				tabView->AddProxyListener( this );	}		// don't bother doing erase if we have appearance - it takes care of all that		if ( gMacInfo.hasAppearanceMgr )		SetNoBackgroundErase( TRUE );		SendMessage( kMsgTabSelectorInitialised, NULL );		}/*---------------------------------***  FindTab  ***------------------------------------*//*access:			publicoverrides:		description: 	determine which tab is under the mouseins: 			<mouse> mouse point local to viewouts: 			index of tab hit, or 0 if nonenotes:			----------------------------------------------------------------------------------------*/short	ZTabSelectorView::FindTab( const Point mouse ){	Rect	r;		for( short i = 1; i <= fNumTabs; i++ )	{		GetTabRect( i, &r );				if ( PtInRect( mouse, &r ) && IsTabEnabled( i ))			return i;	}		return 0;}/*-------------------------------***  CalcTabRects  ***---------------------------------*//*access:			protectedoverrides:		description: 	calculate the bounding rectangle for each tabins: 			noneouts: 			nonenotes:			rects based on title strings and font metrics----------------------------------------------------------------------------------------*/void	ZTabSelectorView::CalcTabRects(){	TabInfo		ti;	Rect		br, r;	short		i, fontHeight, strWidth;	FontInfo	fi;	Str255		title;		Focus();	PrepareForDrawing();	GetFontInfo( &fi );	GetBounds( &br );	fTabRects->DeleteAll();		fontHeight = fi.ascent + fi.descent + fi.leading + kFontExtraTabHeightAllowance;	r.top = br.top;	r.left = br.left + kFirstTabHorizontalInset;#if APPEARANCE_MGR_AWARE		if ( fontHeight > kThemeSmallTabHeight )		r.bottom = br.top + kThemeLargeTabHeightMax;	else		r.bottom = br.top + kThemeSmallTabHeightMax;#else	if ( fontHeight > 16 )		r.bottom = br.top + 24;	else		r.bottom = br.top + 19;#endif		if ( ! fTabsDrawn )		r.bottom = r.top;		for( i = 1; i <= fNumTabs; i++ )	{		fTitles->GetArrayItem( title, i );			strWidth = StringWidth( title );			r.right = MIN( br.right, r.left + strWidth + kFontExtraTabWidthAllowance );				ti.tabRect = r;		ti.tabEnabled = TRUE;		fTabRects->AppendItem( &ti );		r.left = r.right + kTabIntertabGap;	}}/*---------------------------------***  TrackTab  ***-----------------------------------*//*access:			protectedoverrides:		description: 	track mouse in tabins: 			<mouse> starting point				<tabID> index of tab to trackouts: 			TRUE if mouse released in tab, else FALSEnotes:			----------------------------------------------------------------------------------------*/Boolean	ZTabSelectorView::TrackTab( Point mouse, const short tabID ){	Rect		tr;	Boolean		isIn, wasIn;		GetTabRect( tabID, &tr );	isIn = TRUE;	wasIn = FALSE;		do	{		if ( isIn != wasIn )		{			DrawOneTab( &tr, tabID, FALSE, isIn );			wasIn = isIn;		}				GetMouse( &mouse );		isIn = PtInRect( mouse, &tr );	}	while( WaitMouseUp());		if ( wasIn )		DrawOneTab( &tr, tabID, FALSE, FALSE );			return wasIn;}/*-------------------------------***  MakeTabRegion  ***--------------------------------*//*access:			protectedoverrides:		description: 	when emulating tabs, builds a region for the tabins: 			<tabRect> bounding rect of tab				<aRgn> a valid region, receives tab regionouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTabSelectorView::MakeTabRegion( Rect* tabRect, RgnHandle aRgn ){	ZGWorld		temp( *tabRect, 1 );		CGrafPtr	sp;	GDHandle	sd;		Rect	r = *tabRect;		r.left += 6;	r.right -= 6;	r.bottom = r.top + 16;		temp.SetPortToGW( &sp, &sd );	temp.Lock();		PaintRoundRect( &r, 16, 16 );		r.top += 7;	r.bottom = tabRect->bottom;		PolyHandle	p = OpenPoly();	MoveTo( tabRect->left, tabRect->bottom );	LineTo( r.left, r.top );	LineTo( r.right, r.top );	LineTo( tabRect->right, r.bottom );	LineTo( tabRect->left, r.bottom );	ClosePoly();		PaintPoly( p );	KillPoly( p );		BitMapToRegion( aRgn, (BitMap*) *temp.GetPixMap());		SetGWorld( sp, sd );	temp.Unlock();}#if APPEARANCE_MGR_AWARE#pragma mark -/*-----------------------------***  ThemeTabCallback  ***-------------------------------*//*access:			staticoverrides:		description: 	appearance calls this to draw the tab's titleins: 			see <appearance.h>outs: 			nonenotes:			----------------------------------------------------------------------------------------*/pascal void	ZTabSelectorView::ThemeTabCallback( const Rect *bounds, ThemeTabStyle style, ThemeTabDirection direction, SInt16 depth, Boolean isColorDev, UInt32 userData ){	StringPtr	s = (StringPtr) userData;	FontInfo	fi;		GetFontInfo( &fi );	MoveTo(( bounds->left + bounds->right ) / 2 - StringWidth( s ) / 2, bounds->top + fi.ascent );		if (( bounds->bottom - bounds->top ) > kThemeSmallTabHeight )		Move( 0, fi.descent - 1 );		DrawString( s );	}#endif#pragma mark -/*-------------------------***  CreateNewTabSelectorView  ***---------------------------*//*access:			globaloverrides:		description: 	convenience function can be registered as dialog item constructorins: 			<aParent> view's parent				<aFrame> view's frame				<pCount> parameter count				<params> the parametersouts: 			nonenotes:			params[0] is number of tabs to create				params[1] is the ID of the STR# resource for the titles				params[2..] are the IDs of DITL resources to append when used in dialogs----------------------------------------------------------------------------------------*/ZView*	CreateNewTabSelectorView( ZView* aParent, Rect* aFrame, const short pCount, long params[] ){	ZTabSelectorView*	tv = new ZTabSelectorView( aParent, aFrame, params[0], params[1] );		FailNIL( tv );		if ( pCount > 1 )	{		for( short i = 1; i <= params[0]; i++ )			LoadTabSelectorSubviewFromDITL((ZViewDialog*) aParent, tv, i, params[i + 1] );	}		return tv;}/*----------------------***  LoadTabSelectorSubviewFromDITL  ***------------------------*//*access:			globaloverrides:		description: 	load a tab view in a dialog using a DITL resourceins: 			<theDialog> the dialog that the tab view is part of				<tabSelector> the tab selector view				<tabViewIndex> the tab panel to add the items to				<ditlID> the DITL loaded up to this panelouts: 			nonenotes:			dialog items are numbered as tab index x 100 + original ID - use this				calculated ID to access the items so added. This will be called for				each tab that you want to add items to.----------------------------------------------------------------------------------------*/void	LoadTabSelectorSubviewFromDITL( ZViewDialog* theDialog, ZTabSelectorView* tabSelector, const short tabViewIndex, const short ditlID ){	FailNILParam( theDialog );	FailNILParam( tabSelector );		ZView*	parView;		FailNILParam( parView = tabSelector->GetParentViewForTab( tabViewIndex ));	// append the items, renumbering as we go:		theDialog->MakeDialogItems( parView, ditlID, tabViewIndex * 100 );}