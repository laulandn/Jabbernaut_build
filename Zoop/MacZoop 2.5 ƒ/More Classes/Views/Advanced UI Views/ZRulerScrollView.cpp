/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZRulerScrollView.cpp		-- scrollview with rulers******			©2000, Graham Cox*****************************************************************************************************/#include	"ZRulerScrollView.h"#include	"MacZoop.h"#include	"ZGrafState.h"/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZRulerScrollView::ZRulerScrollView( ZView* aParent, Rect* aFrame,				const Boolean makeHBar,				const Boolean makeVBar,				const Boolean hasSizeBox,				const short rulerSize )	: ZScrollView( aParent, aFrame, makeHBar, makeVBar, hasSizeBox ){	classID = CLASS_ZRulerScrollView;		fRulerHeight = rulerSize;	fRulersVisible = TRUE;	fGridVisible = TRUE;		MakeRulers();}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZRulerScrollView::ZRulerScrollView( ZView* aParent, const short viewResourceID )	: ZScrollView( aParent ){	classID = CLASS_ZRulerScrollView;	ViewResInit( viewResourceID );}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZRulerScrollView::~ZRulerScrollView(){	if ( fHRuler )		FORGETOBJECT( fHRuler );			if ( fVRuler )		FORGETOBJECT( fVRuler );}/*------------------------------------***  DrawAll  ***---------------------------------*//*access:			publicoverrides:		ZScrollViewdescription: 	draw view, including drag box if rulers visibleins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::DrawAll(){	DrawOriginDragBox( FALSE );	ZScrollView::DrawAll();}/*----------------------------------***  DrawContent  ***-------------------------------*//*access:			publicoverrides:		ZScrollViewdescription: 	draw content of view, including grid if visibleins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerScrollView::DrawContent(){	if ( fGridVisible )	{		DrawGrid( TRUE );		DrawGrid( FALSE );	}	ZScrollView::DrawContent();}/*-------------------------------------***  Click  ***----------------------------------*//*access:			publicoverrides:		ZScrollViewdescription: 	handle click in drag boxins: 			<mouse> mouse point local to frame				<modifiers> modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::Click( const Point mouse, const short modifiers ){	if ( fRulersVisible )	{		Focus();				if ( PtInRect( mouse, &fOrgDragHotspot ))		{			DrawOriginDragBox( TRUE );			DragOrigin( mouse, modifiers );			Focus();			DrawOriginDragBox( FALSE );			return;		}	}	ZScrollView::Click( mouse, modifiers );}/*--------------------------------***  GetContentRect  ***------------------------------*//*access:			publicoverrides:		ZScrollViewdescription: 	get interior rectangle (excluding ruler areas)ins: 			<aRect> receives content rectangle relative to frameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::GetContentRect( Rect* aRect ){	ZScrollView::GetContentRect( aRect );		if ( fRulersVisible )	{		aRect->left += fRulerHeight;		aRect->top += fRulerHeight;	}}/*---------------------------------***  AdjustCursor  ***-------------------------------*//*access:			publicoverrides:		ZViewdescription: 	update ruler markers as cursor movesins: 			<mouse> mouse point				<modifiers> modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::AdjustCursor( const Point mouse, const short modifiers ){	ZScrollView::AdjustCursor( mouse, modifiers );		if ( fRulersVisible )	{		Rect	br;		Point	cm;				GetContentRect( &br );				if ( PtInRect( mouse, &br ))		{			fHRuler->ShowMarker();			fVRuler->ShowMarker();						cm = mouse;			cm.h -= fRulerHeight;			cm.v -= fRulerHeight;						SetRulersMarker( cm );		}		else		{			fHRuler->HideMarker();			fVRuler->HideMarker();		}	}}/*----------------------------------***  UpdateMenus  ***-------------------------------*//*access:			publicoverrides:		ZCommanderdescription: 	enable and check show rulers commandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::UpdateMenus(){	gMenuBar->EnableCommand( kCmd_ShowHideRulers );	gMenuBar->CheckCommand( kCmd_ShowHideRulers, fRulersVisible );		gMenuBar->EnableCommand( kCmd_ShowHideGrid );	gMenuBar->CheckCommand( kCmd_ShowHideGrid, fGridVisible );		ZScrollView::UpdateMenus();}/*--------------------------------***  HandleCommand  ***-------------------------------*//*access:			publicoverrides:		ZCommanderdescription: 	handle show rulers commandins: 			<cmd> command to handle or pass onouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::HandleCommand( const ZoopCommand cmd ){	switch ( cmd )	{		case kCmd_ShowHideRulers:			ShowHideRulers( ! fRulersVisible );			break;					case kCmd_ShowHideGrid:			ShowHideGrid( ! fGridVisible );			break;					default:			ZScrollView::HandleCommand( cmd );			break;	}}/*----------------------------------***  AutoScroll  ***--------------------------------*//*access:			publicoverrides:		ZScrollViewdescription: 	scroll contents as needed when draggingins: 			<mousePt> mouse point local to boundsouts: 			TRUE if view scrollednotes:			updates ruler markers during drag----------------------------------------------------------------------------------------*/Boolean	ZRulerScrollView::AutoScroll( Point mousePt, const short inset ){	Boolean as;	short h, v;		as = ZScrollView::AutoScroll( mousePt, inset );		GetPosition( &h, &v );	mousePt.h -= h;	mousePt.v -= v;	SetRulersMarker( mousePt );		return as;}/*-----------------------------------***  PlaceAt  ***----------------------------------*//*access:			publicoverrides:		ZViewdescription: 	places rulers to align with viewins: 			<hPos, vPos> new frame position relative to parent boundsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::PlaceAt( const short hPos, const short vPos ){	ZScrollView::PlaceAt( hPos, vPos );		Rect	fr;		GetFrame( &fr );		fHRuler->PlaceAt( fr.left + fRulerHeight, fr.top );	fVRuler->PlaceAt( fr.left, fr.top + fRulerHeight );}/*-----------------------------------***  SetSize  ***----------------------------------*//*access:			publicoverrides:		ZViewdescription: 	sizes rulers to align with viewins: 			<width, height> new frame width and heightouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::SetSize( const short width, const short height ){	Rect	frameOld;		GetFrame( &frameOld );	ZScrollView::SetSize( width, height );		// resize rulers to fit. These needs to be done here because the rulers are really	// child views of this view's parent, not a child of this view itself.		fHRuler->ChangeSize( 0, 0, 0, width - ( frameOld.right - frameOld.left ));	fVRuler->ChangeSize( 0, 0, height - ( frameOld.bottom - frameOld.top ), 0 );}/*-------------------------------***  ShowHideRulers  ***-------------------------------*//*access:			publicoverrides:		description: 	shows or hides the rulersins: 			<showOrHide> TRUE to show, FALSE to hideouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::ShowHideRulers( const Boolean showOrHide ){	if ( showOrHide != fRulersVisible )	{		if ( fRulersVisible )		{			fHRuler->HideMarker();			fVRuler->HideMarker();			fHRuler->Hide();			fVRuler->Hide();		}		else		{			fHRuler->Show();			fVRuler->Show();		}				fRulersVisible = showOrHide;				MoveScrollbars();		CalcScrollParams();		ScrollHook( 0, 0 );				Rect	fr;				Focus();		GetFrame( &fr );		OffsetRect( &fr, -fr.left, -fr.top );		InsetRect( &fr, -1, -1 );		PostRefresh( &fr );	}}/*--------------------------------***  ShowHideGrid  ***--------------------------------*//*access:			publicoverrides:		description: 	shows or hides the gridins: 			<showOrHide> TRUE to show, FALSE to hideouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZRulerScrollView::ShowHideGrid( const Boolean showOrHide ){	if( showOrHide != fGridVisible )	{		fGridVisible = showOrHide;		PostRefresh();	}}/*------------------------------***  SetRulersMarker  ***-------------------------------*//*access:			publicoverrides:		description: 	sets ruler markers to frame point passedins: 			<localPt> mouse or other point local to frameouts: 			nonenotes:			also sends position message----------------------------------------------------------------------------------------*/void	ZRulerScrollView::SetRulersMarker( const Point localPt ){	if ( fRulersVisible )	{		if ( localPt.h != fLastMarker.h )			fHRuler->SetMarkerPosition( fHRuler->PixelToRuler( localPt.h ));				if ( localPt.v != fLastMarker.v )			fVRuler->SetMarkerPosition( fVRuler->PixelToRuler( localPt.v ));					fLastMarker = localPt;	}		FPPoint	fpp;		BoundsPointToRuler( localPt, &fpp );	SendMessage( kMsgReportRulerMouseLocation, &fpp );}/*-------------------------------***  SetRulersUnits  ***-------------------------------*//*access:			publicoverrides:		description: 	sets ruler units and divisions to values passedins: 			<numer> interval represent by each major mark				<denom> screen distance equalling 1 major division of the ruler				<divs> number of small divisions per najor divisionouts: 			nonenotes:			typical values: 1 inch ruler, span = 90.0, 1 cm ruler, span = 35.43----------------------------------------------------------------------------------------*/void	ZRulerScrollView::SetRulersUnits( const double_t numer, const double_t denom, const short divs ){	fHRuler->SetRulerCalibration( numer, denom );	fVRuler->SetRulerCalibration( numer, denom );	fHRuler->SetRulerDivisions( divs );	fVRuler->SetRulerDivisions( divs );}/*-----------------------------***  BoundsPointToRuler  ***-----------------------------*//*access:			publicoverrides:		description: 	convert point in bounds coordinates to ruler coordinateins: 			<bPt> point within the bounds				<rulerPos> ruler reading for this locationouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::BoundsPointToRuler( const Point bPt, FPPoint* rulerPos ){	rulerPos->h = fHRuler->PixelToRuler( bPt.h );	rulerPos->v = fVRuler->PixelToRuler( bPt.v );}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			publicoverrides:		ZScrollViewdescription: 	report data members to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::ReportFields(){	ZScrollView::ReportFields();		XSHOWFIELD( fHRuler, ft_objectref );	XSHOWFIELD( fVRuler, ft_objectref );	XSHOWFIELD( fRulerHeight, ft_signedshort );	XSHOWFIELD( fRulersVisible, ft_boolean );	XSHOWFIELD( fOrgDragHotspot, ft_Rect );	XSHOWFIELD( fLastMarker, ft_Point );}	/*---------------------------------***  DragOrigin  ***---------------------------------*//*access:			protectedoverrides:		description: 	reposition the ruler zero point interactivelyins: 			<startPt> starting point of drag				<modifiers> modifier keysouts: 			nonenotes:			option key supresses live drag of rulers----------------------------------------------------------------------------------------*/void	ZRulerScrollView::DragOrigin( const Point startPt, const short modifiers ){	SetCursorShape( crossCursor );		ZGrafState	gs;	Point		om, nm;	Rect		cr;	RgnHandle	clip;	short 		ph, pv;	PenState	ps;	Boolean		liveDrag = ( modifiers & optionKey ) == 0;		GetPosition( &ph, &pv );		if ( ! liveDrag )	{		fHRuler->ShowMarker();		fVRuler->ShowMarker();		Focus();	}		om = startPt;	PenPat( QDGRAYPATTERN );	PenMode( patXor );	PenSize( 1, 1 );	GetPenState( &ps );	GetContentRect( &cr );		GetClip( clip = NewRgn());	RectRgn( gUtilRgn, &cr );	SectRgn( gUtilRgn, clip, clip );	SetClip( clip );		do	{		GetMouse( &nm );				if ( nm.h != om.h )		{			MoveTo( om.h, cr.top );			LineTo( om.h, cr.bottom - 1 );			MoveTo( nm.h, cr.top );			LineTo( nm.h, cr.bottom - 1 );			if ( liveDrag )			{				fHRuler->SetRulerZeroPosition( nm.h + ph - fRulerHeight );				Focus();				SetPenState( &ps );				SetClip( clip );			}		}				if ( nm.v != om.v )		{			MoveTo( cr.left, om.v );			LineTo( cr.right - 1, om.v );			MoveTo( cr.left, nm.v );			LineTo( cr.right - 1, nm.v );			if ( liveDrag )			{				fVRuler->SetRulerZeroPosition( nm.v + pv - fRulerHeight );				Focus();				SetPenState( &ps );				SetClip( clip );			}		}		om = nm;				if ( ! liveDrag )		{			nm.h -= fRulerHeight;			nm.v -= fRulerHeight;						SetRulersMarker( nm );			Focus();			SetPenState( &ps );			SetClip( clip );		}	}	while( WaitMouseUp());		MoveTo( om.h, cr.top );	LineTo( om.h, cr.bottom - 1 );	MoveTo( cr.left, om.v );	LineTo( cr.right - 1, om.v );	DisposeRgn( clip );		// set ruler zero to this point, or if outside interior,	// reset to 0		if ( PtInRect( om, &fOrgDragHotspot ))	{		fHRuler->SetRulerZeroPosition( 0 );		fVRuler->SetRulerZeroPosition( 0 );	}	else if ( ! liveDrag )	{		fHRuler->SetRulerZeroPosition( om.h + ph - fRulerHeight );		fVRuler->SetRulerZeroPosition( om.v + pv - fRulerHeight );	}		if ( fGridVisible )		PostRefresh();}/*---------------------------------***  ScrollHook  ***---------------------------------*//*access:			protectedoverrides:		ZScrollViewdescription: 	hook into scroll operation to keep rulers aligned with boundsins: 			<dh, dv> scroll deltasouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::ScrollHook( const short dh, const short dv ){	short h, v;		if ( fRulersVisible )	{		GetPosition( &h, &v );			fHRuler->SetPixelOrigin( h );		fVRuler->SetPixelOrigin( v );	}	}/*---------------------------------***  MakeRulers  ***---------------------------------*//*access:			protectedoverrides:		description: 	create the ruler viewsins: 			noneouts: 			nonenotes:			the rulers are managed by this class, but are actually children of the				parent view of this class.----------------------------------------------------------------------------------------*/void	ZRulerScrollView::MakeRulers(){	Rect	rr;		GetFrame( &rr );		rr.left += fRulerHeight;	rr.bottom = rr.top + fRulerHeight;		FailNIL( fHRuler = new ZRulerView( GetParent(), &rr ));	fHRuler->HideMarker();		GetFrame( &rr );		rr.top += fRulerHeight;	rr.right = rr.left + fRulerHeight;		FailNIL( fVRuler = new ZRulerView( GetParent(), &rr ));	fVRuler->HideMarker();		GetFrame( &fOrgDragHotspot );	OffsetRect( &fOrgDragHotspot, -fOrgDragHotspot.left - 1, -fOrgDragHotspot.top - 1 );	fOrgDragHotspot.right = fRulerHeight;	fOrgDragHotspot.bottom = fRulerHeight;		fLastMarker.h = fLastMarker.v = -1;	MoveScrollbars();}/*-----------------------------***  DrawOriginDragBox  ***------------------------------*//*access:			protectedoverrides:		description: 	draw the drag origin boxins: 			<pressed> TRUE if drawn in pressed stateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZRulerScrollView::DrawOriginDragBox( Boolean pressed ){	if ( fRulersVisible )	{		Focus();				// draw origin hotspot and mini-icon			#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )			DrawThemePlacard( &fOrgDragHotspot,								(IsActive() && IsEnabled())? pressed? kThemeStatePressed : kThemeStateActive : kThemeStateInactive );		else		{	#endif			PenNormal();			RGBBackColor((IsActive() && IsEnabled())? pressed? &gDarkGray : &gLightGray: &gVeryLightGray );			EraseRect( &fOrgDragHotspot );			FrameRect( &fOrgDragHotspot );	#if APPEARANCE_MGR_AWARE		}	#endif			// plot icon:				Rect	sr, r;		BitMap	bm;		char	i[8] = { 0x10, 0x38, 0x54, 0xFE, 0x54, 0x38, 0x10, 0x00 };				SetRect( &bm.bounds, 0, 0, 8, 7 );		bm.rowBytes = 1;		bm.baseAddr = (Ptr) &i;				SetRect( &r, 0, 0, 8, 7 );				sr = r;		CentreRects( &fOrgDragHotspot, &r );		CopyBits( &bm, CURRENTPORTPIXMAP, &sr, &r, srcOr, NULL ); 	}}/*----------------------------------***  DrawGrid  ***----------------------------------*//*access:			protectedoverrides:		description: 	draw grid in content area based on ruler settingsins: 			<vh> grid direction TRUE is horizontalouts: 			nonenotes:			draws grid using similar maths to ruler - grid will appear aligned				with rulers at all times.----------------------------------------------------------------------------------------*/void	ZRulerScrollView::DrawGrid( Boolean vh ){	Rect		cr;	double_t	stm, dm, atom, dd, md;	short		divs;	short		m, n, p, q, r, s;		GetBounds( &cr );	RGBForeColor( &gGridColour );		if ( vh )	{		stm = -fmod( fHRuler->GetRulerOrigin(), fHRuler->GetRulerMajorDistance());		divs = fHRuler->GetRulerDivisions();		atom = fHRuler->GetRulerCalibration();		m = (( cr.right - cr.left ) * atom ) + 1; 		q = ((( cr.bottom - cr.top ) * atom ) + 1 ) * divs;		dd = fVRuler->GetRulerMajorDistance() / (double_t) divs;		md = fHRuler->GetRulerMajorDistance();	}	else	{		stm = -fmod( fVRuler->GetRulerOrigin(), fVRuler->GetRulerMajorDistance());		divs = fVRuler->GetRulerDivisions();		atom = fVRuler->GetRulerCalibration();		m = (( cr.bottom - cr.top ) * atom ) + 1; 		q = ((( cr.right - cr.left ) * atom ) + 1 ) * divs;		dd = fHRuler->GetRulerMajorDistance() / (double_t) divs;		md = fVRuler->GetRulerMajorDistance();	}			for( n = 0; n <= m; n++ )	{		p = round( stm / atom );				if ( vh )		{			dm = -fmod( fVRuler->GetRulerOrigin(), 1.0 ) - 1.0;			for( r = 0; r <= q; r++ )			{				s =  round( dm / fVRuler->GetRulerCalibration());				MoveTo( p, s );				LineTo( p, s ); 				dm += dd;			}		}		else		{			dm = -fmod( fHRuler->GetRulerOrigin(), 1.0 ) - 1.0;			for( r = 0; r <= q; r++ )			{				s = round( dm / fHRuler->GetRulerCalibration());				MoveTo( s, p );				LineTo( s, p ); 				dm += dd;			}		}			stm += md;	}}#pragma mark -/*-------------------------***  CreateNewRulerScrollView  ***---------------------------*//*access:			globaloverrides:		description: 	constructor funciton for scrolling view with rulersins: 			<aParent> view's parent view				<aFrame> bounding rect				<pCount> count of parameters				<params> list of parametersouts: 			the viewnotes:			param[0] is a set of flags, indicating basic features				param[1] is bounds width				param[2] is bounds height				param[3] is ruler major span				param[4] is ruler divisions per major----------------------------------------------------------------------------------------*/ZView*	CreateNewRulerScrollView( ZView* aParent, Rect* aFrame, short pCount, long params[] ){	ZRulerScrollView*	sv;	Boolean				hBar, vBar, szBox;		if ( pCount > 0 )	{		vBar = ( params[0] & kScrollingViewHasVerticalBar ) == kScrollingViewHasVerticalBar;		hBar = ( params[0] & kScrollingViewHasHorizontalBar ) == kScrollingViewHasHorizontalBar;		szBox = ( params[0] & kScrollingViewHasSizeBox ) == kScrollingViewHasSizeBox;	}	else	{		hBar = TRUE;		vBar = TRUE;		szBox = TRUE;	}		FailNIL( sv = new ZRulerScrollView( aParent, aFrame, hBar, vBar, szBox ));		if ( pCount > 0 )	{		if ( params[0] & kScrollingViewHasStdBorder )			sv->SetStandardBorder( TRUE );					if ( params[0] & kScrollingViewCanBeHandler )			sv->SetCanBeHandler( TRUE );			if ( pCount > 2 )		{			Rect	br;						br.top = br.left = 0;			br.right = params[1];			br.bottom = params[2];						sv->SetBounds( br );		}				if ( pCount > 3 )			sv->SetRulersUnits( 1.0, params[3], params[4] );	}	return sv;}