/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZMenubarView.cpp		-- menubar that can be used in any window******			©2001, Graham Cox*****************************************************************************************************/#include	"ZMenuBarView.h"#include	"MacZoop.h"RgnHandle	ZMenuBarView::sMBarExclusionRgn = NULL;ZMenuBarView::ZMenuBarView( ZView* aParent, Rect* aFrame, const short mbarID )	: ZView( aParent, aFrame ), ZMenuBar( mbarID ){	FailNIL( fTitles = new ZArray( sizeof( MenuTitleInfo )));		SetFontInfo( kFontIDGeneva, 10, bold );	InitMenuBar();	SetRefreshOnResize( TRUE );		if ( sMBarExclusionRgn == NULL )		FailNIL( sMBarExclusionRgn = NewRgn());			fCurHilite = 0;}ZMenuBarView::~ZMenuBarView(){	if ( fTitles )		FORGETOBJECT( fTitles );}void	ZMenuBarView::DrawContent(){#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )		DrawThemeMenuBar();#endif	DrawTitles();}void	ZMenuBarView::ClickContent( const Point mouse, const short modifiers ){	ClickMenuBar( mouse );}void	ZMenuBarView::DispatchCommand( const long mSelect, const short modifiers ){	ZCommander*		boss;		boss = GetBoss();		if ( boss && HiWord( mSelect ))	{		MenuCmd		mCmd;				FindMCmd( mSelect, &mCmd );				if ( mCmd.theCmd != parentCmd )		{			inDispatch = TRUE;			ZoopCommand	cmd;						if ( modifiers & optionKey )				cmd = mCmd.altCommand;			else			{				if ( modifiers & shiftKey )					cmd = mCmd.shiftCommand;				else					cmd = mCmd.theCmd;			}						if ( mCmd.theCmd != noCommand )				boss->HandleCommand( cmd );			else				boss->HandleCommand( HiWord( mSelect ), LoWord( mSelect ));						inDispatch = FALSE;		}	}		SetTitleHilite( 0, FALSE );}void	ZMenuBarView::SetTitleHilite( const short menuID, const Boolean state ){	Focus();	PrepareForDrawing();	FocusForContent();		if ( fCurHilite && ! state )	{		Draw1MenuTitle( fCurHilite, FALSE );		fCurHilite = 0;		}	else	{		// TO DO: hilite menu title associated with <menuID>				}}void	ZMenuBarView::DrawThemeMenuBar(){	Rect		br;		GetBounds( &br );	DrawThemeMenuBarBackground( &br, kThemeMenuBarNormal, 0 );}void	ZMenuBarView::GetMenuTitleRect( short menuID, Rect* tRect ){	MenuTitleInfo		mti;	short				n, i;		n = fTitles->CountItems();		for( i = 1; i <= n; i++ )	{		fTitles->GetArrayItem( &mti, i );				if ( mti.menuID == menuID )		{			*tRect = mti.titleRect;			return;		}	}}void	ZMenuBarView::InitTitles(){	MenuTitleInfo		mti;	MenuInfRec			mInfo;	short				n, i;	Rect				tr;	Str255				temp;		Focus();	PrepareForDrawing();	GetContentRect( &tr );		tr.left = kMBarOffsetToFirstTitle;	tr.bottom = MAX( tr.bottom, kStdMiniMenubarHeight );		n = theMenus->CountItems();		for( i = 1; i <= n; i++ )	{		theMenus->GetArrayItem( &mInfo, i );				if ( ! mInfo.mIsSubmenu )		{			mti.menuID = mInfo.menuID;		#if TARGET_API_MAC_CARBON			GetMenuTitle( mInfo.macMenu, temp );		#else			CopyPString((*mInfo.macMenu)->menuData, temp );		#endif				CopyPStringTrunc( temp, mti.title, 30 );						tr.right = tr.left + StringWidth( mti.title ) + kMBarTitleMarginAllowance;			mti.titleRect = tr;			fTitles->AppendItem( &mti );					tr.left = tr.right + 1;		}	}}void	ZMenuBarView::DrawTitles(){	short				n, i;		n = fTitles->CountItems();		for( i = 1; i <= n; i++ )		Draw1MenuTitle( i, FALSE );}void	ZMenuBarView::LoadMenus( const Boolean autoInstall ){	ZMenuBar::LoadMenus( FALSE );	InitTitles();}	void	ZMenuBarView::Draw1MenuTitle( const short which, const Boolean selected ){	MenuTitleInfo		mti;	Rect				br;	GetBounds( &br );	fTitles->GetArrayItem( &mti, which );	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ThemeMenuState			ms;		MenuTitleDrawingUPP		mTitleProc;				mTitleProc = NewMenuTitleDrawingUPP( DrawMTCallback );				ms = ( IsActive() && IsEnabled())? selected? kThemeMenuSelected : kThemeMenuActive : kThemeMenuDisabled;				DrawThemeMenuTitle( &br, &mti.titleRect, ms, 0, mTitleProc, (UInt32) mti.title );		DisposeMenuTitleDrawingUPP( mTitleProc );	}	else	{#endif		FontInfo	fi;		short		sw;				GetFontInfo( &fi );		if ( selected )		{			RGBForeColor( &gBlack );			PaintRect( &mti.titleRect );			RGBForeColor( &gWhite );		}				sw = StringWidth( mti.title ) / 2;		MoveTo((( mti.titleRect.left + mti.titleRect.right ) / 2 ) - sw, mti.titleRect.top + fi.ascent - 1 );		DrawString( mti.title );#if APPEARANCE_MGR_AWARE	}#endif}short	ZMenuBarView::FindClickedMenu( const Point mouse ){	MenuTitleInfo		mti;	short				n, i;		n = fTitles->CountItems();		for( i = 1; i <= n; i++ )	{		fTitles->GetArrayItem( &mti, i );				if ( PtInRect( mouse, &mti.titleRect ))			return i;	}		return 0;}long		ZMenuBarView::TrackMenuBar( const Point mouse )	{	long	mSelect = 0;	short	cm, ocm;	Point	km;		ocm = 0;		do	{		GetMouse( &km );				cm = FindClickedMenu( km );		if ( cm != ocm )		{			if ( ocm != 0 )				Draw1MenuTitle( ocm, FALSE );							if ( cm != 0 )			{				Draw1MenuTitle( cm, TRUE );								// pop up the menu				fCurHilite = cm;				mSelect = TrackMenu( cm );			}				ocm = cm;		}	}	while( WaitMouseUp());		return mSelect;}long		ZMenuBarView::TrackMenu( const short which ){	MenuTitleInfo	mti;	MenuInfRec		mi;	long			mSelect;	Point			mLoc;	short			font, fontSize;		fTitles->GetArrayItem( &mti, which );	FindMenuInfo( mti.menuID, &mi );		if ( mi.macMenu == NULL )		return 0;			// calculate where menu will show up		mLoc.h = mti.titleRect.left + 1;	mLoc.v = mti.titleRect.bottom;	LocalToGlobal( &mLoc );	// form the exclusion region which will allow us to switch to a new menu even when	// the menu manager is tracking the pop-up		Rect	br;	GetBounds( &br );	LocalToGlobal( &topLeft( br ));	LocalToGlobal( &botRight( br ));	RectRgn( sMBarExclusionRgn, &br );	br = mti.titleRect;	LocalToGlobal( &topLeft( br ));	LocalToGlobal( &botRight( br ));	RectRgn( gUtilRgn, &br );	DiffRgn( sMBarExclusionRgn, gUtilRgn, sMBarExclusionRgn );	ZViewEnvironment*	env = GetEnvironment();		font = env->GetFont();	fontSize = env->GetFontSize();		// to prevent problems with shared menus, we actually use a fixed menu ID	// for the true menu, but compose the result ourselves, so the caller	// in none the wiser and neither is the toolbox.#if TARGET_API_MAC_CARBON		SetMenuID( mi.macMenu, kMiniBarStandardMenuID );	SetMenuFont( mi.macMenu, font, fontSize );		// Carbon solution for hook is to install an event timer to poll for the mouse	// entering the exclusion region		EventLoopTimerUPP	hook;	EventLoopTimerRef	hookTimerRef;		hook = NewEventLoopTimerUPP( MTHookEventTimerCallback );	FailOSStatus( InstallEventLoopTimer( GetMainEventLoop(), 0.1, 0.1, hook, NULL, &hookTimerRef ));#else	(*mi.macMenu)->menuID = kMiniBarStandardMenuID;		// I dislike doing this - so for now I've bypassed it		if ( 0 )	{		GrafPtr	wPort;				GetWMgrPort( &wPort );		SetPort( wPort );		TextFont( font );		TextSize( fontSize );	}	// install the menuhook callback		MenuHookUPP		oldHook;	MenuHookUPP		hook = NewMenuHookUPP( MTHookCallback );	oldHook = LMGetMenuHook();	LMSetMenuHook( hook );#endif		// insert, pop up and track the menu:		InsertMenu( mi.macMenu, hierMenu );	mSelect = PopUpMenuSelect( mi.macMenu, mLoc.v, mLoc.h, 1 );	DeleteMenu( kMiniBarStandardMenuID );	#if TARGET_API_MAC_CARBON		// clean up Carbon hook / event timer		RemoveEventLoopTimer( hookTimerRef );	DisposeEventLoopTimerUPP( hook );	SetMenuID( mi.macMenu, mi.menuID );	#else	LMSetMenuHook( oldHook );	DisposeMenuHookUPP( hook );		(*mi.macMenu)->menuID = mi.menuID;	#endif		SetEmptyRgn( sMBarExclusionRgn );		if ( HiWord( mSelect ) == kMiniBarStandardMenuID )		mSelect = ((long) mti.menuID << 16 ) + LoWord( mSelect );			Focus();	PrepareForDrawing();	FocusForContent();	return mSelect;}void		ZMenuBarView::PrepareMenusForDisplay(){	// initially disable all menu items		DimMenus();		// ask the command chain to reenable the relevant menu items	ZCommander*	aBoss;		aBoss = GetBoss();		if ( aBoss )		aBoss->UpdateMenus();	SendMessage( kMsgMBarAboutToShowMenu, NULL );}pascal void		ZMenuBarView::DrawMTCallback( const Rect *inBounds, SInt16 inDepth, Boolean inIsColorDevice, SInt32 inUserData ){	StringPtr	s = (StringPtr) inUserData;	short		sw;	FontInfo	fi;		sw = StringWidth( s ) / 2;	GetFontInfo( &fi );	MoveTo((( inBounds->left + inBounds->right ) / 2 ) - sw, inBounds->top + fi.ascent - 1 );	DrawString( s );}pascal void	ZMenuBarView::MTHookCallback(){	Point	pt;		GetMouse( &pt );	if ( PtInRgn( pt, sMBarExclusionRgn ))	{		if ( StillDown())			PostEvent( mouseUp, 0 );		else			PostEvent( keyDown, ESCAPE_KEY );	}}#if TARGET_API_MAC_CARBONpascal void	ZMenuBarView::MTHookEventTimerCallback( EventLoopTimerRef inTimer, void *inUserData ){	Point	pt;		GetMouse( &pt );	if ( PtInRgn( pt, sMBarExclusionRgn ))	{		if ( StillDown())			PostEvent( mouseUp, 0 );		else			PostEvent( keyDown, ESCAPE_KEY );	}}#endif	