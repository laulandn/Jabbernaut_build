/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			ZMouseTracker.h			-- handles mouse tracking in a window******			© 1998, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZMOUSETRACKER__#define	__ZMOUSETRACKER__#include	"ZComrade.h"#include	<quickdraw.h>class	ZView;class	ZScroller;class	ZMouseTracker	: public ZComrade{protected:	ZView*		wOwner;	RgnHandle	selection;	Point		start;	Point		current;	Rect		constraint;	Boolean		inScrollView;	Boolean		autoScroll;	short		fWidth;	short		gridH, gridV;	Pattern		trackPat;	PenState	nps;	public:	ZMouseTracker( ZView* anOwner, Rect* pin = NULL, Boolean willScroll = TRUE );	virtual ~ZMouseTracker();		virtual void	Track( const Point startPt );	virtual void	GetSelectionBounds( Rect* aRect );	virtual void	MakeDragRegion( RgnHandle aRgn );	virtual void	DrawDragRegion( RgnHandle aRgn );		virtual void	StartAction( const Point pt ) {};	virtual void	TrackAction( const Point pt ) {};	virtual void	CompletionAction( const Point pt ) {};		void			SetTrackPattern( Pattern aPat );	void			SetTrackPattern( const short patID );	void			SetTrackPenWidth( const short aWidth ) { fWidth = aWidth; };	void			SetTrackGrid( const short h, const short v ) { gridH = h; gridV = v; };		void			UpdateDragRegion( RgnHandle affectedRgn );	void			UpdateDragRect( Rect* affectedRect );		inline	RgnHandle	GetDragRegion() { return selection; };	};enum{	msgMouseTrackStarting		= 'trk1',	msgMouseTrackNewPosition	= 'trk2',	msgMouseTrackComplete		= 'trk3',	msgMouseTrackScrolledView	= 'trk4',	kDefaultTrackPenWidth		= 2,	kDefaultTrackPenPat			= 4};/*	You can use this object to perform mouse tracking in a view. By default this draws a	rectangular "rubber band" but you could override it to draw other shapes, etc.		You can respond to tracking using your window's ReceiveMessage() method, if the standard	behaviour is what you want. If you subclass it, you can do whatever you want.		This uses region drawing to ensure that the selection is flicker-free and fast.	Normally, you use this as a stack object within your window's Click() or scroller's	ClickContent method. Just invoke the object and call Track() with the mouse location.		Performs autoscrolling in a scroller automatically, unless you supress it.*/#endif