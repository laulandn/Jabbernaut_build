/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			MZTooltips.cpp		-- tooltips scheme for MacZoop 2.5******			©2001, Graham Cox*****************************************************************************************************/#include	"MZTooltips.h"#include	"MacZoop.h"#include	"ZTextBoxView.h"#include	"ZScrollAwareView.h"ZTooltipHandler*	gTooltips = NULL;/*---------------------------------***  CONSTRUCTOR  ***--------------------------------*/ZTooltipHandler::ZTooltipHandler()	: ZCommander(){	classID = 'tips';		fTipsEnabled = TRUE;	ToolTipInit();	gTooltips = this;}/*---------------------------------***  DESTRUCTOR  ***---------------------------------*/ZTooltipHandler::~ZTooltipHandler(){	if ( fTipWindow )		FORGETOBJECT( fTipWindow );}/*--------------------------------***  ShowTooltip  ***---------------------------------*//*access:			publicoverrides:		description: 	display a tooltip for the view in questionins: 			<forView> view to display tip forouts: 			nonenotes:			can be called repeatedly - only displays tip for new views----------------------------------------------------------------------------------------*/void	ZTooltipHandler::ShowTooltip( ZView* forView ){	if ( fTipsEnabled && ( forView != fCurTipView ))	{		HideTooltip();				fCurTipView = forView;				if ( fCurTipView )			QueueTip();	}}/*--------------------------------***  HideTooltip  ***---------------------------------*//*access:			publicoverrides:		description: 	hide current tooltipins: 			<resetTips> if TRUE, reset view referenceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTooltipHandler::HideTooltip( Boolean resetTips ){	// in case a tip pending, kill the timer		KillTimer( this, 1 );		if ( resetTips )		fCurTipView = NULL;		// if a tip shown hide it and refresh the underlying window -	// this assumes that the top document or dialog is affected, but if the tip is	// in a floater, the area beneath the tip will be repainted next update		if ( fTipWindow->IsVisible())	{		::HideWindow( fTipWindow->GetMacWindow());			ZWindow*	top = gApplication->GetFrontWindow();			if ( top )			top->PerformUpdate();	}}/*----------------------------------***  DoTimer  ***-----------------------------------*//*access:			publicoverrides:		description: 	show tip window when delay elapsedins: 			<timerID> ID of local delay timerouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTooltipHandler::DoTimer( long timerID ){	if ( fCurTipView )	{		// use toolbox functions to avoid causing any unwanted activate events:				::ShowWindow( fTipWindow->GetMacWindow());		::BringToFront( fTipWindow->GetMacWindow());	}}/*-------------------------------***  ReportFields  ***---------------------------------*//*access:			publicoverrides:		description: 	report data members to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTooltipHandler::ReportFields(){	ZCommander::ReportFields();		XSHOWFIELD( fTipWindow, ft_objectref );	XSHOWFIELD( fCurTipView, ft_objectref );	XSHOWFIELD( fTipDelay, ft_signedshort );	XSHOWFIELD( fTipsEnabled, ft_boolean );}/*--------------------------------***  ToolTipInit  ***---------------------------------*//*access:			protectedoverrides:		description: 	initialise tipsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZTooltipHandler::ToolTipInit(){	fCurTipView = NULL;	fTipDelay = kDefaultTooltipDelay;		FailNIL( fTipWindow = new ZWindow( this, kStandardTipWindowResID ));	fTipWindow->InitZWindow();		// window manager must know nothing about this one...		gWindowManager->RemoveWindow( fTipWindow );		// set your desired tip font and colours here:		fTipWindow->SetFontInfo( kFontIDGeneva, 10, 0 );	fTipWindow->SetBackColour( &gStraw );		Rect	sr = { 0, 0, 24, 640 };	fTipWindow->SetSizeRect( sr );		// tip text is actually displayed by a textbox view which is fitted to the window		ZTextBoxView*	tt;		FailNIL( tt = new ZTextBoxView( fTipWindow ));	tt->FitToParent();	tt->ChangeSize( 1, 0, 0, 0 );	tt->SetUserID( 'ttip' );	tt->SetFontAlignment( teJustCenter );		tt->SetAutoSizing( AUTOSIZE( NONE, NONE, FIXEDBOTTOM, FIXEDRIGHT ));		// make sure views active so they draw in black - this window will not	// receive activate events otherwise		fTipWindow->Activate();}/*----------------------------------***  QueueTip  ***----------------------------------*//*access:			protectedoverrides:		description: 	prepare the next tip, setting text and positioning the windowins: 			noneouts: 			nonenotes:			this method has nothing to do with cleaning out your ears ;-)----------------------------------------------------------------------------------------*/void	ZTooltipHandler::QueueTip(){	ZTextBoxView*	tv;	short			tWidth, tHeight;	short			tPosH, tPosV;	FontInfo		fi;	Rect			vcr, mr;	GDHandle		mon;	Str255			tipText;		FailNILParam( fCurTipView );		// get the text to display:		fCurTipView->GetTooltipText( tipText );		// if text empty, do nothing:		if ( tipText[0] > 0 )	{		// size window appropriately and position it				fTipWindow->Focus();		fTipWindow->PrepareForDrawing();		tWidth = StringWidth( tipText ) + 10;		GetFontInfo( &fi );		tHeight = fi.ascent + fi.descent + fi.leading + 2;		fTipWindow->SetSize( tWidth, tHeight );				// if view is scroll-aware view, use content of parent instead				if ( dynamic_cast<ZScrollAwareView*>( fCurTipView ))		{			ZView*	pv = fCurTipView->GetParent();					pv->Focus();			pv->GetContentRect( &vcr );		}		else		{			fCurTipView->Focus();			fCurTipView->GetContentRect( &vcr );		}		LocalToGlobal( &TOPLEFTPOINT( vcr ));		LocalToGlobal( &BOTTOMRIGHTPOINT( vcr ));				// centre just below the view, or if wider than the view, start at the left edge				tPosH = CENTRE( vcr.left, vcr.right ) - ( tWidth / 2 );		tPosH = MAX( vcr.left, tPosH );		tPosV = vcr.bottom + 2;				// make sure tip window is fully onscreen:				mon = fTipWindow->GetMaxMonitor();		mr = (*mon)->gdRect;				if (( tPosH + tWidth ) > mr.right )			tPosH -= (( tPosH + tWidth + 4 ) - mr.right );					if ( tPosH < mr.left )			tPosH += mr.left - tPosH + 4;					if (( tPosV + tHeight ) > mr.bottom )			tPosV -= (( tPosV + tHeight + 4 ) - mr.bottom );					if ( tPosV < mr.top )			tPosV += mr.top - tPosV + 4;					// put the window there				fTipWindow->PlaceAt( tPosH, tPosV );				// set actual string				tv = dynamic_cast<ZTextBoxView*>( fTipWindow->FindChildViewByUserID( 'ttip' ));				if ( tv )			tv->SetValue( tipText );		// set up one-shot timer to show window after delay		SetTimer( this, 1, fTipDelay, TRUE );	}}