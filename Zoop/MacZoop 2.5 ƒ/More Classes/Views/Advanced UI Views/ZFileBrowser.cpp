/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZFileSpecViewer.cpp		-- ZArrayBrowser viewer that can interpret FSSpec*										records******			©2000, Graham Cox*****************************************************************************************************/#include	"ZFileBrowser.h"#include	"MacZoop.h"#include	"ZFolderScanner.h"#include	"FileMgrUtils.h"#include	"ZPStrArray.h"#include	"ZWindow.h"/*----------------------------------***  CONSTRUCTOR  ***-------------------------------*/ZFileBrowser::ZFileBrowser( ZView* aParent, Rect* aFrame, const short columns )	: ZArrayBrowser( aParent, aFrame, columns ){	classID = CLASS_ZFileBrowser;		InitStyle( kBrowserStyleAdoptAppearance );	SetColumnWidth( 1, 180 );	SetColumnWidth( 2, 200 );	SetColumnWidth( 3, 50 );		SetColumnWidth( 4, 210 );		ListenTo( aParent );}/*--------------------------------***  UpdateMenus  ***---------------------------------*//*access:			publicoverrides:		description: 	enable appropriate menu commandsins: 			noneouts: 			nonenotes:			enables select all, but only if multiple selections allowed----------------------------------------------------------------------------------------*/void		ZFileBrowser::UpdateMenus(){	gMenuBar->EnableCommand( kCmdPickBrowseFolder );	ZArrayBrowser::UpdateMenus();}/*-------------------------------***  HandleCommand  ***--------------------------------*//*access:			publicoverrides:		ZCommanderdescription: 	respind to commands for this viewins: 			<cmd> the command to processouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZFileBrowser::HandleCommand( ZoopCommand cmd ){	FSSpec	fs;		switch ( cmd )	{		case kCmdPickBrowseFolder:			if ( ChooseFolder( &fs ))			{				SetBrowseFolder( &fs );				GetRootWindow()->SetTitle( fs.name );			}			break;					default:			ZArrayBrowser::HandleCommand( cmd );			break;	}}	/*-------------------------------***  SetBrowseFolder  ***------------------------------*//*access:			publicoverrides:		description: 	set the folder the browser is displayingins: 			<aFolder> file spec of a folderouts: 			nonenotes:			installs viewer and array----------------------------------------------------------------------------------------*/void		ZFileBrowser::SetBrowseFolder( const FSSpec* aFolder ){	ZFolderScanner		scanner( *aFolder );	ZArray*				arr;	ZFileSpecViewer*	vwr;		SetWatchCursor();	FailNIL( arr = new ZArray( sizeof( FSXSpec )));	SetArray( arr );		FailNIL( vwr = new ZFileSpecViewer());	AttachViewer( vwr );		scanner.SetUseProgress( FALSE );	SetArrayUpdates( FALSE );	ListenTo( &scanner );	scanner.ScanFolder();	SetArrayUpdates( TRUE );		PostContentRefresh();	}/*--------------------------------***  ReceiveMessage  ***------------------------------*//*access:			publicoverrides:		description: 	listen for messagesins: 			<aSender> object doing the sending				<msg> message				<msgData> data with messageouts: 			nonenotes:			adds file info to array----------------------------------------------------------------------------------------*/void		ZFileBrowser::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	FSXSpec		xs;		switch( msg )	{		case msgFolderscanProcess1File:		case msgFolderscanProcess1Folder:			if ( fArray )			{				xs.fs = ((tProcessFileInfo*) msgData )->aSpec;				xs.fType = ((tProcessFileInfo*) msgData )->aType;				xs.fsInit = FALSE;								if ( FileTypeFilter( xs.fType ))					fArray->AppendItem( msgData );			}			break;					case kMsgScrollViewNotifyScroll:			// scroll header to match position of this by forwarding message			SendMessage( kCmdFileBrowserNotifyScroll, msgData );			break;			default:			ZArrayBrowser::ReceiveMessage( aSender, msg, msgData );			break;	}}#pragma mark -/*-------------------------------***  DrawBrowserCell  ***------------------------------*//*access:			publicoverrides:		description: 	render array content in list rowins: 			<cellrect> the bounds of the cell to draw				<whichColumn> column number from 1 to #columns in list				<cellData> pointer to array data for this row				<selected> TRUE if this cell is selectedouts: 			nonenotes:			data is pointer to FSSpec----------------------------------------------------------------------------------------*/void		ZFileSpecViewer::DrawBrowserCell( Rect* cellRect, short row, short column, void* cellData, Boolean selected ){	Point					pen;	FSSpecPtr				fs = (FSSpecPtr) cellData;	CInfoPBRec				pbRec;	IconTransformType		iTransform;	Boolean					isFolder;	Boolean					useIconServices;	OSErr					err;	short					cellWidth;	long					result;	Str255					temp;		err = Gestalt( gestaltIconUtilitiesAttr, &result );		useIconServices = ( err == noErr && ( result & gestaltIconUtilitiesHasIconServices ));		pbRec.hFileInfo.ioCompletion = NULL;	pbRec.hFileInfo.ioNamePtr = fs->name;	pbRec.hFileInfo.ioVRefNum = fs->vRefNum;	pbRec.hFileInfo.ioDirID   = fs->parID;	pbRec.hFileInfo.ioFDirIndex = 0;		PBGetCatInfoSync( &pbRec );		isFolder = ( pbRec.hFileInfo.ioFlAttrib & 0x10 ) != 0;	cellWidth = cellRect->right - cellRect->left;	TextFace( 0 );		switch( column )	{		case kFileViewerColumnFileName:			if ( fShowIcon )			{				Rect		ir;				short		label;								iTransform = ( fOwner->IsActive() && fOwner->IsEnabled())? selected? kTransformSelected : kTransformNone : kTransformDisabled;				SetRect( &ir, 0, 0, 16, 16 );				OffsetRect( &ir, cellRect->left + 4, cellRect->top );								// use icon services where possible. This vastly simplifies the need to				// access the desktop database and to figure out our file object types in				// advance.								if ( useIconServices )				{					IconRef		iRef;					short		label;										GetIconRefFromFile( fs, &iRef, &label );										label <<= 8;					PlotIconRef( &ir, kAlignNone, iTransform | label, kIconServicesNormalUsageFlag, iRef );					ReleaseIconRef( iRef );				}				else				{					// if no icon services, resort to the older methods. These are less					// versatile and do not handle 32-bit icons, deep masks, etc.										Handle	iconSuite;										if ( isFolder )						GetIconSuite( &iconSuite, kGenericFolderIconResource, kSelectorAllAvailableData );					else						iconSuite = GetIconSuiteFromDTDB( pbRec.hFileInfo.ioFlFndrInfo.fdType, pbRec.hFileInfo.ioFlFndrInfo.fdCreator );										if ( iconSuite )					{						label = ( pbRec.hFileInfo.ioFlFndrInfo.fdFlags & 0x0E ) << 7;												PlotIconSuite( &ir, kAlignNone, iTransform | label, iconSuite );						DisposeIconSuite( iconSuite, TRUE );					}				}				// when drawing icons, move text right a bit								Move( 22, 0 );			}						// draw file object's name						if ( selected )				TextMode( notSrcCopy );			CopyPString( fs->name, temp );			GetPen( &pen );						cellWidth = cellRect->right - 2 - pen.h;						if ( StringWidth( temp ) > cellWidth )				TextFace( condense );							TruncString( cellWidth, temp, smTruncEnd );				DrawString( temp );			TextMode( ( fOwner->IsActive() && fOwner->IsEnabled())? srcOr : grayishTextOr );			break;					case kFileViewerColumnFileModDate:		{			Str31 timStr;						DateString( pbRec.hFileInfo.ioFlMdDat, longDate, temp, NULL );			ConcatPStrings( temp, "\p, ");						TimeString( pbRec.hFileInfo.ioFlMdDat, FALSE, timStr, NULL );						ConcatPStrings( temp, timStr );			GetPen( &pen );						cellWidth = cellRect->right - 2 - pen.h;						if ( StringWidth( temp ) > cellWidth )				TextFace( condense );						TruncString( cellWidth, temp, smTruncMiddle );				DrawString( temp );			break;		}					case kFileViewerColumnFileSize:			if ( isFolder )				CopyPString( "\p-", temp );			else			{				long	sz = pbRec.hFileInfo.ioFlLgLen + pbRec.hFileInfo.ioFlRLgLen;								NumToString( sz / 1024, temp );				ConcatPStrings( temp, "\pK" );			}						cellWidth -= 2;			if ( StringWidth( temp ) > cellWidth )				TextFace( condense );						TruncString( cellWidth, temp, smTruncEnd );				GetPen( &pen );			pen.h = MAX( cellRect->right - 2 - StringWidth( temp ), cellRect->left + 2 );			MoveTo( pen.h, pen.v );			DrawString( temp );			break;					case kFileViewerColumnFileKind:			temp[0] = 0;						if ( isFolder )				CopyPString( "\pfolder", temp );			else			{				if ( pbRec.hFileInfo.ioFlFndrInfo.fdType == 'APPL' )					CopyPString( "\papplication program", temp );				else				{					GetApplNameFromCreator( fs->vRefNum, pbRec.hFileInfo.ioFlFndrInfo.fdCreator, temp );					if ( temp[0] > 0 )						ConcatPStrings( temp, "\p " );					ConcatPStrings( temp, "\pdocument" );				}			}			GetPen( &pen );						cellWidth = cellRect->right - 2 - pen.h;						if ( StringWidth( temp ) > cellWidth )				TextFace( condense );						TruncString( cellWidth, temp, smTruncEnd );				DrawString( temp );			break;				}}/*-------------------------------***  TestDataEqual  ***--------------------------------*//*access:			publicoverrides:		description: 	test if search data matches array datains: 			<cellData> copy of data in array cell				<testData> pointer to search data				<testDataLen> length of search dataouts: 			TRUE if data matches, otherwise falsenotes:			called by FindArrayData, etc. Do what you need to do.----------------------------------------------------------------------------------------*/Boolean		ZFileSpecViewer::TestDataEqual( void* cellData, Ptr testData, long testDataLen ){	UpperString(((FSSpecPtr) cellData )->name, TRUE );		return EqualMem( &((FSSpecPtr) cellData )->name[1], testData, testDataLen );}/*-----------------------------***  MakeClipboardData  ***------------------------------*//*access:			publicoverrides:		description: 	convert array data to public datains: 			<row> row being converted				<cellData> pointer to array dataouts: 			Handle containing public datanotes:			converts to HFSFlavor record----------------------------------------------------------------------------------------*/Handle		ZFileSpecViewer::MakeClipboardData( short row, void* cellData ){	FSSpecPtr	fs = (FSSpecPtr) cellData;	FInfo		fi;	HFSFlavor	hfs;	Handle		h;		FailNIL( h = NewHandle( sizeof( HFSFlavor )));		FSpGetFInfo( fs, &fi );		hfs.fileType = fi.fdType;	hfs.fileCreator = fi.fdCreator;	hfs.fdFlags = fi.fdFlags;	hfs.fileSpec = *fs;		BlockMoveData( &hfs, *h, sizeof( HFSFlavor ));			return h;	}/*---------------------------***  ConvertClipboardData  ***----------------------------*//*access:			publicoverrides:		description: 	convert public data to array datains: 			<row> row being converted				<dataIn> public data				<dataOut> pointer to storage for array itemouts: 			nonenotes:			converts from HFSFlavor record----------------------------------------------------------------------------------------*/void		ZFileSpecViewer::ConvertClipboardData( short row, Handle dataIn, void* dataOut ){	HFSFlavor**		h = (HFSFlavor**) dataIn;	FSSpecPtr		fs = (FSSpecPtr) dataOut;		*fs = (*h)->fileSpec;}#pragma mark -/*----------------------------------***  CONSTRUCTOR  ***-------------------------------*/ZFileBrowserHeader::ZFileBrowserHeader( ZView* aParent, Rect* aFrame, ZArrayBrowser* aBrowser )	: ZView( aParent, aFrame ){	classID = CLASS_ZFileBrowserHeader;		Str15	dt = "\p";	fBrowser = aBrowser;	fSortReversed = FALSE;	FailNIL( fTitles = new ZPStrArray());		if ( fBrowser )	{		ListenTo( fBrowser );				for( short i = 1; i <= fBrowser->GetColCount(); i++ )			fTitles->AppendItem( dt );	}		SetFontInfo( kFontIDGeneva, 9, 0 );	fScrollOffset = 0;}/*----------------------------------***  DESTRUCTOR  ***--------------------------------*/ZFileBrowserHeader::~ZFileBrowserHeader(){	if ( fTitles )		FORGETOBJECT( fTitles );}/*---------------------------------***  DrawContent  ***--------------------------------*//*access:			publicoverrides:		description: 	draw the placards that make up the headerins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::DrawContent(){	short					n, i;	Rect					br;		if ( fBrowser )	{		n = fBrowser->GetColCount();				for( i = 1; i <= n; i++ )		{			GetButtonRect( &br, i );			DrawHeaderButton( &br, i, FALSE );			}	}}/*--------------------------------***  ClickContent  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to a click in the viewins: 			<mouse> the mouse coordinates local to view				<modifiers> modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::ClickContent( const Point mouse, const short modifiers ){	Rect		br;	short		col, n;	Boolean		isIn, wasIn;	Point		mp;		if ( fBrowser )	{		// find the column hit				n = fBrowser->GetColCount();		wasIn = FALSE;				for( col = 1; col <= n; col++ )		{			GetButtonRect( &br, col );					if ( PtInRect( mouse, &br ))			{				// ok, we hit one. Now track it...				isIn = TRUE;								do				{					if ( isIn != wasIn )					{						DrawHeaderButton( &br, col, isIn ); 												wasIn = isIn;					}									GetMouse( &mp );										isIn = PtInRect( mp, &br );				}				while( WaitMouseUp());								if ( wasIn )				{					if ( col == fBrowser->GetSelectedColumn())						DrawHeaderButton( &br, col, FALSE );					else						DoColumnSwitch( col );					return;				}			}				}	}}/*-------------------------------***  ReceiveMessage  ***-------------------------------*//*access:			publicoverrides:		description: 	respond to messages from browserins: 			<aSender> object sending the message				<msg> the message				<msgData> data with messageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	switch ( msg )	{		case kMsgArrayBrowserColumnMoved:			PostRefresh();			break;				case kMsgArrayBrowserSelectColumn:			SortArrayByColumn( *(short*) msgData );			break;					case kCmdFileBrowserNotifyScroll:			//ScrollHeader( LoWord( *(long*) msgData ));			break;						default:			break;	}}/*----------------------------------***  SetTitle  ***----------------------------------*//*access:			publicoverrides:		description: 	set the header title for the given columnins: 			<column> column to set				<aTitle> header button title for that columnouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::SetTitle( const short column, Str255 aTitle ){	fTitles->SetArrayItem( aTitle, column );}/*----------------------------------***  GetTitle  ***----------------------------------*//*access:			publicoverrides:		description: 	get the header title for the given columnins: 			<column> column to query				<aTitle> receives header button title for that columnouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::GetTitle( const short column, Str255 aTitle ){	fTitles->GetArrayItem( aTitle, column );}/*--------------------------------***  ScrollHeader  ***--------------------------------*//*access:			publicoverrides:		description: 	scroll the headerins: 			<dH> horizontal scroll deltaouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::ScrollHeader( const short dH ){}/*------------------------------***  DrawHeaderButton  ***------------------------------*//*access:			protectedoverrides:		description: 	draw a single button in the headerins: 			<aRect> the bounding rect of the button				<column> column of button				<pressed> true if pressed by mouseouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::DrawHeaderButton( Rect* aRect, short column, Boolean pressed ){	FontInfo	fi;	Str255		title;	GetTitle( column, title );	GetFontInfo( &fi );	MoveTo( aRect->left + 6, ( aRect->top + aRect->bottom ) / 2 + ( fi.ascent / 2 ) - 1 );	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ThemeButtonDrawInfo		bi;		bi.state = ( IsActive() && IsEnabled())? pressed? kThemeStatePressed : kThemeStateActive : kThemeStateInactive;		bi.value = ( column == fBrowser->GetSelectedColumn())? 1 : 0;		bi.adornment = kThemeAdornmentNone;		DrawThemeButton( aRect, kThemeSmallBevelButton, &bi, NULL, NULL, NULL, 0 );	}	else	{#endif		Boolean selected = ( column == fBrowser->GetSelectedColumn());		Rect	rb = *aRect;				rb.right++;				if ( pressed || selected )			RGBBackColor( &gMidGray );		else			RGBBackColor( &gLightGray );				PenNormal();		RGBForeColor( &gBlack );		EraseRect( aRect );		FrameRect( &rb );				if ( selected )			TextFace( underline );		else			TextFace( 0 );#if APPEARANCE_MGR_AWARE	}#endif		if ( pressed )		RGBForeColor( &gWhite );	else		PrepareForDrawing();			if ( IsActive() && IsEnabled())			TextMode( srcOr );	else		TextMode( grayishTextOr );			DrawString( title );}/*-------------------------------***  GetButtonRect  ***--------------------------------*//*access:			protectedoverrides:		description: 	get bounds rect of button for given columnins: 			<aRect> receives the bounding rect of the button				<column> column of buttonouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::GetButtonRect( Rect* aRect, short column ){	Rect	br;	short	w;		GetBounds( &br );	w = fBrowser->GetColumnPosition( column ) + 1;	*aRect = br;	if ( column == fBrowser->GetColCount())		aRect->right = br.right;	else			aRect->right = MIN( br.right, w );		if ( column > 1 )		aRect->left = fBrowser->GetColumnPosition( column - 1 ) + 1;}/*-------------------------------***  DoColumnSwitch  ***-------------------------------*//*access:			protectedoverrides:		description: 	select a new column in the browser when a button pressedins: 			<column> column to selectouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::DoColumnSwitch( const short column ){	if ( fBrowser )	{		short oc = fBrowser->GetSelectedColumn();				if ( column != oc)		{			Rect	br;						GetButtonRect( &br, oc);			PostRefresh( &br );			fBrowser->SelectColumn( column );						Focus();			PrepareForDrawing();			FocusForContent();			GetButtonRect( &br, column);			DrawHeaderButton( &br, column, FALSE );		}	}}/*-----------------------------***  SortArrayByColumn  ***------------------------------*//*access:			protectedoverrides:		description: 	sort the browser's array depending on the column selected.ins: 			<column> selected column - sets sort criterionouts: 			nonenotes:			this method assumes that the array data is an FSSpec record----------------------------------------------------------------------------------------*/void	ZFileBrowserHeader::SortArrayByColumn( const short column ){	// resort the filespec array according to the column selected		ZArray*		arr;	long		flags;		if ( fBrowser )	{		SetWatchCursor();				flags = ( fSortReversed? 0x8000 : 0 ) + column;		 		arr = fBrowser->GetArray();		arr->Sort( FileBrowserSortProc, flags );		fBrowser->DoSelectNone();	}}/*----------------------------***  FileBrowserSortProc  ***-----------------------------*//*access:			static protectedoverrides:		description: 	comparison function used to sort array of FSSpec records according to				selected column.ins: 			<a, b> pointers to FSSpec records				<ref> refCon from caller - contains column ID and reverse flag.outs: 			relative order of two elementsnotes:			pass as comparison function to ZArray::Sort()----------------------------------------------------------------------------------------*/short	ZFileBrowserHeader::FileBrowserSortProc( void* a, void* b, const long ref ){	short		result = 0;	FSSpecPtr	fsA, fsB;	CInfoPBRec	pbA, pbB;	long		sizeA, sizeB;		fsA = (FSSpecPtr) a;	fsB = (FSSpecPtr) b;		if (( ref & 0xFF ) != kFileViewerColumnFileName )	{		pbA.hFileInfo.ioCompletion = NULL;		pbA.hFileInfo.ioNamePtr = fsA->name;		pbA.hFileInfo.ioVRefNum = fsA->vRefNum;		pbA.hFileInfo.ioDirID = fsA->parID;		pbA.hFileInfo.ioFDirIndex = 0;				PBGetCatInfoSync( &pbA );				pbB.hFileInfo.ioCompletion = NULL;		pbB.hFileInfo.ioNamePtr = fsB->name;		pbB.hFileInfo.ioVRefNum = fsB->vRefNum;		pbB.hFileInfo.ioDirID = fsB->parID;		pbB.hFileInfo.ioFDirIndex = 0;				PBGetCatInfoSync( &pbB );	}		switch( ref & 0xFF )	{		case kFileViewerColumnFileName:			result = CompareString( fsA->name, fsB->name, NULL );			break;					case kFileViewerColumnFileModDate:			result = CMP( pbA.hFileInfo.ioFlMdDat, pbB.hFileInfo.ioFlMdDat );			break;					case kFileViewerColumnFileSize:			sizeA = pbA.hFileInfo.ioFlLgLen + pbA.hFileInfo.ioFlRLgLen;			sizeB = pbB.hFileInfo.ioFlLgLen + pbB.hFileInfo.ioFlRLgLen;			result = CMP( sizeA, sizeB );			break;					case kFileViewerColumnFileKind:			sizeA = pbA.hFileInfo.ioFlFndrInfo.fdType;				sizeB = pbB.hFileInfo.ioFlFndrInfo.fdType;				result = CMP( sizeA, sizeB );			break;	}		// check reverse flag and flip if set		if ( ref & 0x8000 )		result = -result;			return result;}