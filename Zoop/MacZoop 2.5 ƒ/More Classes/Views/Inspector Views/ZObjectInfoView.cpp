/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZObjectInfoView.cpp		-- object info view for inspector******			© 2000, Graham Cox*****************************************************************************************************/#include	"ZObjectInfoView.h"#include	"MacZoop.h"#include	<fp.h>/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZObjectInfoView::ZObjectInfoView( ZView* aParent, Rect* aFrame )	: ZScrollAwareView( aParent, aFrame ){	FontInfo	fi;		fFieldLine = 0;	fTheObject = NULL;	fLinks = NULL;	fPreflight = FALSE;		SetFontInfo( kFontIDGeneva, 9, 0 );		Focus();	PrepareForDrawing();	GetFontInfo( &fi );		fLineHeight = fi.ascent + fi.descent + fi.leading + 2;	fLineAscent = fi.ascent + 1;		for( short i = 0; i < kNumInfoTabs; i++ )		fTabs[i] = 4 + ( i * 130 );			ListenTo( gApplication );}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZObjectInfoView::~ZObjectInfoView(){	if ( fLinks )		FORGETOBJECT( fLinks );	}/*-------------------------------***  DrawContent  ***----------------------------------*//*access:			publicoverrides:		description: 	render the contents of this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInfoView::DrawContent(){	Rect	pr;		GetContentRect( &pr );		PenNormal();	RGBForeColor( &gFeintBlue );		for( short i = 1; i < kNumInfoTabs; i++ )	{		MoveTo( fTabs[i] - 4, pr.top );		LineTo( fTabs[i] - 4, pr.bottom - 2 );	}	PrepareForDrawing();		DrawFieldInfo( fTheObject );}/*--------------------------------***  SetObject  ***-----------------------------------*//*access:			publicoverrides:		description: 	set up the object that this view will display the info forins: 			<anObject> the object we wish to interrogate for info				<redraw> TRUE to immediately re-render the viewouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInfoView::SetObject( ZObject* anObject, const Boolean redraw ){	if ( redraw )		PostRefresh();	fTheObject = anObject;		CalcBounds();	if ( redraw )		PostRefresh();	SendMessage( kMsgSwitchedToNewObject, anObject );}/*------------------------------***  ReceiveMessage  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to field report messages from object being viewedins: 			<aSender> th eobject sending the message				<msg> the message				<msgData> the data for the messageouts: 			nonenotes:			each reported data member calls this once via XSHOWFIELD macro----------------------------------------------------------------------------------------*/void	ZObjectInfoView::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	if ( msg == kMsgDebugObjectFieldReport )	{		fieldReport*	rp;					rp = (fieldReport*) msgData;				if ( rp->theObject == fTheObject )		{			DrawOneField( rp );		}	}}/*-------------------------------***  SetViewCursor  ***--------------------------------*//*access:			publicoverrides:		description: 	set cursor for the viewins: 			<mouse> mouse point in view's bounds				<modifiers> modifier key stateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInfoView::SetViewCursor( const Point mouse, const short modifiers ){	short	i, p;		if ( FindLink( mouse ))	{		SetCursorShape( FINGER_CURSOR );		return;	}	else	{		for( i = 0; i < kNumInfoTabs; i++ )		{			p = fTabs[i] - 4;						if ( ABS(  mouse.h - p ) < 3 )			{				SetCursorShape( COLUMN_RESIZE_CURSOR );				return;			}		}	}	SetCursorShape( ARROW_CURSOR );}/*--------------------------------***  ClickContent  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to mouse click in this viewins: 			<mouse> mouse point in view's bounds				<modifiers> modifier key stateouts: 			nonenotes:			drags the column positions for the view, and hits hyperlinks----------------------------------------------------------------------------------------*/void	ZObjectInfoView::ClickContent( const Point mouse, const short modifiers ){	short	i, p;		if ( p = FindLink( mouse ))	{		// clicked a hyperlink. Track it and switch objects				if ( TrackLink( p, mouse ))			ActionLink( p );	}	else	{		for( i = 0; i < kNumInfoTabs; i++ )		{			p = fTabs[i] - 4;						if ( ABS(  mouse.h - p ) < 3 )			{				// drag the tab.								Point		cm, oldm;				short		tabMin, tabMax;				Rect		cr;								if ( i == 0 )					tabMin = 4;				else					tabMin = fTabs[i - 1] + 4;								if ( i == kNumInfoTabs - 1 )					tabMax = fFrame.right - fFrame.left;				else 						tabMax = fTabs[i + 1] - 4;								GetContentRect( &cr );				cr.bottom -= 2;				PenPat( QDGRAYPATTERN );				PenMode( patXor );				PenSize( 1, 1 );				oldm = mouse;				MoveTo( p, cr.top );				LineTo( p, cr.bottom );								do				{					GetMouse( &cm );										if ( DeltaPoint( cm, oldm ))					{ 							MoveTo( p, cr.top );						LineTo( p, cr.bottom );												p = MIN( tabMax, MAX( cm.h, tabMin )); 												MoveTo( p, cr.top );						LineTo( p, cr.bottom );												oldm = cm;					}				}				while( WaitMouseUp());				MoveTo( p, cr.top );				LineTo( p, cr.bottom );				fTabs[i] = p + 4;				PenNormal();								PostRefresh();				break;			}		}	}}/*---------------------------------***  CalcBounds  ***---------------------------------*//*access:			publicoverrides:		description: 	calculate the extent of the view given the amount of data reported				by the objectins: 			noneouts: 			nonenotes:			sets parent's scroll bounds using message----------------------------------------------------------------------------------------*/void	ZObjectInfoView::CalcBounds(){	Rect	r;		fFieldLine = 0;		if ( fTheObject )	{		fPreflight = TRUE;		fTheObject->ReportFields();		fPreflight = FALSE;	}		GetBounds( &r );	r.bottom = fLineHeight * fFieldLine;		if ( r.bottom )		r.bottom++;		SetBounds( r );}/*--------------------------------***  DrawOneField  ***--------------------------------*//*access:			publicoverrides:		description: 	draws one field within the info view.ins: 			<rp> a field report record built by the XSHOWFIELD (or similar) macroouts: 			nonenotes:			calls once for each field reported back----------------------------------------------------------------------------------------*/void	ZObjectInfoView::DrawOneField( fieldReport* rp ){	short			vt;	unsigned short	us;	static short	lpos, sWidth;	long			hs;	Str255			fn;		// keep track of where we got to		if ( fFieldLine == 0 )		lpos = fLineAscent;	else		lpos += fLineHeight;		// count the lines we've drawn			++fFieldLine;		// if preflighting is TRUE, all we're doing is counting the lines so we	// can determine how big the bounds needs to be, so take an early exit.		if ( fPreflight )		return;		Focus();	PrepareForDrawing();	FocusForContent();	// draw the line...		TextFace( 0 );		// actual type of field (short, long, etc)	MoveTo( fTabs[0], lpos );	CopyCToPString( rp->fieldType, fn );	sWidth = fTabs[1] - fTabs[0] - 8;	TruncString( sWidth, fn, smTruncEnd );	DrawString( fn );		// name of the data member	MoveTo( fTabs[1], lpos );	CopyCToPString( rp->name, fn );	sWidth = fTabs[2] - fTabs[1] - 8;	TruncString( sWidth, fn, smTruncEnd );	DrawString( fn );		// draw the line separating each field	RGBForeColor( &gFeintBlue );	MoveTo( 0, lpos + fLineHeight - fLineAscent );	Line( 1024, 0 );		PrepareForDrawing();	MoveTo( fTabs[2], lpos );		// how the value is converted depends on the data type hint		switch( rp->type )	{		case ft_boolean:			if ( *(Boolean*) rp->field )				CopyPString( "\pTRUE", fn );			else				CopyPString( "\pFALSE", fn );			break;					case ft_signedchar:			char	c = *(char*) rp->field;						NumToString( c, fn );			break;					case ft_FontStyle:		case ft_unsignedchar:			unsigned char uc = *(unsigned char*) rp->field;						NumToString( uc, fn );			break;					case ft_signedshort:			vt = *(short*) rp->field;			NumToString( vt, fn );			break;					case ft_unsignedshort:			us = *(unsigned short*) rp->field;			NumToString( us, fn );			break;				case ft_signedlong:			NumToString( *(long*) rp->field, fn );			DrawString( fn );			DrawString("\p = '");			fn[0] = 5;			BlockMoveData( rp->field, &fn[1], 4 );			fn[5] = '\'';			break;					case ft_unsignedlong:			NumToString( *(unsigned long*) rp->field, fn );			DrawString( fn );			DrawString("\p = '");			fn[0] = 5;			BlockMoveData( rp->field, &fn[1], 4 );			fn[5] = '\'';			break;			case ft_fourcharcode:			if ( *(long*) rp->field == 0 )				NumToString( 0, fn );			else			{				fn[0] = 4;				BlockMoveData( rp->field, &fn[1], 4 );			}			break;					case ft_str255:			CopyPString( *(Str255*) rp->field, fn );			break;					case ft_cstr:			CopyCToPString( *(char**) rp->field, fn );			break;					case ft_objectref:			if ( *(long*) rp->field != 0L )			{				TextFace( underline );				RGBForeColor( &gBlue );			}			// fall through to address case					case ft_address:			if ( *(long*) rp->field == 0L )				DrawString( "\pNULL" );			else			{				DrawString( "\p0x" );				DrawLongAsHex( *(long*) rp->field );								if ( rp->type == ft_objectref )				{					// append instance ID										ZObject*	obj;										obj = *(ZObject**) rp->field;									DrawString("\p (instanceID = " );					NumToString( obj->GetInstanceID(), fn );					DrawString( fn );					DrawString("\p)");										AddHyperlink( rp, PORTPENLOCATION( GetMacPort())->h - fTabs[2] );				}			}			return;					case ft_Handle:			if ( *(Handle*) rp->field == NULL )				CopyPString( "\pNULL", fn );			else			{				hs = GetHandleSize( *(Handle*) rp->field );								if ( hs < 1024 )				{					NumToString( hs, fn );					ConcatPStrings( fn, "\p bytes in Handle 0x" );				}					else				{					NumToString( hs / 1024, fn );					ConcatPStrings( fn, "\pK bytes in Handle 0x" );				}								DrawString( fn );				DrawLongAsHex( *(long*) rp->field );				return;				}			break;				case ft_Ptr:			if ( *(Ptr*) rp->field == NULL )				CopyPString( "\pNULL", fn );			else			{				hs = GetPtrSize( *(Ptr*) rp->field );								if ( hs < 1024 )				{					NumToString( hs, fn );					ConcatPStrings( fn, "\p bytes in Ptr 0x" );				}					else				{					NumToString( hs / 1024, fn );					ConcatPStrings( fn, "\pK bytes in Ptr 0x" );				}					DrawString( fn );				DrawLongAsHex( *(long*) rp->field );				return;				}			break;					case ft_Size:			hs = *(unsigned long*) rp->field;						if ( hs < 1024 )			{				NumToString( hs, fn );				ConcatPStrings( fn, "\p bytes" );			}				else			{				NumToString( hs / 1024, fn );				ConcatPStrings( fn, "\pK bytes" );			}				break;					case ft_Point:			Point	p = *(Point*) rp->field;						DrawString( "\ph: " );			NumToString( p.h, fn );			DrawString( fn );			DrawString( "\p,   v: " );			NumToString( p.v, fn );			break;					case ft_Rect:			Rect	r = *(Rect*) rp->field;						DrawString( "\ptop: " );			NumToString( r.top, fn );			DrawString( fn );			DrawString( "\p, left: " );			NumToString( r.left, fn );			DrawString( fn );			DrawString( "\p, bottom: " );			NumToString( r.bottom, fn );			DrawString( fn );			DrawString( "\p, right: " );			NumToString( r.right, fn );			break;					case ft_FSSpec:			FSSpecPtr	fp = (FSSpecPtr) rp->field;						DrawString( "\pvRefNum: " );			NumToString( fp->vRefNum, fn );			DrawString( fn );			DrawString( "\p, parID: " );			NumToString( fp->parID, fn );			DrawString( fn );						DrawString( "\p, name: " );			DrawString( fp->name );			return;					case ft_RGBColor:			RGBColor*	rgb = (RGBColor*) rp->field;						DrawString( "\pred: " );			NumToString( rgb->red, fn );			DrawString( fn );			DrawString( "\p, green: " );			NumToString( rgb->green, fn );			DrawString( fn );			DrawString( "\p, blue: " );			NumToString( rgb->blue, fn );			break;					case ft_FontID:			vt = *(short*) rp->field;			NumToString( vt, fn );			ConcatPStrings( fn, "\p = ");			DrawString( fn );			GetFontName( vt, fn );			break;					case ft_binary8:			DrawBinaryString((rp->field), 8 );			return;					case ft_binary16:			DrawBinaryString((rp->field), 16 );			return;					case ft_binary32:			DrawBinaryString((rp->field), 32 );			return;					case ft_float:			RealToString( *(double_t*) rp->field, fn, 10 );			break;		default:				CopyPString( "\pcan't expand this data type (0x", fn );			DrawString( fn );			DrawLongAsHex( *(long*) rp->field );			CopyPString( "\p)", fn );			break;	}		DrawString( fn );}/*-------------------------------***  DrawFieldInfo  ***--------------------------------*//*access:			publicoverrides:		description: 	asks object to report its fields (which draws them), then sets bounds.ins: 			<selObject> object to displayouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInfoView::DrawFieldInfo( ZObject* selObject ){	fFieldLine = 0;	if ( selObject )	{		if ( fLinks )			fLinks->DeleteAll();					selObject->ReportFields();	}	CalcBounds();	}/*--------------------------------***  AddHyperlink  ***--------------------------------*//*access:			publicoverrides:		description: 	creates a hyperlink for the reported objectins: 			<forObject> field report for linked object				<strLength> string length of info in panelouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInfoView::AddHyperlink( fieldReport* forObject, short strLength ){	// add a hyperlink for the object reference whose fieldReport is passed in. Link length is also	// supplied so we can compute the hot rect.		ObjectInfoLink		link;		link.theObject = *(ZObject**) forObject->field;		if ( link.theObject )	{		link.hotRect.top = (( fFieldLine - 1 ) * fLineHeight ) + 2;		link.hotRect.bottom = link.hotRect.top + fLineHeight - 2;		link.hotRect.left = fTabs[2] - 1;		link.hotRect.right = link.hotRect.left + strLength + 1;				if ( fLinks == NULL )			FailNIL( fLinks = new ZArray( sizeof( ObjectInfoLink )));					fLinks->AppendItem( &link );	}	}/*----------------------------------***  FindLink  ***----------------------------------*//*access:			publicoverrides:		description: 	hit tests a hyperlinkins: 			<mouse> mouse point local to view's boundsouts: 			index position of hyperlink in list, or 0 if not foundnotes:			----------------------------------------------------------------------------------------*/long	ZObjectInfoView::FindLink( const Point mouse ){	// find any hyperlink under the given point	long				n, i;	ObjectInfoLink		link;		if ( fLinks == NULL )		return 0;			n = fLinks->CountItems();		for( i = 1; i <= n; i++ )	{		fLinks->GetArrayItem( &link, i );			if ( PtInRect( mouse, &link.hotRect ))			return i;	}		return 0;}/*---------------------------------***  TrackLink  ***----------------------------------*//*access:			publicoverrides:		description: 	track a drag in a hyperlink - acts like a buttonins: 			<index> index of hyperlink to track				<startPt> starting position of mouse in the view's boundsouts: 			TRUE if link clicked, FALSE if user abandoned the track.notes:			----------------------------------------------------------------------------------------*/Boolean	ZObjectInfoView::TrackLink( const long index, const Point startPt ){	// hilite and track link with index passed		ObjectInfoLink		link;	Boolean				wasIn = FALSE, isIn;	Point				cm;		if ( fLinks )	{		fLinks->GetArrayItem( &link, index );				SetHiliteMode();		InvertRect( &link.hotRect );		wasIn = isIn = TRUE;			do		{			GetMouse( &cm );						isIn = PtInRect( cm, &link.hotRect );						if ( isIn != wasIn )			{				SetHiliteMode();				InvertRect( &link.hotRect );				wasIn = isIn;			}		}		while( WaitMouseUp());			if ( wasIn )		{			SetHiliteMode();			InvertRect( &link.hotRect );		}	}		return wasIn;}/*---------------------------------***  ActionLink  ***---------------------------------*//*access:			publicoverrides:		description: 	switch the object to the hyperlinked objectins: 			<index> index of hyperlink to selectouts: 			TRUE if link clicked, FALSE if user abandoned the track.notes:			----------------------------------------------------------------------------------------*/void	ZObjectInfoView::ActionLink( const long index ){	// set the object to the object in the link indexed	ObjectInfoLink		link;		if ( fLinks )	{		fLinks->GetArrayItem( &link, index );				SetObject( link.theObject );	}	}/*------------------------------***  DrawBinaryString  ***------------------------------*//*access:			publicoverrides:		description: 	draw a binary stringins: 			<data> pointer to some sort of data				<len> data size, in bitsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInfoView::DrawBinaryString( void* data, unsigned char len ){	unsigned long	mask, v;	unsigned char	p = 1;	Str32			bits;		bits[0] = MIN( 32, len );		switch( len )	{		case 8:			v = *(unsigned char*) data;			mask = 0x80;			break;					case 16:			v = *(unsigned short*) data;			mask = 0x8000;			break;					case 32:			v = *(unsigned long*) data;			mask = 0x80000000;			break;	}		while( mask )	{		bits[p++] = ( mask & v )? '1' : '0';		mask >>= 1;	}	DrawString( bits );}