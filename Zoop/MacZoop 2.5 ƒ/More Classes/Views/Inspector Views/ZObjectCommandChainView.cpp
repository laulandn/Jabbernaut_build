/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZObjectCommandChainView.cpp		-- illustrates dynamic command chain graphically******			© 2000, Graham Cox*****************************************************************************************************/#include	"ZObjectCommandChainView.h"#include	"MacZoop.h"ZObjectCommandChainView::ZObjectCommandChainView( ZView* aParent, Rect* aFrame )	: ZScrollAwareView( aParent, aFrame ){	classID = CLASS_ZObjectCommandChainView;		fChainHead = NULL;	CalcBounds();}void	ZObjectCommandChainView::DrawContent(){	ZScrollAwareView::DrawContent();	// draw arrows between boxes		try	{		ZView*	cv = NULL;		Rect	a, b;		short	i = 0;				Focus();		PrepareForDrawing();		FocusForContent();				do		{			cv = GetChildView( ++i );					if ( cv )				cv->GetFrame( &a );			cv = GetChildView( i + 1 );						if ( cv )			{				cv->GetFrame( &b );				DrawLinkArrow( &a, &b );			}		}		while( cv );	}	catch( ZoopError err )	{		}}void	ZObjectCommandChainView::SetChainHead( ZCommander* chainHead ){	if ( chainHead != fChainHead )	{		fChainHead = chainHead;			// recompute the view				DeleteChildren();		MakeChainViews();		// update bounds:				CalcBounds();				// redraw:				PostContentRefresh();	}}void	ZObjectCommandChainView::CalcBounds(){	Rect	cr;		GetContentRectInBounds( &cr );	OffsetRect( &cr, -cr.left, -cr.top );		cr.bottom = MAX( cr.bottom, kChainLinkViewSpacing + ( CountChainLinks() * ( kChainLinkViewHeight + kChainLinkViewSpacing )));		SetBounds( cr );	}void	ZObjectCommandChainView::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	// resend this message as 'ovos' - this will select the object in the inspector automatically	// without this class needing to include its header.		if ( msg == kMsgChainLinkClicked )		SendMessage( 'ovos', msgData );}void	ZObjectCommandChainView::SetSize( const short width, const short height ){	ZScrollAwareView::SetSize( width, height );		CalcBounds();}void	ZObjectCommandChainView::DrawLinkArrow( Rect* fromRect, Rect* toRect ){	PenNormal();	RGBForeColor( &gBlack );	MoveTo(( fromRect->left + fromRect->right ) / 2, fromRect->bottom );	LineTo(( toRect->left + toRect->right ) / 2, toRect->top - 1 );	Point	ir;		GetPen( &ir );	ir.h -= 7;	ir.v -= 11;	DrawSICN( 128, 15, ir );}long	ZObjectCommandChainView::CountChainLinks(){	long		 links = 0;	ZCommander*	 temp;		temp = fChainHead;		while( temp )	{		links++;				temp = temp->GetBoss();	}		return links;}void	ZObjectCommandChainView::MakeChainViews(){	ZCommander*					temp;	ZObjectCommandChainLink*	linkView;		Rect			vf;	temp = fChainHead;		SetRect( &vf, 0, 0, 160, kChainLinkViewHeight );		while( temp )	{		OffsetRect( &vf, 0, kChainLinkViewSpacing );				FailNIL( linkView = new ZObjectCommandChainLink( this, &vf, temp ));				if ( temp == fChainHead )			linkView->SetForeColour( &gRed );					linkView->CentreInParent( TRUE, FALSE );		linkView->SetAutoSizing( AUTOSIZE( NONE, AUTOCENTRE, NONE, AUTOCENTRE ));		OffsetRect( &vf, 0, kChainLinkViewHeight );				if ( IsActive())			linkView->Activate();				temp = temp->GetBoss();	}}#pragma mark -extern long			FindMacZoopObject( ZObject* anObject );ZObjectCommandChainLink::ZObjectCommandChainLink( ZView* aParent, Rect* aFrame, ZCommander* linkObject )	: ZView( aParent, aFrame ){	classID = CLASS_ZObjectCommandChainLink;		fLinkObject = linkObject;	AttachBorder( new ZDropShadowBorder());	SetBackColour( &gWhite );	SetForeColour( &gBlack );	SetFontInfo( kFontIDGeneva, 9, 0 );}void	ZObjectCommandChainLink::DrawContent(){	Rect		br;	char*		classname;	Str255		cn;		GetBounds( &br );	br.top += 2;	br.bottom = br.top + 16;		if ( fLinkObject && FindMacZoopObject( fLinkObject ))	{		classname = (char*) typeid( *fLinkObject ).name();				if ( classname )			CopyCToPString( classname, cn );		else			CopyPString( "\p???", cn );					TextFace( bold + underline );		TETextBox( &cn[1], cn[0], &br, teJustCenter );				// display ID & address				RGBForeColor( &gBlack );		OffsetRect( &br, 0, 13 );		TextFace( 0 );		MoveTo( br.left + 2, br.top + 10 );		DrawString( "\pObject ID = " );		NumToString( fLinkObject->GetInstanceID(), cn );		DrawString( cn );		MoveTo( br.left + 2, br.top + 22 );		DrawString( "\pAddr = 0x" );		DrawLongAsHex((long) fLinkObject );	}}void	ZObjectCommandChainLink::ClickContent( const Point mouse, const short modifiers ){	Rect		br;	Point		mp;	Boolean		in, win;		GetBounds( &br );	InvertRect( &br );	win = TRUE;		do	{		GetMouse( &mp );			in = PtInRect( mp, &br );				if ( win != in )			InvertRect( &br );					win = in;	}	while( WaitMouseUp());		if ( win )	{		InvertRect( &br );				SendMessage( kMsgChainLinkClicked, fLinkObject );	}		}