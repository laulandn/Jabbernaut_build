/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZObjectListView.cpp		-- view for listing objects in inspector******			©2000, Graham Cox*****************************************************************************************************/#include	"ZObjectListView.h"#include	"ZScrollView.h"#include	"MacZoop.h"extern ZCommander*	gCurHandler;/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZObjectListView::ZObjectListView( ZView* aParent, Rect* aFrame )	: ZScrollAwareView( aParent, aFrame ){	FontInfo	fi;		FailNIL( fSelection = NewRgn());	fSelLine = -1;	fObjectCount = 0;	SetFontInfo( kFontIDGeneva, 9, 0 );	SetNoBackgroundErase( TRUE );	Focus();	PrepareForDrawing();		GetFontInfo( &fi );	fLineHeight = fi.ascent + fi.descent + fi.leading + 2;	fLineAscent = fi.ascent + 1;		SetScrollAmount( 20, fLineHeight );	CalcBounds();}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZObjectListView::~ZObjectListView(){	if ( fSelection )		DisposeRgn( fSelection );}/*-------------------------------***  DrawContent  ***----------------------------------*//*access:			publicoverrides:		description: 	render the contents of this viewins: 			noneouts: 			nonenotes:			to draw, __OBJECT_DEBUG needs to be 1----------------------------------------------------------------------------------------*/void	ZObjectListView::DrawContent(){#if __OBJECT_DEBUG	ZObject*	zo;	short		line, topLine, botLine, lc;	Rect		cr;	Str255		s;		GetContentRectInBounds( &cr );		// figure out what's visible		line = fLineAscent;	topLine = MAX( 0, ( cr.top / fLineHeight ) - 1 );	botLine = ( cr.bottom / fLineHeight ) + 1;	lc = 0;		// list them:	zo = ZObject::sObjectDebugListHead;		while( zo )	{		if ( lc >= topLine && lc <= botLine )		{			if ( zo == gCurHandler )			{				TextFace( underline );				ForeColor( redColor );			}			else			{				PrepareForDrawing();				TextFace( 0 );			}			NumToString( zo->GetInstanceID(), s );			MoveTo( 3, line );			DrawString( s );						CopyCToPString( typeid( *zo ).name(), s );			MoveTo( 45, line );			DrawString( s );						MoveTo( 175, line );			DrawString( "\p0x");			DrawLongAsHex((long) zo );						MoveTo( 255, line );			zo->GetDebugInfoString( s );			if ( s[0] > 0 )				DrawString( s );		}		++lc;		line += fLineHeight;		zo = zo->next;	}		SetHiliteMode();	InvertRgn( fSelection );#endif}/*-------------------------------***  ClickContent  ***---------------------------------*//*access:			publicoverrides:		description: 	respond to mouse in this viewins: 			<mouse> mouse point local to view's bounds				<modifiers> state of modifier keysouts: 			nonenotes:			handles selection in the view and sends message if changed----------------------------------------------------------------------------------------*/void	ZObjectListView::ClickContent( const Point mouse, const short modifiers ){	RgnHandle	temp;	Point		m, om = { -1, -1 };	short		line, lastLine;		line = lastLine = fSelLine;	FailNIL( temp = NewRgn());		do	{				GetMouse( &m );				if ( DeltaPoint( m, om ))		{			line = CalcSelection( m.v, temp );						if ( line != lastLine )			{				XorRgn( fSelection, temp, fSelection );								SetHiliteMode();				InvertRgn( fSelection );								CopyRgn( temp, fSelection );							lastLine = line;			}						AutoScroll( m );						om = m;		}	}	while( WaitMouseUp());		DisposeRgn( temp );		// if user clicked a new selection, report a change of the selected object		if ( lastLine != fSelLine )	{		fSelLine = lastLine;		SendMessage( kNewObjectSelected, &fSelLine );	}}/*--------------------------------***  SelectLine  ***----------------------------------*//*access:			publicoverrides:		description: 	programatically change the selected line in the viewins: 			<aLine> the line to selectouts: 			nonenotes:			changes selection in the view and sends message if changed----------------------------------------------------------------------------------------*/void	ZObjectListView::SelectLine( const short aLine ){	if ( aLine != fSelLine )	{		Rect		sr;		RgnHandle	temp;				Focus();		PrepareForDrawing();		FocusForContent();		GetBounds( &sr );				sr.top = aLine * fLineHeight;		sr.bottom = sr.top + fLineHeight;				FailNIL( temp = NewRgn());		RectRgn( temp, &sr );		XorRgn( fSelection, temp, fSelection );		SetHiliteMode();		InvertRgn( fSelection );		CopyRgn( temp, fSelection );		DisposeRgn( temp );				fSelLine = aLine;		ScrollAsNeeded( TOPLEFTPOINT( sr ));		SendMessage( kNewObjectSelected, &fSelLine );	}}/*-----------------------------------***  Type  ***-------------------------------------*//*access:			publicoverrides:		description: 	change selection using arrow keysins: 			<theKey> the character code of the key				<modifiers> state of modifier keysouts: 			nonenotes:			changes selection in the view and sends message if changed----------------------------------------------------------------------------------------*/void	ZObjectListView::Type( const char theKey, const short modifiers ){	switch( theKey )	{		case UP_ARROW_KEY:			SelectLine( MAX( 0, fSelLine - 1 ));			break;			case DOWN_ARROW_KEY:			SelectLine( MIN( fSelLine + 1, fObjectCount - 1 ));			break;					default:			ZView::Type( theKey, modifiers );			break;	}}/*--------------------------------***  CalcBounds  ***----------------------------------*//*access:			publicoverrides:		description: 	computes the bounds rect of the viewins: 			noneouts: 			nonenotes:			sets scrollbars of parent to match view height----------------------------------------------------------------------------------------*/void	ZObjectListView::CalcBounds(){	Rect	r;#if __OBJECT_DEBUG		fObjectCount = ZObject::CountInstances();#else	fObjectCount = 0;#endif		GetBounds( &r );	SetBounds( r.right - r.left, fLineHeight * fObjectCount );}/*------------------------------***  CalcSelection  ***---------------------------------*//*access:			publicoverrides:		description: 	forms the region of the selected line based on mouse positionins: 			<vMouse> vertical mouse coordinate				<selRgn> region to set with potential selection regionouts: 			nonenotes:			----------------------------------------------------------------------------------------*/short	ZObjectListView::CalcSelection( const short vMouse, RgnHandle selRgn )	{	short		line;	Rect		sr;		FailNILParam( selRgn );	GetBounds( &sr );		line = MAX( 0, MIN( fObjectCount - 1, vMouse / fLineHeight ));		sr.top = line * fLineHeight;	sr.bottom = sr.top + fLineHeight;		RectRgn( selRgn, &sr );		return line;}