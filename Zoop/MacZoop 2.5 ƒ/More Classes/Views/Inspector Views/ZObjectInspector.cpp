/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZObjectInspector.cpp		-- built-in object inspector for MacZoop******			©2000, Graham Cox*****************************************************************************************************/#include	"ZObjectInspector.h"#include	"ZControlView.h"#include	"ZScrollView.h"#include	"ZObjectListView.h"#include	"ZObjectInfoView.h"#include	"ZObjectListViewHeader.h"#include	"ZObjectCommandChainView.h"#include	"MacZoop.h"extern ZCommander* 	gCurHandler;enum{	kInfoHeaderHeight	= 28};/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZObjectInspector::ZObjectInspector( ZCommander* aBoss, const short windID )	: ZWindow( aBoss, windID ){	classID = CLASS_ZObjectInspector;		fList = NULL;	fInfo = NULL;	fSplit = 112 + kInfoHeaderHeight + 2;	fSplit2 = 240;	fCurHandler = NULL;}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZObjectInspector::~ZObjectInspector(){}/*----------------------------------***  InitZWindow  ***-------------------------------*//*access:			publicoverrides:		description: 	initialise the window - create all the child views that make up the UIins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInspector::InitZWindow(){	ZWindow::InitZWindow();		ZViewEnvironment* env = GetEnvironment();		env->SetThemedTextColour( kThemeTextColorDialogActive );	env->SetBackColour( &gWhite );		// add our child views	// first the list header		Rect	wf;		GetFrame( &wf );		ZObjectListViewHeader*	header;		FailNIL( header = new ZObjectListViewHeader( this, NULL ));		header->SetSize( 0, kInfoHeaderHeight );	header->FitToParentPlusOne( TRUE, FALSE );	header->PlaceAt( -1, -1 );	header->SetAutoSizing( AUTOSIZE( NONE, NONE, NONE, FIXEDRIGHT ));	header->SetUserID( kInspectorHeaderID );		// a scrollview for the list		ZScrollView*	sv;		FailNIL( sv = new ZScrollView( this, NULL, FALSE, TRUE ));		sv->SetSize( 0, fSplit - 3 );	sv->FitToParent( TRUE, FALSE );	sv->ChangeSize( kInfoHeaderHeight - 1, 0, 0, 0 );	sv->SetAutoSizing( AUTOSIZE( NONE, NONE, NONE, FIXEDRIGHT ));	sv->SetBounds( 640, fSplit );	sv->SetUserID( 'scr1' );		// the list itself within the scroller		FailNIL( fList = new ZObjectListView( sv, NULL ));		fList->FitToParent();	ListenTo( fList );		// a scrollview for the info panel		FailNIL( sv = new ZScrollView( this, NULL, FALSE, TRUE, FALSE ));		sv->FitToParent();	sv->ChangeSize( fSplit, 0, fSplit2 - 3 - wf.bottom, 0 );	sv->SetAutoSizing( AUTOSIZE( NONE, NONE, NONE, FIXEDRIGHT ));	sv->SetBounds( 640, fSplit );	sv->SetUserID( 'scr2' );		// and the info panel itself		FailNIL( fInfo = new ZObjectInfoView( sv, NULL ));	ListenTo( fInfo );		fInfo->FitToParent();		// scroller for the command chain view:		FailNIL( sv = new ZScrollView( this, NULL, FALSE, TRUE, TRUE ));		sv->FitToParent();	sv->ChangeSize( fSplit2, 0, 0, 0 );	sv->SetAutoSizing( AUTOSIZE( NONE, NONE, FIXEDBOTTOM, FIXEDRIGHT ));	sv->SetUserID( 'scr3' );	sv->SetBackColour( &gLightGray );		// command chain viewer:		ZObjectCommandChainView*	ccv;		FailNIL( ccv = new ZObjectCommandChainView( sv, NULL ));		ccv->SetUserID( kInspectorChainViewID );	ccv->SetChainHead( gCurHandler );	ListenTo( ccv );		fInfo->SetObject( gApplication );		// listen for object info from the app and set up a polling timer		ListenTo( gApplication );	SetTimer( this, 1, 20 );	}/*--------------------------------***  ReceiveMessage  ***------------------------------*//*access:			publicoverrides:		description: 	respond to messages from objects the window is listening toins: 			<aSender> the sender of the message				<msg> the message itself				<msgData> data associated with the messageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZObjectInspector::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	ZObject*	selectedObject;	ZView*		hv;	short		index;		switch( msg )	{		case kNewObjectSelected:			index = *(short*) msgData;			selectedObject = GetNthMacZoopObject( index );						if ( selectedObject && fInfo)				fInfo->SetObject( selectedObject ); 			break;			case kMsgSwitchedToNewObject:			selectedObject = (ZObject*) msgData;			index = FindMacZoopObject( selectedObject );						if ( index && fList )				fList->SelectLine( index - 1 );			break;			case kMsgDebugObjectDeleted:		case kMsgDebugObjectAdded:			hv = FindChildViewByUserID( kInspectorHeaderID );						if ( hv )				hv->PostRefresh();							case kMsgDebugObjectFocusChanged:			fList->CalcBounds();			fList->PostContentRefresh();			break;	}}/*---------------------------------***  SetViewCursor  ***------------------------------*//*access:			publicoverrides:		description: 	Set the cursor shape for the window viewouts: 			<mouse> the mouse point				<modifiers> state of modifier keysnotes:			----------------------------------------------------------------------------------------*/void	ZObjectInspector::SetViewCursor( const Point mouse, const short modifiers ){	if ( ABS( mouse.v - fSplit ) < 4  ||		 ABS( mouse.v - fSplit2 ) < 4 )		SetCursorShape( HORIZ_SPLIT_CURSOR );	else		SetCursorShape( ARROW_CURSOR );}/*----------------------------------***  ClickContent  ***------------------------------*//*access:			publicoverrides:		description: 	handle a click in the window view - drags the split barouts: 			<mouse> the mouse point				<modifiers> state of modifier keysnotes:			----------------------------------------------------------------------------------------*/void	ZObjectInspector::ClickContent( const Point mouse, const short modifiers ){	if ( ABS( mouse.v - fSplit ) < 4 ||		 ABS( mouse.v - fSplit2 ) < 4 )	{		// drag the split				Rect	cr;		Point	cm, old;		short	spMin, spMax, splitDelta, tSplit, splitID;				if ( ABS( mouse.v - fSplit ) < 4 )		{			splitDelta = fSplit;			tSplit = fSplit - 3;			spMin = kInfoHeaderHeight + 60;			spMax = fSplit2 - 60;			splitID = 1;		}		else		{			splitDelta = fSplit2;			tSplit = fSplit2 - 3;			spMin = fSplit + 60;			spMax = fFrame.bottom - 60;			splitID = 2;		}				Focus();		PenPat( QDGRAYPATTERN );		PenMode( patXor );		PenSize( 1, 3 );		GetContentRect( &cr );		old = mouse;		MoveTo( 0, tSplit );		LineTo( cr.right, tSplit );			do		{			GetMouse( &cm );						if ( DeltaPoint( cm, old ))			{				MoveTo( 0, tSplit );				LineTo( cr.right, tSplit );								tSplit = MAX( spMin, MIN( spMax, cm.v ));							MoveTo( 0, tSplit );				LineTo( cr.right, tSplit );								old = cm;			}		}		while( WaitMouseUp());				MoveTo( 0, tSplit );		LineTo( cr.right, tSplit );				splitDelta = tSplit + 3 - splitDelta;				long upperView, lowerView;				switch ( splitID )		{			case 1:				fSplit = tSplit + 3;				upperView = 'scr1';				lowerView = 'scr2';				break;							case 2:				fSplit2 = tSplit + 3;				upperView = 'scr2';				lowerView = 'scr3';				break;		}				// resize the scrollviews to the new split				if ( splitDelta !=  0 )		{			ZView*	sv;						sv = FindChildViewByUserID( upperView );			if ( sv )				sv->ChangeSize( 0, 0, splitDelta, 0 );							sv = FindChildViewByUserID( lowerView );			if ( sv )				sv->ChangeSize( splitDelta, 0, 0, 0 );							PostRefresh();		}				// erase the gap between the split bars:				Focus();		RGBForeColor( &gWhite );		MoveTo( 0, tSplit + 1 );		LineTo( cr.right, tSplit + 1 );	}	else		ZView::ClickContent( mouse, modifiers );}/*------------------------------------***  DoTimer  ***---------------------------------*//*access:			publicoverrides:		description: 	respond to the timers for this commander - polls for handler changeouts: 			<id> timer ID numbernotes:			----------------------------------------------------------------------------------------*/void			ZObjectInspector::DoTimer( long id ){	// this timer polls for changes in the current handler	// also check if bounds needs recalculating		static long ref = -999;	if ( ref != ZObject::sObjectRefCount )	{		fList->CalcBounds();		fList->PostContentRefresh();		ref = ZObject::sObjectRefCount;				ZView*	hv = FindChildViewByUserID( kInspectorHeaderID );				if ( hv )			hv->PostRefresh();	}	else	{		if ( gCurHandler != fCurHandler )		{			fList->PostContentRefresh();			fCurHandler = gCurHandler;						ZObjectCommandChainView* ccv = (ZObjectCommandChainView*) FindChildViewByUserID( kInspectorChainViewID, TRUE );						if ( ccv )				ccv->SetChainHead( fCurHandler );		}	}	// also check if displayed object has been deleted. If so,	// select the current handler		if ( FindMacZoopObject( fInfo->GetObject()) == 0 )		fInfo->SetObject( gCurHandler );		}void			ZObjectInspector::ReportFields(){	ZWindow::ReportFields();		XSHOWFIELD( fList, ft_objectref );	XSHOWFIELD( fInfo, ft_objectref );	XSHOWFIELD( fSplit, ft_signedshort );	XSHOWFIELD( fCurHandler, ft_objectref );}/*------------------------------***  GetNthMacZoopObject  ***---------------------------*//*access:			publicoverrides:		description: 	find the nth object in the debug chainouts: 			<index> ordinal index of object within debug chainnotes:			The object list displays objects in the same order----------------------------------------------------------------------------------------*/ZObject*		ZObjectInspector::GetNthMacZoopObject( const long index ){	ZObject*	ob = NULL;	long		n = 0;	#if __OBJECT_DEBUG	ob = ZObject::sObjectDebugListHead;		while( ob && ( n != index ))	{		ob = ob->next;		++n;	}#endif	return ob;}/*-------------------------------***  FindMacZoopObject  ***----------------------------*//*access:			globaloverrides:		description: 	inverse to above - finds the index given the objectins:			<anObject> an object in the debug chainouts:			the ordinal position of the object in the chain, or 0 if not foundnotes:			The object list displays objects in the same order----------------------------------------------------------------------------------------*/long			FindMacZoopObject( ZObject* anObject ){	// given an object, returns its ordinal within the list (1-based)	#if __OBJECT_DEBUG		ZObject*	ob = NULL;	long		n = 0;		ob = ZObject::sObjectDebugListHead;		while( ob )	{		++n;		if ( ob == anObject )			return n;				ob = ob->next;	}#endif	return 0;}