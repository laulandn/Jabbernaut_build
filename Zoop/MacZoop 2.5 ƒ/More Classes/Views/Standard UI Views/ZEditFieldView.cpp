/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZEditFieldView.cpp		-- view that allows text input******			©2000, Graham Cox*****************************************************************************************************/#include	"ZEditFieldView.h"#include	"ZWindow.h"#include	"MacZoop.h"DIALOGITEMCONSTRUCTOR( ZEditFieldView );/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZEditFieldView::ZEditFieldView( ZView* aParent, Rect* aFrame, const unsigned short flags )	: ZItemView( aParent, aFrame ){	classID = CLASS_ZEditFieldView;		fMacTE = NULL;	fMacPWTE = NULL;	fFlags = flags;	fMax = 9999;	fMin = 1;	fJustify = teJustLeft;	fDecimals = kEFDefaultDecimalPlaces;		// edit fields black & white by default		SetForeColour( &gBlack );	SetBackColour( &gWhite );	EFInit();}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZEditFieldView::ZEditFieldView( ZView* aParent, const short viewResourceID ){	classID = CLASS_ZEditFieldView;		fMacTE = NULL;	fMacPWTE = NULL;	fFlags = 0;	SetForeColour( &gBlack );	SetBackColour( &gWhite );	ViewResInit( viewResourceID );}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZEditFieldView::~ZEditFieldView(){	if ( fMacTE )		TEDispose( fMacTE );			if ( fMacPWTE )		TEDispose( fMacPWTE );}/*---------------------------------*** DrawContent ***----------------------------------*//*access:			publicoverrides:		description: 	Update the text on demandins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::DrawContent(){	Rect	r;		GetContentRectInBounds( &r );		if ( IsEnabled() && IsActive())		(*fMacTE)->txMode = srcOr;		else		(*fMacTE)->txMode = grayishTextOr;	TEUpdate( &r, fMacTE );}/*---------------------------------*** ClickContent ***---------------------------------*//*access:			publicoverrides:		description: 	handle clicks and drags in the viewins: 			<mouse> mouse position local to bounds				<modifiers> modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::ClickContent( const Point mouse, const short modifiers ){	TEClick( mouse, ( modifiers & shiftKey ) == shiftKey, fMacTE );		if ( fFlags & kEFHiddenChars )	{		(*fMacPWTE)->selStart = (*fMacTE)->selStart;		(*fMacPWTE)->selEnd   = (*fMacTE)->selEnd;	}		SendMessage( kMsgEditFieldClicked, NULL );}/*--------------------------------*** SetViewCursor ***---------------------------------*//*access:			publicoverrides:		description: 	set cursor to iBeam when over the viewins: 			<mouse> mouse position local to frame				<modifiers> modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::SetViewCursor( const Point mouse, const short modifiers ){	if ( IsEnabled())	{		if ( ShouldDrag( mouse, modifiers ))			SetCursorShape( DRAG_CURSOR );		else			SetCursorShape( iBeamCursor );	}	else		ZView::SetViewCursor( mouse, modifiers );}/*---------------------------------*** SetFontInfo ***----------------------------------*//*access:			publicoverrides:		description: 	sets font info for the viewins: 			<fontID> the font				<size> the font size				<aStyle> the font styleouts: 			nonenotes:			updates textEdit to match----------------------------------------------------------------------------------------*/void		ZEditFieldView::SetFontInfo( const short fontID, const short size, const Style aStyle ){	ZView::SetFontInfo( fontID, size, aStyle );		if ( fMacTE )	{		(*fMacTE)->txFont = fontID;		(*fMacTE)->txFace = aStyle;		(*fMacTE)->txSize = size;				FontInfo	fi;				Focus();		PrepareForDrawing();				GetFontInfo( &fi );				(*fMacTE)->lineHeight = fi.ascent + fi.descent + fi.leading;		(*fMacTE)->fontAscent = fi.ascent;				TECalText( fMacTE );	}}/*-----------------------------------*** SetSize ***------------------------------------*//*access:			publicoverrides:		description: 	set TE rects to match frameins: 			<aWidth> new width of frame				<aHeight> new height of frameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::SetSize( const short aWidth, const short aHeight ){	ZView::SetSize( aWidth, aHeight );	Rect	viewRect, destRect;		GetContentRect( &viewRect );		if (( fFlags & kEFBorderless ) == 0 )		InsetRect( &viewRect, 2, 2 );			destRect = viewRect;		if (( fFlags & kEFWrapTextToFrame ) == 0 )		destRect.right += 400;		(*fMacTE)->viewRect = viewRect;	(*fMacTE)->destRect = destRect;	TECalText( fMacTE );}/*-------------------------------*** FocusForContent ***--------------------------------*//*access:			publicoverrides:		description: 	focus for content drawins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::FocusForContent(){	Boolean f = ZItemView::FocusForContent();		(*fMacTE)->inPort = (GrafPtr) GetMacPort();		return f;}/*----------------------------------*** Activate ***------------------------------------*//*access:			publicoverrides:		description: 	handle activationins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void       	ZEditFieldView:: Activate(){	ZView::Activate();		if ( IsInDirectCommandChain())	{		Focus();		PrepareForDrawing();		FocusForContent();		TEActivate( fMacTE );	}}/*----------------------------------*** Deactivate ***----------------------------------*//*access:			publicoverrides:		description: 	handle deactivationins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZEditFieldView::Deactivate(){	ZView::Deactivate();	Focus();	PrepareForDrawing();	FocusForContent();	TEDeactivate( fMacTE );}/*------------------------------------*** Enable ***------------------------------------*//*access:			publicoverrides:		description: 	enable this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::Enable(){	ZView::Enable();	DrawSelfBorder();}/*-----------------------------------*** Disable ***------------------------------------*//*access:			publicoverrides:		description: 	disable this viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::Disable(){	ZView::Disable();	DrawSelfBorder();}/*-------------------------------------*** Type ***-------------------------------------*//*access:			publicoverrides:		description: 	handle user typing when the field is activeins: 			<theKey>	the character to process				<modifiers> modifier keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::Type( const char theKey, const short modifiers ){	if ( theKey == TAB_KEY 		||		 theKey == RETURN_KEY 	||		 theKey == ENTER_KEY 	||		 theKey == ESCAPE_KEY	||		 theKey == PAGE_UP_KEY	||		 theKey == PAGE_DOWN_KEY||		 theKey == HOME_KEY		||		 theKey == END_KEY		||		 theKey == HELP_KEY		||		 ( modifiers & cmdKey ) == cmdKey )		ZView::Type( theKey, modifiers );	else	{		if ( IsEnabled() && IsVisible())		{			char key = theKey;						Focus();			PrepareForDrawing();			FocusForContent();						// here, we need to check filter flags, etc for valid keys. This also			// mutates the char as necessary for password fields, etc.						if ( CheckKey( &key ))			{				MZTEKey( key, fMacTE, modifiers );								// if a password field, echo the original key to the mirror record								if (( fFlags & kEFHiddenChars ) && fMacPWTE )					MZTEKey( theKey, fMacPWTE, modifiers );									SendMessage( kMsgSignalViewTyping, NULL );			}			else			{				if (( fFlags & kEFNoBeep ) == 0 )					SysBeep( 1 );			}		}	}}/*---------------------------------*** UpdateMenus ***----------------------------------*//*access:			publicoverrides:		description: 	enable pertinent commandsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::UpdateMenus(){	gMenuBar->EnableCommand( kCmdSelectAll );		if ( ! EmptySelection())	{		gMenuBar->EnableCommand( kCmdCut );		gMenuBar->EnableCommand( kCmdCopy );		gMenuBar->EnableCommand( kCmdClear );	}		ZView::UpdateMenus();}/*--------------------------------*** BecomeHandler ***---------------------------------*//*access:			publicoverrides:		description: 	become part of command chain, or notins: 			<isBecoming> TRUE if bnecoming the handler, FALSE if notouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::BecomeHandler( Boolean isBecoming ){	ZView::BecomeHandler( isBecoming );		if ( isBecoming )		DoSelectAll();}/*------------------------------*** DoSelectionUpdate ***-------------------------------*//*access:			publicoverrides:		description: 	update the selection when the item becomes the handler, etcins: 			<state> the handler stateouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::DoSelectionUpdate( Boolean state ){	if ( IsVisible())	{		DrawSelfBorder();		Focus();		PrepareForDrawing();		FocusForContent();	}	else	{		SetEmptyRgn( gUtilRgn );		SetClip( gUtilRgn );	}			if ( state )		TEActivate( fMacTE );	else		TEDeactivate( fMacTE );}/*-------------------------------------*** Idle ***-------------------------------------*//*access:			publicoverrides:		description: 	blink caret when activeins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::Idle(){	if ( IsEnabled() && IsActive() && IsVisible())	{		Focus();		PrepareForDrawing();		FocusForContent();		TEIdle( fMacTE );	}}/*---------------------------------*** CanPasteType ***---------------------------------*//*access:			publicoverrides:		description: 	check if paste menu can be enabledins: 			noneouts: 			nonenotes:			password fields do not accept paste command----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::CanPasteType(){	return CheckPasteData();}/*------------------------------------*** DoCut ***-------------------------------------*//*access:			publicoverrides:		description: 	removes selected text from field and puts it on clipboardins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::DoCut(){	if ( ! EmptySelection())	{		gClipboard->Clear();				Focus();		PrepareForDrawing();		FocusForContent();		TECut( fMacTE );				if ( fMacPWTE )			TEDelete( fMacPWTE );		FailOSErr( TEToScrap());		SendMessage( kMsgSignalViewTyping, NULL );	}}/*-----------------------------------*** DoCopy ***-------------------------------------*//*access:			publicoverrides:		description: 	copies selected text to clipboardins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::DoCopy(){	if ( ! EmptySelection())	{		gClipboard->Clear();		TECopy( fMacTE );		FailOSErr( TEToScrap());	}}/*-----------------------------------*** DoPaste ***------------------------------------*//*access:			publicoverrides:		description: 	inserts clipboard text into fieldins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::DoPaste(){	if ( fFlags & kEFHiddenChars )		SysBeep( 1 );	else	{		Focus();		PrepareForDrawing();		FocusForContent();		FailOSErr( TEFromScrap());		TEPaste( fMacTE );				SendMessage( kMsgSignalViewTyping, NULL );	}}/*-----------------------------------*** DoClear ***------------------------------------*//*access:			publicoverrides:		description: 	removes selected text from the fieldins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::DoClear(){	if ( ! EmptySelection())	{		Focus();		PrepareForDrawing();		FocusForContent();		TEDelete( fMacTE );				if ( fFlags & kEFHiddenChars )			TEDelete( fMacPWTE );		SendMessage( kMsgSignalViewTyping, NULL );	}}/*---------------------------------*** DoSelectAll ***----------------------------------*//*access:			publicoverrides:		description: 	selects all of the characters in the fieldins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::DoSelectAll(){	Focus();	PrepareForDrawing();	FocusForContent();		TESetSelect( 0, 32767, fMacTE );		if ( fFlags & kEFHiddenChars )		TESetSelect( 0, 32767, fMacPWTE );}/*-----------------------------------*** SetValue ***-----------------------------------*//*access:			publicoverrides:		description: 	set the field to the value passedins: 			<aValue> number to set as field textouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::SetValue( const long aValue ){	Str255		ns;		NumToString( aValue, ns );	SetValue( ns );}/*----------------------------------*** SetValue ***------------------------------------*//*access:			publicoverrides:		description: 	set the field to the floating point number passedins: 			<aValue> floating point number to set as field textouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::SetValue( const double_t aValue ){	Str255		ns;		RealToString( aValue, ns, fDecimals );	SetValue( ns );}/*-----------------------------------*** SetValue ***-----------------------------------*//*access:			publicoverrides:		description: 	set the field text to the string passedins: 			<aValue> string value to set as field textouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::SetValue( const Str255 aValue ){    // parameter is const but we are intending to modify it locally, so make    // a temporary copy        Str255		tempCopy;        CopyPString( aValue, tempCopy );    ExtractEFParamsFromString( tempCopy );        Focus();    PrepareForDrawing();    FocusForContent();		if (( fFlags & kEFHiddenChars ) == kEFHiddenChars )	{        short   i;        Str255  bulletStr;                // set the text into the real record and put bullets into        // the displayed one        SetDialogItemText((*fMacPWTE)->hText, tempCopy );                // make up string of right number of bullets                i = bulletStr[0] = tempCopy[0];        while( i > 0 )            bulletStr[i--] = '¥';                    SetDialogItemText((*fMacTE)->hText, bulletStr );    }    else	    SetDialogItemText((*fMacTE)->hText, tempCopy );		TECalText( fMacTE );	DrawContent();}/*-----------------------------------*** GetValue ***-----------------------------------*//*access:			publicoverrides:		description: 	returns field entry as an integer valueins: 			noneouts: 			integer value of text in fieldnotes:			----------------------------------------------------------------------------------------*/long		ZEditFieldView::GetValue(){	Str255		ns;	long		v;		GetValueAsText( ns );	StringToNum( ns, &v );		return v;}/*-------------------------------*** GetValueAsFloat ***--------------------------------*//*access:			publicoverrides:		description: 	return field entry as floating point valueins: 			noneouts: 			floating point value of text in fieldnotes:			----------------------------------------------------------------------------------------*/double_t	ZEditFieldView::GetValueAsFloat(){	Str255		ns;	decimal		d;	short		vp, ix = 1;		GetValueAsText( ns );		// make sure it can be read as a null-terminated string		ns[ ns[0] + 1 ] = 0;		str2dec((const char*) ns, &ix, &d, &vp );	return dec2f( &d );}/*-------------------------------*** GetValueAsText ***---------------------------------*//*access:			publicoverrides:		description: 	return field text as pascal stringins: 			<aStr> receives the stringouts: 			nonenotes:			n.b. use of Dialog Manager function here is correct.----------------------------------------------------------------------------------------*/void		ZEditFieldView::GetValueAsText( Str255 aStr ){	if ( fFlags & kEFHiddenChars )		GetDialogItemText((*fMacPWTE)->hText, aStr );	else		GetDialogItemText((*fMacTE)->hText, aStr );}/*----------------------------------*** Validate ***------------------------------------*//*access:			publicoverrides:		description: 	check the entry in the field for validity against flags. ins: 			<showAlert> TRUE if user is shown alert if validity failsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::Validate( Boolean showAlert ){	Boolean valid = TRUE;	short	reason = 0;		if ( ExecuteModifiers( kModifierEFValidate, &valid ))	{		if ( IsEnabled())		{			if ( fFlags & kEFCantBeEmpty )			{				// not valid if this flag set and field empty							Str255	efText;								GetValueAsText( efText );				if ( efText[0] == 0 )				{					reason = kEFIsEmpty;					valid = FALSE;				}			}						if ( valid )			{				long	v = GetValue();								if ( fFlags & ( kEFHasMinValue | kEFHasMaxValue ))				{					// we need to check limits, so do that										if ((( fFlags & kEFHasMinValue ) && ( v < fMin )) ||						(( fFlags & kEFHasMaxValue ) && ( v > fMax )))					{						reason = kEFOutOfRange;						valid = FALSE;					}				}			}		}	}		if ( ! valid )		ValidationAlert( showAlert, reason );			return valid;}/*-----------------------------------*** CheckKey ***-----------------------------------*//*access:			publicoverrides:		description: 	determine if character can be typed into this field.ins: 			<theKey> the character to testouts: 			nonenotes:			may mutate character for some field flags----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::CheckKey( char* theKey ){	Boolean			keyLegal = TRUE;	Boolean			numeric;	Boolean			isControlChar;	Boolean			handleIt;	char			k = *theKey;	EFKeyInfo		mk;	// give a modifier a chance to handle this:		mk.legal = keyLegal;	mk.key = k;		handleIt = ExecuteModifiers( kModifierEFCheckKey, &mk );		keyLegal = mk.legal;	k = mk.key;		if ( handleIt )	{			// if flags are all zero, this is a normal field and all chars are allowed,		// otherwise we're limited to certain sets of characters according to exactly		// which flags are set.				if ( fFlags & 0xFFFE )		{			keyLegal = TRUE;						// these keys are always considered legal:			isControlChar =	( k == BACKSPACE_KEY 	||			                  k == FORWARD_DELETE_KEY   ||						   	  k == UP_ARROW_KEY		||						      k == DOWN_ARROW_KEY	||						      k == LEFT_ARROW_KEY	||						      k == RIGHT_ARROW_KEY 	||						      k == RETURN_KEY		||						      k == ENTER_KEY		||						      k == ESCAPE_KEY );						if ( !isControlChar )			{				numeric = ( k >= '0' && k <= '9' );								// alphabetic only eliminates all ascii chars below the @ symbol:								if ( fFlags & kEFAlphabeticOnly )					keyLegal = ( k >= '@' || k < '0' );									// signed integer allows only numbers and - sign								if ( fFlags & kEFSignedInteger )						keyLegal = numeric || ( k == '-' );								// signed float additionally allows decimal point									if ( fFlags & kEFSignedFloat )					keyLegal = numeric || (k == '-' ) || ( k == '.' );								// unsigned integer disallows - sign									if ( fFlags & kEFUnsignedInteger )					keyLegal = numeric;									// unsigned float allows decimal point but not - sign								if ( fFlags & kEFUnsignedFloat )					keyLegal = numeric || ( k == '.' );								// password field? all chars permitted, but transmutes the character.								if ( fFlags & kEFHiddenChars )				{					// if not a control character, transmute to a bullet:										*theKey = '¥';				}								// count limit? if the next char would exceed the limit, reject it. The				// limit is only applicable if no lower limit flag, as it is stored in the				// min data member								if (( fFlags & ( kEFCharCountLimit + kEFHasMinValue )) == kEFCharCountLimit )				{					// how many chars in field?										short 		chars = (*fMacTE)->teLength;									if ( chars >= fMin )						keyLegal = FALSE;				}			}		}	}	else		*theKey = k;	return keyLegal;}/*--------------------------------*** CheckPasteData ***--------------------------------*//*access:			publicoverrides:		description: 	check if data on clipboard is OK to pasteins: 			noneouts: 			nonenotes:			returns FALSE if and text on clipboard fails CheckKey----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::CheckPasteData(){	Boolean		legalPaste;	char*		testStr;	long		tSize;	Handle		tx;			legalPaste = gClipboard->QueryType( 'TEXT' );	if ( legalPaste )	{				// you can't paste into a password field, so if that flag's set, return FALSE always				if ( fFlags & kEFHiddenChars )			return FALSE;				// in order to check the text, we need to obtain a copy of it				tx = gClipboard->GetData( 'TEXT' );				if ( tx )		{			// to test the text, we scan through it and call CheckKey() for each			// character until it returns FALSE, indicating that a bad char was			// found in the text.							tSize = GetHandleSize( tx );			HLock( tx );			testStr = (char*) *tx;						while( tSize )			{				if ( ! CheckKey( testStr ))				{					legalPaste = FALSE;					break;				}								testStr++;				tSize--;			}			HUnlock( tx );			DisposeHandle( tx );		}		else			legalPaste = FALSE;		// no text, can't paste anyway.	}	return legalPaste;}/*--------------------------------*** EmptySelection ***--------------------------------*//*access:			publicoverrides:		description: 	test whether the selection is emptyins: 			noneouts: 			TRUE if selection empty, FALSE otherwisenotes:			----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::EmptySelection(){	return ((*fMacTE)->selEnd <= (*fMacTE)->selStart );}/*-------------------------------*** SetFontAlignment ***-------------------------------*//*access:			publicoverrides:		description: 	set font alignment of the fieldins: 			<aJust> justification parameter as per TextEdit's usualouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZEditFieldView::SetFontAlignment( short aJust ){	if ( aJust != fJustify )	{		fJustify = aJust;			// realign the view rect as required				Rect	dr;				TESetAlignment( fJustify, fMacTE );		dr = (*fMacTE)->viewRect;				switch( fJustify )		{			case teJustLeft:				dr.right += 2000;				TEAutoView( TRUE, fMacTE );				break;							case teJustCenter:				dr.left -= 1000;				dr.right += 1000;				TEAutoView( FALSE, fMacTE );				break;							case teJustRight:				dr.left -= 2000;				TEAutoView( FALSE, fMacTE );				break;		}				(*fMacTE)->destRect = dr;		TECalText( fMacTE );		PostContentRefresh();	}}/*----------------------------------*** ShouldDrag ***----------------------------------*//*access:			publicoverrides:		description: 	test whether user can dragins: 			mouse position and modifiersouts: 			TRUE to drag, else FALSEnotes:			----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::ShouldDrag( const Point mouse, const short modifiers ){	Boolean doDrag = FALSE;		if ( fFlags & kEFAllowDragSend )	{		TEGetHiliteRgn( gUtilRgn, fMacTE );		doDrag = PtInRgn( mouse, gUtilRgn );	}		return doDrag;}/*------------------------------*** MakeDragRegion ***----------------------------------*//*access:			publicoverrides:		description: 	create the drag outlineins: 			<aRgn> receives the local version of the regionouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::MakeDragRegion( RgnHandle aRgn ){	TEGetHiliteRgn( aRgn, fMacTE );}/*--------------------------------*** MakeDragData ***----------------------------------*//*access:			publicoverrides:		description: 	add drag data to the dragins: 			<theDrag> the drag to add to				<modifiers> modifiers keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::MakeDragData( const DragReference theDrag, const short modifiers ){	Handle	iData;	long	tLength;	char	hs;		// copy selected text to handle:		tLength = (*fMacTE)->selEnd - (*fMacTE)->selStart;		if ( tLength )	{		iData = (*fMacTE)->hText;				hs = HGetState( iData );		HLock( iData );		AddDragItemFlavor( theDrag, 1, 'TEXT', *iData + (*fMacTE)->selStart, tLength, 0 );		HSetState( iData, hs );	}}/*-------------------------------*** AcceptsFlavour ***---------------------------------*//*access:			publicoverrides:		description: 	check if drag flavour is OK with usins: 			<aFlavour> one of the drag flavours to testouts: 			TRUE if we can receive this flavournotes:			----------------------------------------------------------------------------------------*/Boolean		ZEditFieldView::AcceptsFlavour( const OSType aFlavour ){	return (( fFlags & kEFAllowDragReceive ) && ( aFlavour == 'TEXT' ) && ( sCurTxDragSender != this ));}/*------------------------------------*** Drop ***--------------------------------------*//*access:			publicoverrides:		description: 	process data item dropped on the viewins: 			<flavour> flavour to process				<data> the data				<dataSize> length of data				<theDrag> the drag reference of the dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::Drop( const OSType flavour, const Ptr data, const long dataSize, const DragReference theDrag ){	if ( flavour == 'TEXT' )	{		// replace entire field contents with text dropped				TESetText( data, dataSize, fMacTE );		PostContentRefresh();		SendMessage( kMsgSignalViewTyping, NULL );	}}/*------------------------------***  InitViewFromResource  ***--------------------------*//*access:			publicoverrides:		description: 	initialise the view from data in a 'View' resource handleins: 			<theRes> handle to 'View' resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::InitViewFromResource( Handle theRes ){	FailNILParam( theRes );		ZItemView::InitViewFromResource( theRes );		EditFieldTemplateHdl	efH = (EditFieldTemplateHdl) theRes;		fJustify = (*efH)->justify;	fDecimals = (*efH)->decimals;	fFlags = 0;		if ((*efH)->noBorder )		fFlags |= kEFBorderless;	if ((*efH)->sIntField )		fFlags |= kEFSignedInteger;		if ((*efH)->sFloatField )		fFlags |= kEFSignedFloat;		if ((*efH)->uIntField )		fFlags |= kEFUnsignedInteger;		if ((*efH)->uFloatField )		fFlags |= kEFUnsignedFloat;		if ((*efH)->hasMin )		fFlags |= kEFHasMinValue;		if ((*efH)->hasMax )		fFlags |= kEFHasMaxValue;		if ((*efH)->alphabetic )		fFlags |= kEFAlphabeticOnly;		if ((*efH)->passwordField )		fFlags |= kEFHiddenChars;		if ((*efH)->charCount )		fFlags |= kEFCharCountLimit;	if ((*efH)->noEmpty )		fFlags |= kEFCantBeEmpty;		if ((*efH)->noBeep )		fFlags |= kEFNoBeep;		if ((*efH)->wrapText )		fFlags |= kEFWrapTextToFrame;			EFInit();}/*-------------------------------***  CreateViewResource  ***---------------------------*//*access:			publicoverrides:		description: 	Fills in the resource handle according to its templated structureins: 			<resHandle> valid handle of adequate sizeouts: 			nonenotes:			This method should only be used by the RAD tool to create View resources				(not for application use)----------------------------------------------------------------------------------------*/void		ZEditFieldView::CreateViewResource( Handle resHandle ){	FailNILParam( resHandle );		if ( GetHandleSize( resHandle ) < sizeof( EditFieldTemplate ))		FailOSErr( kViewTemplateHandleSizeTooSmallErr );			EditFieldTemplateHdl	efH = (EditFieldTemplateHdl) resHandle;		(*efH)->justify = fJustify;	(*efH)->decimals = fDecimals;		(*efH)->noBorder 		= ( fFlags & kEFBorderless )? 		TRUE : FALSE;	(*efH)->sIntField 		= ( fFlags & kEFSignedInteger )? 	TRUE : FALSE;	(*efH)->sFloatField 	= ( fFlags & kEFSignedFloat )? 		TRUE : FALSE;	(*efH)->uIntField 		= ( fFlags & kEFUnsignedInteger )? 	TRUE : FALSE;	(*efH)->uFloatField 	= ( fFlags & kEFUnsignedFloat )? 	TRUE : FALSE;	(*efH)->hasMin 			= ( fFlags & kEFHasMinValue )? 		TRUE : FALSE;	(*efH)->hasMax 			= ( fFlags & kEFHasMaxValue )? 		TRUE : FALSE;	(*efH)->alphabetic 		= ( fFlags & kEFAlphabeticOnly )? 	TRUE : FALSE;	(*efH)->passwordField 	= ( fFlags & kEFHiddenChars )? 		TRUE : FALSE;	(*efH)->charCount 		= ( fFlags & kEFCharCountLimit )? 	TRUE : FALSE;	(*efH)->noEmpty 		= ( fFlags & kEFCantBeEmpty )? 		TRUE : FALSE;	(*efH)->noBeep 			= ( fFlags & kEFNoBeep )? 			TRUE : FALSE;	(*efH)->wrapText 		= ( fFlags & kEFWrapTextToFrame )? 	TRUE : FALSE;		ZItemView::CreateViewResource( resHandle );}/*-------------------------------*** GetNewTextHandle ***-------------------------------*//*access:			publicoverrides:		description: 	returns a new handle with the copy of the field's textins: 			noneouts: 			the handlenotes:			Caller is responsible for disposing this handle----------------------------------------------------------------------------------------*/Handle		ZEditFieldView::GetNewTextHandle(){	Handle		th;		th = (*fMacTE)->hText;			FailOSErr( HandToHand( &th ));		return th;}/*---------------------------------*** ReportFields ***---------------------------------*//*access:			publicoverrides:		description: 	report data members to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::ReportFields(){	ZItemView::ReportFields();		XSHOWFIELD( fMacTE, ft_Handle );	XSHOWFIELD( fMacPWTE, ft_Handle );	XSHOWFIELD( fFlags, ft_unsignedshort );	XSHOWFIELD( fJustify, ft_signedshort );}/*------------------------------------*** EFInit ***------------------------------------*//*access:			protectedoverrides:		description: 	initialise the TE stuff, etcins: 			noneouts: 			nonenotes:			this may be called more than once if needed----------------------------------------------------------------------------------------*/void		ZEditFieldView::EFInit(){	Rect	viewRect, destRect;		Focus();	PrepareForDrawing();		GetContentRect( &viewRect );		if (( fFlags & kEFBorderless ) == 0 )		InsetRect( &viewRect, 2, 2 );			destRect = viewRect;	if (( fFlags & kEFWrapTextToFrame ) == 0 )		destRect.right += 2000;		if ( fMacTE == NULL )	{		FailNIL( fMacTE = TENew( &destRect, &viewRect ));				TEAutoView( TRUE, fMacTE );				if (( fFlags & kEFWrapTextToFrame ) == 0 )			(*fMacTE)->crOnly = -1;	}		if (( fFlags & kEFHiddenChars ) && ( fMacPWTE == NULL ))	{		OffsetRect( &viewRect, -30000, -30000 );		OffsetRect( &destRect, -30000, -30000 );		FailNIL( fMacPWTE = TENew( &destRect, &viewRect ));	}		SetCanBeHandler( TRUE );	SetRefreshOnResize( TRUE );		if (( fFlags & kEFBorderless ) == 0 )		SetStandardBorder( TRUE );}/*-------------------------------*** ValidationAlert ***--------------------------------*//*access:			protectedoverrides:		description: 	display validation alert as neededins: 			<showAlert> show the alert (otherwise beep)				<reason> a reason code for the alert - this assists in wording it.outs: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZEditFieldView::ValidationAlert( const Boolean showAlert, const short reason ){	// invalid field, so show alert if wanted and abort	// set the value in the field to a legal one...		long			val;	short			alertID;	val = GetValue();		// select ourselves...	if ( CanBeHandler() && !IsInDirectCommandChain() && IsEnabled())	{		SendMessage( kMsgRequireSelectionForValidation, NULL );		GetRootWindow()->SelectHandlingView( this );		GetRootWindow()->Select();		GetRootWindow()->PerformUpdate();	}					// show the alert...	if ( showAlert )	{		Str15 	ma, mb;		Str32	sa, sb;				switch ( reason )		{			case kEFOutOfRange:				alertID = kFieldRangeAlertID;				NumToString( fMin, ma );				NumToString( fMax, mb );								if (( fFlags & ( kEFHasMinValue + kEFHasMaxValue )) ==							   ( kEFHasMinValue + kEFHasMaxValue ))				{					GetIndString( sa, kEditFieldValidationStringsID, kEditFieldIsBetween );					GetIndString( sb, kEditFieldValidationStringsID, kEditFieldAnd );				}				else				{					sb[0] = 0;					mb[0] = 0;										if ( fFlags & kEFHasMinValue )						GetIndString( sa, kEditFieldValidationStringsID, kEditFieldIsGreaterThan );					else					{						GetIndString( sa, kEditFieldValidationStringsID, kEditFieldIsLessThan );						NumToString( fMax, ma );					}				}				break;							case kEFIsEmpty:				alertID = kEditFieldEmptyAlertID;				break;		}				ParamText( sa, ma, sb, mb );				// it would be nice to position the alert just above the field in question, so		// that a) it's not obscured, and b) it's clearer which one is meant. This involves		// directly modifying the rect in the ALRT resource here...				AlertTHndl		alertTemplateH = (AlertTHndl) GetResource( 'ALRT', alertID );				if ( alertTemplateH )		{			HNoPurge((Handle) alertTemplateH );						Rect	ar, efr;						Focus();			GetContentRect( &efr );			LocalToGlobal( &TOPLEFTPOINT( efr ));			LocalToGlobal( &BOTTOMRIGHTPOINT( efr ));					ar = (*alertTemplateH)->boundsRect;					CentreRects( &efr, &ar );			OffsetRect( &ar, 0, -(( ar.bottom - ar.top ) / 2 ) - ( efr.bottom - efr.top ) - 2 );						// protect against going off the top of the screen:						if ( ar.top < GetMBarHeight())				OffsetRect( &ar, 0, ( ar.bottom - ar.top ) + ( efr.bottom - efr.top ) + 24 );						(*alertTemplateH)->boundsRect = ar;						ChangedResource((Handle) alertTemplateH );		}				// show the alert or post notification:				NotifyAlert( alertID );	}	else	{		if (( fFlags & kEFNoBeep ) == 0 )			SysBeep( 1 );	}		if ( reason == kEFOutOfRange )	{		// set nearest valid value		SetValue( MIN( MAX( val, fMin ), fMax ));		DoSelectAll();	}}/*---------------------------*** ExtractEFParamsFromString ***--------------------------*//*access:			protectedoverrides:		description: 	set up flags and limits based on special characters in formatted stringins: 			<efText> string to parse, is modified to remove extra dataouts: 			nonenotes:			called when view built from parameterised string in a dialog box----------------------------------------------------------------------------------------*/void		ZEditFieldView::ExtractEFParamsFromString( Str255 efText ){	register char	cc = 1, dc;	unsigned char	stPart, ssLen;	long			temp;	Str15			subStr;		do	{		// scan forward looking for two forward slashes				if (( efText[cc] == '/' ) && ( efText[cc + 1] == '/' ))		{			// found two consecutive slashes- note the length of the info and scan for			// delimiters						stPart = 0;			ssLen = efText[0] - cc + 1;						// string will consist of up to three numbers, separated by commas.			// the first number is the flags field, the second (optional) the			// min limit, and the third (optional) the max limit						cc += 2;				dc = cc;						while( dc <= efText[0] )			{				// scan for the next comma or end of string:							if (( dc >= efText[0] ) || ( efText[ dc + 1 ] == ',' ))				{	 					// found a segment- extract it into subStr and convert to number										subStr[0] = dc - cc + 1;					BlockMoveData( &efText[cc], &subStr[1], dc - cc + 1 );					StringToNum( subStr, &temp );										// assign it to the relevant parameter										switch( stPart )					{						case 0:							fFlags = temp;							break;												case 1:							fMin = temp;							break;													case 2:							fMax = temp;							break;					}										stPart++;					cc = dc + 2;					dc = cc - 1;				}								dc++;				}						// remove extra data from string:						efText[0] -= ssLen;				break;		}	}	while( ++cc <= efText[0] );		// if flags have changed (likely) - make sure everything is in place	EFInit();}