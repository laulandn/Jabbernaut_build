/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZProgressBarView.cpp		-- a progress indicator view******			©2000, Graham Cox*****************************************************************************************************/#include	"ZProgressBarView.h"#include	"MacZoop.h"/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZProgressBarView::ZProgressBarView( ZView* aParent, Rect* aFrame, const long max, ProgType barType )	: ZItemView( aParent, aFrame ){	fMode = barType;	if ( max == 0 )		fMax = 100;	else		fMax = max;	fValue = 0;	fStripesPat = NULL;	fBackPatID = kStdProgressBarBackPattern;	fForePatID = kStdProgressBarPattern;	FailNILRes( fStripesPat = GetPixPat( kStdProgressBarStripedPattern ));	FillInTrackInfo();		SetAcceptsMouseClicks( FALSE );	SetNoBackgroundErase( TRUE );		if ( !gMacInfo.hasAppearanceMgr )	{		// appearance draws its border inside the bounds, but classic		// draws it outside, so fix things up to look the same:				ChangeSize( 2, 2, -2, -2 );		SetStandardBorder( TRUE );	}}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZProgressBarView::~ZProgressBarView(){	if ( fStripesPat )		DisposePixPat( fStripesPat );}/*-------------------------------***  DrawContent  ***----------------------------------*//*access:			publicoverrides:		description: 	draw the progress barins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZProgressBarView::DrawContent(){#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		FillInTrackInfo();		DrawThemeTrack( &fTrackInfo, NULL, NULL, 0 );	}	else	{#endif		DrawEmptyBar();		UpdateBar();#if APPEARANCE_MGR_AWARE	}#endif}/*---------------------------------***  SetValue  ***-----------------------------------*//*access:			publicoverrides:		description: 	set the bar's valueins: 			<aVal> new valueouts: 			nonenotes:			in indeterminate mode, will cause animation----------------------------------------------------------------------------------------*/void		ZProgressBarView::SetValue( const long aVal ){	if ( fMode == kIndeterminateProgress )		Animate();	else	{		if ( fValue != aVal )		{			fValue = MIN( fMax, aVal );						Focus();			PrepareForDrawing();			FocusForContent();					#if APPEARANCE_MGR_AWARE			if ( gMacInfo.hasAppearanceMgr )				DrawContent();			else			{			#endif						Rect			r, barBox;				short			barLength;								GetBounds( &r );								barLength = (short)(((double) fValue / (double) fMax ) * (long)( r.right - r.left ));							barBox = r;				barBox.right = MIN( barBox.left + barLength, r.right );							// if this is different to the previously calculated bar, repaint it							if (! EqualRect( &fBarRect, &barBox ))				{					if ( EmptyRect( &fBarRect ) || ( barBox.right < fBarRect.right ))						DrawEmptyBar();					fBarRect = barBox;					UpdateBar();				}		#if APPEARANCE_MGR_AWARE			}		#endif				}	}}/*--------------------------------***  SetMaximum  ***----------------------------------*//*access:			publicoverrides:		description: 	set the bar's maximum valueins: 			<aMax> new max. Bar length depends on this and valueouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZProgressBarView::SetMaximum( const long aMax ){	if ( fMax != aMax )	{		fMax = aMax;		PostRefresh();	}}/*----------------------------------***  Animate  ***-----------------------------------*//*access:			publicoverrides:		description: 	in indeterminate mode, call repeatedly to animate the barins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZProgressBarView::Animate(){	if ( fMode == kIndeterminateProgress )	{		Focus();		PrepareForDrawing();		FocusForContent();		#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )		{			static long lt = 0;						if ( TickCount() > lt + 3 )			{				lt = TickCount();							++fPhase;				DrawContent();			}		}		else		{	#endif			ShiftCPattern( fStripesPat );			UpdateBar();		#if APPEARANCE_MGR_AWARE		}	#endif		}}/*-------------------------------***  SetDisplayMode  ***-------------------------------*//*access:			publicoverrides:		description: 	set the mode for the barins: 			<aMode> new modeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZProgressBarView::SetDisplayMode( ProgType aMode ){	if ( fMode != aMode )	{		fMode = aMode;		SetRect( &fBarRect, 0, 0, 0, 0 );		PostRefresh();	}}/*--------------------------------***  DrawEmptyBar  ***--------------------------------*//*access:			publicoverrides:		description: 	draw bar backgroundins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZProgressBarView::DrawEmptyBar(){	Rect	r;		GetBounds( &r );#if APPEARANCE_MGR_AWARE	if ( ! gMacInfo.hasAppearanceMgr )	{#endif			PixPatHandle	backPP;				FailNILRes( backPP = GetPixPat( fBackPatID ));				FillCRect( &r, backPP );		DisposePixPat( backPP );#if APPEARANCE_MGR_AWARE	}#endif}/*---------------------------------***  UpdateBar  ***----------------------------------*//*access:			publicoverrides:		description: 	draw bar foregroundins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZProgressBarView::UpdateBar(){	Rect	r;		GetBounds( &r );		if ( fMode == kIndeterminateProgress )		FillCRect( &r, fStripesPat );	else	{		PixPatHandle	forePP;			FailNIL( forePP = GetPixPat( fForePatID ));			FillCRect( &fBarRect, forePP );		DisposePixPat( forePP );	}}/*-----------------------------***  FillInTrackInfo  ***--------------------------------*//*access:			protectedoverrides:		description: 	when using appearance, fill in the theme info record according to the				view's state, value, etc.ins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZProgressBarView::FillInTrackInfo(){#if APPEARANCE_MGR_AWARE	Rect r;		GetBounds( &r );		fTrackInfo.kind = ( fMode == kProportionalProgress )? kThemeProgressBar : kThemeIndeterminateBar;	fTrackInfo.bounds = r;	fTrackInfo.min = 0;	fTrackInfo.max = fMax;	fTrackInfo.value = fValue;	fTrackInfo.reserved = 0;	fTrackInfo.attributes = ( r.right > r.bottom )? kThemeTrackHorizontal : 0;	fTrackInfo.enableState = (IsActive() && IsEnabled())? kThemeTrackActive : kThemeTrackDisabled;	fTrackInfo.trackInfo.progress.phase = ( fMode == kProportionalProgress )? 0 : (( fPhase & 3 ) + 1 );#endif}#pragma mark - /*-------------------------***  CreateNewProgressBarView  ***---------------------------*//*access:			globaloverrides:		description: 	create progress bar from set of parameters passedins: 			<aParent> the view's parent				<aFrame> the view's frame				<pCount> parameter count				<params> parametersouts: 			the progress view objectnotes:			Can be registered as dialog item constructor function----------------------------------------------------------------------------------------*/ZView*		CreateNewProgressBarView( ZView* aParent, Rect* aFrame, short pCount, long params[] ){	// "magic" parameters to this object are:	// 0: mode, 0 = proportional, 1 = indeterminate	// 1: max value ( 0 = max is 100 )	ZProgressBarView*	pb;		FailNIL( pb = new ZProgressBarView( aParent, aFrame, params[1], (ProgType) params[0] ));	return pb;}