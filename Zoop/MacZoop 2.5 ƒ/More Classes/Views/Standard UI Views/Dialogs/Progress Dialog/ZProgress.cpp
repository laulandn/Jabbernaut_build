/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZProgress.cpp		-- a progress dialog******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZProgress.h"#include	"ZProgressBarView.h"#include	"MacZoop.h"/*-----------------------------***  CONSTRUCTOR  ***------------------------------------*/// this is an alternative constructor to set the striped/proportional mode explicitly, or// you can use the other constructor passing a negative value to default to striped mode.ZProgress::ZProgress( 	ZCommander* aBoss,			  			const short dialogID,			   			const long maxValue,			   			const short pType,			   			const ProgType aMode )	: ZViewDialog( aBoss, dialogID ){	classID = CLASS_ZProgress;	theType = pType;		// make sure bar item is registered:		ZViewDialog::RegisterDialogItem( CreateNewProgressBarView, kMagicStringProgressBar, kInitItemWithMagicParams );		// how many InformProgress() calls between handling an event?		evtProcRatio = 3;	evtProcCount = evtProcRatio;		deferTime = 0;	createTime = TickCount();	fAbort = FALSE;	estTicksToFinish = -1;		SetBeachBallCursor();	InitZWindow();	SetMaximum( kBarItem, maxValue );	SetMode( aMode );}/*-----------------------------***  CONSTRUCTOR  ***------------------------------------*/ZProgress::ZProgress()	: ZViewDialog(){	classID = CLASS_ZProgress;	theType = kCancelType;		// make sure bar item is registered:		ZViewDialog::RegisterDialogItem( CreateNewProgressBarView, kMagicStringProgressBar, kInitItemWithMagicParams );	evtProcRatio = 3;	evtProcCount = evtProcRatio;		deferTime = 0;	createTime = TickCount();	fAbort = FALSE;	estTicksToFinish = -1;		SetBeachBallCursor();	InitZWindow();}			/*------------------------------***  DESTRUCTOR  ***------------------------------------*/ZProgress::~ZProgress(){#if _AUTO_WPOS_FOR_DIALOGS	SavePosition();#endif	Hide();}/*---------------------------------***  SETUP  ***--------------------------------------*//*	overrides ZDialog to set up the button and bar according to the type----------------------------------------------------------------------------------------*/void		ZProgress::SetUp(){	// set up the text of the button to the requested type of dialog		fDefaultItem = fEscapeItem = 0;	if ( theType == kNoButton )		HideItem( kCancelButton );	else	{		// the button is visible, but maybe its text is different.		// By default it is Cancel, but may need to say "Stop"				if ( theType == kStopType )		{			Str31	stopStr;						GetIndString( stopStr, 128, kStopStringID );			SetItemTitle( kCancelButton, stopStr );		}	}	// call inherited SetUp in case base class wants to do something	ZViewDialog::SetUp();}/*-------------------------------***  CLICKITEM  ***------------------------------------*//*	set the abort flag if the user clicked cancel or stop----------------------------------------------------------------------------------------*/void		ZProgress::ItemClicked( const short theItem ){	fAbort = ( theItem == kCancelButton );		#if _CANCEL_PROGRESS_THROWS_EXCEPTION		if ( fAbort )		FailOSErr( userCanceledErr );			#endif}/*-----------------------------***  INFORMPROGRESS  ***---------------------------------*//*	called to keep the progress dialog moving as a lengthy operation proceeds----------------------------------------------------------------------------------------*/Boolean		ZProgress::InformProgress( const long progressSoFar ){	CGrafPtr	savePort;	GDHandle	saveDevice;		// save the current port and device in case we were called from	// some function that had changed it. Note that the caller should be	// aware that the port, device, etc MAY not be exactly preserved	// across calls to this, since this processes events, etc.		GetGWorld( &savePort, &saveDevice );	SetGWorld( GetMacPort(), GetMainDevice());		// if it is time to show the progress dialog, make it visible		if (( TickCount() > ( createTime + deferTime )) && !IsVisible())	{		Select();		PerformUpdate();		SetBusyArrowCursor();	}			// let the application handle any pending event, so we get updated, etc. etc	// any exceptions arising are handled by the caller. Note that in the	// event of an exception, the device is set to the main device, which	// is possibly safer, though if the caller knows different, it should	// try to do the right thing.		// N.B. This is now "geared" down to prevent the progress-monitored function from going	// too slowly. This processes one event for every <n> calls of this method, where <n> is	// set by <evtProcRatio>. This defaults to 1, but you can change it to anything you want	// from 1->32768.		evtProcCount--;		if ( evtProcCount <= 0 )	{		gApplication->ProcessAllEvents();		evtProcCount = evtProcRatio;	}		// redraw the progress bar & time remaining info		if ( IsVisible())	{		Focus();		SetValue( kBarItem, progressSoFar );		EstimateCompletionTime();		UpdateTimeToComplete();	}	// restore what we think is the port and device		SetGWorld( savePort, saveDevice );	return !fAbort;	// carry on until this flag is set}/*--------------------------------***  SETDELAY  ***------------------------------------*//*	set the initial deferment delay----------------------------------------------------------------------------------------*/void		ZProgress::SetDelay( const short delayTicks ){	deferTime = delayTicks;}/*-------------------------------***  SETMESSAGE  ***-----------------------------------*//*	set the message string to the string passed----------------------------------------------------------------------------------------*/void		ZProgress::SetMessage( const Str255 aMsg ){	SetValue( kMessageItem, aMsg );}/*-------------------------------***  SETMESSAGE  ***-----------------------------------*//*	set the message to the STR# resource with ID and index passed----------------------------------------------------------------------------------------*/void		ZProgress::SetMessage( const short resID, const short index ){	Str255	aStr;		GetIndString( aStr, resID, index );	SetMessage( aStr );}/*------------------------------***  ResetMaximum  ***----------------------------------*//*	set a new max for the bar----------------------------------------------------------------------------------------*/void		ZProgress::ResetMaximum( const long maxValue ){	SetMaximum( kBarItem, maxValue );}/*---------------------------------***  SETMODE  ***------------------------------------*//*	set the progress mode (proportional or indeterminate)----------------------------------------------------------------------------------------*/void		ZProgress::SetMode( ProgType aMode ){	ZProgressBarView*	pb;		pb = dynamic_cast<ZProgressBarView*>( GetItem( kBarItem ));		if ( pb )	{		pb->SetDisplayMode( aMode );				// hide time info for indeterminate mode				if ( aMode == kIndeterminateProgress )		{			HideItem( kTimeRemLabel );			HideItem( kEstTimeDisplay );		}		else		{			ShowItem( kTimeRemLabel );			ShowItem( kEstTimeDisplay );		}	}}/*-----------------------------------***  TYPE  ***-------------------------------------*//*	maps command-period to the cancel/stop button, unless a kNoButton type----------------------------------------------------------------------------------------*/void		ZProgress::Type( const char theKey, const short modifiers ){	if ( theType != kNoButton )	{		if (( theKey == '.' ) &&			( modifiers & cmdKey ) == cmdKey )			FakeClick( kCancelButton );	}}/*--------------------------***  ESTIMATECOMPLETIONTIME  ***----------------------------*//*estimates the time to complete based on the amount completed and the time taken so far.This updates <estTicksToFinish>, and does not directly display this information anywhere.n.b. if <estTicksToFinish> is -1, the time has not been calculated yet.----------------------------------------------------------------------------------------*/void		ZProgress::EstimateCompletionTime(){	// wait until at least 3% of the bar has been drawn, otherwise the time estimate	// is wildly exaggerated, due to insufficient sample data.	long  max, value;		value = GetValue( kBarItem );	max = GetMaximum( kBarItem );		if ((( value * 100 ) / max ) > 3 )	{		unsigned long	ticksTakenSoFar = TickCount() - createTime;		float			currentRate = (float) ticksTakenSoFar / (float) value;		long			newEst = (long)( currentRate * (float)( max - value ));				// only increase the current estimate if it's greater by more than 20 seconds,		// since it may have been just down to a temporary pause...				if ( estTicksToFinish == -1 || ( newEst < estTicksToFinish ) || newEst > ( estTicksToFinish + 1 ))			estTicksToFinish = newEst;	}}/*---------------------------***  UPDATETIMETOCOMPLETE  ***-----------------------------*//*sets up the "Time Remaining:" string. This checks <estTicksToFinish>, and builds asuitable string. This is called every time InformProgress is called, but only resets thestring when it needs to, based on the time resolution indicated.----------------------------------------------------------------------------------------*/void		ZProgress::UpdateTimeToComplete(){	// the default behaviour is similar to the MacOS 8.x Finder. The string will be	// moderately vague in the interests of user friendliness "About a minute", etc.		if ( estTicksToFinish == -1 )		return;		static long	updateTicks = 0;	short		days, hours, minutes, seconds;		days 	=   estTicksToFinish / 5184000L;	hours 	= ( estTicksToFinish - ( days * 5184000L )) / 216000L;	minutes = ( estTicksToFinish - ( days * 5184000L ) - ( hours * 216000L )) / 3600L;	seconds = ( estTicksToFinish - ( days * 5184000L ) - ( hours * 216000L ) - ( minutes * 3600L )) / 60L;		// determine if it's time to update yet. We only update if it appears sensible to bother, based on	// the sort of time we're looking at, or once per minute, whichever is less.		if ( TickCount() >= updateTicks )	{		// decide the form of the string, based on the time				Str255	estStr;		Str15	xx, yy;		short	idx = 0;				xx[0] = 0;		yy[0] = 0;				if ( days )		{			// "more than 24 hours"						idx = 1;			goto setEstTimeStr;		}				if ( hours >= 8 )		{			// "more than x hours"					NumToString( hours, xx );			idx = 2;			goto setEstTimeStr;		}				if ( estTicksToFinish > 252000L  )		// > 1hr, 10 minutes		{			// "about x hours, y minutes"						NumToString( hours, xx );			NumToString( minutes, yy );			idx = 3;			goto setEstTimeStr;		}				if ( estTicksToFinish > 198000L )	// > 55 minutes		{			// "about an hour"			idx = 4;			goto setEstTimeStr;		}				if ( estTicksToFinish > 144000L )	// > 40 minutes		{			// "less than an hour"						idx = 5;			goto setEstTimeStr; 		} 		 		if ( estTicksToFinish > 4200L )		// > 1 minute, 10 sec	 		{ 			// "about x minutes, y seconds 						NumToString( minutes, xx );			NumToString( seconds, yy );						if ( minutes == 1 )				idx = 11;			else				idx = 6;			goto setEstTimeStr; 		} 		 		if ( estTicksToFinish > 3000L )		// > 50 seconds 		{ 			// "about a minute" 			 			idx = 7;			goto setEstTimeStr; 		} 		 		if ( estTicksToFinish > 1500L )		// > 25 seconds 		{ 			// "less than a minute" 			 			idx = 8;				goto setEstTimeStr; 		} 		 		if ( estTicksToFinish > 120L )		// > 2 seconds 		{ 			NumToString( seconds, xx ); 			idx = 9; 			goto setEstTimeStr; 		} 		 		idx = 10;		setEstTimeStr:		GetIndString( estStr, kTimeEstimateStrID, idx );		ParamText( NULL, NULL, xx, yy );		SetValue( kEstTimeDisplay, estStr );				updateTicks = TickCount() + 60;	}}