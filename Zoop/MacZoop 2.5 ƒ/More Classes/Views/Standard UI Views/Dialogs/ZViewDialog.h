/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZViewDialog.h		-- dialog based on views******			©2000, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZVIEWDIALOG__#define	__ZVIEWDIALOG__#include	"ZWindow.h"#include	"MZDialogTypes.h"#include	<fp.h>class	ZClassRegistry;class	ZItemView;// the dialog:DEFINECLASSID( ZViewDialog, 'zvdg' );// the class:class	ZViewDialog	: public ZWindow{protected:	short				fDefaultItem;		// item number of default item	short				fEscapeItem;		// item number of cancel or escape item	short				fDITLid;			// DITL id used to build items	short				fLastClickItem;		// item last clicked	short				fBaseCount;			// count of base items	Boolean				fModal;				// true if this is a modal dialog	Boolean				fInline;			// true if this dialog is inline (i.e. caller disposes)	Boolean				fEnableAccel;		// if TRUE, dialog automatically provides control accelerators	WindowPlacing		fAutoPos;			// automatic window placement code	ZArray*				fAuxItemInfo;		// switch grouping, accel codes, etc	Rect				fOriginalSize;		// original dialog size before appended items	public:	ZViewDialog( ZCommander* aBoss, const short dlogID );		ZViewDialog();	virtual ~ZViewDialog();// window:	virtual void		InitZWindow();	virtual void		SetUp();	virtual void		UpdateMenus();	virtual Boolean		Close( const short phase );	virtual void		Type( const char theKey, const short modifiers );	virtual void		Place();	virtual void		DrawContent();	virtual void		SetSize( const short width, const short height );	// modality:	void				SetModal( Boolean isModal ) { fModal = isModal; };	inline	Boolean		IsModal() { return fModal; };	virtual Boolean		RunModalDialog();	// item handling:	virtual void		FakeClick( const short item );	virtual void		ItemClicked( const short theItem );	virtual Boolean		ValidateFields( Boolean showAlert = TRUE );	virtual Boolean		CloseDialog();	virtual void		ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData );	virtual void		SelectItem( const short item );// item states:		virtual void		HideItem( const short item );	virtual void		ShowItem( const short item );	virtual void		EnableItem( const short item );	virtual void		DisableItem( const short item );	virtual void		SetItemTitle( const short item, Str255 title );	virtual void		SetItemSizing( const short item, Sizing sizing );	// item values:	virtual void		SetValue( const short item, const long value );	virtual void		SetValue( const short item, const int value ) 	{ SetValue(item, (long) value); }	virtual void		SetValue( const short item, const short value )	{ SetValue(item, (long) value); }	virtual void		SetValue( const short item, const Str255 value );	virtual void		SetValue( const short item, const double_t value );		virtual long		GetValue( const short item );	virtual void		GetValueAsText( const short item, Str255 aStr );	virtual double_t	GetValueAsFloat( const short item );		virtual void        SetMaximum( const short item, const long aMax );	virtual void        SetMinimum( const short item, const long aMin );	virtual long        GetMaximum( const short item );	virtual long        GetMinimum( const short item );// item groups:		virtual short		GetSelectedItemInGroup( const short groupID );	virtual void		SetItemGroupID( const short item, const short groupID );	virtual short		GetItemGroupID( const short item );	virtual void		EnableGroup( const short groupID );	virtual void		DisableGroup( const short groupID );	// extending dialogs:	virtual void		AppendMoreItems( const short ditlID, DITLMethod how = overlayDITL );	virtual void		RemoveAppendedItems( Boolean resizeDialog = FALSE );	virtual void		SizeDialogToItems( Boolean hFit = TRUE, Boolean vFit = TRUE );// getters and setters:	inline	short		GetDITLID() { return fDITLid; };	inline	short		GetDLOGID() { return windID; };		virtual ZView*		GetItem( const short item );	virtual ZView*		GetNthItem( const short item );	virtual short		CountItems( Boolean baseItemsOnly = TRUE );	virtual OSType		GetItemType( const short item );	virtual Boolean		GetItemViewItem( ZItemView** aView, const short id );		virtual void		SetReturnItem( const short item );	virtual void		SetCancelItem( const short item ) { fEscapeItem = item; }	// item registration - the new simpler way to extend item types	static void			RegisterDialogItem( void* itemFunc, const OSType magicType, const short param = 0 );	static void			RegisterStandardItems();		virtual void		ReportFields();// create all item views (not normally used directly by apps)	virtual void		MakeDialogItems( ZView* parView, const short ditlID, short numberFrom = 0 );	protected:	virtual void		MakeMacWindow( const short dlogID );	virtual void		MakeMacWindow( Rect* aRect, Str255 title, Boolean visible = FALSE, short varCode = 0, Boolean hasCloseBox = FALSE, void* userData = NULL );	virtual ZView*		CreateNewDialogItem( ZView* parView, const short item, const OSType magicType, Rect* frame, Ptr DITLparam, short pCount, long params[], Boolean* success );	virtual void		ParseStatText( Str255 sText, OSType* typeParam, short* paramCount, long params[] );	virtual	OSType		GetMagicTypeFromDialogManagerType( short dmType );	virtual void		InitItemFromICTB( const short item, ictbHandle ictb, const short ictbIndex );    virtual void        InitItemFromDFTB( const short item, dftbHandle dftb, const short dftbIndex );	virtual void		InitItemSizingFromRes( const short resID );	virtual void		SetItemTooltip( const short resID, const short itemNumber, const short index );private:	static ZClassRegistry*	sDialogItemRegistry;	static Boolean			sStdItemsRegistered;	static Point			sItemPosOrigin;};// errors, constants, etc:enum{	kMagicTypeNotRegisteredErr		= kUnsupportedTypeErr,	kInvalidDialogItemNumberErr		= 126,	kDialogMarginExtraWidth			= 10,	kMaxDITLNestingDepth			= 9};// other stuff:// When registering a dialog item constructor function, you can pass a hint to the registry which in turn informs the dialog what// to do when the associated magic item is encountered. Because of the variable nature of data for dialog items, this mechanism// gives you a general way to handle all the different cases your dialog may encounter.// if the hint/param is 0, it is ignored.// if the hint/param is a positive integer, that value is passed verbatim to the constructor function// if the hint/param is one of these special sentinels, the dialog will pass various things to the constructor function// note that the constructor function itself is defined using a variable parameter list, so what you get passed depends on what you// asked for when registering the function. This allows the "magic" mechanism to be highly flexible and extensible.enum{	kUseDITLResourceID				= -19998,			// means "use what the DITL tells you"	kUseDITLStringData				= -19997,			// likewise, but where DITL data expected is a string	kInitItemWithMagicParams		= -19996,			// pass the "magic" params directly to the constructor function	kInitItemWithFirstParam			= -19995			// pass first magic parameter as short to function};// handy macro for registering basic constructor funcntions in one call - MZDialogTypes.h also contains some related macros// that pertain to this - but this one needs to be here as it is ZViewDialog specific.#define REGISTERDICONSTRUCTOR( classType, id )	( ZViewDialog::RegisterDialogItem(((DialogItemConstructorFunction) DICF_##classType ), id, kInitItemWithFirstParam ))/*This class is the new way to do dialogs from MacZoop 2.5 onwards. It is views based anddoes not rely on the Dialog Manager at all. It provides all the same functionality as theold ZDialog class, but has a smaller, more rational API and is more flexible.Please use this for all dialog boxes in new code written with MacZoop.ZDialog is deprecated, though still available for backward compatibility.------------------------------------------------------------------------------------------One important change is the new (simpler) way to extend the types of items the dialog can make. Ratherthan the cumbersome method used by ZDialog, this class supports a simple registry of dialog types.This registry is based on ZClassRegistry, and maps a magic type to a constructor function for therelevant object. You must supply this function, but the macros in ZObject and here make this trivial,and something that can be done as a matter of course when writing code for an item. Extending thetypes of items is a simple case of registering the item, once, when your app runs. Such an item canthen be freely used in any subsequent dialog. */// this class used to draw a border around unregistered items. This is just a convenience for// programmers - users should not see this!class	ZUTBorder	: public ZViewBorder{public:	virtual void	Draw( Rect* borderFrame );};// this data structure stores auxiliary info for each dialog item. This is done because dialog items are views and// it would be wasteful to have fields set aside for this in ZView. To allow extra dialog-related auxiliary info// to be added and extended, this separate list is used.typedef struct{	short		itemNumber;			// item number of the item (in case info not in order)	short		switchGroup;		// which switch group the item belongs to (set from 'sitl' resource) 0 = none	char		accelKey;			// which character accelerates this item (buttons only) 0 = none}AuxDialogInfo, *AuxDialogInfoPtr;// creation function for auxiliary DITL:ZView*	CreateNewAuxiliaryDITLView( ZView* parView, Rect* aFrame, short pCount, long params[] );#endif