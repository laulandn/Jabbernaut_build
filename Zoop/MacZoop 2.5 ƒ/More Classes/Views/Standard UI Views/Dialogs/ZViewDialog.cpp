/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZViewDialog.cpp		-- dialog based on views******			©2000, Graham Cox*****************************************************************************************************/#include	"ZViewDialog.h"#include	"MacZoop.h"#include	"ZClassRegistry.h"#include	"ZControlView.h"#include	"ZTextBoxView.h"#include	"ZEditFieldView.h"#include	"MZCustomViewFunctions.h"#include	"BottleneckFix.h"// globals, statics:ZClassRegistry*		ZViewDialog::sDialogItemRegistry = NULL;Boolean				ZViewDialog::sStdItemsRegistered = FALSE;Point				ZViewDialog::sItemPosOrigin = { 0, 0 };extern ZCommander*	gCurHandler;/*------------------------------***  RegisterDialogItem  ***----------------------------*//*access:			globaloverrides:		description: 	register a dialog item type  with the item registryins: 			<itemFunc> the constructor function for the item				<magicType> the magic type code for the item				<param> initialisation parameter or hintouts: 			nonenotes:			must be called once for every type of dialog item used in the app----------------------------------------------------------------------------------------*/void			ZViewDialog::RegisterDialogItem( void* itemFunc, const OSType magicType, const short param ){	if ( sDialogItemRegistry == NULL )		FailNIL( sDialogItemRegistry = new ZClassRegistry());			// note - this registry uses the <classid> field to store the magic type for the item. In fact	// this type, being unique, is then used as the class ID for such objects. However, such classes	// must be registered through this function as the REGISTERCLASS macro will NOT do the right thing.		// the param is stored in the registry refCon field. This is a value that you can set which will be	// passed to the construction function as required. What it means is up to you - for most types, it is	// the procID or the resource ID to use to initialise the item. You can also pass one of the special	// hint values that informs the CreateNewDialogItem() method whether to pass the info from the DITL or	// the registry.		sDialogItemRegistry->RegisterClass( magicType, (ConstructorFunction) itemFunc, NULL, param );	}/*---------------------------***  RegisterStandardItems  ***----------------------------*//*access:			globaloverrides:		description: 	register all the standard types with the item registryins: 			noneouts: 			nonenotes:			will be called first time a view dialog is called up----------------------------------------------------------------------------------------*/void			ZViewDialog::RegisterStandardItems(){	RegisterDialogItem( DICONSTRUCTORFUNCTION( ZControlView ), kMagicStdPushButton, pushButProc );	RegisterDialogItem( DICONSTRUCTORFUNCTION( ZControlView ), kMagicStdCheckbox, checkBoxProc );	RegisterDialogItem( DICONSTRUCTORFUNCTION( ZControlView ), kMagicStdRadioButton, radioButProc );	RegisterDialogItem( CreateNewResourceControl, kMagicStdResControl, kUseDITLResourceID );	RegisterDialogItem( CreateNewControlWithParams, kMagicStringGeneralControl, kInitItemWithMagicParams );	RegisterDialogItem( DICONSTRUCTORFUNCTION( ZTextBoxView ), kMagicStdStaticText, kUseDITLStringData );	RegisterDialogItem( DICONSTRUCTORFUNCTION( ZEditFieldView ), kMagicStdEditText, kUseDITLStringData );	RegisterDialogItem( DICONSTRUCTORFUNCTION( ZPictureView ), kMagicStdPicture, kUseDITLResourceID );	RegisterDialogItem( DICONSTRUCTORFUNCTION( ZIconView ), kMagicStdIcon, kUseDITLResourceID );	RegisterDialogItem( CreateNewUserItemView, kMagicStdUserItem, 0 );	RegisterDialogItem( CreateNewUserItemView, kMagicStringFrameBox, kInitItemWithFirstParam );	RegisterDialogItem( CreateNewAuxiliaryDITLView, kMagicStringAuxiliaryDITL, kInitItemWithMagicParams );	RegisterDialogItem( CreateNewMacZoopVersionStringView, kMagicStringZoopVersion, 0 );	RegisterDialogItem( CreateNewApplicationVersionStringView, kMagicStringAppVersion, 0 );		sStdItemsRegistered = TRUE;}#pragma mark -/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZViewDialog::ZViewDialog( ZCommander* aBoss, const short dlogID )	: ZWindow( aBoss, dlogID ){	classID = CLASS_ZViewDialog;		fDefaultItem = 1;	fEscapeItem = 2;	fDITLid = dlogID;	fModal = FALSE;	fInline = FALSE;	fLastClickItem = 0;	fEnableAccel = FALSE;	#if USE_DIALOG_AUX_INFO	FailNIL( fAuxItemInfo = new ZArray( sizeof( AuxDialogInfo )));#else	fAuxItemInfo = NULL;#endif	sItemPosOrigin.h = 0;	sItemPosOrigin.v = 0;		// build the registry, if it hasn't already been done. This will register all standard	// dialog items first time any dialog is created.		if ( !sStdItemsRegistered )		RegisterStandardItems();	}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZViewDialog::ZViewDialog()	: ZWindow(){	classID = CLASS_ZViewDialog;	fDefaultItem = 1;	fEscapeItem = 2;	fDITLid = 0;	fModal = FALSE;	fInline = FALSE;	fLastClickItem = 0;	fEnableAccel = FALSE;#if USE_DIALOG_AUX_INFO	FailNIL( fAuxItemInfo = new ZArray( sizeof( AuxDialogInfo )));#else	fAuxItemInfo = NULL;#endif	sItemPosOrigin.h = 0;	sItemPosOrigin.v = 0;	if ( !sStdItemsRegistered )		RegisterStandardItems();	}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZViewDialog::~ZViewDialog(){	if ( fAuxItemInfo )		FORGETOBJECT( fAuxItemInfo );}/*--------------------------------***  InitZWindow  ***---------------------------------*//*access:			publicoverrides:		description: 	initialise the whole darn caboodleins: 			noneouts: 			nonenotes:			must be called - creates everything----------------------------------------------------------------------------------------*/void		ZViewDialog::InitZWindow(){	MakeMacWindow( windID );			// make the dialog box, and set modal flag	if ( gMacInfo.hasAppearanceMgr )		InstallBottleneckFix( GetMacWindow());	if ( gMacInfo.hasDragManager )		InstallDragHandlers();			InitSizeFromResource( kDialogSizeLimitResType );		Focus();	SetFontInfo( 0, 0, 0 );				// dialogs have system font by default	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ZViewEnvironment*	env = GetEnvironment();				if ( fModal )			env->SetThemedTextColour( kThemeTextColorDialogActive );		else			env->SetThemedTextColour( kThemeTextColorModelessDialogActive );	}#endif				sItemPosOrigin.h = 0;	sItemPosOrigin.v = 0;		long dInfo = ((long) fDITLid << 16 ) + windID;	SendMessage( kMsgDialogPreSetUp, &dInfo );								MakeDialogItems( this, fDITLid );	// build all the subviews	fBaseCount = CountItems();			// keep track of original items	Focus();							// make sure dialog is focussed for setup call	SetUp();							// call user's set up method, may change defaults		// if for some reason no items were loaded, set default and escape to 0	if ( fDefaultItem > CountItems())		fDefaultItem = 0;	else	{		if ( fDefaultItem && GetItemType( fDefaultItem ) == kMagicStdPushButton )			GetItem( fDefaultItem )->SetDefaultItem( TRUE );		else			fDefaultItem = 0;	}		if ( fEscapeItem > CountItems())		fEscapeItem = 0;	else	{		if ( fEscapeItem && GetItemType( fEscapeItem ) != kMagicStdPushButton )			fEscapeItem = 0;	}		// tell the window manager of our existence.		gWindowManager->AddWindow( this );#if _AUTO_WPOS_FOR_DIALOGS	RestorePosition();#endif	// select initial handler item:		Type( TAB_KEY, 0 );}/*-----------------------------------***  SetUp  ***------------------------------------*//*access:			publicoverrides:		description: 	your chance to set up items before the dialog is shownins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetUp(){	// override this method to initialise your items to the desired	// state for your dialog, but call the inherited method as well.		long	id = ((long) fDITLid << 16 ) + windID;		SendMessage( kMsgDialogSetUp, &id );}/*--------------------------------***  UpdateMenus  ***---------------------------------*//*access:			publicoverrides:		description: 	enable dialog commandsins: 			noneouts: 			nonenotes:			this blocks the chain if this is a modal dialog. This prevents any				objects further up the command chain from handling commands, which is				exactly what you want with a modal dialog----------------------------------------------------------------------------------------*/void		ZViewDialog::UpdateMenus(){	if ( !fModal )		ZWindow::UpdateMenus();}/*-----------------------------------***  Close  ***------------------------------------*//*access:			publicoverrides:		description: 	the dialog has been told to close - do so if you canins: 			<phase> application phase, used to control alert wordingouts: 			TRUE if dialog closed, FALSE if close was rejectednotes:			----------------------------------------------------------------------------------------*/Boolean		ZViewDialog::Close( const short phase ){	// called for a modeless dialog. This calls CloseDialog. If TRUE, the object is	// deleted. This overrides the similar method in ZWindow.		Boolean	wasClosed = CloseDialog();		if ( wasClosed )	{		long	dFudge = ((long) windID << 16 ) + windID;				SendMessage( kMsgDialogSuccessfullyClosed, &dFudge );				// if the dialog is inline, the caller is responsible for deleting it. In which case		// we simply hide ourselves and will get deleted later.				if ( fInline )			Hide();		else			wasClosed = ZWindow::Close( phase );		#if _AUTO_WPOS_FOR_DIALOGS		if ( wasClosed )			SavePosition();	#endif	}		return wasClosed;}/*------------------------------------***  Type  ***------------------------------------*//*access:			publicoverrides:		description: 	handle keyboard aimed at the dialog itselfins: 			<thekey> character to process				<modifiers> modifier keysouts: 			nonenotes:			handles default item mapping----------------------------------------------------------------------------------------*/void		ZViewDialog::Type( const char theKey, const short modifiers ){	switch ( theKey )	{		case RETURN_KEY:		case ENTER_KEY:			if ( fDefaultItem && ( modifiers & kFromAutoKeyEvent ) == 0 )				FakeClick( fDefaultItem );			break;					case ESCAPE_KEY:			if ( fEscapeItem && ( modifiers & kFromAutoKeyEvent ) == 0 )				FakeClick( fEscapeItem );			break;					case '.':			if ( fEscapeItem && ( modifiers & kFromAutoKeyEvent + cmdKey ) == cmdKey )				FakeClick( fEscapeItem );			break;			default:			ZWindow::Type( theKey, modifiers );			break;	}}/*--------------------------------***  DrawContent  ***---------------------------------*//*access:			publicoverrides:		description: 	draw modeless frame if appropriateins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::DrawContent(){#if APPEARANCE_MGR_AWARE	if ( ! fModal && gMacInfo.hasAppearanceMgr )	{		Rect	br;				GetBounds( &br );		InsetRect( &br, -1, -1 );		DrawThemeModelessDialogFrame( &br, IsActive() && IsEnabled());	}#endif		ZWindow::DrawContent();}/*----------------------------------***  SetSize  ***-----------------------------------*//*access:			publicoverrides:		description: 	resize the dialogins: 			<width, height> new sizesouts: 			nonenotes:			updates modeless frame if there is one----------------------------------------------------------------------------------------*/void		ZViewDialog::SetSize( const short width, const short height ){	RgnHandle	mfRgn;	Rect		r;		if ( gMacInfo.hasAppearanceMgr )	{		FailNIL( mfRgn = NewRgn());		GetBounds( &r );				r.left = r.right - 3;		RectRgn( mfRgn, &r );		GetBounds( &r );		r.top = r.bottom - 3;		RectRgn( gUtilRgn, &r );		UnionRgn( mfRgn, gUtilRgn, mfRgn );	}	ZWindow::SetSize( width, height );		if ( gMacInfo.hasAppearanceMgr )	{		GetBounds( &r );		r.left = r.right - 3;		RectRgn( gUtilRgn, &r );		UnionRgn( mfRgn, gUtilRgn, mfRgn );		GetBounds( &r );		r.top = r.bottom - 3;		RectRgn( gUtilRgn, &r );		UnionRgn( mfRgn, gUtilRgn, mfRgn );				Focus();		MZInvalWindowRgn( GetRootWindowMacWindow(), mfRgn );		DisposeRgn( mfRgn );	}}/*-----------------------------------***  Place  ***------------------------------------*//*access:			publicoverrides:		description: 	place the dialog on screen.ins: 			noneouts: 			nonenotes:			what happens depends on a number of factors. If possible, the dialog is				placed where it was last time, and will appear there if this is never called				If this is called, the fAutoPos setting overrides the restored position,				unless it is kNoPosition----------------------------------------------------------------------------------------*/void		ZViewDialog::Place(){	if ( fAutoPos != kNoPosition )	{		ZWindow* parent = dynamic_cast<ZWindow*>( GetBoss());				if ( parent == NULL )			parent = gApplication->GetFrontWindow();				PlaceRelative( parent, fAutoPos );	}}/*-------------------------------***  RunModalDialog  ***-------------------------------*//*access:			publicoverrides:		description: 	simple way to handle a dialog "inline".ins: 			noneouts: 			TRUE if dialog dismissed by default button, FALSE otherwisenotes:			caller is responsible for disposing the dialog object if using this----------------------------------------------------------------------------------------*/Boolean		ZViewDialog::RunModalDialog(){	Boolean		okClicked = FALSE;	ZWindow*	topDialog;		if ( GetMacWindow() == NULL )		InitZWindow();		if ( fModal )	{		// make sure we are activated and shown				if ( ! IsVisible())		{			Place();			Select();		}					if ( GetHandler())			GetHandler()->BecomeHandler( TRUE );				fInline = TRUE;	// caller is responsible for deleting this				// process events until the dialog is dismissed				do		{			gApplication->Process1Event();			topDialog = gApplication->GetFrontWindow();		}		while(( topDialog == this ) && IsVisible());				okClicked = ( fLastClickItem == fDefaultItem );	}		return okClicked;}/*---------------------------------***  FakeClick  ***----------------------------------*//*access:			publicoverrides:		description: 	simulates a click on the itemins: 			<item> item number of item to clickouts: 			nonenotes:			will hilight the item momentarily if appropriate----------------------------------------------------------------------------------------*/void		ZViewDialog::FakeClick( const short item ){	ZControlView*	cv;		if ( GetItem( item )->IsEnabled())	{		cv = dynamic_cast<ZControlView*>( GetItem( item ));				if ( cv )		{			cv->Highlight( 1 );			MZDelay( 8 );			cv->Highlight( 0 );		}				ItemClicked( item );	}}/*---------------------------------***  ItemClicked  ***--------------------------------*//*access:			publicoverrides:		description: 	an item was clicked - deal with it.ins: 			<theItem> item that was clickedouts: 			nonenotes:			some item processing is done by ReceiveMessage.----------------------------------------------------------------------------------------*/void		ZViewDialog::ItemClicked( const short theItem ){	fLastClickItem = theItem;		long msg = ((long) windID << 16 ) | theItem;	SendMessage( kMsgDialogItemClicked, &msg );		if ( fModal )	{		if ( theItem == fDefaultItem )		{			Close( kRunning );			return;		}		else if ( theItem == fEscapeItem )		{			SetDirty( FALSE );				// suppress save check			SendMessage( kMsgDialogCancelled, &windID );							if ( fInline )				Hide();			else				ZWindow::Close( kRunning );		// does not verify dialog			#if _AUTO_WPOS_FOR_DIALOGS				SavePosition();			#endif		}	}}/*-------------------------------***  ValidateFields  ***-------------------------------*//*access:			publicoverrides:		description: 	validate any edit text fields in the dialogins: 			<showAlert> TRUE if a bad field puts up an alert, FALSE if it just beepsouts: 			TRUE if all fields valid, FALSE if any field invalid.notes:			----------------------------------------------------------------------------------------*/Boolean		ZViewDialog::ValidateFields( Boolean showAlert ){	ZViewList*			vl;	ZEditFieldView*		ef;	short				i, n;	Boolean				result = TRUE;		vl = FlattenViewsToList( NULL, FALSE );		n = vl->CountItems();		for( i = 1; i <= n; i++ )	{		ef = dynamic_cast<ZEditFieldView*>( vl->GetObject( i ));			if ( ef )		{			result = ef->Validate( showAlert );					if ( ! result )				break;		}	}		FORGETOBJECT( vl );		if ( ! result )		Select();		return result;}/*---------------------------------***  CloseDialog  ***--------------------------------*//*access:			publicoverrides:		description: 	determine if the dialog should actually closeins: 			noneouts: 			TRUE if may be closed, FALSE if closure barrednotes:			also your chance to read the data from the dialog----------------------------------------------------------------------------------------*/Boolean		ZViewDialog::CloseDialog(){	// the dialog is about to close. Return FALSE if you can't close (Verify fields?)	// we check if there are any fields that have limits set and are some kind of	// numeric field. If the limits have been exceeded by the user's entry, we	// hilite the offending field, make a noise and prevent the dialog from closing.		return ValidateFields();}/*------------------------------***  ReceiveMessage  ***--------------------------------*//*access:			publicoverrides:		description: 	respond to messages from child viewsins: 			<aSender> object sending the message				<msg> the message				<msgData> any associated dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::ReceiveMessage( ZComrade* aSender, ZoopMessage msg, UntypedPtr msgData ){	switch( msg )	{		case kMsgSignalViewClicked:		case kMsgUnspecifiedItemClicked:		case kMsgEditFieldClicked:		case kMsgControlViewClicked:		case kMsgSignalViewTyping:			ItemClicked(((ZView*) aSender )->GetUserID());			break;					case kMsgRadioControlTurningOn:			// if sender is not an immediate child, this will already have been handled,			// otherwise fall through to default case						if (((ZView*) aSender )->GetParent() != this )				break;			default:			ZWindow::ReceiveMessage( aSender, msg, msgData );			break;	}	}/*---------------------------------***  SelectItem  ***---------------------------------*//*access:			publicoverrides:		description: 	select which item is the handler (has keyboard focus)ins: 			<item> item number to selectouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SelectItem( const short item ){	ZView*	iv = GetItem( item );		if ( iv && iv->CanBeHandler() && iv->IsEnabled())		SelectHandlingView( iv );}/*----------------------------------***  HideItem  ***----------------------------------*//*access:			publicoverrides:		description: 	hide a dialog itemins: 			<item> the item to hideouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::HideItem( const short item ){	GetItem( item )->Hide();}/*----------------------------------***  ShowItem  ***----------------------------------*//*access:			publicoverrides:		description: 	show a dialog itemins: 			<item> the item to showouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::ShowItem( const short item ){	GetItem( item )->Show();}/*---------------------------------***  EnableItem  ***---------------------------------*//*access:			publicoverrides:		description: 	enable a dialog itemins: 			<item> the item to enableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::EnableItem( const short item ){	if ( item < 0 )		EnableGroup( -item );	else		GetItem( item )->Enable();}/*--------------------------------***  DisableItem  ***---------------------------------*//*access:			publicoverrides:		description: 	disable a dialog itemins: 			<item> the item to disableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::DisableItem( const short item ){	if ( item < 0 )		DisableGroup( -item );	else	{		ZView*	dv;				dv = GetItem( item );				dv->Disable();				// deal with focus if we disabled focused item				if ( dv->IsTheHandler())			Type( TAB_KEY, 0 );	}}/*-------------------------------***  SetItemTitle  ***---------------------------------*//*access:			publicoverrides:		description: 	set the title of an item (typically a control)ins: 			<item> item whose title to set				<title> the title to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetItemTitle( const short item, Str255 title ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->SetTitle( title );}/*------------------------------***  SetItemSizing  ***---------------------------------*//*access:			publicoverrides:		description: 	set the sizing options for an itemins: 			<item> item whose sizing options to set				<sizing> the options to assign to itouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetItemSizing( const short item, Sizing sizing ){	ZView*	di = GetItem( item );		if ( di )		di->SetAutoSizing( sizing );}/*---------------------------------***  SetValue  ***-----------------------------------*//*access:			publicoverrides:		description: 	set an item's valueins: 			<item> item whose value to set				<value> the value to set it toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetValue( const short item, const long value ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->SetValue( value );}/*---------------------------------***  SetValue  ***-----------------------------------*//*access:			publicoverrides:		description: 	set an item's valueins: 			<item> item whose value to set				<value> the string to set it toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetValue( const short item, const Str255 value ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->SetValue( value );}/*---------------------------------***  SetValue  ***-----------------------------------*//*access:			publicoverrides:		description: 	set an item's valueins: 			<item> item whose value to set				<value> the value to set it toouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetValue( const short item, const double_t value ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->SetValue( value );}/*---------------------------------***  GetValue  ***-----------------------------------*//*access:			publicoverrides:		description: 	get an item's valueins: 			<item> item whose value to getouts: 			the item's valuenotes:			----------------------------------------------------------------------------------------*/long		ZViewDialog::GetValue( const short item ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		return ( iv->GetValue());	else		return 0;}/*------------------------------***  GetValueAsText  ***--------------------------------*//*access:			publicoverrides:		description: 	get an item's value as a stringins: 			<item> item whose value to get				<aStr> receives string with valueouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::GetValueAsText( const short item, Str255 aStr ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->GetValueAsText( aStr );}/*-----------------------------***  GetValueAsFloat  ***--------------------------------*//*access:			publicoverrides:		description: 	get an item's value as a floatins: 			<item> item whose value to getouts: 			item's valuenotes:			----------------------------------------------------------------------------------------*/double_t	ZViewDialog::GetValueAsFloat( const short item ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		return ( iv->GetValueAsFloat());	else		return 0.0;}/*--------------------------------***  SetMaximum  ***----------------------------------*//*access:			publicoverrides:		description: 	set an item's max limitins: 			<item> item whose max limit to set				<aMax> the limit to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZViewDialog::SetMaximum( const short item, const long aMax ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->SetMaximum( aMax );}/*--------------------------------***  SetMinimum  ***----------------------------------*//*access:			publicoverrides:		description: 	set an item's min limitins: 			<item> item whose min limit to set				<aMin> the limit to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZViewDialog::SetMinimum( const short item, const long aMin ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->SetMinimum( aMin );}/*--------------------------------***  GetMaximum  ***----------------------------------*//*access:			publicoverrides:		description: 	get an item's max limitins: 			<item> item whose max limit to getouts: 			the maxnotes:			----------------------------------------------------------------------------------------*/long        ZViewDialog::GetMaximum( const short item ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		return iv->GetMaximum();	else		return 0;}/*--------------------------------***  GetMinimum  ***----------------------------------*//*access:			publicoverrides:		description: 	get an item's min limitins: 			<item> item whose min limit to getouts: 			the minnotes:			----------------------------------------------------------------------------------------*/long        ZViewDialog::GetMinimum( const short item ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		return iv->GetMinimum();	else		return 0;}/*--------------------------***  GetSelectedItemInGroup  ***----------------------------*//*access:			publicoverrides:		description: 	find which item in a group is selectedins: 			<groupID> group to queryouts: 			item number of the selected item, or 0 if not foundnotes:			mainly useful for radio button groups----------------------------------------------------------------------------------------*/short		ZViewDialog::GetSelectedItemInGroup( const short groupID ){	ZItemView*	item;	short		n, i;		n = CountItems();		for( i = 1; i <= n; i++ )	{		if ( GetItemViewItem( &item, i ))		{			if (( item->GetGroupID() == groupID ) && item->GetValue())				return i;		} 	}		return 0;}/*------------------------------***  SetItemGroupID  ***--------------------------------*//*access:			publicoverrides:		description: 	set the group ID of an itemins: 			<item> the item number				<groupID> the group ID the item should be part ofouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetItemGroupID( const short item, const short groupID ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		iv->SetGroupID( groupID );}/*------------------------------***  GetItemGroupID  ***--------------------------------*//*access:			publicoverrides:		description: 	get the group ID of an itemins: 			<item> the item numberouts: 			the item's group IDnotes:			----------------------------------------------------------------------------------------*/short		ZViewDialog::GetItemGroupID( const short item ){	ZItemView*	iv;		if ( GetItemViewItem( &iv, item ))		return( iv->GetGroupID());	else		return 0;}/*--------------------------------***  EnableGroup  ***---------------------------------*//*access:			publicoverrides:		description: 	enable all items in a groupins: 			<groupID> the group to enableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::EnableGroup( const short groupID ){	short		i, n;	ZItemView*	iv;		n = CountItems();	for( i = 1; i <= n; i++ )	{		if ( GetItemViewItem( &iv, i ))		{			if ( iv->GetGroupID() == groupID )				iv->Enable();		}	}}/*-------------------------------***  DisableGroup  ***---------------------------------*//*access:			publicoverrides:		description: 	disable all items in a groupins: 			<groupID> the group to disableouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::DisableGroup( const short groupID ){	short		i, n;	ZItemView*	iv;	Boolean		recheckFocus = FALSE;		n = CountItems();	for( i = 1; i <= n; i++ )	{		if ( GetItemViewItem( &iv, i ))		{			if ( iv->GetGroupID() == groupID )			{				iv->Disable();								if ( iv->IsTheHandler())					recheckFocus = TRUE;			}		}	}		// if we disabled the focus item, switch to another:		if ( recheckFocus )		Type( TAB_KEY, 0 );}/*------------------------------***  AppendMoreItems  ***-------------------------------*//*access:			publicoverrides:		description: 	adds more items to the dialog from another DITL resourceins: 			<ditlID> id of the extra DITL to append				<how> how extra items are positioned					DITLMethod can be one of four things:					overlayDITL - no special positioning					appendDITLRight - add items to the right of all others					appendDITLBottom - add items below all others					a negative number - relative to item given by negative of number	outs: 			nonenotes:			may resize the dialog. Because this is done with SetSize, and this may				move items, this is more versatile than Dialog Manager AppendDITL. This				also permits the full suite of custom items, which AppendDITL would not.----------------------------------------------------------------------------------------*/void		ZViewDialog::AppendMoreItems( const short ditlID, DITLMethod how ){	Rect		pr;	ZView*		item;	Boolean		hFit = FALSE, vFit = FALSE;		if ( CountItems() == fBaseCount )		GetBounds( &fOriginalSize );		sItemPosOrigin.h = 0;	sItemPosOrigin.v = 0;		switch( how )	{		case overlayDITL:			break;					case appendDITLRight:			GetFrame( &pr );			sItemPosOrigin.h = pr.right;			hFit = TRUE;			break;					case appendDITLBottom:			GetFrame( &pr );			sItemPosOrigin.v = pr.bottom;			vFit = TRUE;			break;					default:			if ( how < 0 )			{				item = GetItem( -how );								if ( item )				{					item->GetFrame( &pr );								sItemPosOrigin.h = pr.left;					sItemPosOrigin.v = pr.top;										hFit = vFit = TRUE;				}			}			break;	}		// create all the extra items		MakeDialogItems( this, ditlID );		// resize the dialog if needed -		if ( hFit || vFit )		SizeDialogToItems( hFit, vFit );		// make sure newly added items are activated correctly:		if ( IsActive())			Activate();}/*----------------------------***  RemoveAppendedItems  ***-----------------------------*//*access:			publicoverrides:		description: 	removes all items that were not part of the original base setins: 			<resizeDialog> TRUE to shrink dialog to fit afterwardsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::RemoveAppendedItems( Boolean resizeDialog ){	short		n, i;	ZView*		doomedView;	Boolean		reFocus = FALSE;		n = CountItems();		if ( n > fBaseCount )	{		for( i = n; i > fBaseCount; i-- )		{			doomedView = GetChildView( i );						if ( doomedView->IsInDirectCommandChain())				reFocus = TRUE;							doomedView->Hide();			FORGETOBJECT( doomedView );			}				if ( reFocus ) 		{			SetHandler( NULL );			gCurHandler = NULL;			Type( TAB_KEY, 0 );		}				if ( resizeDialog )			SetSize( fOriginalSize.right, fOriginalSize.bottom );	}}/*-----------------------------***  SizeDialogToItems  ***------------------------------*//*access:			publicoverrides:		description: 	sizes the dialog to fit the extent of its items.ins: 			<hFit> size to allow horizontal extent				<vFit> size to allow vertical extentouts: 			nonenotes:			Use with care!----------------------------------------------------------------------------------------*/void		ZViewDialog::SizeDialogToItems( Boolean hFit, Boolean vFit ){	Rect	dr;	ZView*	item;		GetFrame( &dr );	OffsetRect( &dr, -dr.left, -dr.top );		// find the spatial extent of the dialog items:	for( short i = 1; i <= CountItems(); i++ )	{		Rect	fi;				item = GetChildView( i );		item->GetFrame( &fi );				if ( hFit && fi.right > dr.right )			dr.right = fi.right;					if ( vFit && fi.bottom > dr.bottom )			dr.bottom = fi.bottom;	}		if ( hFit )		dr.right += kDialogMarginExtraWidth;			if ( vFit )		dr.bottom += kDialogMarginExtraWidth;		SetSize( dr.right, dr.bottom );	}/*------------------------------------***  GetItem  ***---------------------------------*//*access:			publicoverrides:		description: 	return the item with the given IDins: 			<item> id of the item (starts at 1)outs: 			the view objectnotes:			items are permitted to have non-contiguous numbering----------------------------------------------------------------------------------------*/ZView*		ZViewDialog::GetItem( const short item ){	// performs a "deep" search so that compound items are found correctly.	ZView*	v;		v = FindChildViewByUserID( item, TRUE );		FailNILErr( v, kInvalidDialogItemNumberErr );		return v;}/*-----------------------------------***  GetNthItem  ***-------------------------------*//*access:			publicoverrides:		description: 	return the nth item in the dialog hierarchy, regardless of IDins: 			<item> ordinal number of the item (starts at 1)outs: 			the view objectnotes:			in general, you should use GetItem - this is for special needs----------------------------------------------------------------------------------------*/ZView*		ZViewDialog::GetNthItem( const short item ){	ZView*		iv = NULL;	ZViewList*	vl = FlattenViewsToList( NULL, FALSE );	iv = (ZView*) vl->GetObject( item );		FORGETOBJECT( vl );	return iv;}/*----------------------------------***  CountItems  ***--------------------------------*//*access:			publicoverrides:		description: 	return the current number of itemsins: 			<baseItemsOnly> if TRUE, only counts immediate items in the dialog. If				FALSE, counts all views in the entire dialog hierarchy (but not dialog itself)outs: 			number of itemsnotes:			----------------------------------------------------------------------------------------*/short		ZViewDialog::CountItems( Boolean baseItemsOnly ){	if ( baseItemsOnly )		return CountChildViews();	else		return CountViews();}/*----------------------------------***  GetItemType  ***-------------------------------*//*access:			publicoverrides:		description: 	return the magic type of the item with the given IDins: 			<item> id of the item (starts at 1)outs: 			type code for the itemnotes:			----------------------------------------------------------------------------------------*/OSType		ZViewDialog::GetItemType( const short item ){	return GetItem( item )->GetClassRef();}/*--------------------------------***  GetItemViewItem  ***-----------------------------*//*access:			publicoverrides:		description: 	get an item but only if it is a ZItemView classins: 			<aView> receives the view if valid				<id> the item idouts: 			TRUE if view is the right type, FALSE otherwisenotes:			----------------------------------------------------------------------------------------*/Boolean		ZViewDialog::GetItemViewItem( ZItemView** aView, const short id ){	*aView = dynamic_cast<ZItemView*>( GetItem( id ));	return ( *aView != NULL );	}/*--------------------------------***  SetReturnItem  ***-------------------------------*//*access:			publicoverrides:		description: 	set the item actioned when return/enter typedins: 			<item> item number to make default itemouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetReturnItem( const short item ){	if ( item != fDefaultItem )	{		ZView*	di;				if ( fDefaultItem > 0 )		{			di = GetItem( fDefaultItem );			di->SetDefaultItem( FALSE );			di->PostRefresh();		}				fDefaultItem = item;				di = GetItem( fDefaultItem );				if ( di )		{			di->SetDefaultItem( TRUE );			di->PostRefresh();		}	}}/*---------------------------------***  ReportFields  ***-------------------------------*//*access:			publicoverrides:		description: 	report field info to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::ReportFields(){	ZWindow::ReportFields();	XSHOWFIELD( fDefaultItem, ft_signedshort );	XSHOWFIELD( fEscapeItem, ft_signedshort );	XSHOWFIELD( fDITLid, ft_signedshort );	XSHOWFIELD( fLastClickItem, ft_signedshort );	XSHOWFIELD( fModal, ft_boolean );	XSHOWFIELD( fInline, ft_boolean );	XSHOWFIELD( fEnableAccel, ft_boolean );}/*---------------------------------***  MakeMacWindow  ***------------------------------*//*access:			protectedoverrides:		description: 	construct the window that the dialog is built onins: 			<dlogID> id of the DLOG resource which determines window style, etcouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::MakeMacWindow( const short dlogID ){	DialogTHndl		dtH;	ThemeBrush		dBrushActive, dBrushInactive;		FailNILRes( dtH = (DialogTHndl) GetResource( 'DLOG', dlogID ));	HNoPurge((Handle) dtH );		fDITLid = (*dtH)->itemsID;		short proc = (*dtH)->procID;	fResizeable = FALSE;		// if we have appearance, translate proc to newer proc IDs. This allows us to use the	// cleaner window creation routines that work on Carbon.		if ( gMacInfo.hasAppearanceMgr )	{		dBrushActive = kThemeBrushDialogBackgroundActive;		dBrushInactive = kThemeBrushDialogBackgroundInactive;				switch ( proc )		{			case dBoxProc:				proc = kWindowModalDialogProc;				break;							case plainDBox:				proc = kWindowPlainDialogProc;				break;							case altDBoxProc:				proc = kWindowShadowDialogProc;				break;							case movableDBoxProc:				proc = kWindowMovableModalDialogProc;				break;							case documentProc:				proc = kWindowGrowDocumentProc;				fResizeable = TRUE;				dBrushActive = kThemeBrushModelessDialogBackgroundActive;				dBrushInactive = kThemeBrushModelessDialogBackgroundInactive;				break;							case noGrowDocProc:				proc = kWindowDocumentProc;				dBrushActive = kThemeBrushModelessDialogBackgroundActive;				dBrushInactive = kThemeBrushModelessDialogBackgroundInactive;				break;							case zoomDocProc:				proc = kWindowFullZoomGrowDocumentProc;				fResizeable = TRUE;				dBrushActive = kThemeBrushModelessDialogBackgroundActive;				dBrushInactive = kThemeBrushModelessDialogBackgroundInactive;				break;							case zoomNoGrow:				proc = kWindowFullZoomDocumentProc;				dBrushActive = kThemeBrushModelessDialogBackgroundActive;				dBrushInactive = kThemeBrushModelessDialogBackgroundInactive;				break;						case kAlertVariantCode:			case kMovableAlertVariantCode:				case kWindowAlertProc:			case kWindowMovableAlertProc:				dBrushActive = kThemeBrushAlertBackgroundActive;				dBrushInactive = kThemeBrushAlertBackgroundInactive;				break;							default:				break;		}	}	else	{		// non-appearance should still set resizeable flag according to basic window type				fResizeable = ( proc == documentProc ||						proc == zoomDocProc );	}		HLock((Handle) dtH );		MakeMacWindow( &(*dtH)->boundsRect, (*dtH)->title, FALSE, proc, (*dtH)->goAwayFlag, NULL );		// read the auto positioning variable too. This is the last item in the template,	// and follows the title string (variable offset)		unsigned short pv = *(unsigned short*)((Ptr)( &(*dtH)->title ) + (*dtH)->title[0] + 1 + ((*dtH)->title[0] + 1 ) %2 );		// set up autoPos to equivalent behaviour		switch ( pv )	{		case kWindowCenterMainScreen:			fAutoPos = kCentreOnScreen;			break;					case kWindowAlertPositionMainScreen:			fAutoPos = kAlertPositionOnScreen;			break;					case kWindowCenterParentWindow:			fAutoPos = kCentreOnParent;			break;					case kWindowAlertPositionParentWindow:			fAutoPos = kAlertPositionOnParent;			break;					case kWindowStaggerParentWindow:			fAutoPos = kStaggerOnParent;			break;				default:		case kWindowDefaultPosition:			fAutoPos = kNoPosition;			break;	}	HUnlock((Handle) dtH );	ReleaseResource((Handle) dtH );		MakeEnvironment();		// if appearance aware, set up the theme background for the dialog according	// to its type#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ZViewEnvironment*	env = GetEnvironment();				if ( env )		{			env->SetThemedBack( dBrushActive );			env->SetThemedInactiveBack( dBrushInactive );		}	}	else	{#endif		// look for 'dctb' resource to set up background colour of window				CTabHandle		dctb;				dctb = (CTabHandle) GetResource( 'dctb', dlogID );				if ( dctb )		{			HLock((Handle) dctb );			SetBackColour( &(*dctb)->ctTable[0].rgb );						// if older system, attach table to window		#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON				if ( gMacInfo.hasModernWindowMgr )			{				SetWindowContentColor( GetMacWindow(), &(*dctb)->ctTable[0].rgb );				ReleaseResource((Handle) dctb );			}			else			{			#endif		#if ! TARGET_API_MAC_CARBON				HNoPurge((Handle) dctb );				HUnlock((Handle) dctb );				SetWinColor( GetMacWindow(), (WinCTab**) dctb ); 		#endif		#if USE_MODERN_WINDOW_MGR || TARGET_API_MAC_CARBON				}		#endif			}#if APPEARANCE_MGR_AWARE	}#endif}/*---------------------------------***  MakeMacWindow  ***------------------------------*//*access:			protectedoverrides:		description: 	construct the window that the dialog is built onins: 			<aRect> global rectangle of window				<title> the title string				<visible> is window to be shown?				<varCode> window style				<hasCloseBox> TRUE if has a close box				<userData> additional user dataouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::MakeMacWindow( Rect* aRect, Str255 title, Boolean visible, short varCode, Boolean hasCloseBox, void* userData ){	gWindowManager->GetUniqueUntitledName( title );		WindowPtr	w;	if ( gMacInfo.supportsColour )		FailNIL( w = NewCWindow( NULL, aRect, title, visible, varCode, NULL, hasCloseBox, (long) this ));	else		FailNIL( w = NewWindow( NULL, aRect, title, visible, varCode, NULL, hasCloseBox, (long) this ));	SetMacWindow( w );	SetFrame( WINDOWPORTRECT( GetMacWindow()));	SetWindowKind( GetMacWindow(), kMacZoopWindowIdentifier );	CopyPStringTrunc( title, macFile.name, 31 );		short	pID = ( varCode / 16 );		// with appearance manager, the WDEF IDs for floating windows are 66 & 67		if ( gMacInfo.hasAppearanceMgr )		floating |= ( 	pID == kWindowUtilityDefProcResID || pID == kWindowUtilitySideTitleDefProcResID );	floating |= (	pID == kFloatingWindowDefinition || pID == kInfinityWindoidDefinition );						// auto-detect if dialog is modal		fModal = ( 	varCode == dBoxProc 	||				varCode == plainDBox 	||				varCode == altDBoxProc  ||				varCode == movableDBoxProc ||				pID == kWindowDialogDefProcResID );}/*------------------------------***  CreateNewDialogItem  ***---------------------------*//*access:			protectedoverrides:		description: 	create the dialog item view given a magic type & parameters.ins: 			<parView> parent view of the item to create				<item> id of the item to make				<magicType> the type code for the item				<frame> the bounding frame of the item				<DITLparam> pointer to item data in DITL resource				<pCount> count of magic parameters listed				<params> array of parameters from magic string				<success> set to TRUE if creation of view succeeded, else FALSEouts: 			the view object notes:			the item is already a child of parView on exit----------------------------------------------------------------------------------------*/ZView*		ZViewDialog::CreateNewDialogItem( ZView* parView, const short item, const OSType magicType, Rect* frame, Ptr DITLparam, short pCount, long params[], Boolean* success ){	ZView*							obj = NULL;	Object_Info						oi;	DialogItemConstructorFunction	dif;	short							param;		if ( sDialogItemRegistry )	{		long	index = sDialogItemRegistry->FindClass( magicType );			if ( index > 0 )		{			sDialogItemRegistry->GetArrayItem( &oi, index );					if ( oi.newfunc == NULL )				FailOSErr( kBadConstructorFuncErr );						dif = (DialogItemConstructorFunction) oi.newfunc;						// how the parameter is passed to the object constructor depends on what's in the registry. If it's one			// of the hints, we know how to interpret the DITLparam passed to this. If anything else, that value			// is directly passed itself. So decide what to do and call the function:						switch( oi.refCon )			{				case kUseDITLResourceID:					// pass a single short param extracted from DITL resource					param = *(short*) DITLparam;					FailNIL( obj = (*dif)( parView, frame, param ));					break;									case kUseDITLStringData:					// string data is set up by the caller - pass zero.					param = 0;					FailNIL( obj = (*dif)( parView, frame, param ));					break;									case kInitItemWithMagicParams:					// pass magic data directly to constructor function					FailNIL( obj = (*dif)( parView, frame, pCount, params ));					break;									case kInitItemWithFirstParam:					// pass single magic param as a short					param = params[0];					FailNIL( obj = (*dif)( parView, frame, param ));					break;									default:					// pass whatever was registered					param = oi.refCon;					FailNIL( obj = (*dif)( parView, frame, param ));					break;			}			*success = TRUE;		}		else		{			// for an unregistered type, let's be helpful by making a textbox object. This will display the			// original "magic string" and therefore alert the programmer that something isn't registered.			Str255	piStr;						FailNIL( obj = new ZTextBoxView( parView, frame ));			obj->SetFontInfo( kFontIDMonaco, 9, 0 );			obj->AttachBorder( new ZUTBorder());			obj->SetForeColour( &gRed );						CopyPString( "\pUnregistered Magic Item [", piStr );			*(long*) &piStr[ ++piStr[0]] = magicType;			piStr[0] += 3;			ConcatPStrings( piStr, "\p] - please fix before shipping!" );			((ZTextBoxView*) obj )->SetValue( piStr );			*success = FALSE;		}	}	else		FailOSErr( kNoDialogItemsRegisteredErr );		// note that to track items easily, we use the classID to store the magic type, and the user ID	// to store the item number. Do NOT overwrite these fields when using dialogs, otherwise the dialog	// won't be able to find its items.		obj->SetClassID( magicType );	obj->SetUserID( item );	if ( obj->GetParent() != this )		ListenTo( obj );	#if USE_DIALOG_AUX_INFO	// also create an auxiliary info record for the item. This is currently not really used, but	// is a useful gateway to add dialog-specific features in the future.	AuxDialogInfo	ai;		ai.itemNumber = item;	ai.switchGroup = 0;	ai.accelKey = 0;	fAuxItemInfo->AppendItem( &ai );#endif		return obj;}/*---------------------------------***  MakeDialogItems  ***----------------------------*//*access:			publicoverrides:		description: 	create all the dialog item views from the DITL listins: 			<parView> parent view for items created - normally the dialog itself.				<ditlID> resource ID of the template to use				<numberFrom> start numbering items atthis value (0 = use default numbering)outs: 			nonenotes:			not usually called directly by applications - public for special use.----------------------------------------------------------------------------------------*/void		ZViewDialog::MakeDialogItems( ZView* parView, const short ditlID, short numberFrom ){	DITLHdl			dh;	ictbHandle		ictb = NULL;	dftbHandle      dftb = NULL;	short			i, dmType, pCount, itemNumber;	Ptr				dhp, paramPtr;	OSType			magicType;	Rect			frame;	ZView*			theItem;	Boolean			viewOK;	long			params[ kMaxNumOfMagicParameters ];		FailNILRes( dh = (DITLHdl) GetResource( 'DITL', ditlID ));	HNoPurge((Handle) dh );		// look for resources to set up fonts and colours for items. If there is a 'dftb', use that. If not,	// try an 'ictb'. If not, use the defaults. Note that you can use a 'dftb' even if your app is not	// appearance aware - in that case, any "themed" fonts won't work		    dftb = ( dftbHandle ) GetResource( 'dftb', ditlID );    if ( dftb )        HNoPurge((Handle) dftb );    else     {  		ictb = ( ictbHandle ) GetResource( 'ictb', ditlID );					if ( ictb )			HNoPurge((Handle) ictb );    }      		// OK, ready to rock and roll-		HLock((Handle) dh );	dhp = (Ptr) &(*dh)->i;		for( i = 0; i <= (*dh)->itemCount; i++ )	{		// clear param list, in case items are not strictly checking		// the paramCount they are passed (a 0 param means use default)				pCount = kMaxNumOfMagicParameters;		while( pCount )			params[--pCount] = 0;				// get basic info from DITL:				frame = ((DITLItemHeader*) dhp)->itemFrame;		OffsetRect( &frame, sItemPosOrigin.h, sItemPosOrigin.v );		dmType = (((DITLItemHeader*) dhp)->itemType & 0x7F );			magicType = GetMagicTypeFromDialogManagerType( dmType );				// skip help items				if ( magicType != kHelpStdItem )		{			// use actual item count rather than DITL index - this allows use to use this			// method when we come to append items as well						if ( numberFrom == 0 )				itemNumber = CountItems() + 1;			else				itemNumber = ++numberFrom;							// outset frame for edit field item, this compensates for differences between DM			// and view implementations of this item						if ( dmType & editText )				InsetRect( &frame, -2, -2 );						// pointer to the variable DITL data:							paramPtr = (Ptr) &((DITLItemHeader*) dhp)->iData;						if ( dmType >= iconItem ||				 ( dmType & 7 ) == 7 )			{				// these are basic resControl or other resource based types (icon or picture)				// these types never have magic parameters, and the basic info comes directly from the DITL								theItem = CreateNewDialogItem( parView, itemNumber, magicType, &frame, paramPtr, 0, params, &viewOK );			}			else			{				// plain buttons, checkboxes, radios, static and edit text items handled here.				// copy the string data - further calls may modify it:								Str255		stat;								BlockMoveData( paramPtr, &stat[1], ((DITLItemHeader*) dhp)->iDataLen );				stat[0] = ((DITLItemHeader*) dhp)->iDataLen;								// if static text, parse for special magic items:								if ( dmType & statText )					ParseStatText( stat, &magicType, &pCount, params );									// create the view:								theItem = CreateNewDialogItem( parView, itemNumber, magicType, &frame, paramPtr, pCount, params, &viewOK );				// these items have a string - either a title or a value. Controls have titles,				// others have values.								if ( viewOK )				{					ZItemView*	iv;										iv = dynamic_cast<ZItemView*>( theItem );										if ( iv && stat[0] > 0 )					{						if ( dmType & ctrlItem )							iv->SetTitle( stat );						else							iv->SetValue( stat );					}				}			}			// set up item colours and fonts from associated resources						if ( viewOK )			{					if ( dftb )					InitItemFromDFTB( itemNumber, dftb, i );				else				{					if ( ictb )						InitItemFromICTB( itemNumber, ictb, i );				}							// the "enabled" flag in the DITL sets whether the view accepts clicks or not							theItem->SetAcceptsMouseClicks((((DITLItemHeader*) dhp)->itemType & 0x80 ) == 0 );								SetItemTooltip( ditlID, itemNumber, i + 1 );			}		}		// move pointer to next item				dhp += ((DITLItemHeader*) dhp)->iDataLen + sizeof( DITLItemHeader ) - sizeof( short );				// add pad byte if not an even address				if ((long) dhp & 1 )			dhp++;	}		// all done, clean up.		HUnlock((Handle) dh );	HPurge((Handle) dh );	ReleaseResource((Handle) dh );		if ( dftb )	{	    HPurge((Handle) dftb );	    ReleaseResource((Handle) dftb );	}		if ( ictb )	{	    HPurge((Handle) ictb );		ReleaseResource((Handle) ictb );	}		InitItemSizingFromRes( ditlID );}/*---------------------------------***  ParseStatText  ***------------------------------*//*access:			protectedoverrides:		description: 	break down "magic string" into constituent partsins: 			<sText> raw text to process, receives modified string				<typeParam> receives magic type code				<paramCount> receives count of parameters				<params> receives parametersouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::ParseStatText( Str255 sText, OSType* typeParam, short* paramCount, long params[] ){	// is the string at least 6 chars long? It must consist of two dollar signs followed	// by a four character object code. The additional parameters are optional.		unsigned char 	cc = 0;		while( ++cc < sText[0] )	{		// find two dollar signs?				if ( sText[cc] == '$' && sText[cc + 1] == '$' )		{			// yes, so extract the magic object code ( next 4 chars ).				*typeParam = *(long*) &sText[ cc + 2 ];						// any parameters? These should be comma delimited numbers						unsigned char	pc = 0;			unsigned char	i = cc + 6;			unsigned char	t;			long			p;			Str15			seg;						while( i <= sText[0] )			{				if ( sText[i++] == ',' )				{					t = i;										// found a comma, search forward to next comma or					// end of string										while(( sText[t] != ',' ) && ( t <= sText[0] )) t++;										// extract part of string between two commas										BlockMoveData( &sText[i], &seg[1], t - i );					seg[0] = t - i;										StringToNum( seg, &p );										i = t;										// set parameter										params[ MIN( kMaxNumOfMagicParameters, pc )] = p;										pc++;				}			}						*paramCount = pc;						// set the string empty except for any preceding characters						sText[0] = cc - 1;			break;		}	}}/*-----------------------***  GetMagicTypeFromDialogManagerType  ***--------------------*//*access:			protectedoverrides:		description: 	return magic type code for Dialog Manager codeins: 			<dmType> dialog manager codeouts: 			magic type codenotes:			----------------------------------------------------------------------------------------*/OSType		ZViewDialog::GetMagicTypeFromDialogManagerType( short dmType ){	long m = 0;		if ( dmType & ctrlItem )	{		switch( dmType & 3 )		{			case 0:				m = kMagicStdPushButton;				break;							case 1:				m = kMagicStdCheckbox;				break;							case 2:				m = kMagicStdRadioButton;				break;							case 3:				m = kMagicStdResControl;				break;		}	}	else	{		switch ( dmType & 0x7B )		{			case iconItem:				m = kMagicStdIcon;				break;							case picItem:				m = kMagicStdPicture;				break;							case editText:				m = kMagicStdEditText;				break;							case statText:				m = kMagicStdStaticText;				break;							case userItem:				m = kMagicStdUserItem;				break;						    case helpItem:		        m = kHelpStdItem;		        break;		}	}		return m;}/*--------------------------------***  InitItemFromICTB  ***----------------------------*//*access:			protectedoverrides:		description: 	set up item colours, font, etc from 'ictb' resourceins: 			<item> item to set up				<ictb> handle to ictb resource				<ictbIndex> entry in table to use for this itemouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::InitItemFromICTB( const short item, ictbHandle ictb, const short ictbIndex ){	if (( GetMacWindow() != NULL ) && IsColourPort( WINDOWGRAFPTR( GetMacWindow() )) && ictb )	{		// there is an ictb, so see if this item has a special entry:				ZView*			di;		ictbItemEntry	ie;		TextStyle		tsRec;		Boolean			setFont = FALSE;				di = GetItem( item );				ie = (*ictb)[ ictbIndex ];				if ( ie.iData != 0 &&			 ie.iOffset != 0 )		{			// yes, there is a special setting for this item- what is it?						ictbTablePtr	tp;						HLock((Handle) ictb );			tp = ( ictbTablePtr ) ((Ptr) *ictb + ie.iOffset );				// tp is now pointing at the text table for the item. Using this table,			// we need to set up a TEStyle record and pass it to TextEdit.						// the font is either already known or can be looked up via its name						if ( ie.iData & fFamChange )			{				if ( ie.iData & fIsFNameOffset )				{					// need to look up the font via the name table. In this case					// txtFont contains the offset to the font's name										GetFNum((unsigned char*) *ictb + tp->txtFont , &tsRec.tsFont );				}				else					tsRec.tsFont = tp->txtFont;									setFont = TRUE;			}			else				tsRec.tsFont = 0;							// set simple fields						if ( ie.iData & fFaceChange )			{				tsRec.tsFace = tp->txtFace;				setFont = TRUE;			}			else				tsRec.tsFace = 0;							if ( ie.iData & fSizeChange )			{				tsRec.tsSize = tp->txtSize;				setFont = TRUE;			}			else				tsRec.tsSize = 0;							// set the colours of the port						if ( ie.iData & fFColourChange )				di->SetForeColour( &tp->txtFColour );						if ( ie.iData & fBColourChange )				di->SetBackColour( &tp->txtBColour );			HUnlock((Handle) ictb );						if ( setFont )				di->SetFontInfo( tsRec.tsFont, tsRec.tsSize, tsRec.tsFace );		}	}}/*--------------------------------***  InitItemFromDFTB  ***----------------------------*//*access:			protectedoverrides:		description: 	set up item colours, font, etc from 'dftb' resourceins: 			<item> item to set up				<dftb> handle to ictb resource				<dftbIndex> entry in table to use for this itemouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void        ZViewDialog::InitItemFromDFTB( const short item, dftbHandle dftb, const short dftbIndex ){	if ( GetMacWindow() && IsColourPort( WINDOWGRAFPTR( GetMacWindow())) && dftb )	{        // entries in the dftb have variable length, so we need to walk through them to obtain        // the right entry                 ZView*    		di;        short           count, font, size;        Style           face;        dftbEntryPtr    dp;                if (( dftbIndex >= 0 ) && ( dftbIndex < (*dftb)->dfCount ))        {                 di = GetItem( item );            face = font = size = 0;            count = 0;            HLock((Handle) dftb );            dp = &(*dftb)->df[0];                        while( count++ < dftbIndex )            {		    	if( dp->dfType != 0 )		    		dp = (dftbEntry*)((long) dp + dfEntrySize + dp->dfFontNameLen );		     	else		    		dp = (dftbEntry*)((long) dp + 2 );            }                        // now, dp points to the relevant entry, so let's parse that and set up the item                        if ( dp->dfType != 0 && dp->dfFontFlags != 0 )            {                // font flags are present, so interpret them:                                if ( dp->dfFontFlags & kDialogFontUseFaceMask )                    face = dp->dfFontStyle;                                if ( dp->dfFontFlags & kDialogFontUseSizeMask )                    size = dp->dfFontSize;                                    if ( dp->dfFontFlags & kDialogFontUseFontNameMask )                    GetFNum( &dp->dfFontNameLen, &font );                else                {                    if ( dp->dfFontFlags & kDialogFontUseFontMask )                    {                        font = dp->dfFontID;                                        if ( font < 0 )                        {                        #if APPEARANCE_MGR_AWARE                         	if ( gMacInfo.hasAppearanceMgr )                        	{         							Str255          fName;                                                        	// meta-font constant, so get the actual font ID                                                        	GetThemeFont((ThemeFontID)((-font) - 1 ), smSystemScript, fName, &size, &face );                            	GetFNum( fName, &font );                            }                            else                        #endif                        		font = -font;	// this will give erroneous results, but dftb aren't *really*                        						// supposed to be used if you haven't got appearance.                        						// However this will make Max happy... ;-)                        }                    }                }                                di->SetFontInfo( font, size, face );                            // now the colours:                                if ( dp->dfFontFlags & kDialogFontUseForeColorMask )                    di->SetForeColour( &dp->dfTextColour );                                    if ( dp->dfFontFlags & kDialogFontUseBackColorMask )                    di->SetBackColour( &dp->dfBackColour );                                /*                if ( dp->dfFontFlags & kDialogFontUseJustMask )                    di->SetFontAlignment( dp->dfTextJust );                */		// TO DO            }            HUnlock((Handle) dftb );        }    }}/*------------------------------***  InitItemSizingFromRes  ***-------------------------*//*access:			protectedoverrides:		description: 	set up item automatic sizing from 'ISIZ' resourceins: 			<resID> resource ID to useouts: 			nonenotes:			if no ISIZ resource, attempts to use more limited ILIM resource----------------------------------------------------------------------------------------*/void		ZViewDialog::InitItemSizingFromRes( const short resID ){	ItemLimHdl		ih;	ItemSizeHdl		sH;	short			nItems;		// see if we have the new resource type first:		sH = (ItemSizeHdl) GetResource( kDialogItemSizeResType, resID );		if ( sH )	{		nItems = GetHandleSize((Handle) sH ) / sizeof( ItemSizeRecord );				for ( short i = 0; i < nItems; i++ )		{			Sizing	s;						s = AUTOSIZE((*sH)[i].top, (*sH)[i].left, (*sH)[i].bottom, (*sH)[i].right );			SetItemSizing((*sH)[i].itemID, s );		}					ReleaseResource((Handle) sH );	}	else	{		// no, so attempt to use old type			ih = (ItemLimHdl) GetResource( kDialogItemSizingResType, resID );				if ( ih )		{			nItems = GetHandleSize((Handle) ih ) / sizeof( ItemLimRecord );						for ( short i = 0; i < nItems; i++ )				SetItemSizing((*ih)[i].item, (*ih)[i].iSizing );							ReleaseResource((Handle) ih );		}	}}/*---------------------------------***  SetItemTooltip  ***-----------------------------*//*access:			protectedoverrides:		description: 	set up item tooltips from 'DTIP' resourceins: 			<resID> resource ID to use				<itemNumber> item number of item to set				<index> index of string in resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZViewDialog::SetItemTooltip( const short resID, const short itemNumber, const short index ){	ZView*		vi;	Str255		tt;		try	{		GetIndStringFromResource( 'DTIP', resID, index, tt );				if ( tt[0] > 0 )		{			vi = GetItem( itemNumber );					if ( vi )				vi->SetTooltipText( tt );		}	}	catch(...)	{		// ignore this exception - just means no tips exist	}}#pragma mark -void	ZUTBorder::Draw( Rect* borderFrame ){	Pattern dashPat = { 0x07, 0x0E, 0x1C, 0x38, 0x70, 0xE0, 0xC1, 0x83 };		PenNormal();	PenPat( &dashPat );	RGBForeColor( &gRed );	FrameRect( borderFrame );}#pragma mark -/*---------------------------***  CreateNewAuxiliaryDITLView  ***-----------------------*//*access:			globaloverrides:		description: 	create a view subhierarchy from a DITL resourceins: 			<parView> parent view				<aFrame> frame of auxiliary view				<pCount> parameter count				<params> the parameters, as  listed belowouts: 			the master view which is parent to all the othersnotes:			params[0] is the DITL ID to incorporate				params[1] is the starting value to number the items from				NOTE: this will only permit views to be embedded to a certain depth.				If this is exceeded, further inclusions will be ignored. This is				important to avoid crashes due to the potential for stack overflow.				WARNING: never create circular references - a DITL can't include itself				or any other than eventually includes an earlier one.----------------------------------------------------------------------------------------*/ZView*	CreateNewAuxiliaryDITLView( ZView* parView, Rect* aFrame, short pCount, long params[] ){	static short	recursionMonitor = 0;	ZView*			mv = NULL;		++recursionMonitor;		FailNIL( mv = new ZView( parView, aFrame ));	if (( recursionMonitor < kMaxDITLNestingDepth ) && ( pCount > 0 ))	{		// borrow a temporary dialog object to do the hard work:				ZViewDialog		dt;				dt.MakeDialogItems( mv, params[0], params[1] );	}		--recursionMonitor;		return mv;}