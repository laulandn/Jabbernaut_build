/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZScrollView.cpp		-- a view that scrolls******			©2000, Graham Cox*****************************************************************************************************/#include	"ZScrollView.h"#include	"MacZoop.h"#include	"ZWindow.h"// statics; globals:ControlActionUPP	ZScrollView::sScrollViewProc = NULL;ControlHandle		ZScrollView::sCurrentScrollbar = NULL;DragGrayRgnUPP		ZScrollView::sLiveScrollProc = NULL;short				ZScrollView::sLSPosition = 0;long				ZScrollView::sScrollThrottle = 0;/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZScrollView::ZScrollView( ZView* aParent, Rect* aFrame,							const Boolean makeHBar,							const Boolean makeVBar,							const Boolean hasSizeBox )	: ZView( aParent, aFrame ){	classID = CLASS_ZScrollView;		fHasSizeBox = ( hasSizeBox || ( makeHBar && makeVBar ));		ScrollViewInit( makeHBar, makeVBar );		if ( sScrollViewProc == NULL )		sScrollViewProc = NewControlActionUPP( ScrollBarViewProc );			if ( sLiveScrollProc == NULL )		sLiveScrollProc = NewDragGrayRgnUPP( LiveScrollDragProc );	}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZScrollView::ZScrollView( ZView* aParent, const short viewResourceID )	: ZView( aParent ){	classID = CLASS_ZScrollView;	ViewResInit( viewResourceID );	if ( sScrollViewProc == NULL )		sScrollViewProc = NewControlActionUPP( ScrollBarViewProc );			if ( sLiveScrollProc == NULL )		sLiveScrollProc = NewDragGrayRgnUPP( LiveScrollDragProc );	}/*---------------------------------***  DESTRUCTOR  ***----------------------------------*/ZScrollView::~ZScrollView(){	if ( HasHBar())		DisposeControl( theHBar );			if ( HasVBar())		DisposeControl( theVBar );}/*---------------------------------***  DrawAll  ***------------------------------------*//*access:			publicoverrides:		description: 	draw the frame. This includes the attached scrollbarsins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::DrawAll(){	if ( IsVisible())	{		Rect	cr;				GetContentRect( &cr );				// draw sizebox...				if ( fHasSizeBox )		{			Rect	sb;						GetSizingBox( &sb );		#if APPEARANCE_MGR_AWARE			if ( gMacInfo.hasAppearanceMgr )				DrawThemePlacard( &sb, ( IsActive() && IsEnabled()));			else			{		#endif				RGBBackColor( IsActive()? &gMediumGray: &gVeryLightGray );				EraseRect( &sb );		#if APPEARANCE_MGR_AWARE			}		#endif		}				if( HasHBar())		{		#if APPEARANCE_MGR_AWARE			if ( gMacInfo.hasAppearanceMgr )				DrawControlInCurrentPort( theHBar );			else		#endif				Draw1Control( theHBar );						if ( fHBarInset )			{				PenNormal();				RGBForeColor( &gBlack );					MoveTo( cr.left, cr.bottom );				LineTo( cr.right, cr.bottom );			}		}				if( HasVBar())		{		#if APPEARANCE_MGR_AWARE			if ( gMacInfo.hasAppearanceMgr )				DrawControlInCurrentPort( theVBar );			else		#endif				Draw1Control( theVBar );						if ( fVBarInset )			{				PenNormal();				RGBForeColor( &gBlack );					MoveTo( cr.right, cr.top );				LineTo( cr.right, cr.bottom );			}		}				ZView::DrawAll();	}}/*--------------------------------***  DrawBorder  ***----------------------------------*//*access:			publicoverrides:		description: 	draw the border. draws 1-pixel frame if std border not setins: 			<borderFrame> border to drawouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::DrawBorder( Rect* borderFrame ){	if ( ! HasStdBorder())	{		PenNormal();		RGBForeColor( &gBlack );		FrameRect( borderFrame );	}	else		ZView::DrawBorder( borderFrame );}/*---------------------------------***  Click  ***-------------------------------------*//*access:			publicoverrides:		description: 	respond to a click within the frame.ins: 			<mouse> the point relative to the frame				<modifiers> the modifier flagsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::Click( const Point mouse, const short modifiers ){	ControlHandle		cb;	short				partCode = 0;		// point is relative to frame here	// Can't use FindControl because it assumes all controls are in same coordinate space.	// This isn't true - controls are local to our frame. Use TestControl instead.		if ( HasHBar())	{		cb = theHBar;		partCode = TestControl( cb, mouse );	}		if ( partCode == 0 && HasVBar())	{		cb = theVBar;		partCode = TestControl( cb, mouse );	}		if ( partCode )	{		// scrollbar was hit, so track the control				sCurrentScrollbar = cb;		sLSPosition = GetControlValue( cb );				if (( partCode == kControlIndicatorPart ) && ! gMacInfo.hasAppearanceMgr )		{			cInitValue = GetControlValue( cb );			TrackControl( cb, mouse, (ControlActionUPP) sLiveScrollProc );						// scrollbar will be in the wrong place when released, because we've already updated its			// value as we tracked, but then the CM adds the offset to the existing value. To fix this,			// we restore the true final value we last calculated.						SetControlValue( cb, sLSPosition );		}		else			MZTrackControl( cb, mouse, modifiers, sScrollViewProc );				sCurrentScrollbar = NULL;	}	else	{		// if click in sizing box, pass to method to deal with it.				if ( fHasSizeBox )		{			Rect	sb;						GetSizingBox( &sb );									if ( PtInRect( mouse, &sb ))			{				ClickSizingBox();				return;			}		}				ZView::Click( mouse, modifiers );	}}/*-----------------------------------***  Type  ***-------------------------------------*//*access:			publicoverrides:		description: 	respond to page up, page down, home and endins: 			<theKey> character typed				<modifiers> the modifiers keysouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::Type( const char theKey, const short modifiers ){	Rect			br;		switch ( theKey )	{		case HOME_KEY:			Focus();			ScrollTo( 0, 0 );			break;					case END_KEY:			Focus();			GetBounds( &br );			ScrollTo( br.right, br.bottom );			break;				case PAGE_UP_KEY:			if ( HasVBar())			{				Focus();				ScrollCallback( GetVBar(), kControlPageUpPart );			}			break;					case PAGE_DOWN_KEY:			if ( HasVBar())			{				Focus();				ScrollCallback( GetVBar(), kControlPageDownPart );			}			break;					default:			ZView::Type( theKey, modifiers );			break;	}}/*--------------------------------***  Activate  ***------------------------------------*//*access:			publicoverrides:		description: 	activates the viewins: 			noneouts: 			nonenotes:			shows scrollbars when activated----------------------------------------------------------------------------------------*/void		ZScrollView::Activate(){	ZView::Activate();		if ( IsVisible())	{		Focus();				if ( HasHBar())			HiliteControl( theHBar, 0 );				if ( HasVBar())			HiliteControl( theVBar, 0 );	}}/*-------------------------------***  Deactivate  ***-----------------------------------*//*access:			publicoverrides:		description: 	deactivates the viewins: 			noneouts: 			nonenotes:			hides scrollbars when deactivated----------------------------------------------------------------------------------------*/void		ZScrollView::Deactivate(){	ZView::Deactivate();		if ( IsVisible())	{		Focus();				if ( HasHBar())			HiliteControl( theHBar, 255 );				if ( HasVBar())			HiliteControl( theVBar, 255 );	}}/*---------------------------------***  Enable  ***-------------------------------------*//*access:			publicoverrides:		description: 	enables the viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::Enable(){	ZView::Enable();	Focus();		if ( HasHBar())		HiliteControl( theHBar, 0 );		if ( HasVBar())		HiliteControl( theVBar, 0 );}/*---------------------------------***  Disable  ***------------------------------------*//*access:			publicoverrides:		description: 	disables the viewins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::Disable(){	ZView::Disable();	Focus();		if ( HasHBar())		HiliteControl( theHBar, 255 );		if ( HasVBar())		HiliteControl( theVBar, 255 );}/*------------------------------------***  Show  ***------------------------------------*//*access:			publicoverrides:		description: 	make the view visible.ins: 			noneouts: 			nonenotes:		----------------------------------------------------------------------------------------*/void		ZScrollView::Show(){	ZView::Show();	Focus();	ShowScrollbars();}/*------------------------------------***  Hide  ***------------------------------------*//*access:			publicoverrides:		description: 	make the view non-visible.ins: 			noneouts: 			nonenotes:		----------------------------------------------------------------------------------------*/void		ZScrollView::Hide(){	ZView::Hide();	Focus();	HideScrollbars();}/*------------------------------***  DoSelectionUpdate  ***-----------------------------*//*access:			publicoverrides:		description: 	handle change in command chain involving this viewins: 			<state> acquiring or losing the handler statusouts: 			nonenotes:			draws standard border----------------------------------------------------------------------------------------*/void		ZScrollView::DoSelectionUpdate( Boolean state ){	DrawSelfBorder();	ZView::DoSelectionUpdate( state );}/*---------------------------------***  SetSize  ***------------------------------------*//*access:			publicoverrides:		description: 	sizes the viewins: 			<aWidth, aHeight>, new sizes for the viewouts: 			nonenotes:			adjusts scrollbars to allow for changed size----------------------------------------------------------------------------------------*/void		ZScrollView::SetSize( const short aWidth, const short aHeight ){	Rect	r;		GetFrame( &r );		if ( aWidth != ( r.right - r.left ) ||		 aHeight != ( r.bottom - r.top ))	{		if ( fStateFlags & kViewRefreshOnResize )		{			GetParent()->Focus();			InsetRect( &r, -1, -1 );			EraseRect( &r );			PostRefresh( &r );		}				HideScrollbars();		ZView::SetSize( aWidth, aHeight );		MoveScrollbars();		ShowScrollbars();		DrawSelfBorder();				// some embedded views might be interested in the fact that we've resized,		// even though the bounds hasn't changed				SendMessage( kMsgScrollViewAreaReveal, NULL );	}}/*------------------------------***  GetContentRect  ***--------------------------------*//*access:			publicoverrides:		description: 	returns the interior area of the viewins: 			<aRect>, receives the interior rectangleouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::GetContentRect( Rect* aRect ){	ZView::GetContentRect( aRect );		if ( HasHBar())		aRect->bottom -= sbWidth;			if ( HasVBar())		aRect->right -= sbWidth;}/*--------------------------------***  SetBounds  ***-----------------------------------*//*access:			publicoverrides:		description: 	set the logical bounds rect to the rect passedins: 			<aBounds>, the logical drawing area of the viewouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::SetBounds( const Rect& aBounds ){	Rect	br, nbr;		GetBounds( &br );	Focus();	fBounds = aBounds;	CalcScrollParams();	GetBounds( &nbr );		short	dt, dl, db, dr;		dt = nbr.top - br.top;	dl = nbr.left - br.left;	db = nbr.bottom - br.bottom;	dr = nbr.right - br.right;			if ( dt || dl || db || dr )	{		ITERATECHILDVIEWS( AdjustToParent( dt, dl, db, dr ));	}}/*--------------------------------***  SetBounds  ***-----------------------------------*//*access:			publicoverrides:		description: 	set the logical bounds rect from the sizes passedins: 			<hSize> new width of bounds				<vSize> new height of boundsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::SetBounds( const short hSize, const short vSize ){	Rect	r;	SetRect( &r, 0, 0, hSize, vSize );	SetBounds( r );}/*-------------------------------***  GetPosition  ***----------------------------------*//*access:			publicoverrides:		description: 	return offset between frame and boundsins: 			<posH, posV> horizontal and vertical offsets from the frameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::GetPosition( short* posH, short* posV ){	ZView::GetPosition( posH, posV );	if ( HasHBar())	{		if ( GetControlMaximum( theHBar ) > GetControlMinimum( theHBar ))			*posH += GetControlValue( theHBar );	}				if ( HasVBar())	{		if ( GetControlMaximum( theVBar ) > GetControlMinimum( theVBar ))			*posV += GetControlValue( theVBar );	}}/*------------------------------***  GetSizingBox  ***----------------------------------*//*access:			publicoverrides:		description: 	return area of "sizing box", if there is one.ins: 			<sizBox> accepts rect, in frame coordinatesouts: 			nonenotes:			returns empty rect if no sizebox----------------------------------------------------------------------------------------*/void		ZScrollView::GetSizingBox( Rect* sizBox ){	if ( fHasSizeBox )	{		GetFrame( sizBox );		OffsetRect( sizBox, -fFrame.left, -fFrame.top );			sizBox->left = sizBox->right - sbWidth;		sizBox->top = sizBox->bottom - sbWidth;		sizBox->right++;		sizBox->bottom++;	}	else		SetRect( sizBox, 0, 0, 0, 0 );}/*----------------------------***  SetScrollbarInset  ***-------------------------------*//*access:			publicoverrides:		description: 	inset scrollbars to allow for e.g. placards, etc in bar areains: 			<hBarInset> left offset of horizontal bar				<vBarInset> top offset of vertical barouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::SetScrollbarInset( const short hBarInset, const short vBarInset ){	if ( hBarInset != fHBarInset ||		 vBarInset != fVBarInset )	{		fHBarInset = hBarInset;		fVBarInset = vBarInset;			MoveScrollbars();	}}/*-------------------------***  GetAuxiliaryPlacardRect  ***----------------------------*//*access:			publicoverrides:		description: 	return a frame rectangle suitable for a placardins: 			<placRect> receives the rectangle				<horv> FALSE for horizontal placarrd, TRUE for verticalouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::GetAuxiliaryPlacardRect( Rect* placRect, const Boolean horv ){	Rect	fr, cr;		GetFrame( &fr );	GetContentRect( &cr );		*placRect = fr;		if ( horv )	{		placRect->top = fr.top + cr.top - 1;		placRect->bottom = placRect->top + fVBarInset + 1;		placRect->left = placRect->right - sbWidth;		placRect->right++;	}	else	{		placRect->left = fr.left + cr.left - 1;		placRect->right = placRect->left + fHBarInset + 1;		placRect->top = placRect->bottom - sbWidth;		placRect->bottom++;	}}/*-----------------------------***  SetScrollAmount  ***--------------------------------*//*access:			publicoverrides:		description: 	set the number of pixels moved for each click of the scrollbarins: 			<hS, vS> horizontal and vertical scales for the scrolling				<autoTweak> TRUE if the height is adjusted to a whole number of linesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::SetScrollAmount( const short hS, const short vS, const Boolean autoTweak ){	hScale = hS;	vScale = vS;	CalcScrollParams();		if ( autoTweak )		TweakHeight();}/*-------------------------------***  ScrollView  ***----------------------------------*//*access:			publicoverrides:		description: 	scroll the view by the deltas passed.ins: 			<dH, dV> horizontal and vertical distances to scrollouts: 			nonenotes:			don't call directly - this does not update the bars. Use ScrollTo instead----------------------------------------------------------------------------------------*/void		ZScrollView::ScrollView( const short dH, const short dV ){	RgnHandle	updateRgn;	Rect		content;		if ( dH == 0 && dV == 0 )		return;			// if scroll throttle engaged, make sure we don't go too fast		if ( fUseThrottle )	{		long	t = TickCount() - sScrollThrottle;				if ( t < fUseThrottle )			MZDelay( fUseThrottle - t );					sScrollThrottle = TickCount();	}	Focus();		// if we're the target of a drag, compensate for scroll	// n.b. DragPreScroll doesn't work properly, it seems.	// this is flickery, but it does the job.		if ( sCurRxDragRef && (( sCurRxDragTarget == this ) || IsChildView( sCurRxDragTarget )))		sCurRxDragTarget->DDHiliteView( FALSE, sCurRxDragRef );		// scroll the actual bits in the content rect		PrepareForDrawing();	FailNIL( updateRgn = NewRgn());	GetContentRect( &content );	LocalScroll( &content, dH, dV, updateRgn );		// set up to redraw the revealed region		short pH = PORTPORTRECT( GetMacPort())->left;	short pV = PORTPORTRECT( GetMacPort())->top;		sViewBaseClipRgn = updateRgn;		// copy updated region to util for benefit of ZMouseTracker		CopyRgn( updateRgn, gUtilRgn );	OffsetRgn( sViewBaseClipRgn, -pH, -pV );		// set up clip & update the content area		if ( FocusForContent())	{		ClipViewsAbove();		DrawContent();	}		// restore the previous origin		sViewBaseClipRgn = NULL;	Focus();	DisposeRgn( updateRgn );	// call the scroll hook - this gives you the chance to do additional things	// whenever the view is scrolled. Default hook just sends a message.		ScrollHook( dH, dV );	Focus();		// deal with drag hilite, if any		if ( sCurRxDragRef && (( sCurRxDragTarget == this ) || IsChildView( sCurRxDragTarget )))		sCurRxDragTarget->DDHiliteView( TRUE, sCurRxDragRef );}/*---------------------------------***  ScrollTo  ***-----------------------------------*//*access:			publicoverrides:		description: 	scroll the view to the absolute offset passedins: 			<hPosition> horizontal positon of frame relative to bounds				<vPosition> vertical position of frame relative to boundsouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::ScrollTo( const short hPosition, const short vPosition ){	short	fH, fV, pH, pV;		GetPosition( &fH, &fV );	Focus();		if ( HasHBar())	{		if ( GetControlMaximum( theHBar ) > GetControlMinimum( theHBar ))			SetControlValue( theHBar, hPosition );	}				if ( HasVBar())	{		if ( GetControlMaximum( theVBar ) > GetControlMinimum( theVBar ))			SetControlValue( theVBar, vPosition );	}		GetPosition( &pH, &pV );	ScrollView( fH - pH, fV - pV );}/*------------------------------***  ScrollAsNeeded  ***--------------------------------*//*access:			publicoverrides:		description: 	given a point within the bounds, scroll the view to ensure that				the point is visible. Basic method for scrolling to selectionins: 			<toShowPt> the point to make visibleouts: 			nonenotes:			point passed should usually represent top, left of selection----------------------------------------------------------------------------------------*/void		ZScrollView::ScrollAsNeeded( const Point toShowPt ){	Rect	cr;	short	pH, pV, dH = 0, dV = 0;		GetContentRectInBounds( &cr );	GetPosition( &pH, &pV );		// allow one scale unit to ensure point fully in view		cr.bottom -= vScale;	cr.right -= hScale;		if ( ! PtInRect( toShowPt, &cr ))	{		// point not visible, so we need to scroll				if ( toShowPt.v < cr.top )			dV = cr.top - toShowPt.v;		else		{			if ( toShowPt.v > cr.bottom )				dV = cr.bottom - toShowPt.v;		}					if ( toShowPt.h < cr.left )			dH = cr.left - toShowPt.h;		else		{			if ( toShowPt.h > cr.right )				dH = cr.right - toShowPt.h;		}					ScrollTo( pH - dH, pV - dV );	}}/*------------------------------***  ScrollCallback  ***--------------------------------*//*access:			publicoverrides:		description: 	called by the action procs for the barsins: 			< aCtl > the control to handle				< partCode> the part of the control being manipulatedouts: 			nonenotes:			do not call this directly----------------------------------------------------------------------------------------*/void		ZScrollView::ScrollCallback( ControlHandle aCtl, const short partCode ){	// this actually peforms the scroll of the content rect		short		curValue;	Boolean		hitIsVertical;	RgnHandle	saveClip = NewRgn();		curValue = GetControlValue( aCtl );	GetClip( saveClip );		// are we scrolling the horizontal or the vertical bar? Find out by comparing	// the control with one of our data members		hitIsVertical = ( aCtl == theVBar );		switch ( partCode )	{		case kControlUpButtonPart:			SetControlValue( aCtl, GetControlValue(aCtl) - (hitIsVertical? vScale : hScale ));			break;				case kControlDownButtonPart:			SetControlValue( aCtl, GetControlValue(aCtl) + (hitIsVertical? vScale : hScale ));			break;				case kControlPageUpPart:			SetControlValue( aCtl, GetControlValue(aCtl) - (hitIsVertical? vPage : hPage ));			break;				case kControlPageDownPart:			SetControlValue( aCtl, GetControlValue(aCtl) + (hitIsVertical? vPage : hPage ));			break;				case kControlIndicatorPart:			// called when live scrolling the thumb. If we have appearance, the scrollbar handles			// this itself, if not, we handle it here.						curValue = sLSPosition - curValue;			break;	}		if ( partCode != kControlIndicatorPart )		curValue -= GetControlValue( aCtl );			if ( hitIsVertical )		ScrollView( 0, curValue );	else		ScrollView( curValue, 0 );	    SetClip( saveClip );	DisposeRgn( saveClip );}/*--------------------------------***  AutoScroll  ***----------------------------------*//*access:			publicoverrides:		description: 	automatically scroll the view based on bounds point passedins: 			<mousePt>, mouse location in bounds coordinates				<inset> pixels inside of content rect that cause autoscrollingouts: 			TRUE if view actually scrolled, otherwise FALSEnotes:			called by ZMouseTracker as required----------------------------------------------------------------------------------------*/Boolean		ZScrollView::AutoScroll( Point mousePt, const short inset ){	Rect			cr;	Boolean			result = FALSE;	short			pH, pV, st;		GetContentRectInBounds( &cr );	GetPosition( &pH, &pV );	InsetRect( &cr, inset, inset );		if ( ! PtInRect( mousePt, &cr ))	{		// mouse moved outside content, so figure out which way and		// scroll it accordingly.			short dH = 0, dV = 0, maxScrollH, maxScrollV;				maxScrollH = hScale * 4;		maxScrollV = vScale * 4;				if ( mousePt.h > cr.right )			dH = MIN( maxScrollH, mousePt.h - cr.right );		else		{			if ( mousePt.h < cr.left )				dH = MAX( -maxScrollH, mousePt.h - cr.left );		}					if ( mousePt.v > cr.bottom )			dV = MIN( maxScrollV, mousePt.v - cr.bottom );		else		{			if ( mousePt.v < cr.top )				dV = MAX( -maxScrollV, mousePt.v - cr.top );		}				st = SetScrollThrottle( 1 );		ScrollTo( pH + dH, pV + dV );		SetScrollThrottle( st );		GetPosition( &dH, &dV );				result = (( dH != pH ) || ( dV != pV ));				// reset for content draw				FocusForContent();		ClipViewsAbove();				OffsetRgn( gUtilRgn, dH, dV );	}		return result;}/*--------------------------------***  WillScroll  ***----------------------------------*//*access:			publicoverrides:		description: 	test if a call to AutoScroll is likely to scroll the viewins: 			<mousePt>, mouse location in bounds coordinatesouts: 			TRUE if view will scroll, otherwise FALSEnotes:			----------------------------------------------------------------------------------------*/Boolean		ZScrollView::WillScroll( Point mousePt, const short inset ){	Rect			cr;		GetContentRect( &cr );	InsetRect( &cr, inset, inset );		return ! PtInRect( mousePt, &cr );}/*-------------------------------***  ClickScroll  ***----------------------------------*//*access:			publicoverrides:		description: 	scroll the view in a grabber-wise fashionins: 			<mousePt>, mouse location in bounds coordinatesouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::ClickScroll( const Point mouse ){	Point	sp, old;	long	delta;	short	ph, pv;	Rect	cr;		FocusForContent();	SetCursorShape( HAND_CURSOR_CLOSED );	GetContentRect( &cr );	sp = old = mouse;		while( WaitMouseUp())	{		GetMouse( &sp );		GetPosition( &ph, &pv );		sp.h -= cr.left;		sp.v -= cr.top;				delta = DeltaPoint( sp, old );				if ( delta )		{			ScrollTo( ph - LoWord( delta ), pv - HiWord( delta ));						old.h = sp.h - LoWord( delta );			old.v = sp.v - HiWord( delta );						FocusForContent();			ClipViewsAbove();		}	}}/*------------------------------***  DDInsideView  ***----------------------------------*//*access:			publicoverrides:		description: 	callsed as long as mouse within view during a dragins: 			<mouse> local mouse point				<theDrag> the drag referenceouts: 			nonenotes:			autoscrolls the view if mouse within 5 pixels of edge----------------------------------------------------------------------------------------*/void		ZScrollView::DDInsideView( const Point mouse, const DragReference theDrag )	{	AutoScroll( mouse, 5 );}/*---------------------------***  SetScrollBarWidth  ***--------------------------------*//*access:			publicoverrides:		description: 	set the width of scrollbars used in the viewins: 			<aWidth> width of barsouts: 			nonenotes:			can be used to match the view to a window's sizebox size----------------------------------------------------------------------------------------*/void		ZScrollView::SetScrollBarWidth( const short aWidth ){	if ( aWidth != sbWidth )	{		HideScrollbars();		sbWidth = aWidth;		MoveScrollbars();		ShowScrollbars();	}}/*-------------------------------***  TweakHeight  ***----------------------------------*//*access:			publicoverrides:		description: 	adjust the height to encompass an exact number of scroll unitsins: 			noneouts: 			nonenotes:			will always adjust the height smaller - call after SetScrollAmount----------------------------------------------------------------------------------------*/void		ZScrollView::TweakHeight(){	Rect	cr;		GetContentRect( &cr );	short	hx = ( cr.bottom - cr.top ) % vScale;		ChangeSize( 0, 0, -hx, 0 );}/*--------------------------------***  ScrollHook  ***----------------------------------*//*access:			publicoverrides:		description: 	a place to hook into the basic scrolling operationins: 			<dh, dv> scroll deltasouts: 			nonenotes:			default method just sends message----------------------------------------------------------------------------------------*/void		ZScrollView::ScrollHook( const short dh, const short dv ){	long	delta;		delta = ((long) dv << 16 ) + dh;	SendMessage( kMsgScrollViewNotifyScroll, &delta );}/*----------------------------***  InitViewFromResource  ***----------------------------*//*access:			publicoverrides:		description: 	initialise this class from a suitable 'View' resourceins: 			<theRes> handle to View resourceouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::InitViewFromResource( Handle theRes ){	FailNILParam( theRes );		ZView::InitViewFromResource( theRes );		ScrollViewTemplateHdl	svH = (ScrollViewTemplateHdl) theRes;		Boolean		hb, vb;		hb = (*svH)->hasHBar;	vb = (*svH)->hasVBar;	fHasSizeBox = ((*svH)->hasSizeBox || ( hb && vb ));		ScrollViewInit( hb, vb );		hScale = (*svH)->hScale;	vScale = (*svH)->vScale;		Rect	r;		SetRect( &r, 0, 0, (*svH)->boundsWidth, (*svH)->boundsHeight );	SetBounds( r );	}/*---------------------------***  CreateViewResource  ***-------------------------------*//*access:			publicoverrides:		description: 	write View resource details for this classins: 			<resHandle> a handleouts: 			nonenotes:			for RAD tool use only - not for apps----------------------------------------------------------------------------------------*/void		ZScrollView::CreateViewResource( Handle resHandle ){	FailNILParam( resHandle );		if ( GetHandleSize( resHandle ) < sizeof( ScrollViewTemplate ))		FailOSErr( kViewTemplateHandleSizeTooSmallErr );			ScrollViewTemplateHdl	svH = (ScrollViewTemplateHdl) resHandle;		(*svH)->hasHBar 	= HasHBar();	(*svH)->hasVBar 	= HasVBar();	(*svH)->hasSizeBox 	= fHasSizeBox;	(*svH)->hScale 		= hScale;	(*svH)->vScale 		= vScale;		Rect	r;	GetBounds( &r );		(*svH)->boundsWidth  = r.right - r.left;	(*svH)->boundsHeight = r.bottom - r.top;		ZView::CreateViewResource( resHandle );	}/*------------------------------***  ReportFields  ***----------------------------------*//*access:			publicoverrides:		description: 	return member data to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::ReportFields(){	ZView::ReportFields();		XSHOWFIELD( theHBar, ft_Handle );	XSHOWFIELD( theVBar, ft_Handle );	XSHOWFIELD( fBounds, ft_Rect );	XSHOWFIELD( hScale, ft_signedshort );	XSHOWFIELD( vScale, ft_signedshort );	XSHOWFIELD( hPage, ft_signedshort );	XSHOWFIELD( vPage, ft_signedshort );	XSHOWFIELD( cInitValue, ft_signedshort );	XSHOWFIELD( sbWidth, ft_signedshort );		Point	pp;	GetPosition( &pp.h, &pp.v );	SHOWFIELD( "->GetPosition()", pp, ft_Point );}/*-----------------------------***  ScrollViewInit  ***---------------------------------*//*access:			protectedoverrides:		description: 	common initialisation for the viewins: 			<h> TRUE to make a horizontal scrollbar				<v> TRUE to make a vertical scrollbarouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZScrollView::ScrollViewInit( Boolean h, Boolean v ){	theHBar = theVBar = NULL;	GetContentRect( &fBounds );	hScale = vScale = 10;	fHBarInset = 0;	fVBarInset = 0;	fUseThrottle = 0;		// if root window is a floater, use small scrollbars		GetRootWindow()->GetGrowBoxSize( &sbWidth, &sbWidth );		if ( sbWidth == 0 )		sbWidth = kStdScrollbarWidth;		// make the scrollbars		Rect		sb = { 0, 0, sbWidth, sbWidth };	WindowPtr	macW;		macW = GetRootWindowMacWindow();#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		if ( h )			FailNIL( theHBar = NewControl( macW, &sb, NULL, TRUE, 0, 0, 0, kControlScrollBarLiveProc, (long) this ));				if ( v )			FailNIL( theVBar = NewControl( macW, &sb, NULL, TRUE, 0, 0, 0, kControlScrollBarLiveProc, (long) this ));	}	else	{#endif		if ( h )		FailNIL( theHBar = NewControl( macW, &sb, NULL, TRUE, 0, 0, 0, scrollBarProc, (long) this ));		if ( v )		FailNIL( theVBar = NewControl( macW, &sb, NULL, TRUE, 0, 0, 0, scrollBarProc, (long) this ));#if APPEARANCE_MGR_AWARE	}#endif			// move them to the edge of the frame		MoveScrollbars();}/*----------------------------***  CalcScrollParams  ***--------------------------------*//*access:			protectedoverrides:		description: 	compute control maximums, paging values, etc.ins: 			noneouts: 			nonenotes:			called internally as required----------------------------------------------------------------------------------------*/void		ZScrollView::CalcScrollParams(){	long	excess, val;	Rect	cr;		GetContentRect( &cr );		if ( HasVBar())	{		val = GetControlValue( theVBar );				excess = ( fBounds.bottom - fBounds.top ) - ( cr.bottom - cr.top );			if ( excess < 0 )			excess = 0;		SetControlMaximum( theVBar, excess );		SetControlMinimum( theVBar, fBounds.top );				if ( excess == 0 )			SetControlValue( theVBar, 0 );		if ( GetControlValue( theVBar ) != val )			PostContentRefresh();	}		if ( HasHBar())	{		val = GetControlValue( theHBar );				excess = ( fBounds.right - fBounds.left ) - ( cr.right - cr.left );			if ( excess < 0 )			excess = 0;		SetControlMaximum( theHBar, excess );		SetControlMinimum( theHBar, fBounds.left );				if ( excess == 0 )			SetControlValue( theHBar, 0 );		if ( GetControlValue( theHBar ) != val )			PostContentRefresh();	}	hPage = cr.right - cr.left - hScale;	vPage = cr.bottom - cr.top - vScale;	// set scrollbar proportion. Note that this function is only available	// with appearance mgr, Carbon or ControlsLib.	#if USE_PROPORTIONAL_SCROLLBARS || TARGET_API_MAC_CARBON	if ( gMacInfo.hasAppearanceMgr )	{		if ( HasHBar())			SetControlViewSize( theHBar, cr.right - cr.left );					if ( HasVBar())			SetControlViewSize( theVBar, cr.bottom - cr.top );	}#endif}/*-----------------------------***  HideScrollbars  ***---------------------------------*//*access:			protectedoverrides:		description: 	hide the scrollbarsins: 			noneouts: 			nonenotes:			called internally as required----------------------------------------------------------------------------------------*/void		ZScrollView::HideScrollbars(){	Focus();		if ( HasHBar())		HideControl( theHBar );			if ( HasVBar())		HideControl( theVBar );			if ( fHasSizeBox )	{		Rect	sb;				GetSizingBox( &sb );		EraseRect( &sb );		PostRefresh( &sb );	}}/*-----------------------------***  MoveScrollbars  ***---------------------------------*//*access:			protectedoverrides:		description: 	position the scrollbars on the edges of the frameins: 			noneouts: 			nonenotes:			called internally as required----------------------------------------------------------------------------------------*/void		ZScrollView::MoveScrollbars(){	Rect	sbRect, cr;		GetContentRect( &cr );		if ( HasHBar())	{		sbRect = fFrame;		OffsetRect( &sbRect, -sbRect.left, -sbRect.top );				sbRect.top = sbRect.bottom - sbWidth;		sbRect.left = cr.left + fHBarInset;				if ( HasVBar() || fHasSizeBox )			sbRect.right -= sbWidth;			MoveControl( theHBar, sbRect.left - 1, sbRect.top );		SizeControl( theHBar, sbRect.right - sbRect.left + 2, sbWidth + 1 );	}	if ( HasVBar())	{		sbRect = fFrame;		OffsetRect( &sbRect, -sbRect.left, -sbRect.top );		sbRect.left = sbRect.right - sbWidth;		sbRect.top = cr.top + fVBarInset;				if ( HasHBar() || fHasSizeBox )			sbRect.bottom -= sbWidth;			MoveControl( theVBar, sbRect.left, sbRect.top - 1 );		SizeControl( theVBar, sbWidth + 1, sbRect.bottom - sbRect.top + 2 );	}		CalcScrollParams();}/*-----------------------------***  ShowScrollbars  ***---------------------------------*//*access:			protectedoverrides:		description: 	show the scrollbars after a moveins: 			noneouts: 			nonenotes:			called internally as required----------------------------------------------------------------------------------------*/void		ZScrollView::ShowScrollbars(){	Focus();		if ( HasHBar())		ShowControl( theHBar );			if ( HasVBar())		ShowControl( theVBar );			if ( fHasSizeBox )	{		Rect	sb;				GetSizingBox( &sb );		PostRefresh( &sb );	}}/*-------------------------------***  LocalScroll  ***----------------------------------*//*access:			protectedoverrides:		description: 	actually perform the scroll operationins: 			<r> area to scroll				<dH> h distance to scroll				<dV> v distance to scroll				<updateRgn> accumulates revealed areaouts: 			nonenotes:			wraps call to ScrollRect so it can be overridden for special needs----------------------------------------------------------------------------------------*/void		ZScrollView::LocalScroll( Rect* r, short dH, short dV, RgnHandle updateRgn ){	::ScrollRect( r, dH, dV, updateRgn );}#pragma mark -/*---------------------------***  ScrollBarViewProc  ***--------------------------------*//*access:			protectedoverrides:		description: 	convert action callback to view method callins: 			<theControl> control calling us				<partCode> partcode to actionouts: 			nonenotes:			called internally as required----------------------------------------------------------------------------------------*/pascal void	ZScrollView::ScrollBarViewProc( ControlHandle theControl, short partCode ){	// action proc for passing scrolling callbacks back to the object.		ZScrollView*	aScrollView = (ZScrollView*) GetControlReference( theControl );		try	{		if ( aScrollView )			aScrollView->ScrollCallback( theControl, partCode );					sLSPosition = GetControlValue( theControl );	}	catch( ... )	{	}}/*---------------------------***  ScrollBarViewProc  ***--------------------------------*//*access:			protectedoverrides:		description: 	convert drag callback to view method callins: 			noneouts: 			nonenotes:			called internally as required----------------------------------------------------------------------------------------*/pascal void	ZScrollView::LiveScrollDragProc(){	if ( sCurrentScrollbar )	{		Rect		cr, slopRect;		Point		mp;		Boolean		hitVertical;		short		cRange, cVal;				ZScrollView*	aScrollView = (ZScrollView*) GetControlReference( sCurrentScrollbar );				if ( aScrollView )		{			try			{				// calculate control's value based on mouse position. This code assumes the traditional				// scrollbar metrics, which means that it is not quite right if your OS has smart scrolling				// enabled or some other theme. Since this is only called if this app is compiled to not				// take into account appearance, or if appearance is not available, there is no way to query				// the theme metrics to make this more intelligent. In general, compiling with appearance				// awareness is recommended then this will only be called on an OS that genuinely doesn't have				// appearance.								GETCONTROLRECT( sCurrentScrollbar, &cr );				slopRect = cr;				InsetRect( &slopRect, -32, -32 );				sLSPosition = GetControlValue( sCurrentScrollbar );								hitVertical = ( sCurrentScrollbar == aScrollView->theVBar );				if ( hitVertical )				{					cr.top += kWidthOfScrollArrow;					cr.bottom -= kWidthOfScrollArrow;				}				else				{					cr.left += kWidthOfScrollArrow;					cr.right -= kWidthOfScrollArrow;				}				cRange = GetControlMaximum( sCurrentScrollbar ) - GetControlMinimum( sCurrentScrollbar );				GetMouse( &mp );								if ( PtInRect( mp, &slopRect ))				{					if ( hitVertical )						cVal = ((long)( mp.v - cr.top ) * cRange ) / (long)( cr.bottom - cr.top );					else						cVal = ((long)( mp.h - cr.left ) * cRange ) / (long)( cr.right - cr.left );										SetControlValue( sCurrentScrollbar, GetControlMinimum( sCurrentScrollbar ) + cVal );				}				else					SetControlValue( sCurrentScrollbar, aScrollView->cInitValue );								// call object to perform actual scroll based on new value								aScrollView->ScrollCallback( sCurrentScrollbar, kControlIndicatorPart );			}			catch( ... )			{			}		}	}}/*---------------------------***  CreateNewScrollView  ***------------------------------*//*access:			globaloverrides:		description: 	constructor funciton for generic scrolling boxins: 			<aParent> view's parent view				<aFrame> bounding rect				<pCount> count of parameters				<params> list of parametersouts: 			the viewnotes:			param[0] is a set of flags, indicating basic features				param[1] is bounds width				param[2] is bounds height----------------------------------------------------------------------------------------*/ZView*	CreateNewScrollView( ZView* aParent, Rect* aFrame, short pCount, long params[] ){	ZScrollView*	sv;	Boolean			hBar, vBar, szBox;		if ( pCount > 0 )	{		vBar = ( params[0] & kScrollingViewHasVerticalBar ) == kScrollingViewHasVerticalBar;		hBar = ( params[0] & kScrollingViewHasHorizontalBar ) == kScrollingViewHasHorizontalBar;		szBox = ( params[0] & kScrollingViewHasSizeBox ) == kScrollingViewHasSizeBox;	}	else	{		hBar = TRUE;		vBar = TRUE;		szBox = TRUE;	}		FailNIL( sv = new ZScrollView( aParent, aFrame, hBar, vBar, szBox ));		if ( pCount > 0 )	{		if ( params[0] & kScrollingViewHasStdBorder )			sv->SetStandardBorder( TRUE );					if ( params[0] & kScrollingViewCanBeHandler )			sv->SetCanBeHandler( TRUE );			if ( pCount > 2 )		{			Rect	br;						br.top = br.left = 0;			br.right = params[1];			br.bottom = params[2];						sv->SetBounds( br );		}	}	return sv;}