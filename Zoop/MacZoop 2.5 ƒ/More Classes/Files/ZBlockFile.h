/****************************************************************************************************			ObjectMacZapp		-- a standard Mac OOP application template****			ZBlockFile.h		-- a generic file object that includes some basic block*									management facilities. This type of file is useful for*									implementing VM schemes and databases, etc.***			© 1996, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZBLOCKFILE__#define __ZBLOCKFILE__#include	"ZFile.h"class	ZArray;#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif// block status:typedef enum{	freed,	notFreed}BlockStatus;// this is what is stored in the <bmap> array, one for every block in the file:typedef struct{	long			fRefNum;	unsigned long	fMark;	unsigned long	fSize;	BlockStatus		fStatus;}Block;// when the "standard header" formatting option is enabled, ZBlockFile will write out a standard// header and map to the file that you create. This saves you from having to figure out how to// do this yourself, which should improve the utility of this class. The format is very general// and should work well for most data types.typedef struct{	OSType			hSignature;			// file signature ( 'ZBFL' )	short			hVersion;			// format version (3)	short			hReserved;			// for future use - set to 0	long			hRefSeed;			// ref seed	unsigned long	hMapEntryCount;		// count of map entries	unsigned long	hMapOffset;			// offset to map from start of file}ZBlockStdHeader;#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endifenum{	kBlockFileHeaderSignature = 'ZBFL',	kBlockFileHeaderVersion = 3};class	ZBlockFile	: public ZFile{protected:	ZArray*			bmap;	long			refSeed;	long			useCount;	unsigned long	bkEnd;	public:	ZBlockFile( const FSSpec& aFileSpec );	ZBlockFile( Str255 fName );	virtual ~ZBlockFile();	// overrides:	virtual void			Open( SInt8 permission = fsCurPerm );	virtual void			Close();	// specific to this class:		virtual long			AddBlock();	virtual void			AddBlockUsingRef( const long aRef );	virtual void			RemoveBlock( const long ref );	virtual void			GetBlockData( const long ref, void* dataPtr, long* dataLen );	virtual void			GetBlockData( const long ref, Handle dataH );		virtual void			SetBlockData( const long ref, void* dataPtr, long dataLen );	virtual void			SetBlockData( const long ref, Handle dataH );		virtual long			GetNewRefSeed() { return ++refSeed; };	virtual long			GetBlockCount();	virtual long			GetBlock( const long ref );	virtual long			GetBlockRef( const long bkIndex );	virtual unsigned long	GetBlockSize( const long bkIndex );protected:		virtual void			AppendBlock( const long ref, const unsigned long sizeNeeded );	virtual long			FindFreeBlock( const unsigned long sizeNeeded );	virtual void			FreeBlock( const long bkIndex );	virtual void			SplitBlock( const long bkIndex, const unsigned long bkSize );	virtual void			ReallocBlock( const long ref, long newBkSize );	virtual void			SetMarkToBlock( const long bkIndex );		virtual void			ReadMap();	virtual void			WriteMap();	virtual void			InitMap();	virtual void			WriteHeader();		virtual void			CompactMap();	virtual void			CompactFile() {};};// possible errors:enum{	kBlockFileNotOpenErr	= 257,	kBlockBadRefErr,	kBlockNotFoundErr,	kBlockDupRefErr,	kBadSplitReqErr};/*This object is a file which is subdivided into a sequence of multiple blocks. This is usefulwhen you want to store in a single file a lot of different things. Each item in the file musthave a unique "block reference number", which can be allocated sequentially from a seed ifyou desire. Otherwise, for temporary files, you could use an object address- as long as thevalue is unique it doesn't matter. You can then get and set the block's data at any time- thisobject looks after where it is stored in the file. Before you can do this, you must registerthe block refnum using AddBlock(). This creates an entry in the map table referring to thisblock. If you no longer need the block, calling RemoveBlock() will free the space in the filefor other's use.If you want to use this class for permanent files, the map itself must be saved in the fileand recovered when it is opened. To do this, you must override WriteHeader, WriteMap andReadMap. The header should generally include an offset to the start of the map so that you canread it back into memory. HINT: Since the map is a ZArray, you can read and write the map bystreaming the array to the file.The methods in this object manage the filespace reasonably efficiently, but never split datainto non-contiguous segments. Thus the file will grow but not automatically shrink (thoughfreed space is always re-used where possible for new data). To shrink the file, you can callCompactFile(), which will remove all unused space. This may take a while due to the amount ofdata movement needed on disk, and uses a progress bar. CompactMap() is a much faster operationwhich conjoins all adjacent free blocks into larger ones, thus making the reuse of such partsof the file much more likely. This is called internally and you shouldn't need to call ityourself.This object makes no assumptions whatever about the data you store- as long as you supply itstotal size in bytes, it will store and return it to you. You are free to change the size oncethe block is written- the position within the file where the data is saved is automaticallymanaged so that you can always retrieve it and that freed space becomes available for new data.***********************************************************************************************Using _USE_STANDARD_ZBFHEADERWhen this option is set to 1, the map and header are automatically saved for you. The resultingfile format looks like this:<signature>			4 bytes		'ZBFL'<version>			2 bytes		currently 3<reserved>			2 bytes		set to 0<ref seed>			4 bytes		copy of ref seed at the time file was saved<map count>			4 bytes		count of entries in the map<map offset>		4 bytes		offset to start of map data from beginning of file...<data blocks>		n bytes		variable contents of actual data blocks written...<map data>			m bytes		variable contents of map for file, consisting of:	<block ref>		4 bytes		reference number of the block	<block mark>	4 bytes		position in file of blocks data	<block size>	4 bytes		length of the block in bytes	<block status>	1 byte		block status, free or not free					1 byte		paddingMap size = number of blocks * sizeof(Block)File size = sizeof( header) + map size + sumof( data sizes of blocks )*/#endif