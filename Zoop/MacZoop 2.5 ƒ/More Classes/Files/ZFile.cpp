/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZFile.cpp	-- a generic file object******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZFile.h"#include	"MacZoop.h"#include	"FileMgrUtils.h"#if _CUSTOM_ICON_SUPPORT#include	"PixMapUtils.h"#include	"ZGWorld.h"#include	<icons.h>#endif#include	<finder.h>#include	<folders.h>// statics, globals:FSSpec	ZFile::sDummySpec = { 0, 0, "\p" };/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZFile::ZFile( const FSSpec& aSpec )	: ZComrade(){	classID = CLASS_ZFile;	itsSpec = aSpec;		InitFile();}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZFile::ZFile( Str255 fName )	: ZComrade(){	short	vRefNum;	long	dirID;		classID = CLASS_ZFile;	FailOSErr( HGetVol( NULL, &vRefNum, &dirID ));	(void) FSMakeFSSpec( vRefNum, dirID, fName, &itsSpec );		InitFile();}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZFile::ZFile()	: ZComrade(){	classID = CLASS_ZFile;		itsSpec.vRefNum = 0;	itsSpec.parID = 0;	itsSpec.name[0] = 0;		InitFile();}	/*-------------------------------***  DESTRUCTOR  ***----------------------------------*/ZFile::~ZFile(){	Close();	CloseResFork();}/*----------------------------------***  InitFile  ***----------------------------------*//*access:			public	overrides:description: 	common file initialisationins: 			noneouts: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZFile::InitFile(){	refNum = _NOT_OPEN;	resRefNum = _NOT_OPEN;	isSafeSave = FALSE;	itsType = kUnknownType;	itsCreator = gAppSignature;	ssFSpec = itsSpec;		// if the file already exists, get the file type	// from the file. If file not found, its type is not yet defined.		FInfo	finderInfo;		if ( FSpGetFInfo( &itsSpec, &finderInfo ) == noErr )	{		itsType = finderInfo.fdType;		itsCreator = finderInfo.fdCreator;	}		unsigned long rs;			GetDateTime( &rs );	SETQDRANDSEED( rs );	GetTempFolderID();}/*------------------------------------***  Open  ***------------------------------------*//*access:			public	overrides:description: 	open the file for reading or writingins: 			<permission> file access permission desiredouts: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZFile::Open( SInt8 permission ){	FailOSErr( FSpOpenDF( &itsSpec, permission, &refNum ));	SetMark( 0 );}/*----------------------------------***  OpenSafe  ***----------------------------------*//*access:			public	overrides:description: 	open the file for a safe-save writeins: 			<copyResourceFork> TRUE to copy resource fork across automaticallyouts: 			nonenotes:----------------------------------------------------------------------------------------*/void	ZFile::OpenSafe( Boolean copyResourceFork ){	// the file is to opened for a safe save. This creates a temporary file in the system's	// temp folder, but with a name built from part of the original plus a random number.	// The file is set to be invisible in the Finder. When the file is later closed, the	// catalogue entries will be swapped and the temp file deleted.		// The <copyResourceFork> parameter, if true, will copy all resources from the original	// file to the new file. This solves the problem of resources getting lost in the safe-	// save process when only the data fork is updated/written. Note that this is usually a	// good idea, but the default is FALSE because older code may have created its own solution	// to this problem (i.e. it's backward compatible this way)		short   vRef;	OSErr   fsErr;		long	tfRand, dirID;	Str31	tfName;		vRef = itsSpec.vRefNum;	dirID = itsSpec.parID;		// if the volume of the target and temp folder differ, do a safe save in the	// target's location, otherwise in the temp items folder. This is because ExchangeFiles	// only works on the same volume.		if ( itsSpec.vRefNum == tempFVolID )		dirID = tempFID;		do	{    	tfRand = ((unsigned long) Random() << 16L ) + Random();    	    	NumToString( ABS( tfRand ), tfName );    	    	// use up to the first 10 chars of the true name, then append our random characters    	    	ssFSpec.name[0] = MIN( itsSpec.name[0], 10 );    	ConcatPStrings( ssFSpec.name, tfName );    	    	fsErr = FSMakeFSSpec( vRef, dirID, ssFSpec.name, &ssFSpec );    	    	// keep doing this until we're certain the filename is unique- it almost always will be    	// on the first try, but this makes it very robust indeed.	}	while( fsErr != fnfErr );		// create and open the file		FailOSErr( FSpCreate( &ssFSpec, gAppSignature, 'temp', smSystemScript ));	FailOSErr( FSpOpenDF( &ssFSpec, fsRdWrPerm, &refNum ));	SetMark( 0 );		// optionally copy the resource fork across. The resources are copied as a blind	// fork-to-fork copy so resources in use should be unaffected in theory. Any exception	// here will orphan the temp file, but the OS will clean it up next reboot.		if ( copyResourceFork && HasResFork())	    CopyResourceFork( &itsSpec, &ssFSpec );		// set the flag so that all subsequent operations until closure operate on the	// new temporary file		isSafeSave = TRUE;}/*------------------------------------***  Close  ***-----------------------------------*//*access:			public	overrides:description: 	close the fileins: 			noneouts: 			nonenotes:			performs file exchange at end of safe-save operation----------------------------------------------------------------------------------------*/void	ZFile::Close(){	if (( refNum != _NOT_OPEN ) &&		( refNum != 0 ))		FailOSErr( FSClose( refNum ));			refNum = _NOT_OPEN;		// if we are closing after a safe-save, swap the files and delete the temp file, AND,	// if the original file doesn't exist, create it before swapping it.		if ( isSafeSave )	{		isSafeSave = FALSE;				if (! IsReal())			Create();				// n.b. finder info not swapped, so get that from the temp file and apply to the		// real file:				FInfo	fi;				FailOSErr( FSpGetFInfo( &ssFSpec, &fi ));		FailOSErr( FSpExchangeFiles( &itsSpec, &ssFSpec ));		FailOSErr( FSpDelete( &ssFSpec ));				fi.fdFlags &= ~fInvisible;		fi.fdType = itsType;		fi.fdCreator = itsCreator;				FailOSErr( FSpSetFInfo( &itsSpec, &fi ));	}}/*-----------------------------------***  Create  ***-----------------------------------*//*access:			public	overrides:description: 	create the file on diskins: 			noneouts: 			nonenotes:			does not open the file----------------------------------------------------------------------------------------*/void	ZFile::Create(){	FailOSErr( FSpCreate( &itsSpec, itsCreator, itsType, smSystemScript ));}/*----------------------------------***  Discard  ***-----------------------------------*//*access:			public	overrides:description: 	closese the file if necessary and deletes it from the diskins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::Discard(){	if (refNum != _NOT_OPEN )		Close();			FailOSErr( FSpDelete( &itsSpec ));}/*--------------------------------***  OpenResFork  ***---------------------------------*//*access:			public	overrides:description: 	opens the file's resource fork, reading the resource map into memoryins: 			<permission> access permission desiredouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::OpenResFork( SInt8 permission ){	if ( resRefNum == _NOT_OPEN )	{		short cr = CurResFile();				if ( isSafeSave )			resRefNum = FSpOpenResFile( &ssFSpec, permission );		else			resRefNum = FSpOpenResFile( &itsSpec, permission );				FailOSErr( ResError());		FailOSErr((resRefNum == -1)? fnfErr : noErr );				UseResFile( cr );	}}/*-------------------------------***  CloseResFork  ***---------------------------------*//*access:			public	overrides:description: 	closes the file's resource forkins: 			noneouts: 			nonenotes:			will record any resource changes to disk before closing----------------------------------------------------------------------------------------*/void	ZFile::CloseResFork(){	if ( resRefNum != _NOT_OPEN )	{		CloseResFile( resRefNum );		FailOSErr( ResError());	}		resRefNum = _NOT_OPEN;}/*------------------------------***  CreateResFork  ***---------------------------------*//*access:			public	overrides:description: 	creates the file's resource forkins: 			noneouts: 			nonenotes:			does not open the fork----------------------------------------------------------------------------------------*/void	ZFile::CreateResFork(){	if ( ! HasResFork())	{		if ( isSafeSave )			FSpCreateResFile( &ssFSpec, gAppSignature, itsType, smSystemScript );		else			FSpCreateResFile( &itsSpec, gAppSignature, itsType, smSystemScript );				FailOSErr( ResError());	}}/*----------------------------------***  Read  ***-------------------------------------*//*access:			public	overrides:description: 	read data from the fileins: 			<inBuffer> pointer to a suitable block of storage				<howMuch> how many bytes to read - returns number actually readouts: 			nonenotes:			caller is responsible for allocating sufficient buffer space----------------------------------------------------------------------------------------*/void	ZFile::Read( Ptr inBuffer, long* howMuch ){	FailOSErr( isSafeSave? permErr : noErr );	FailOSErr( FSRead( refNum, howMuch, inBuffer ));}/*---------------------------------***  Write  ***-------------------------------------*//*access:			public	overrides:description: 	write data to the fileins: 			<outBuffer> pointer to data to save				<howMuch> how many bytes to write - returns number actually writtenouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::Write( Ptr outBuffer, long* howMuch ){	FailOSErr( FSWrite( refNum, howMuch, outBuffer ));}/*----------------------------------***  Read  ***-------------------------------------*//*access:			public	overrides:description: 	read data from the file into a Handleins: 			<aHandle> a valid handleouts: 			nonenotes:			this reads the remaining data in the file, sizing the handle as needed				this is unlikely to work with very big files.----------------------------------------------------------------------------------------*/void	ZFile::Read( Handle aHandle ){	long	howMuch;	char	hs;		FailNIL( aHandle );	FailOSErr( isSafeSave? permErr : noErr );		// the handle is sized to the size of the rest of the data in the file, that is, the	// length less the current position. Override this for different behaviour.		howMuch = GetLength() - GetMark();	SetHandleSize( aHandle, howMuch );		FailOSErr( MemError());		hs = HGetState( aHandle );	HLock( aHandle );	Read( *aHandle, &howMuch );	HSetState( aHandle, hs );	}/*----------------------------------***  Write  ***------------------------------------*//*access:			public	overrides:description: 	write a handle's data to the fileins: 			<aHandle> a valid handleouts: 			nonenotes:			entire handle is copied to the file from the current mark----------------------------------------------------------------------------------------*/void	ZFile::Write( Handle aHandle ){	long	howMuch;	char	hs;	FailNIL( aHandle );		howMuch = GetHandleSize( aHandle );		hs = HGetState( aHandle );	HLock( aHandle );	Write( *aHandle, &howMuch );	HSetState( aHandle, hs );		// set the length of the file to the current mark, in case the file was	// shortened. This is OK even if multiple calls are made to this method.		SetLength( GetMark());	}/*-----------------------------------***  Copy  ***-------------------------------------*//*access:			public	overrides:description: 	duplicate the file on diskins: 			<srcFile> another file objectouts: 			nonenotes:			copies entire file. Copy will have name and location specified here, or				if not specified, will be set to same location as original, with "copy"				appended to the name. Both files should initially be closed.----------------------------------------------------------------------------------------*/void    ZFile::Copy( ZFile* srcFile ){    Ptr     copyBuffer;    long    dfLength, dfBytes, bytesCopied;    FSSpec  srcSpec;        // may take a few seconds...        SetWatchCursor();    FailNILParam( srcFile );        // copy over the type and creator        SetType( srcFile->GetType());    SetCreator( srcFile->GetCreator());        // if not a real filespec here, set it up based on the original. This allows you to    // create this object using the default constructor to simply copy any file with the    // minimum of set-up steps        if ( itsSpec.vRefNum == 0 &&         itsSpec.parID == 0 &&         itsSpec.name[0] == 0 )    {        srcFile->GetFSSpec( &itsSpec );        ConcatPStringsTrunc( itsSpec.name, "\p copy", 31 );    }        // open this file for safe-saving        OpenSafe( FALSE );        // open the source file        srcFile->Open( fsRdPerm );    dfLength = srcFile->GetLength();    bytesCopied = 0;        // make a buffer for doing the copy        FailNIL( copyBuffer = NewPtr( kCopyBufferSize ));        while( dfLength > 0 )    {        dfBytes = MIN( dfLength, kCopyBufferSize );                srcFile->Read( copyBuffer, &dfBytes );        Write( copyBuffer, &dfBytes );            dfLength -= dfBytes;        bytesCopied += dfBytes;                // send a message so anybody who is interested in monitoring this operation can do so                SendMessage( msgFileCopyProgress, &bytesCopied );    }        SetLength( GetMark());    DisposePtr( copyBuffer );        // now the resource fork, if there is one        if ( srcFile->HasResFork())    {        srcFile->GetFSSpec( &srcSpec );        CopyResourceFork( &srcSpec, &ssFSpec );    }    // close the files, which will swap out the temp file        srcFile->Close();    Close();        // make sure both files have identical flags, but offset the    // copied file's icon in the finder        FInfo	fi;        srcFile->GetInfo( &fi );    fi.fdLocation.h += 16;    fi.fdLocation.v += 16;    SetInfo( &fi );}/*----------------------------------***  SetMark  ***-----------------------------------*//*access:			public	overrides:description: 	set the file's markins: 			<aMark> absolute position of the markouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::SetMark( const long aMark ){	FailOSErr( SetFPos( refNum, fsFromStart, aMark ));}/*----------------------------------***  SetType  ***-----------------------------------*//*access:			public	overrides:description: 	set the file's filetype valueins: 			<aType> the type to setouts: 			nonenotes:			if file on disk, changes the filetype there as well----------------------------------------------------------------------------------------*/void	ZFile::SetType( const OSType aType ){	if (aType != itsType)	{			itsType = aType;				if ( IsReal())		{			FInfo	fi;						FailOSErr( FSpGetFInfo( &itsSpec, &fi ));			fi.fdType = itsType;			FailOSErr( FSpSetFInfo( &itsSpec, &fi ));		}		}}/*---------------------------------***  SetCreator  ***---------------------------------*//*access:			public	overrides:description: 	set the file's creator valueins: 			<aCreator> the creator to setouts: 			nonenotes:			if file on disk, changes the creator there as well----------------------------------------------------------------------------------------*/void	ZFile::SetCreator( const OSType aCreator ){	if ( aCreator != itsCreator )	{			itsCreator = aCreator;				if ( IsReal())		{			FInfo	fi;						FailOSErr( FSpGetFInfo( &itsSpec, &fi ));			fi.fdCreator = itsCreator;			FailOSErr( FSpSetFInfo( &itsSpec, &fi ));		}		}}/*-----------------------------------***  GetMark  ***----------------------------------*//*access:			public	overrides:description: 	get current position of file's markins: 			noneouts: 			the marknotes:			----------------------------------------------------------------------------------------*/long	ZFile::GetMark(){	long	mark = 0;		FailOSErr( GetFPos( refNum, &mark ));		return mark;}/*----------------------------------***  GetFSSpec  ***---------------------------------*//*access:			public	overrides:description: 	get filespec of this fileins: 			<aSpec> receives the specouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::GetFSSpec( FSSpec* aSpec ){	*aSpec = itsSpec;}/*---------------------------------***  SetResFork  ***---------------------------------*//*access:			public	overrides:description: 	sets this file's resource fork as the current resource fileins: 			<curRes> receives previous res file refouts: 			nonenotes:			res fork must exist and be open----------------------------------------------------------------------------------------*/void	ZFile::SetResFork( short* curRes ){	*curRes = CurResFile();		if ( resRefNum != _NOT_OPEN )		UseResFile( resRefNum );}/*----------------------------------***  GetLength  ***---------------------------------*//*access:			public	overrides:description: 	get the total length of the file, in bytesins: 			noneouts: 			the file logical lengthnotes:			----------------------------------------------------------------------------------------*/long	ZFile::GetLength(){	long	len = 0;		FailOSErr( GetEOF( refNum, &len ));		return len;}/*----------------------------------***  SetLength  ***---------------------------------*//*access:			public	overrides:description: 	set the total length of the file, in bytesins: 			<aLength> the logical length to make the fileouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::SetLength( const long aLength ){	FailOSErr( SetEOF( refNum, aLength ));}/*-----------------------------------***  GetType  ***----------------------------------*//*access:			public	overrides:description: 	get the file's typeins: 			noneouts: 			its typenotes:			----------------------------------------------------------------------------------------*/OSType	ZFile::GetType(){	return itsType;}/*-----------------------------------***  GetInfo  ***----------------------------------*//*access:			public	overrides:description: 	get the file's Finder infoins: 			<fi> receives the infoouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::GetInfo( FInfo* fi ){	if ( isSafeSave )		FailOSErr( FSpGetFInfo( &ssFSpec, fi ));	else		FailOSErr( FSpGetFInfo( &itsSpec, fi ));}/*-----------------------------------***  SetInfo  ***----------------------------------*//*access:			public	overrides:description: 	set the file's Finder infoins: 			<fi> the info to setouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::SetInfo( FInfo* fi ){	if ( isSafeSave )		FailOSErr( FSpSetFInfo( &ssFSpec, fi ));	else		FailOSErr( FSpSetFInfo( &itsSpec, fi ));}/*-----------------------------------***  GetName  ***----------------------------------*//*access:			public	overrides:description: 	get the file's nameins: 			<aName> receives the nameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::GetName( Str31 aName ){	CopyPString( itsSpec.name, aName );}/*------------------------------***  GetModificationDate  ***---------------------------*//*access:			public	overrides:description: 	get the file's modification dateins: 			noneouts: 			the mod datenotes:			----------------------------------------------------------------------------------------*/unsigned long	ZFile::GetModificationDate(){	Str31			fName;	CInfoPBRec		pb;	OSErr			theErr;		if ( isSafeSave )		CopyPString( ssFSpec.name, fName );	else		CopyPString( itsSpec.name, fName );		pb.hFileInfo.ioCompletion = NULL;	pb.hFileInfo.ioNamePtr = fName;	pb.hFileInfo.ioVRefNum = isSafeSave? ssFSpec.vRefNum : itsSpec.vRefNum;	pb.hFileInfo.ioDirID = isSafeSave? ssFSpec.parID : itsSpec.parID;	pb.hFileInfo.ioFDirIndex = 0;		theErr = PBGetCatInfoSync( &pb );		if ( theErr == noErr )		return pb.hFileInfo.ioFlMdDat;	else		return 0;}/*--------------------------------***  GetCreationDate  ***-----------------------------*//*access:			public	overrides:description: 	get the file's creation dateins: 			noneouts: 			the creation datenotes:			----------------------------------------------------------------------------------------*/unsigned long	ZFile::GetCreationDate(){	Str31			fName;	CInfoPBRec		pb;	OSErr			theErr;		if ( isSafeSave )		CopyPString( ssFSpec.name, fName );	else		CopyPString( itsSpec.name, fName );		pb.hFileInfo.ioCompletion = NULL;	pb.hFileInfo.ioNamePtr = fName;	pb.hFileInfo.ioVRefNum = isSafeSave? ssFSpec.vRefNum : itsSpec.vRefNum;	pb.hFileInfo.ioDirID = isSafeSave? ssFSpec.parID : itsSpec.parID;	pb.hFileInfo.ioFDirIndex = 0;		theErr = PBGetCatInfoSync( &pb );		if ( theErr == noErr )		return pb.hFileInfo.ioFlCrDat;	else		return 0;}/*----------------------------------***  HasResFork  ***--------------------------------*//*access:			public	overrides:description: 	query whether this file has a resource forkins: 			noneouts: 			TRUE if a resource fork has been creatednotes:			----------------------------------------------------------------------------------------*/Boolean	ZFile::HasResFork(){	Str31			fName;	CInfoPBRec		pb;	OSErr			theErr;		if ( isSafeSave )		CopyPString( ssFSpec.name, fName );	else		CopyPString( itsSpec.name, fName );		pb.hFileInfo.ioCompletion = NULL;	pb.hFileInfo.ioNamePtr = fName;	pb.hFileInfo.ioVRefNum = isSafeSave? ssFSpec.vRefNum : itsSpec.vRefNum;	pb.hFileInfo.ioDirID = isSafeSave? ssFSpec.parID : itsSpec.parID;	pb.hFileInfo.ioFDirIndex = 0;		theErr = PBGetCatInfoSync( &pb );		if (theErr)		return FALSE;	else	{		// see if any physical bytes are alloted to the resource fork				return( pb.hFileInfo.ioFlRPyLen > 0 );	}		}/*---------------------------------***  HasDataFork  ***--------------------------------*//*access:			public	overrides:description: 	query whether this file has a data forkins: 			noneouts: 			TRUE if a data fork has been creatednotes:			----------------------------------------------------------------------------------------*/Boolean	ZFile::HasDataFork(){	Str31			fName;	CInfoPBRec		pb;	OSErr			theErr;		if ( isSafeSave )		CopyPString( ssFSpec.name, fName );	else		CopyPString( itsSpec.name, fName );		pb.hFileInfo.ioCompletion = NULL;	pb.hFileInfo.ioNamePtr = fName;	pb.hFileInfo.ioVRefNum = isSafeSave? ssFSpec.vRefNum : itsSpec.vRefNum;	pb.hFileInfo.ioDirID = isSafeSave? ssFSpec.parID : itsSpec.parID;	pb.hFileInfo.ioFDirIndex = 0;		theErr = PBGetCatInfoSync( &pb );		if (theErr)		return FALSE;	else	{		// see if any physical bytes are alloted to the data fork				return( pb.hFileInfo.ioFlPyLen > 0 );	}		}/*------------------------------------***  IsReal  ***----------------------------------*//*access:			public	overrides:description: 	query whether this file actually exists on the diskins: 			noneouts: 			TRUE if file exists on disknotes:			----------------------------------------------------------------------------------------*/Boolean	ZFile::IsReal(){	OSErr	theErr;	FInfo	fi;		theErr = FSpGetFInfo( &itsSpec, &fi );	return (theErr == noErr);}/*-----------------------------------***  IsLocked  ***---------------------------------*//*access:			public	overrides:description: 	query whether this file has software lock bit setins: 			noneouts: 			TRUE if file lockednotes:			----------------------------------------------------------------------------------------*/Boolean	ZFile::IsLocked(){	OSErr	theErr;	FInfo	fi;		theErr = FSpGetFInfo( &itsSpec, &fi );	return (( theErr == noErr ) &&			( fi.fdFlags & 0x1000 ));}/*------------------------------------***  IsOpen  ***----------------------------------*//*access:			public	overrides:description: 	query whether this file's data fork is openins: 			noneouts: 			TRUE if file opennotes:			----------------------------------------------------------------------------------------*/Boolean	ZFile::IsOpen(){	return ( refNum != _NOT_OPEN );}/*--------------------------------***  MakeCustomIcon  ***------------------------------*//*access:			public	overrides:description: 	Add a custom icon to the fileins: 			<srcImage> Picture to convert into custom iconouts: 			nonenotes:			performs conversion to icon and saves it in resource fork.----------------------------------------------------------------------------------------*/void	ZFile::MakeCustomIcon( PicHandle srcImage ){#if _CUSTOM_ICON_SUPPORT	FailNILParam( srcImage );		Handle icnSuite = ConstructCustomIconSuite( srcImage );		if ( icnSuite )	{		SaveCustomIconSuite( icnSuite );				// dispose of the suite, but not the icon data, since we just added it as a resource,		// and in any case that routine just NULLED the icon data here.				FailOSErr( DisposeIconSuite( icnSuite, FALSE ));	}#endif}/*--------------------------------***  MakeCustomIcon  ***------------------------------*//*access:			public	overrides:description: 	Add a custom icon to the fileins: 			<srcImage> an offscreen GWorld object comtaining the imageouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::MakeCustomIcon( ZGWorld* srcImage ){#if _CUSTOM_ICON_SUPPORT	FailNILParam( srcImage );		Rect		r;	PicHandle	p;		SetRect( &r, 0, 0, 32, 32 );	FailNIL( p = srcImage->MakePicture( &r ));		try	{		MakeCustomIcon( p );	}	catch( ZoopError err )	{		KillPicture( p );		throw err;	}	KillPicture( p );#endif}/*----------------------------***  ConstructCustomIconSuite  ***------------------------*//*access:			public	overrides:description: 	create icon suite from pictureins: 			<srcPic> picture containing image to useouts: 			Handle to icon suitenotes:			----------------------------------------------------------------------------------------*/Handle	ZFile::ConstructCustomIconSuite( PicHandle srcPic ){	Handle	icnSuite = NULL;#if _CUSTOM_ICON_SUPPORT	Handle	theIcon;	char	pHState;		pHState = HGetState((Handle) srcPic );	HNoPurge((Handle) srcPic );		FailOSErr( NewIconSuite( &icnSuite ));		FailNIL( theIcon = MakeIconFromPicture( srcPic, kLarge8BitData ));	FailOSErr( AddIconToSuite( theIcon, icnSuite, kLarge8BitData ));		FailNIL( theIcon = MakeIconFromPicture( srcPic, kLarge4BitData ));	FailOSErr( AddIconToSuite( theIcon, icnSuite, kLarge4BitData ));		FailNIL( theIcon = MakeIconFromPicture( srcPic, kLarge1BitMask ));	FailOSErr( AddIconToSuite( theIcon, icnSuite, kLarge1BitMask ));	FailNIL( theIcon = MakeIconFromPicture( srcPic, kSmall8BitData ));	FailOSErr( AddIconToSuite( theIcon, icnSuite, kSmall8BitData ));		FailNIL( theIcon = MakeIconFromPicture( srcPic, kSmall4BitData ));	FailOSErr( AddIconToSuite( theIcon, icnSuite, kSmall4BitData ));		FailNIL( theIcon = MakeIconFromPicture( srcPic, kSmall1BitMask ));	FailOSErr( AddIconToSuite( theIcon, icnSuite, kSmall1BitMask ));		HSetState((Handle) srcPic, pHState );#endif		return icnSuite;}/*-------------------------------***  SaveCustomIconSuite  ***--------------------------*//*access:			public	overrides:description: 	saves icon suite to file as custom iconins: 			<icnSuite> Handle to icon suiteouts: 			nonenotes:			Warning: this releases the icon handles in the suite----------------------------------------------------------------------------------------*/void	ZFile::SaveCustomIconSuite( Handle icnSuite ){#if _CUSTOM_ICON_SUPPORT	if ( icnSuite )	{		Handle		iconH, oldH;		short		id = kCustomIconResource;				CreateResFork();		OpenResFork();				// remove any existing icons in the file. Normally there won't be any since		// this is usually done under a safe save.				oldH = Get1Resource( kLarge8BitData, id );		if ( oldH )		{			RemoveResource( oldH );			DisposeHandle( oldH );		}				oldH = Get1Resource( kLarge4BitData, id );		if ( oldH )		{			RemoveResource( oldH );			DisposeHandle( oldH );		}				oldH = Get1Resource( kLarge1BitMask, id );		if ( oldH )		{			RemoveResource( oldH );			DisposeHandle( oldH );		}				oldH = Get1Resource( kSmall8BitData, id );		if ( oldH )		{			RemoveResource( oldH );			DisposeHandle( oldH );		}				oldH = Get1Resource( kSmall4BitData, id );		if ( oldH )		{			RemoveResource( oldH );			DisposeHandle( oldH );		}				oldH = Get1Resource( kSmall1BitMask, id );		if ( oldH )		{			RemoveResource( oldH );			DisposeHandle( oldH );		}				// save each icon in the suite		FailOSErr( GetIconFromSuite( &iconH, icnSuite, kLarge8BitData ));		AddResource( iconH, kLarge8BitData, id, "\p" );		FailOSErr( ResError());		AddIconToSuite( NULL, icnSuite, kLarge8BitData );		::WriteResource( iconH );		ReleaseResource( iconH );				FailOSErr( GetIconFromSuite( &iconH, icnSuite, kLarge4BitData ));		AddResource( iconH, kLarge4BitData, id, "\p" );		FailOSErr( ResError());		AddIconToSuite( NULL, icnSuite, kLarge4BitData );		::WriteResource( iconH );		ReleaseResource( iconH );				FailOSErr( GetIconFromSuite( &iconH, icnSuite, kLarge1BitMask ));		AddResource( iconH, kLarge1BitMask, id, "\p" );		FailOSErr( ResError());		AddIconToSuite( NULL, icnSuite, kLarge1BitMask );		::WriteResource( iconH );		ReleaseResource( iconH );				FailOSErr( GetIconFromSuite( &iconH, icnSuite, kSmall8BitData ));		AddResource( iconH, kSmall8BitData, id, "\p" );		FailOSErr( ResError());		AddIconToSuite( NULL, icnSuite, kSmall8BitData );		::WriteResource( iconH );		ReleaseResource( iconH );				FailOSErr( GetIconFromSuite( &iconH, icnSuite, kSmall4BitData ));		AddResource( iconH, kSmall4BitData, id, "\p" );		FailOSErr( ResError());		AddIconToSuite( NULL, icnSuite, kSmall4BitData );		::WriteResource( iconH );		ReleaseResource( iconH );				FailOSErr( GetIconFromSuite( &iconH, icnSuite, kSmall1BitMask ));		AddResource( iconH, kSmall1BitMask, id, "\p" );		FailOSErr( ResError());		AddIconToSuite( NULL, icnSuite, kSmall1BitMask );		::WriteResource( iconH );		ReleaseResource( iconH );				CloseResFork();				// make sure the "custom icon" bit is set in the finder info				FInfo	fi;				GetInfo( &fi );		fi.fdFlags |= kHasCustomIcon;		SetInfo( &fi );	}#endif} /*--------------------------------***  GetTempFolderID  ***-----------------------------*//*access:			public	overrides:description: 	determines the ID of the Temporary Items folder and sets data membersins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::GetTempFolderID(){	short	fv;	long	fd;		FailOSErr( FindFolder( kOnSystemDisk, kTemporaryFolderType, kCreateFolder, &fv, &fd ));		tempFID = fd;	tempFVolID = fv;}/*------------------------------***  GetDebugInfoString  ***----------------------------*//*access:			public	overrides:description: 	get basic debug infoins: 			<s> receives the infoouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::GetDebugInfoString( Str255 s ){	GetFullPathname( &itsSpec, s );}/*---------------------------------***  ReportFields  ***-------------------------------*//*access:			public	overrides:description: 	report data members to the inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZFile::ReportFields(){	ZComrade::ReportFields();	XSHOWFIELD( refNum, ft_signedshort );	XSHOWFIELD( resRefNum, ft_signedshort );	XSHOWFIELD( isSafeSave, ft_boolean );	XSHOWFIELD( itsType, ft_fourcharcode );	XSHOWFIELD( itsCreator, ft_fourcharcode );	XSHOWFIELD( itsSpec, ft_FSSpec );	XSHOWFIELD( ssFSpec, ft_FSSpec );	XSHOWFIELD( tempFID, ft_signedlong );	XSHOWFIELD( tempFVolID, ft_signedshort );		Str255	s;		GetFullPathname( &itsSpec, s );	SHOWFIELD( "[full pathname]", s, ft_str255 );}/*-------------------------------***  CopyResourceFork  ***-----------------------------*//*access:			public	overrides:description: 	perform straight bit-copy of resource forkins: 			<srcFile> file to copy from				<destFile> file to copy toouts: 			nonenotes:			destroys any existing resource fork in destFile----------------------------------------------------------------------------------------*/void    ZFile::CopyResourceFork( FSSpec* srcFile, FSSpec* destFile ){    Ptr     rfBuffer = NULL;    long    rfLength, rfBytes;    short   rfTempRef, ssrfTempRef;    try    {	    // make a buffer and open the source file 	    	    FailNIL( rfBuffer = NewPtr( krfBufferSize ));       	    FailOSErr( FSpOpenRF( srcFile, fsRdPerm, &rfTempRef ));	    FailOSErr( GetEOF( rfTempRef, &rfLength ));	    	    // open the destination file	    	    FailOSErr( FSpOpenRF( destFile, fsRdWrPerm, &ssrfTempRef ));	    FailOSErr( SetFPos( ssrfTempRef, fsFromStart, 0 ));	    	    // copy the fork	    	    while( rfLength > 0 )	    {	        rfBytes = MIN( rfLength, krfBufferSize );	        	        FailOSErr( FSRead( rfTempRef, &rfBytes, rfBuffer ));	        FailOSErr( FSWrite( ssrfTempRef, &rfBytes, rfBuffer ));	    	        rfLength -= rfBytes;	    }	    	    // set length to mark	    	    FailOSErr( GetFPos( ssrfTempRef, &rfLength ));	    FailOSErr( SetEOF( ssrfTempRef, rfLength ));	    	    // close the forks	    	    FailOSErr( FSClose( rfTempRef ));	    FailOSErr( FSClose( ssrfTempRef ));    	}	catch( ZoopError err )	{	    if ( rfBuffer )	        DisposePtr( rfBuffer );	        	    throw err;	}		DisposePtr( rfBuffer );}