/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZUndoTask.h			-- a generic object for implementing Undo******			© 1996, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZUNDOTASK__#define __ZUNDOTASK__#include	"ZObject.h"class	ZView;DEFINECLASSID( ZUndoTask, 'zudo' );class	ZUndoTask	: public ZObject{protected:	Str63		taskString;		// name of the task- menu shows "Undo <taskString>"	ZView*		itsTarget;		// view the task is intended for	Boolean		undone;			// if undone (if TRUE, menu shows Redo)	Boolean		isFirstTask;	// TRUE if this is the first task since file savedpublic:	ZUndoTask( Str63 aTaskString, ZView* aTarget );	ZUndoTask( const short strListID, const short strListIndex, ZView* aTarget );	virtual ~ZUndoTask() {};	virtual void	Do();	virtual void	Undo();	virtual void	Redo();	virtual void	GetTaskString( Str63 aTaskStr );		inline Boolean	IsUndone() { return undone; };	inline ZView*	GetUndoTarget() { return itsTarget; };	inline void		SetUndoTarget( ZView* aTarget ) { itsTarget = aTarget; };	inline void		SetIsFirstTask() { isFirstTask = TRUE; };};/*To use this to implement Undo, you need to subclass it for each kind of undoable actionyou require. The application will keep hold of the last undo task and manage the Undo menuitem, calling the task's Undo or Redo method as appropriate. The task string you supply whencreating the task is appended to the menu item- e.g. "Undo Editing" if the task string was"Editing". Undo tasks are associated with windows- if the window no longer exists, the taskwill be deleted. Sending an undo task marks the window as dirty automatically.*/#endif