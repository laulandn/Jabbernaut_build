/***************************************************************************************************		xDEFJump.c			- allows embedded xDEFs to be called internally***		13/7/94  Graham Cox***************************************************************************************************/#include	"xDEFjump.h"Handle	GetUniversalFunctionHandle(ProcPtr functionAddress, ProcInfoType pInfo){	Handle				pHNullProc = NULL;		// this technique is not compatible with Carbon AT ALL. Alternative solutions are	// provided for the MDEF and LDEF vectors within MacZoop under Carbon	#if !TARGET_API_MAC_CARBON	ISAType				isa;	UniversalProcPtr 	axDEFUPP;		isa = GetCurrentISA();		if (isa == kPowerPCISA)	{	   pHNullProc = NewHandle(sizeof(RoutineDescriptor));	   axDEFUPP = NewRoutineDescriptor(functionAddress,pInfo,isa);	   BlockMoveData(axDEFUPP, *pHNullProc, sizeof(RoutineDescriptor));	   DisposeRoutineDescriptor(axDEFUPP);	}	else	{	   pHNullProc = NewHandle(sizeof(JmpInstructionTemplate));	   PatchJmpInstruction(*pHNullProc, (void*)functionAddress);	}#endif	return( pHNullProc );}void PatchJmpInstruction(void* patchAddress, void* jumpAddress){   JmpInstructionTemplate* aJmpInstructionPtr;      aJmpInstructionPtr = (JmpInstructionTemplate *) patchAddress;   aJmpInstructionPtr->Jmp = 0x4EF9;   aJmpInstructionPtr->Routine = jumpAddress;}/* Thanks to Apple DTS for the method *//* This new version of Sneaky Jump supplies a new function- GetUniversalFunctionHandle().	It takes two parameters- the function address and the parameter info. It will compile under the	new universal headers for the PowerPC. Your routine needs to supply the appropriate constant	for the type of xDEF that is being called- unfortunately this is less universal than it used	to be in this respect. The type of jump is resolved at run time- on a 680x0 mac, the old style	fake jump is created instead. It is the caller's responsibility to dispose of the handle when	done with it.*/