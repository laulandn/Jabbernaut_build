/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			PixMapUtils.cpp		-- pixel map utilities******			© 1997, Graham Cox*****************************************************************************************************/#include	"PixMapUtils.h"#include	"MacZoop.h"#include	<icons.h>#include	<QDOffscreen.h>/*---------------------------------*** MAKEBITMAP ***-----------------------------------*//*	make a bitmap with the bounds rect passed. This is a true 1-bit offscreen classic bitmapwhich is needed for some particular QD operations----------------------------------------------------------------------------------------*/void		MakeBitMap( Rect* aRect, BitMap* aBMap ){	short	width, height;	long	bufSize;		aBMap->bounds = *aRect;		width = aRect->right - aRect->left;	height = aRect->bottom - aRect->top;		aBMap->rowBytes = ((width + 15) / 16) * 2;		bufSize = (long) aBMap->rowBytes * (long) height;		FailNIL( aBMap->baseAddr = NewPtrClear( bufSize ));}/*-------------------------------*** DISPOSEBITMAP ***----------------------------------*//*	releases memory used by bitmap made above----------------------------------------------------------------------------------------*/void		DisposeBitMap( BitMap* aBMap ){	DisposePtr( aBMap->baseAddr );}/*-------------------------------***  MAKEPIXMAP  ***----------------------------------*//*make a self-contained pixmap with the size, depth and colours passed---------------------------------------------------------------------------------------*/PixMapHandle	MakePixMap( Rect* aSize, short aDepth, CTabHandle aCTable ){	PixMapHandle 	pp;	long			ppBufSize;	short			height, rBytes;		FailNIL( pp = (PixMapHandle) NewHandleClear( sizeof( PixMap )));		height = aSize->bottom - aSize->top;	rBytes = (( aDepth * ( aSize->right - aSize->left ) + 15 ) / 16 ) * 2;	ppBufSize = (long) height * (long) rBytes;		if ( aDepth < 16 )	{		if ( aCTable == NULL )		{			aCTable = GetCTable( aDepth );						// if still NULL, make a dummy table						if ( aCTable == NULL )			{					aCTable = (CTabHandle) NewHandleClear( sizeof( ColorTable ));								(*aCTable)->ctSeed = aDepth;				(*aCTable)->ctFlags = 0x8000;				(*aCTable)->ctSize = 0;				}			}		else			// clone the cTable so we can assign it to the pixmap without upsetting			// its true owners!						FailOSErr( HandToHand((Handle*) &aCTable ));	}		// fill in fields of pixmap		(*pp)->rowBytes = rBytes | 0x8000;	(*pp)->bounds = *aSize;		FailNIL((*pp)->baseAddr = NewPtrClear( ppBufSize ));		(*pp)->pixelSize = aDepth;	(*pp)->pmVersion = 0;	(*pp)->packType = 0;	(*pp)->packSize = 0;	(*pp)->pmTable = NULL;		(*pp)->hRes = 0x00480000;	(*pp)->vRes = 0x00480000;		if ( aDepth < 16 )	{		(*pp)->pixelType = 0;		(*pp)->cmpCount = 1;		(*pp)->cmpSize = aDepth;		(*pp)->pmTable = aCTable;	}	else	{		(*pp)->pixelType = RGBDirect;		(*pp)->cmpCount = 3;		if ( aDepth == 16 )			(*pp)->cmpSize = 5;		else			(*pp)->cmpSize = 8;			(*pp)->pmTable = (CTabHandle) NewHandleClear( sizeof( ColorTable ));				(*(*pp)->pmTable)->ctSeed = 3 * aDepth;		(*(*pp)->pmTable)->ctFlags = 0x8000;		(*(*pp)->pmTable)->ctSize = 0;	}		return pp;}/*----------------------------***  MAKEOFFSCREENPORT  ***------------------------------*//*make a self-contained offscreen port with the size, depth and colours passed---------------------------------------------------------------------------------------*/CGrafPtr		MakeOffscreenPort( Rect* aSize, short aDepth, CTabHandle aCTable ){	CGrafPtr		thePort;	PixMapHandle	pp;	RgnHandle       temp;		thePort = MZNewPort();		FailNIL( pp = MakePixMap( aSize, aDepth, aCTable ));		SetPort((GrafPtr) thePort );	SetPortPix( pp );		// make sure clip and vis are set to the bounds initially		*PORTPORTRECT( thePort ) = *aSize;	ClipRect( aSize );		temp = NewRgn();	GETPORTCLIPRGN( thePort, temp );	SETPORTVISRGN( thePort, temp );	DisposeRgn( temp );		EraseRect( aSize );		return thePort;} /*---------------------------***  DISPOSEOFFSCREENPORT  ***----------------------------*//*dispose of a port created above---------------------------------------------------------------------------------------*/void			DisposeOffscreenPort( CGrafPtr aPort ){	FailNILParam( aPort );		PixMapHandle	pp = PORTPIXMAPHANDLE( aPort );	Ptr				p;		p = (*pp)->baseAddr;	DisposePtr( p );		if ((*pp)->pmTable )		DisposeHandle((Handle) (*pp)->pmTable );		MZDisposePort( aPort );}/*----------------------------***  MAKEICONFROMPICTURE  ***----------------------------*//*make a complete icon from the picture passed in. Used to build custom icons for files.---------------------------------------------------------------------------------------*/Handle			MakeIconFromPicture( PicHandle srcPic, OSType iconType ){	Handle		h;	GrafPtr		savePort;	CGrafPtr	pPort;	Rect		dest, dog;	RgnHandle	iconMaskRgn, dogEarRgn;	short		iconSize, iDepth;	long		iBufSize;	Ptr			p;		FailNILParam( srcPic );		switch ( iconType )	{		default:		case kLarge8BitData:			iconSize = 32;			iDepth = 8;			break;				case kLarge4BitData:			iconSize = 32;			iDepth = 4;			break;				case kLarge1BitMask:			iconSize = 32;			iDepth = 1;			break;				case kSmall8BitData:			iconSize = 16;			iDepth = 8;			break;				case kSmall4BitData:			iconSize = 16;			iDepth = 4;			break;				case kSmall1BitMask:			iconSize = 16;			iDepth = 1;			break;	}	SetRect( &dest, 0, 0, iconSize, iconSize );		if ( iconSize == 32 )		SetRect( &dog, iconSize - 8, iconSize - 8, iconSize, iconSize );	else		SetRect( &dog, iconSize - 4, iconSize - 4, iconSize, iconSize );			// set up clipping and frame regions		iconMaskRgn = NewRgn();	dogEarRgn = NewRgn();		RectRgn( iconMaskRgn, &dest );	RectRgn( dogEarRgn, &dog );	DiffRgn( iconMaskRgn, dogEarRgn, iconMaskRgn );		// to make an icon, we need to construct hand-made pixmaps that have short	// word alignment- GWorlds won't do unfortunately. We make each pixmap, draw	// the picture into it, add a border and "dog-ear" corner, then copy the data	// from the pixmap to the handle and return it		GetPort( &savePort );		pPort = MakeOffscreenPort( &dest, iDepth );	// also sets the port	SetClip( iconMaskRgn );		// scale the image into the icon port. TO DO- use Scaling of rects to get better image.		InstallDitherProc( pPort );	DrawPicture( srcPic, &dest );	RemoveDitherProc( pPort );		// draw dog ear	ClipRect( &dest );	FrameRgn( iconMaskRgn );	MoveTo( dog.left - 1, dog.bottom - 1 );	LineTo( dog.right - 1, dog.top );		// we need to build a handle of the actual pixel data which is the icon data itself.		p = GetPixBaseAddr( PORTPIXMAPHANDLE( pPort ));	iBufSize = GetPtrSize( p );	FailOSErr( PtrToHand( p, &h, iBufSize ));		DisposeOffscreenPort( pPort );	SetPort( savePort );		// if this is the 1-bit icon, we also need to form the icon mask. This is simply	// concatenated onto the end of the icon data.		if ( iDepth == 1 )	{		OpenRgn();		MoveTo( dog.left,  dog.top );		LineTo( dog.right, dog.top );		LineTo( dog.left,  dog.bottom );		LineTo( dog.left,  dog.top );				CloseRgn( dogEarRgn );		UnionRgn( iconMaskRgn, dogEarRgn, iconMaskRgn );				pPort = MakeOffscreenPort( &dest, 1 );		PaintRgn( iconMaskRgn );				p = GetPixBaseAddr( PORTPIXMAPHANDLE( pPort ));		iBufSize = GetPtrSize( p );				FailOSErr( PtrAndHand( p, h, iBufSize ));		DisposeOffscreenPort( pPort );	}		DisposeRgn( iconMaskRgn );	DisposeRgn( dogEarRgn );	SetPort( savePort );		return h;}void			InstallDitherProc( CGrafPtr aPort ){	// installs a dither procedure into the port so that DrawPicture will dither down when drawn into	// the small shallow icons. Can be used for other purposes.		FailNILParam( aPort );		CQDProcsPtr		osProcs;	QDBitsUPP		ditherProcUPP;		FailNIL( osProcs = (CQDProcsPtr) NewPtr( sizeof( CQDProcs )));	SetStdCProcs( osProcs );		ditherProcUPP = NewQDBitsUPP( DitherBitsProc );		osProcs->bitsProc = ditherProcUPP;	#if OPAQUE_TOOLBOX_STRUCTS	SetPortGrafProcs( aPort, osProcs );#else	aPort->grafProcs = osProcs;#endif}void			RemoveDitherProc( CGrafPtr aPort ){	FailNILParam( aPort );		CQDProcsPtr		osProcs;#if OPAQUE_TOOLBOX_STRUCTS	osProcs = GetPortGrafProcs( aPort );#else	osProcs = aPort->grafProcs;#endif		DisposeQDBitsUPP( osProcs->bitsProc );	DisposePtr((Ptr) osProcs );	#if OPAQUE_TOOLBOX_STRUCTS	SetPortGrafProcs( aPort, NULL );#else	aPort->grafProcs = NULL;#endif}pascal void DitherBitsProc( BitMap *srcBits, const Rect *srcRect, const Rect *destRect, short mode, RgnHandle maskRgn ){	/* special filter proc to dither pictures containing copybits opcodes */		StdBits( srcBits, srcRect, destRect, mode | ditherCopy, maskRgn );}