/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			PixPatUtils.c		-- pixel pattern utilities******			© 2000, Graham Cox*****************************************************************************************************/#include    "PixPatUtils.h"#include    "MacZoop.h"#include    <QDOffscreen.h>PixPatHandle    MakePixPat( PicHandle srcpic, short pixDepth ){    PixPatHandle    pp = NULL;    Rect            bounds, pixBounds;    short           wh, q;    long            imgSize;    GWorldPtr       temp;    CGrafPtr        savePort;    GDHandle        saveDev;    PixMapHandle    pixels;    char            ss;        FailNILParam( srcpic );    ss = HGetState((Handle) srcpic );    HNoPurge((Handle) srcpic );    // calculate the bounds rect        bounds = (*srcpic)->picFrame;    wh = bounds.right - bounds.left;    if (( bounds.bottom - bounds.top ) < wh )        wh = bounds.bottom - bounds.top;        // find power of two that fits. The smallest size is 8 pixels- if smaller than    // that, bail...        if ( wh >= 8 )    {        q = 8;                while( q <= wh )            q *= 2;                // q is now double the best fit                wh = q / 2;                        SetRect( &pixBounds, 0, 0, wh, wh );        OffsetRect( &bounds, -bounds.left, -bounds.top );                // make a GWorld and draw the picture into it                FailOSErr( NewGWorld( &temp, pixDepth, &pixBounds, NULL, NULL, 0 ));                pixels = GetGWorldPixMap( temp );                if ( LockPixels( pixels ))        {            GetGWorld( &savePort, &saveDev );            SetGWorld( temp, NULL );            ClipRect( &pixBounds );            EraseRect( &pixBounds );            DrawPicture( srcpic, &bounds );            SetGWorld( savePort, saveDev );                    // OK, now make the pattern this size and make it access the GWorld            // pixels still locked here            FailNIL( pp = NewPixPat());            HLock((Handle) pp );            CopyPixMap( pixels, (*pp)->patMap );                    // copy the actual pixel data to the pattern's handle                        imgSize = ((*pixels)->rowBytes & 0x3FFF ) * pixBounds.bottom;            FailOSErr( PtrToXHand((*pixels)->baseAddr, (*pp)->patData, imgSize ));               (*(*pp)->patMap)->baseAddr = *(*pp)->patData;            (*pp)->patType = 1;                        HUnlock((Handle) pp );            UnlockPixels( pixels );            PixPatChanged( pp );                        DisposeGWorld( temp );        }    }        HSetState((Handle) srcpic, ss );        return pp;}Handle          MakeppatResource( PixPatHandle pp ){    // convert a "live" pixpat into a flattened version that can be saved as a 'ppat' resource        Handle  ppat = NULL;        FailNILParam( pp );    FailNIL( ppat = NewHandle( 0 ));        // first section is the PixPat record itself:        FailOSErr( HandAndHand((Handle) pp, ppat ));        // we must null out some fields however:        ( *(PixPatHandle) ppat )->patXData = 0L;    ( *(PixPatHandle) ppat )->patXValid = -1;    ( *(PixPatHandle) ppat )->patXMap = 0L;    ( *(PixPatHandle) ppat )->patMap = (PixMapHandle) GetHandleSize( ppat );        // now append the pixMap record:        FailOSErr( HandAndHand((Handle) (*pp)->patMap, ppat ));        // null out some of these fields        ( *(PixPatHandle) ppat )->patData = (Handle) GetHandleSize( ppat );        HLock( ppat );    PixMapPtr   px = (PixMapPtr)( *ppat + (long)( *(PixPatHandle) ppat )->patMap );        px->baseAddr = 0L;    px->hRes = 0x00480000;    px->vRes = 0x00480000;    px->planeBytes = 0L;    px->pmReserved = 0L;    HUnlock( ppat );        // we still need to write out the colour table and the offset to it, once we've written    // the actual pixel data        FailOSErr( HandAndHand((*pp)->patData, ppat ));        HLock( ppat );    px = (PixMapPtr)( *ppat + (long)( *(PixPatHandle) ppat )->patMap );    px->pmTable = (CTabHandle) GetHandleSize( ppat );    HUnlock( ppat );        // write the colour table        HLock((Handle) pp );    FailOSErr( HandAndHand((Handle) (*(*pp)->patMap)->pmTable ,ppat ));    HUnlock((Handle) pp );    return ppat;}