/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			FileMgrUtils.c		-- file utilities******			© 1998, Graham Cox*****************************************************************************************************/#include	"FileMgrUtils.h"#include	"MacZoop.h"/*****************************************************************************/// Static methods obtained from MoreFiles- code provided by Apple DTS./*****************************************************************************/#pragma mark ----- File Manager Utilities -----/*****************************************************************************/pascal	OSErr	GetDirectoryID(short vRefNum,							   long dirID,							   StringPtr name,							   long *theDirID,							   Boolean *isDirectory){	CInfoPBRec pb;	Str31 tempName;	OSErr error;	/* Protection against File Sharing problem */	if ( (name == NULL) || (name[0] == 0) )	{		tempName[0] = 0;		pb.hFileInfo.ioNamePtr = tempName;		pb.hFileInfo.ioFDirIndex = -1;	/* use ioDirID */	}	else	{		pb.hFileInfo.ioNamePtr = name;		pb.hFileInfo.ioFDirIndex = 0;	/* use ioNamePtr and ioDirID */	}	pb.hFileInfo.ioVRefNum = vRefNum;	pb.hFileInfo.ioDirID = dirID;	error = PBGetCatInfoSync(&pb);	*isDirectory = (pb.hFileInfo.ioFlAttrib & ioDirMask) != 0;	*theDirID = (*isDirectory) ? pb.dirInfo.ioDrDirID : pb.hFileInfo.ioFlParID;	return ( error );}/*****************************************************************************/pascal	OSErr	FSpGetDirectoryID(const FSSpec *spec,								  long *theDirID,								  Boolean *isDirectory){	return ( GetDirectoryID(spec->vRefNum, spec->parID, (StringPtr)spec->name,			 theDirID, isDirectory) );}/*****************************************************************************/short	GetSFCurVol(){#if TARGET_API_MAC_CARBON	return 0;#else	return -(LMGetSFSaveDisk());#endif}/*****************************************************************************/long	GetSFCurDir(){#if TARGET_API_MAC_CARBON	return 0;#else	return LMGetCurDirStore();#endif}Boolean		GetFullPathname(FSSpec* aSpec, Str255 pathname, long relDir ){	// returns the full pathname for the file spec passed. If the file does not exist, this	// returns FALSE, if it does, it returns TRUE.		DirInfo		blk;	Str255		dirName;	OSErr		theErr;	Boolean 	result = TRUE;	pathname[0] = 0;		blk.ioDrParID = aSpec->parID;	blk.ioNamePtr = dirName;		do	{		blk.ioVRefNum = aSpec->vRefNum;		blk.ioFDirIndex = -1;		blk.ioDrDirID = blk.ioDrParID;				theErr = PBGetCatInfoSync((CInfoPBPtr) &blk );				if ( theErr )		{			result = FALSE;			break;		}				ConcatPStrings( dirName, "\p:" );		pStrInsert( pathname, dirName );	}	while( blk.ioDrDirID != relDir );		if ( result )		ConcatPStrings( pathname, aSpec->name );			if ( relDir != 2 )		pStrInsert( pathname, "\p:" );		return result;}/*****************************************************************************/OSErr MakeCanonFSSpec ( FSSpec *spec ){	OSErr		err ;		err = FSMakeFSSpec( spec->vRefNum,						spec->parID,						spec->name,						spec ) ;	return noErr ;}/*****************************************************************************/Boolean SameFile ( FSSpec *spec1, FSSpec *spec2 ){	if (spec1->vRefNum != spec2->vRefNum)		return false;	if (spec1->parID != spec2->parID)		return false;	if ( !EqualString( spec1->name, spec2->name, false, true ) )		return false;	return true;}/*****************************************************************************/void		pStrInsert(StringPtr dest,StringPtr src){	// inserts <src> at the beginning of <dest>		BlockMoveData(dest + 1,dest + *src + 1,*dest);	BlockMoveData(src + 1,dest + 1,*src);	*dest += *src;}/*****************************************************************************/pascal	OSErr	GetDirName(short vRefNum,						   long dirID,						   Str31 name,						   long* parID ){	CInfoPBRec pb;	OSErr error;	if ( name != NULL )	{		pb.dirInfo.ioNamePtr = name;		pb.dirInfo.ioVRefNum = vRefNum;		pb.dirInfo.ioDrDirID = dirID;		pb.dirInfo.ioFDirIndex = -1;	/* get information about ioDirID */		error = PBGetCatInfoSync(&pb);				*parID = pb.dirInfo.ioDrParID;	}	else	{		error = paramErr;	}		return ( error );}/*****************************************************************************/pascal	OSErr	GetParentID(short vRefNum,							long dirID,							ConstStr255Param name,							long *parID){	CInfoPBRec pb;	Str31 tempName;	OSErr error;	short realVRefNum;		/* Protection against File Sharing problem */	if ( (name == NULL) || (name[0] == 0) )	{		tempName[0] = 0;		pb.hFileInfo.ioNamePtr = tempName;		pb.hFileInfo.ioFDirIndex = -1;	/* use ioDirID */	}	else	{		pb.hFileInfo.ioNamePtr = (StringPtr)name;		pb.hFileInfo.ioFDirIndex = 0;	/* use ioNamePtr and ioDirID */	}	pb.hFileInfo.ioVRefNum = vRefNum;	pb.hFileInfo.ioDirID = dirID;	error = PBGetCatInfoSync(&pb);	if ( error == noErr )	{		/*		**	There's a bug in HFS where the wrong parent dir ID can be		**	returned if multiple separators are used at the end of a		**	pathname. For example, if the pathname:		**		'volumeName:System Folder:Extensions::'		**	is passed, the directory ID of the Extensions folder is		**	returned in the ioFlParID field instead of fsRtDirID. Since		**	multiple separators at the end of a pathname always specifies		**	a directory, we only need to work-around cases where the		**	object is a directory and there are multiple separators at		**	the end of the name parameter.		*/		if ( (pb.hFileInfo.ioFlAttrib & ioDirMask) != 0 )		{			/* Its a directory */						/* is there a pathname? */			if ( pb.hFileInfo.ioNamePtr == name )				{				/* could it contain multiple separators? */				if ( name[0] >= 2 )				{					/* does it contain multiple separators at the end? */					if ( (name[name[0]] == ':') && (name[name[0] - 1] == ':') )					{						/* OK, then do the extra stuff to get the correct parID */												/* Get the real vRefNum (this should not fail) */						error = DetermineVRefNum(name, vRefNum, &realVRefNum);						if ( error == noErr )						{							/* we don't need the parent's name, but add protect against File Sharing problem */							tempName[0] = 0;							pb.dirInfo.ioNamePtr = tempName;							pb.dirInfo.ioVRefNum = realVRefNum;							/* pb.dirInfo.ioDrDirID already contains the */							/* dirID of the directory object */							pb.dirInfo.ioFDirIndex = -1;	/* get information about ioDirID */							error = PBGetCatInfoSync(&pb);							/* now, pb.dirInfo.ioDrParID contains the correct parID */						}					}				}			}		}				if ( error == noErr )		{			/* if no errors, then pb.hFileInfo.ioFlParID (pb.dirInfo.ioDrParID) */			/* contains the parent ID */			*parID = pb.hFileInfo.ioFlParID;		}	}		return ( error );}/*****************************************************************************//***	GetVolumeInfoNoName uses pathname and vRefNum to call PBHGetVInfoSync**	in cases where the returned volume name is not needed by the caller.**	The pathname and vRefNum parameters are not touched, and the pb**	parameter is initialized by PBHGetVInfoSync except that ioNamePtr in**	the parameter block is always returned as NULL (since it might point**	to the local tempPathname).****	I noticed using this code in several places, so here it is once.**	This reduces the code size of MoreFiles.*/pascal	OSErr	GetVolumeInfoNoName(ConstStr255Param pathname,									short vRefNum,									HParmBlkPtr pb){	Str255 tempPathname;	OSErr error;		/* Make sure pb parameter is not NULL */ 	if ( pb != NULL )	{		pb->volumeParam.ioVRefNum = vRefNum;		if ( pathname == NULL )		{			pb->volumeParam.ioNamePtr = NULL;			pb->volumeParam.ioVolIndex = 0;		/* use ioVRefNum only */		}		else		{			BlockMoveData(pathname, tempPathname, pathname[0] + 1);	/* make a copy of the string and */			pb->volumeParam.ioNamePtr = (StringPtr)tempPathname;	/* use the copy so original isn't trashed */			pb->volumeParam.ioVolIndex = -1;	/* use ioNamePtr/ioVRefNum combination */		}		error = PBHGetVInfoSync(pb);		pb->volumeParam.ioNamePtr = NULL;	/* ioNamePtr may point to local	tempPathname, so don't return it */	}	else	{		error = paramErr;	}	return ( error );}/*****************************************************************************/pascal	OSErr	DetermineVRefNum(ConstStr255Param pathname,								 short vRefNum,								 short *realVRefNum){	HParamBlockRec pb;	OSErr error;	error = GetVolumeInfoNoName(pathname,vRefNum, &pb);	if ( error == noErr )	{		*realVRefNum = pb.volumeParam.ioVRefNum;	}	return ( error );}/*-------------------------***  GetIconSuiteFromDTDB  ***-------------------------------*//*access:			publicoverrides:		description: 	returns an icon suite from the desktop databaseins: 			<fileType> file type of file				<fileCreator> creator code of fileouts: 			Handle to Icon Suite (can be passed directly to PlotIconSuite)notes:			currently only looks on startup volume, returns generic icons for				unrecognised files----------------------------------------------------------------------------------------*/Handle			GetIconSuiteFromDTDB( const OSType fileType, const OSType fileCreator ){	Handle 		icon = NULL;	Handle 		suite = NULL;	Boolean		gotIcon = FALSE;	FailOSErr( NewIconSuite( &suite ));	icon = GetDTDBIcon( -1, kLarge1BitMask, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kLarge1BitMask );	}		icon = GetDTDBIcon( -1, kSmall1BitMask, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kSmall1BitMask );	}		icon = GetDTDBIcon( -1, kLarge8BitData, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kLarge8BitData );	}		icon = GetDTDBIcon( -1, kSmall8BitData, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kSmall8BitData );	}	/*	icon = GetDTDBIcon( -1, kSmall8BitMask, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kSmall8BitMask );	}	icon = GetDTDBIcon( -1, kLarge8BitMask, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kLarge8BitMask );	}	icon = GetDTDBIcon( -1, kLarge32BitData, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kLarge32BitData );	}	icon = GetDTDBIcon( -1, kSmall32BitData, fileType, fileCreator );	if ( icon )	{		gotIcon = TRUE;		AddIconToSuite( icon, suite, kSmall32BitData );	}	*/		if ( ! gotIcon )	{		DisposeIconSuite( suite, TRUE );		FailOSErr( GetIconSuite( &suite, kGenericDocumentIconResource, kSelectorAllAvailableData ));	}		return suite;}/*-------------------------------***  GetDTDBIcon  ***----------------------------------*//*access:			globaloverrides:		description: 	returns a single icpon that can be added to a suiteins: 			<vRefNum> volume reference number to look on				<iconType> type of icon we want				<fileType> file type				<fileCreator> file creatorouts: 			Handle to Icon (can be passed to AddIconToSuite)notes:			----------------------------------------------------------------------------------------*/Handle 			GetDTDBIcon( short vRefNum, ResType iconType, OSType fileType, OSType fileCreator ){	Handle			icon;	DTPBRec 		dtr;	SInt8			iType;	Size			iSize;	switch( iconType )	{		case kLarge1BitMask:			iType = kLargeIcon; 			iSize = kLargeIconSize; 			break;				case kLarge4BitData:			iType = kLarge4BitIcon; 			iSize = kLarge4BitIconSize; 			break;				case kLarge8BitData:			iType = kLarge8BitIcon; 			iSize = kLarge8BitIconSize; 			break;				case kSmall1BitMask:			iType = kSmallIcon; 			iSize = kSmallIconSize; 			break;				case kSmall4BitData:			iType = kSmall4BitIcon; 			iSize = kSmall4BitIconSize; 			break;				case kSmall8BitData:			iType = kSmall8BitIcon; 			iSize = kSmall8BitIconSize; 			break;					case kSmall8BitMask:			break;					case kLarge8BitMask:			break;					case kLarge32BitData:			break;					case kSmall32BitData:			break;				default:			return NULL;	}			// find database		dtr.ioNamePtr = NULL;	dtr.ioVRefNum = vRefNum;	dtr.ioCompletion = NULL;			FailOSErr( PBDTGetPath( &dtr ));	FailNIL( icon = NewHandle( iSize ));	HLock( icon );		// get icon from Desktop database		dtr.ioTagInfo 		= 0;	dtr.ioDTBuffer		= *icon;	dtr.ioDTReqCount 	= iSize;	dtr.ioIconType 		= iType;	dtr.ioFileCreator	= fileCreator;	dtr.ioFileType		= fileType; 	 	try 	{ 		FailOSErr( PBDTGetIconSync( &dtr )); 		HUnlock( icon ); 	} 	catch( ZoopError err ) 	{ 		HUnlock( icon ); 		DisposeHandle( icon ); 		icon = NULL; 	}	return icon;}/*-------------------------***  GetApplNameFromCreator  ***-----------------------------*//*access:			globaloverrides:		description: 	returns the name of the application associated with the creator type passedins: 			<vRefNum> volume reference number to look on				<fileCreator> file creator				<appName> receives nameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void			GetApplNameFromCreator( short vRefNum, const OSType fileCreator, Str31 appName ){	DTPBRec 		dtr;	// find database		dtr.ioNamePtr = NULL;	dtr.ioVRefNum = vRefNum;	dtr.ioCompletion = NULL;			FailOSErr( PBDTGetPath( &dtr ));		dtr.ioNamePtr = appName;	dtr.ioIndex = 0;	dtr.ioFileCreator = fileCreator;		try	{		FailOSErr( PBDTGetAPPLSync( &dtr ));	}	catch( ZoopError err )	{		appName[0] = 0;	}}