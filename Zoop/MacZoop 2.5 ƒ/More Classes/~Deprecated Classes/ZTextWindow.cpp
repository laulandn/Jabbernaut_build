/****************************************************************************************************			ObjectMacZapp		-- a standard Mac OOP application template****			ZTextWindow.cpp		-- a window that displays text files (uses TextEdit)******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZTextWindow.h"#include	"MacZoop.h"#include	<TextEdit.h>static pascal Boolean	ztClickproc( TERec* tr );static ZTextWindow*		gClickedTE;static TEClickLoopUPP	gTEClickLoopCallBack = NewTEClickLoopUPP( ztClickproc );CLASSCONSTRUCTOR( ZTextWindow );/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZTextWindow::ZTextWindow( ZCommander* aBoss, const short windID, Boolean allowEditing, Boolean allowSelecting )	: ZScroller( aBoss, windID, TRUE, TRUE ){	classID = CLASS_ZTextWindow;		itsText = NULL;	isEditable = allowEditing;	isSelectable = ( allowSelecting || allowEditing );	wControl = teWindowWidth;	emWidth = 255;}/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZTextWindow::ZTextWindow()	: ZScroller(){	classID = CLASS_ZTextWindow;	itsText = NULL;	isEditable = FALSE;	isSelectable = FALSE;	wControl = teWindowWidth;	emWidth = 255;}/*---------------------------------***  DESTRUCTOR  ***---------------------------------*/ZTextWindow::~ZTextWindow(){	if ( itsText )		TEDispose( itsText );}/*--------------------------------***  INITZWINDOW  ***---------------------------------*//*	 initialise the window----------------------------------------------------------------------------------------*/void	ZTextWindow::InitZWindow(){	ZScroller::InitZWindow();		MakeTextEdit();}/*--------------------------------***  DRAWCONTENT  ***---------------------------------*//*	 update the window's contents----------------------------------------------------------------------------------------*/void	ZTextWindow::DrawContent(){	Rect	r;		SetOrigin( 0, 0 );	GetContentRect( &r );	ClipRect( &r );		if ( itsText )		TEUpdate( &r, itsText );}/*-------------------------------***  CLICKCONTENT  ***---------------------------------*//*	 handle mouse click in the window, handling text click and scrollbars----------------------------------------------------------------------------------------*/void	ZTextWindow::ClickContent( const Point mouse, const short modifiers ){	if ( isSelectable )	{		Point tm = mouse;				SetOrigin( 0, 0 );				tm.v += topMargin;		tm.h += leftMargin;		if ( hasVBar )			tm.v -= GetControlValue( theVBar );				if ( hasHBar )			tm.h -= GetControlValue( theHBar );				gClickedTE = this;			ClipRect( &(*itsText)->viewRect );				TEClick( tm, (modifiers & shiftKey) == shiftKey, itsText );	}}/*---------------------------------***  ACTIVATE  ***-----------------------------------*//*	 the window is being activated----------------------------------------------------------------------------------------*/void	ZTextWindow::Activate(){	ZScroller::Activate();		if ( gFontMenuID )		gMenuBar->EnableCommand( gFontMenuID, 0 );	if ( isSelectable )		TEActivate( itsText );}/*--------------------------------***  DEACTIVATE  ***----------------------------------*//*	 the window is becoming inactive----------------------------------------------------------------------------------------*/void	ZTextWindow::Deactivate(){	Focus();		if ( isSelectable )		TEDeactivate( itsText );	if ( gFontMenuID )		gMenuBar->DisableCommand( gFontMenuID, 0 );	ZScroller::Deactivate();}/*-----------------------------------***  IDLE  ***-------------------------------------*//*	 blink the cursor in the text----------------------------------------------------------------------------------------*/void	ZTextWindow::Idle(){	if ( isSelectable )		TEIdle( itsText );		ZScroller::Idle();}/*-------------------------------***  ADJUSTCURSOR  ***---------------------------------*//*	 set the cursor to an i-Beam over the text----------------------------------------------------------------------------------------*/void	ZTextWindow::AdjustCursor( const Point mouse, const short modifiers ){	Rect		content;		if ( isSelectable )	{		GetContentRect( &content );				if ( PtInRect( mouse, &content ) && ( modifiers & cmdKey ) == 0 )			SetCursorShape( iBeamCursor );		else			ZScroller::AdjustCursor( mouse, modifiers );	}}/*--------------------------------***  UPDATEMENUS  ***---------------------------------*//*	 update the menus to the appropriate state for this window----------------------------------------------------------------------------------------*/void	ZTextWindow::UpdateMenus(){	if ( isSelectable )	{		if ((*itsText)->selStart < (*itsText)->selEnd )		{			gMenuBar->EnableCommand( kCmdCopy );						if ( isEditable )			{				    gMenuBar->EnableCommand( kCmdCut );				    gMenuBar->EnableCommand( kCmdClear );			}			}				gMenuBar->EnableCommand( kCmdSelectAll );	}		if ( isEditable )	{		gMenuBar->EnableCommand( kCmdSetLeftJustify );			gMenuBar->EnableCommand( kCmdSetCentreJustify );			gMenuBar->EnableCommand( kCmdSetRightJustify );					// Font/style menus:				TEStyleRunInfo	ri;				TEGetStyleRunInfo( &ri, itsText );					// check sizes, styles & font				gMenuBar->UpdateFontSizeMenu( &ri );		gMenuBar->UpdateStyleMenu( &ri );		gMenuBar->EnableCommand( kCmdSetColourBlack );		gMenuBar->EnableCommand( kCmdSetColourWhite );		gMenuBar->EnableCommand( kCmdSetColourRed );		gMenuBar->EnableCommand( kCmdSetColourGreen );		gMenuBar->EnableCommand( kCmdSetColourBlue );		gMenuBar->EnableCommand( kCmdSetColourCyan );		gMenuBar->EnableCommand( kCmdSetColourMagenta );		gMenuBar->EnableCommand( kCmdSetColourYellow );		gMenuBar->EnableCommand( kCmdSetColourOther );	}		ZScroller::UpdateMenus();}/*------------------------------***  HANDLECOMMAND  ***---------------------------------*//*	 handle text commands----------------------------------------------------------------------------------------*/void	ZTextWindow::HandleCommand( const ZoopCommand aCmd ){	// handle font size and style commands		TextStyle		newStyle;	Boolean			wasChanged = TRUE;		switch( aCmd )	{		case kCmdPlainText:			newStyle.tsFace = normal;			TESetStyle( doFace, &newStyle, true, itsText );			break;				case kCmdBoldText:			newStyle.tsFace = bold;			TESetStyle( doFace + doToggle, &newStyle, true, itsText );			break;				case kCmdItalicText:			newStyle.tsFace = italic;			TESetStyle( doFace + doToggle, &newStyle, true, itsText );			break;				case kCmdUnderlineText:			newStyle.tsFace = underline;			TESetStyle( doFace + doToggle, &newStyle, true, itsText );			break;				case kCmdOutlineText:			newStyle.tsFace = outline;			TESetStyle( doFace + doToggle, &newStyle, true, itsText );			break;				case kCmdShadowText:			newStyle.tsFace = shadow;			TESetStyle( doFace + doToggle, &newStyle, true, itsText );			break;				case kCmdCondensedText:			newStyle.tsFace = condense;			TESetStyle( doFace + doToggle, &newStyle, true, itsText );			break;				case kCmdExtendedText:			newStyle.tsFace = extend;			TESetStyle( doFace + doToggle, &newStyle, true, itsText );			break;				case kCmdStdFontSize7:		case kCmdStdFontSize9:		case kCmdStdFontSize10:		case kCmdStdFontSize12:		case kCmdStdFontSize14:		case kCmdStdFontSize18:		case kCmdStdFontSize24:		case kCmdStdFontSize36:		case kCmdStdFontSize48:		case kCmdStdFontSize60:		case kCmdStdFontSize72:			newStyle.tsSize = aCmd - kStdFontSizeBase;			TESetStyle( doSize, &newStyle, true, itsText );			break;						case kCmdSetColourRed:			newStyle.tsColor = gRed;			TESetStyle( doColor, &newStyle, true, itsText );			break;						case kCmdSetColourGreen:			newStyle.tsColor = gGreen;			TESetStyle( doColor, &newStyle, true, itsText );			break;						case kCmdSetColourBlue:			newStyle.tsColor = gBlue;			TESetStyle( doColor, &newStyle, true, itsText );			break;						case kCmdSetColourBlack:			newStyle.tsColor = gBlack;			TESetStyle( doColor, &newStyle, true, itsText );			break;						case kCmdSetColourWhite:			newStyle.tsColor = gWhite;			TESetStyle( doColor, &newStyle, true, itsText );			break;						case kCmdSetColourCyan:			newStyle.tsColor = gCyan;			TESetStyle( doColor, &newStyle, true, itsText );			break;						case kCmdSetColourMagenta:			newStyle.tsColor = gMagenta;			TESetStyle( doColor, &newStyle, true, itsText );			break;						case kCmdSetColourYellow:			newStyle.tsColor = gYellow;			TESetStyle( doColor, &newStyle, true, itsText );			break;					case kCmdSetLeftJustify:			TESetAlignment( teFlushLeft, itsText );			PostRefresh();			break;					case kCmdSetCentreJustify:			TESetAlignment( teCenter, itsText );			PostRefresh();			break;					case kCmdSetRightJustify:			TESetAlignment( teFlushRight, itsText );			PostRefresh();			break;							default:			ZScroller::HandleCommand( aCmd );			wasChanged = FALSE;			break;	}		if ( wasChanged )	{		SetDirty( TRUE );		RecalText();	}}/*------------------------------***  HANDLECOMMAND  ***---------------------------------*//*	 handle choices from the font menu----------------------------------------------------------------------------------------*/void	ZTextWindow::HandleCommand( const short menuID, const short itemID ){	if ( menuID == gFontMenuID )		// Found font menu! Select our font:	{		Str255		itemName;		TextStyle	newStyle;				GetMenuItemText( GetMenuHandle( gFontMenuID ), itemID, itemName );		GetFNum( itemName, &newStyle.tsFont );		TESetStyle( doFont, &newStyle, true, itsText );	}	else		ZScroller::HandleCommand( menuID, itemID );}/*-------------------------------***  CANPASTETYPE  ***---------------------------------*//*	 the window can accept TEXT data from the clipboard----------------------------------------------------------------------------------------*/Boolean	ZTextWindow::CanPasteType(){	return isEditable && gClipboard->QueryType( 'TEXT' );}/*----------------------------------***  DOCUT  ***-------------------------------------*//*	 cut selected text to the clipboard----------------------------------------------------------------------------------------*/void	ZTextWindow::DoCut(){	if ( isEditable )	{		gClipboard->Clear();		TECut( itsText );		RecalText();		SetDirty( TRUE );	}}/*----------------------------------***  DOCOPY  ***------------------------------------*//*	 copies selected text to the clipboard----------------------------------------------------------------------------------------*/void	ZTextWindow::DoCopy(){	if ( isSelectable )	{		gClipboard->Clear();		TECopy( itsText );	}}/*---------------------------------***  DOPASTE  ***------------------------------------*//*	 paste text on the clipboard into the text----------------------------------------------------------------------------------------*/void	ZTextWindow::DoPaste(){	if ( isEditable )	{		TEStylePaste( itsText );				RecalText();		SetDirty( TRUE );	}}/*----------------------------------***  DOCLEAR  ***-----------------------------------*//*	 delete the selection----------------------------------------------------------------------------------------*/void	ZTextWindow::DoClear(){	if ( isEditable )	{		TEDelete( itsText );		RecalText();		SetDirty( TRUE );	}}/*-------------------------------***  DOSELECTALL  ***----------------------------------*//*	 select all of the text----------------------------------------------------------------------------------------*/void	ZTextWindow::DoSelectAll(){	if ( isSelectable )		TESetSelect( 0, 32767, itsText );}/*---------------------------------***  SETSIZE  ***------------------------------------*//*	 set the size of the window----------------------------------------------------------------------------------------*/void	ZTextWindow::SetSize( const short width, const short height ){	ZScroller::SetSize( width, height );		if ( itsText )	{		// if variable width, adjust the width to the new window size				if ( wControl == teWindowWidth )		{			Rect	r, cr;						r = (*itsText)->destRect;			GetContentRect( &cr );						r.right = r.left + cr.right - cr.left;						(*itsText)->destRect = r;						Focus();		#if TARGET_API_MAC_CARBON			InvalWindowRect( GetMacWindow(), &cr);		#else			InvalRect( &cr );		#endif		}				// if the resize caused a shift in position, we must scroll to correctly position the text		// in the view. Normally ZScroller does this for us but text views are complicated by the		// fact that TextEdit handles its own scrolling.				RecalText();	}}/*-----------------------------------***  ZOOM  ***-------------------------------------*//*	 zoom the window----------------------------------------------------------------------------------------*/void	ZTextWindow::Zoom( const short partCode ){	ZScroller::Zoom( partCode );		// if variable width, adjust the width to the new window size		if ( wControl == teWindowWidth )	{		Rect	r, cr;				r = (*itsText)->destRect;		GetContentRect( &cr );				r.right = r.left + cr.right - cr.left;				(*itsText)->destRect = r;	}		// perform the same trick as SetSize...		RecalText();	Draw();}/*----------------------------------***  SCROLL  ***------------------------------------*//*	 scroll the text----------------------------------------------------------------------------------------*/void	ZTextWindow::Scroll( const short dH, const short dV ){	TEPinScroll( dH, dV, itsText );}/*-----------------------------------***  TYPE  ***-------------------------------------*//*	 handle keyboard input in this window----------------------------------------------------------------------------------------*/void	ZTextWindow::Type( const char theChar, const short modifiers ){	if ( isEditable )	{		MZTEKey( theChar, itsText, modifiers );				RecalText( TRUE );		SetDirty( TRUE );	}}/*-------------------------------***  MAKETEXTEDIT  ***---------------------------------*//*	 build the Mac data structures----------------------------------------------------------------------------------------*/void	ZTextWindow::MakeTextEdit(){	Rect		destRect, viewRect;	FontInfo	fi;		// the dest rect is the scrollbounds, but that hasn't been set yet.	// the view rect is the content area by default		Focus();		TextFont( kFontIDGeneva );	TextSize( 12 );	GetFontInfo( &fi );		emSpace = fi.widMax;	GetTextViewRect( &viewRect );		destRect = viewRect;	destRect.right = destRect.left + ( emSpace * emWidth );		FailNIL( itsText = TEStyleNew( &destRect, &viewRect ));		TESetClickLoop( gTEClickLoopCallBack, itsText );	SetBounds( destRect );	RecalText();}/*---------------------------------***  OPENFILE  ***-----------------------------------*//*	 open a text file into this window----------------------------------------------------------------------------------------*/void	ZTextWindow::OpenFile( const OSType fType, Boolean isStationery ){	FInfo	fi;	short	refNum;	long	pSize;	Handle	temp = NULL;	if ( macFile.vRefNum != kNoFile )	{		FailOSErr( FSpGetFInfo( &macFile, &fi ));				if ( fi.fdType != 'TEXT' )			FailOSErr( paramErr );					FailOSErr( FSpOpenDF( &macFile, fsCurPerm, &refNum ));				try		{			FailOSErr( GetEOF( refNum, &pSize ));			if ( pSize > kMaxTextSize )				FailOSErr( kTextFileTooBigErr );							FailNIL( temp = NewHandle( pSize ));							HLock( temp );			FailOSErr( FSRead( refNum, &pSize, *temp ));						// set the text in text edit						TESetText( *temp, pSize, itsText );			HUnlock( temp );						DisposeHandle( temp );			FSClose( refNum );						// see if there is a 'styl' resource:						refNum = FSpOpenResFile( &macFile, fsCurPerm );						if ( refNum > 0 )	// If there's no resFork, no styles to look for:			{				UseResFile( refNum );				temp = Get1Resource( 'styl', 128 );								if ( temp && ( ResError() == noErr ))				{					TEUseStyleScrap( 0, pSize, (StScrpHandle) temp, FALSE, itsText );					ReleaseResource( temp );				}								CloseResFile( refNum );			}		}		catch( ZoopError err )		{			FSClose( refNum );						if ( temp )			{				HUnlock( temp );				DisposeHandle( temp );			}			throw err;		}	}		ZScroller::OpenFile( fType, isStationery );		// set up the bounds, etc		RecalText();	Draw();}/*---------------------------------***  SAVEFILE  ***-----------------------------------*//*	 saves the text into a TEXT file----------------------------------------------------------------------------------------*/void	ZTextWindow::SaveFile(){	short		refNum;	long		pSize;	OSErr		theErr;	Handle		text = NULL;	char		tState;		if ( macFile.vRefNum != kNoFile )	{		theErr = FSpOpenDF( &macFile, fsCurPerm, &refNum );				if ( theErr == fnfErr )		{			FailOSErr( FSpCreate( &macFile, gAppSignature, 'TEXT', 0 ));			FSpCreateResFile( &macFile, gAppSignature, 'TEXT', 0 );			FailOSErr( ResError() );			FailOSErr( FSpOpenDF( &macFile, fsCurPerm, &refNum ));		}		else			FailOSErr( theErr );				try		{			FailNIL( text = (*itsText)->hText );						pSize = GetHandleSize( text );							tState = HGetState( text );			HLock( text );			FailOSErr( FSWrite( refNum, &pSize, *text ));			HSetState( text, tState );						FailOSErr( SetEOF( refNum, pSize ));			FSClose( refNum );							// Now save styles:						short		savedStart = (*itsText)->selStart;			short		savedEnd   = (*itsText)->selEnd;						(*itsText)->selStart = 0;			(*itsText)->selEnd = (*itsText)->teLength;						StScrpHandle	styles = TEGetStyleScrapHandle( itsText );						(*itsText)->selStart = savedStart;			(*itsText)->selEnd = savedEnd;						refNum = FSpOpenResFile( &macFile, fsCurPerm );						if( refNum > 0 )			{				Handle		theRes = Get1Resource( 'styl', 128 );								if( theRes )					RemoveResource( theRes );								AddResource((Handle) styles, 'styl', 128, "\p" );				WriteResource((Handle) styles );				ReleaseResource((Handle) styles );			}						CloseResFile( refNum );		}		catch( ZoopError err )		{			FSClose( refNum );			if ( text )				HSetState( text, tState );			throw err;		}		ZScroller::SaveFile();	}}/*--------------------------------***  RECALTEXT  ***-----------------------------------*//*	 calculate scrollbar params, reflow, etc.----------------------------------------------------------------------------------------*/void	ZTextWindow::RecalText( Boolean scrollToCaret ){	static Boolean rtInProgress = FALSE;		Rect	content, tBounds, vRect;	short 	textHeight, lineHeight, diff;	Boolean needsRedraw = FALSE;		if ( ! rtInProgress )	{		rtInProgress = TRUE;				Focus();		SetOrigin( 0, 0 );		GetContentRect(&content);		(*itsText)->viewRect = content;				TECalText( itsText );			lineHeight = TEGetHeight( 1, 1, itsText );		textHeight = TEGetHeight( 0, 32767 , itsText );				GetBounds( &tBounds );		tBounds.bottom = textHeight;				if( wControl == teWindowWidth )			tBounds.right = tBounds.left + content.right - content.left;				SetBounds( tBounds );				vRect = (*itsText)->destRect;		OffsetRect( &tBounds, vRect.left - tBounds.left, vRect.top - tBounds.top );				diff = (*itsText)->viewRect.bottom - tBounds.bottom;				if ( diff > 0 )		{			OffsetRect( &tBounds, 0 , diff );		    needsRedraw = TRUE;		}			diff = (*itsText)->viewRect.top - tBounds.top;				if ( diff < 0 )		{			OffsetRect( &tBounds, 0, diff );		    needsRedraw = TRUE;		}				(*itsText)->destRect = tBounds;				SetScrollAmount( emSpace, lineHeight );				if ( scrollToCaret )		{		    TEAutoView( TRUE, itsText );		    TESelView( itsText );		    TEAutoView( FALSE, itsText );        }        		if ( hasVBar )			SetControlValue( theVBar, (*itsText)->viewRect.top - (*itsText)->destRect.top );					if ( hasHBar )			SetControlValue( theHBar, (*itsText)->viewRect.left - (*itsText)->destRect.left );				if ( needsRedraw )		    Draw();				rtInProgress = FALSE;	}}/*------------------------------***  SETWIDTHCONTROL  ***-------------------------------*//*	 set the behaviour for text wrap for this window----------------------------------------------------------------------------------------*/void	ZTextWindow::SetWidthControl( TEWidthControl aCtl, short fixWidth ){	// this changes the text width control of the view. The default is a fixed width of 255 characters	// of the max width of the default font. This is quite a good setting for e.g. code listings.	// However, for text such as Read Me docs, etc, a variable width is probably more useful. In that	// case the text view is adjusted to the current width of the window.		if ( aCtl != wControl )	{		wControl = aCtl;				if ( wControl == teFixedWidth )			emWidth = fixWidth;				// change the destRect of the text so that it is correct for the behaviour we are		// selecting.				if ( itsText )		{			Rect	r = (*itsText)->destRect;			Rect	cr;						if ( wControl == teWindowWidth )			{				GetContentRect( &cr );				r.right = r.left + cr.right - cr.left;			}			else				r.right = r.left + ( emSpace * emWidth );						(*itsText)->destRect = r;							RecalText();			Draw();		}	}}/*-------------------------------***  SETSIZERECT  ***----------------------------------*//*	 set the max user-draggable size of the window----------------------------------------------------------------------------------------*/void	ZTextWindow::SetSizeRect( const Rect& szRect ){	ZScroller::SetSizeRect( szRect );		// if variable width, allow user to drag window regardless of bounds:		if ( wControl == teWindowWidth )	{		sizeRect.right = 10000;		sizeRect.bottom = 10000;	}}/*-----------------------------***  TEXTEDITCLICKLOOP  ***------------------------------*//*	 implements a default clickLoop that autoscrolls the text----------------------------------------------------------------------------------------*/void	ZTextWindow::TextEditClickLoop(){	// perform autoscrolling. This is the default click loop action- you can override it	// if you want to do something else in the click loop.		Point	mouse;	Rect	r;		Focus();	GetMouse( &mouse );	AutoScroll( mouse );	SetOrigin( 0, 0 );	GetContentRect( &r );	ClipRect( &r );}/*-------------------------------***  GETTEXTHANDLE  ***--------------------------------*//*	 returns a handle to the text----------------------------------------------------------------------------------------*/Handle	ZTextWindow::GetTextHandle(){	return (Handle) TEGetText( itsText );}long	ZTextWindow::GetTextLength(){	return (*itsText)->teLength;}#pragma mark -static pascal Boolean		ztClickproc( TERec* tr ){	try	{		if ( gClickedTE )			gClickedTE->TextEditClickLoop();	}	catch(...)	{		// do NOT propagate	}		return TRUE;}