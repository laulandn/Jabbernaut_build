/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZScroller.cpp		-- a window with scrollbars******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZScroller.h"#include	"ZGrafState.h"#include	"MacZoop.h"#if _INSTALL_STD_MOUSE_TRACKING#include	"ZMouseTracker.h"#endifstatic pascal void 	ScrollBarZProc( ControlHandle theControl, short partCode );static ControlActionUPP		gScrollbarProc = NewControlActionUPP( ScrollBarZProc );static ControlHandle		gCurrentScrollbar = NULL;#ifdef _LIVE_SCROLLING#if TARGET_API_MAC_CARBONstatic pascal void	ThumbZProc( ControlHandle theControl, short partCode );static ControlActionUPP     gThumbProc = NewControlActionUPP( ThumbZProc );#elsestatic pascal void	ThumbZProc();static ThumbActionUPP		gThumbProc = NewThumbActionProc( ThumbZProc );#endif#endifCLASSCONSTRUCTOR( ZScroller );/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZScroller::ZScroller(	ZCommander* aBoss,						const short windID,						const Boolean hasHScroll,						const Boolean hasVScroll )	: ZWindow( aBoss, windID ){	classID = CLASS_ZScroller;		theHBar = NULL;	theVBar = NULL;	SetRect( &bounds, 0, 0, 0, 0 );	hScale = 10;	vScale = 10;		hasHBar = hasHScroll;	hasVBar = hasVScroll;		cInitValue = 0;	topMargin = 0;	leftMargin = 0;		dragMask = cmdKey;}ZScroller::ZScroller()	: ZWindow(){	classID = CLASS_ZScroller;		theHBar = NULL;	theVBar = NULL;	SetRect( &bounds, 0, 0, 0, 0 );	hScale = 10;	vScale = 10;		hasHBar = FALSE;	hasVBar = FALSE;		cInitValue = 0;	topMargin = 0;	leftMargin = 0;		dragMask = cmdKey;}/*--------------------------------***  INITZWINDOW  ***---------------------------------*//*	overrides the base ZWindow to initialise the scrollbars as well----------------------------------------------------------------------------------------*/void	ZScroller::InitZWindow(){	ZWindow::InitZWindow();		// do the basic initialisation		Focus();	MakeScrollbars();			// make the scrollbar controls		// in case there is special scrollbar positioning, call MoveScrollbars:		MoveScrollbars();}/*----------------------------------***  ACTIVATE  ***----------------------------------*//*	overrides ZWindow to show the scrollbars when the window state changes----------------------------------------------------------------------------------------*/void	ZScroller::Activate(){	ZWindow::Activate();		if ( theVBar )		ShowControl( theVBar );			if ( theHBar )		ShowControl( theHBar );		if ( topMargin > 0 )			DrawHeader();}/*---------------------------------***  DEACTIVATE  ***---------------------------------*//*	overrides ZWindow to hide the scrollbars when the window state changes----------------------------------------------------------------------------------------*/void	ZScroller::Deactivate(){	ZWindow::Deactivate();	if ( theVBar )		HideControl( theVBar );			if ( theHBar )		HideControl( theHBar );		if ( topMargin > 0 )		DrawHeader();}/*------------------------------------***  DRAW  ***------------------------------------*//*	overrides ZWindow to draw the content allowing for the scroll and the scrollbars themselves----------------------------------------------------------------------------------------*/void	ZScroller::Draw(){	// need to set the origin to the scroll position here		RgnHandle   temp;		SetOriginToScroll();	ExecuteModifiers( kModifierWindowDraw, NULL );	DrawContent();		FailNIL( temp = NewRgn());		Focus();	GETWINDOWVISRGN( GetMacWindow(), temp );	SetClip( temp );		UpdateControls( GetMacWindow(), temp );	DisposeRgn( temp );		// if margins set, draw them	Rect hr;		PenNormal();		if ( topMargin > 0 )	{		SetRect( &hr, 0, 0, WINDOWPORTRECT( GetMacWindow())->right, topMargin );		// clip to header rect and draw it				ClipRect ( &hr );		DrawHeader();	}		if ( leftMargin > 0 )	{		SetRect( &hr, 0, topMargin, leftMargin, WINDOWPORTRECT( GetMacWindow())->bottom );		if ( topMargin > 0 )		{			SetOrigin( 0, -topMargin );			OffsetRect( &hr, 0, -topMargin );		}		ClipRect( &hr );		DrawLeftMargin();		SetOrigin( 0, 0 );	}    ClipRect( WINDOWPORTRECT( GetMacWindow()));	DrawGrow();}/*----------------------------------***  DRAWGROW  ***----------------------------------*//*	overrides ZWindow to draw the grow box, allowing for the actual scrollbars present----------------------------------------------------------------------------------------*/void	ZScroller::DrawGrow(){	// overrides the standard method to clip down to the growbox. This prevents	// scrollbar lines being drawn when there are no scrollbars in one dimension	Rect	growBoxRect = *WINDOWPORTRECT( GetMacWindow());		if ( theVBar == NULL )		growBoxRect.top = growBoxRect.bottom - kStdScrollbarWidth;	else		growBoxRect.top = topMargin;				if ( theHBar == NULL )		growBoxRect.left = growBoxRect.right - kStdScrollbarWidth;	else		growBoxRect.left = leftMargin;				ClipRect( &growBoxRect );	DrawGrowIcon( GetMacWindow());}/*--------------------------------***  DRAWHEADER  ***----------------------------------*//*	if appearance is on, draws a default header panel, otherwise does nothing----------------------------------------------------------------------------------------*/void	ZScroller::DrawHeader(){	Rect	r = *WINDOWPORTRECT( GetMacWindow());		InsetRect( &r, -1, -1 );	r.bottom = topMargin;	ClipRect( &r );	#if APPEARANCE_MGR_AWARE || TARGET_API_MAC_CARBON	if ( gMacInfo.hasAppearanceMgr )	{		DrawThemeWindowHeader( &r, IsActive()? kThemeStateActive : kThemeStateInactive );	}	else	{#endif    EraseRect( &r );	MoveTo( 0, r.bottom - 1 );	LineTo( r.right, r.bottom - 1 );#if APPEARANCE_MGR_AWARE || TARGET_API_MAC_CARBON    }#endif}/*------------------------------***  DRAWLEFTMARGIN  ***--------------------------------*//*	if appearance is on, draws a default margin panel, otherwise does nothing----------------------------------------------------------------------------------------*/void	ZScroller::DrawLeftMargin(){	Rect	r = *WINDOWPORTRECT( GetMacWindow());		r.right = leftMargin - 1;	r.top = 0;	InsetRect( &r, -1, -1 );#if APPEARANCE_MGR_AWARE || TARGET_API_MAC_CARBON	if ( gMacInfo.hasAppearanceMgr )	{		DrawThemeWindowHeader( &r, IsActive()? kThemeStateActive : kThemeStateInactive );	}	else	{#endif        EraseRect( &r );	MoveTo( r.right - 1, r.top );	LineTo( r.right - 1, r.bottom );    #if APPEARANCE_MGR_AWARE || TARGET_API_MAC_CARBON    }#endif}/*------------------------------------***  CLICK  ***-----------------------------------*//*	overrides ZWindow to handle clicks in the scrollbars and perform the scrolling----------------------------------------------------------------------------------------*/void	ZScroller::Click( const Point mouse, const short modifiers ){	// handle a click in the content and also the scrollbar clicks		short			partCode, curValue;	ControlHandle	hitCtl;	Point			soMouse = mouse;		ExecuteModifiers( kModifierWindowClick, &soMouse );		// did the mouse go down in any part of a control (scrollbar)?		partCode = FindControl( soMouse, GetMacWindow(), &hitCtl );		if ( partCode == kControlNoPart )	{		// was the mouse in the header region or the left margin?				if ( topMargin > 0 && soMouse.v < topMargin )			ClickHeader( soMouse, modifiers );		else		{			if ( leftMargin > 0 && soMouse.h < leftMargin )			{				soMouse.v -= topMargin;				ClickLeftMargin( soMouse, modifiers );			}			else			{				// translate the point to the current scroll offset				// before passing it to ClickContent.				Rect	cr;								GetContentRect( &cr );								if ( PtInRect( soMouse, &cr ))				{					soMouse.h -= leftMargin;					soMouse.v -= topMargin;					if ( theHBar )						soMouse.h += GetControlValue( theHBar );											if ( theVBar )						soMouse.v += GetControlValue( theVBar );					// set origin & clip to visible content area					SetOriginToScroll();										if (( modifiers & dragMask ) == dragMask )						ClickScroll( soMouse );					else						ClickContent( soMouse, modifiers );				}			}		}	}	else	{		// scrollbar was hit, so track the control				gCurrentScrollbar = hitCtl;				curValue = GetControlValue( hitCtl );				if ( partCode == kControlIndicatorPart )		{			#ifdef _LIVE_SCROLLING			cInitValue = GetControlValue( hitCtl );			partCode = TrackControl( hitCtl, mouse, (ControlActionUPP) gThumbProc );			#else			partCode = TrackControl( hitCtl, mouse, NULL );			#endif		}		else			partCode = TrackControl( hitCtl, mouse, gScrollbarProc );				// if the thumb was dragged, figure out where it was dragged to and scroll		// the contents appropriately				if ( partCode == kControlIndicatorPart )		{			#ifndef _LIVE_SCROLLING			curValue -= GetControlValue( hitCtl );						if ( hitCtl == theHBar )				Scroll( curValue, 0 );			else				Scroll( 0, curValue );			#else			// after live scrolling, redraw the control so that the thumb hilite is cancelled			ClipRect( WINDOWPORTRECT( GetMacWindow()));			Draw1Control( hitCtl );			SetOriginToScroll();			#endif			PostScroll( hitCtl );					}		gCurrentScrollbar = NULL;	}}void	ZScroller::ClickContent( const Point mouse, const short modifiers ){#if _INSTALL_STD_MOUSE_TRACKING	ZMouseTracker	mt( this );		mt.Track( mouse );#endif}/*---------------------------------***  CLICKSCROLL  ***--------------------------------*//*	drags the scroller around as the mouse is dragged. Can be used to implement a "hand" tool----------------------------------------------------------------------------------------*/void	ZScroller::ClickScroll( const Point mouse ){	Point	sp, old;	long	delta;	short	ph, pv;		SetCursorShape( HAND_CURSOR_CLOSED );		sp = old = mouse;		while( WaitMouseUp())	{		GetMouse( &sp );				delta = DeltaPoint( old, sp );				if ( delta )		{			GetPosition( &ph, &pv );			ScrollTo( ph + LoWord( delta ), pv + HiWord( delta ));						old.h = sp.h + LoWord( delta );			old.v = sp.v + HiWord( delta );		}	}}/*---------------------------------***  ADJUSTCURSOR  ***-------------------------------*//*	if cmdKey is down, show hand cursor----------------------------------------------------------------------------------------*/void	ZScroller::AdjustCursor( const Point mouse, const short modifiers ){	Rect	cr;		GetContentRect( &cr );	if ( PtInRect( mouse, &cr ) && ( modifiers & dragMask ) == dragMask )		SetCursorShape( HAND_CURSOR );	else		ZWindow::AdjustCursor( mouse, modifiers );}/*-------------------------------------***  TYPE  ***-----------------------------------*//*	Handle page up and page down in scroller----------------------------------------------------------------------------------------*/void	ZScroller::Type( const char key, const short modifiers ){	// handles page up and page down keys		Focus();		switch ( key )	{		case PAGE_UP_KEY:			if ( theVBar )				ScrollHandler( theVBar, kControlPageUpPart );			break;					case PAGE_DOWN_KEY:			if ( theVBar )				ScrollHandler( theVBar, kControlPageDownPart );			break;					default:			ZWindow::Type( key, modifiers );			break;	}}/*-----------------------------------***  SETSIZE  ***----------------------------------*//*	overrides ZWindow to reposition the scrollbars when the window size is changed----------------------------------------------------------------------------------------*/void	ZScroller::SetSize( const short width, const short height ){	Focus();		// if the reDraw flag is TRUE, we supress the various updates that would otherwise	// occur since we force the entire contents to reDraw in one go at the end. If reDraw	// is false, the normal updates are generated so that the relevant parts of the	// window are refreshed after the resize.		HideScrollbars();			// need to erase the grow icon before sizing		Rect	growRect = *WINDOWPORTRECT( GetMacWindow());		growRect.left = growRect.right - kStdScrollbarWidth;	growRect.top = growRect.bottom - kStdScrollbarWidth;	EraseRect( &growRect );		ZWindow::SetSize( width, height );		MoveScrollbars();}/*------------------------------------***  ZOOM  ***------------------------------------*//*	overrides ZWindow to reposition the scrollbars when the window is zoomed----------------------------------------------------------------------------------------*/void	ZScroller::Zoom( const short partCode ){	Focus();		HideScrollbars( FALSE );		ZWindow::Zoom( partCode );	MoveScrollbars();	Draw();		MZValidWindowRect( GetMacWindow(), WINDOWPORTRECT( GetMacWindow()));}/*----------------------------------***  SETBOUNDS  ***---------------------------------*//*	sets the scrollable area to a certain size. This then recalculates the scrollbar settingsso that that area can be scrolled over. The bounds is the "real" size of a document.----------------------------------------------------------------------------------------*/void	ZScroller::SetBounds( const Rect& aBounds){	bounds = aBounds;	CalculateControlParams();		// by default, set the sizeRect for the window to the bounds	// plus the scrollbar widths, unless size rect is already bigger.		Rect	sz = sizeRect;		if ( hasHBar )		sz.bottom = MAX( sz.top, MAX( sz.bottom, ( bounds.bottom - bounds.top ) + kStdScrollbarWidth + topMargin ));			if ( hasVBar )		sz.right = MAX( sz.left, MAX( sz.right, ( bounds.right - bounds.left ) + kStdScrollbarWidth + leftMargin ));		SetSizeRect( sz );}/*----------------------------------***  SETBOUNDS  ***---------------------------------*/void	ZScroller::SetBounds( short top, short left, short bottom, short right ){	Rect	r;		SetRect( &r, left, top, right, bottom );	SetBounds( r );}/*----------------------------------***  SETBOUNDS  ***---------------------------------*/void	ZScroller::SetBounds( Point tl, Point br ){	Rect	r;		Pt2Rect( tl, br, &r );	SetBounds( r );}/*---------------------------------***  GETBOUNDS  ***----------------------------------*//*	get the scrollable area----------------------------------------------------------------------------------------*/void	ZScroller::GetBounds( Rect* aBounds ){	*aBounds = bounds;}/*--------------------------***  GETIDEALWINDOWZOOMSIZE  ***----------------------------*//*	return the optimum ideal size for a zoomed window. By default this is equal to themax size rectangle, but you can override this if you know better.----------------------------------------------------------------------------------------*/void	ZScroller::GetIdealWindowZoomSize( Rect* idealSize ){	Rect	ir;		ir = bounds;		if ( EmptyRect( &ir ))		GetContentRect( &ir );	else	{		// make sure no smaller than minimum set				ir.right = MAX( sizeRect.left, ir.right );		ir.bottom = MAX( sizeRect.top, ir.bottom );	}		ir.right  += ( hasVBar? kStdScrollbarWidth : 0 ) + leftMargin;	ir.bottom += ( hasHBar? kStdScrollbarWidth : 0 ) + topMargin;			*idealSize = ir;}/*------------------------------***  SETSCROLLAMOUNT  ***-------------------------------*//*	sets how many pixels each click on a scroll arrow shifts the content area----------------------------------------------------------------------------------------*/void	ZScroller::SetScrollAmount( const short hAmount, const short vAmount ){	hScale = hAmount;	vScale = vAmount;}/*--------------------------------***  GETPOSITION  ***---------------------------------*//*	returns the current scroll position of the window- i.e. the "frame" position relative tothe "real" document area (the bounds)----------------------------------------------------------------------------------------*/void	ZScroller::GetPosition( short* hPosition, short* vPosition ){	if ( theVBar )		*vPosition = GetControlValue( theVBar );	else		*vPosition = 0;			if ( theHBar )		*hPosition = GetControlValue( theHBar );	else		*hPosition = 0;}/*----------------------------------***  SCROLLTO  ***----------------------------------*//*	moves the content area to the scroll position passed. This immediately redraws the content----------------------------------------------------------------------------------------*/void	ZScroller::ScrollTo( const short hPosition, const short vPosition ){	short	fH, fV, pH, pV;		GetPosition( &fH, &fV );	Focus();		if ( theHBar && ( GetControlMaximum( theHBar ) > GetControlMinimum( theHBar )))		SetControlValue( theHBar, hPosition );			if ( theVBar && ( GetControlMaximum( theVBar ) > GetControlMinimum( theVBar )))		SetControlValue( theVBar, vPosition );		GetPosition( &pH, &pV );	Scroll( fH - pH, fV - pV );		SetOriginToScroll();}/*---------------------------------***  AUTOSCROLL  ***---------------------------------*//*	if the mouse point passed is outside the content rect, the view is scrolled accordingly.This can be called from within some kind of drag loop if desired.----------------------------------------------------------------------------------------*/Boolean	ZScroller::AutoScroll( Point mousePt ){	Rect			cr;	Boolean			result = FALSE;		GetContentRect( &cr );		if ( ! PtInRect( mousePt, &cr ))	{		// mouse moved outside content, so figure out which way and		// scroll it accordingly.			short dH = 0, dV = 0, maxScrollH, maxScrollV, pH, pV;				maxScrollH = hScale * 4;		maxScrollV = vScale * 4;				if ( mousePt.h > cr.right )			dH = MIN( maxScrollH, mousePt.h - cr.right );		else		{			if ( mousePt.h < cr.left )				dH = MAX( -maxScrollH, mousePt.h - cr.left );		}					if ( mousePt.v > cr.bottom )			dV = MIN( maxScrollV, mousePt.v - cr.bottom );		else		{			if ( mousePt.v < cr.top )				dV = MAX( -maxScrollV, mousePt.v - cr.top );		}				GetPosition( &pH, &pV );			ScrollTo( pH + dH, pV + dV );				GetPosition( &dH, &dV );		result = (( dH != pH ) || ( dV != pV ));	}		return result;}/*---------------------------------***  WILLSCROLL  ***---------------------------------*//*	will the scroller scroll if AutoScroll were called?----------------------------------------------------------------------------------------*/Boolean	ZScroller::WillScroll( Point mousePt ){	Rect			cr;		GetContentRect( &cr );		return ! PtInRect( mousePt, &cr );}/*-------------------------------***  GETCONTENTRECT  ***-------------------------------*//*	get the scrollable portion of the window- the bit you can see, less the scrollbars.----------------------------------------------------------------------------------------*/void	ZScroller::GetContentRect( Rect* aRect ){	// returns the scrollable part of the window. The bit without the scrollbars.	*aRect = *WINDOWPORTRECT( GetMacWindow());		if ( hasVBar )		aRect->right -= kStdScrollbarWidth;			if ( hasHBar )		aRect->bottom -= kStdScrollbarWidth;			aRect->top += topMargin;	aRect->left += leftMargin;}/*---------------------------***  CALCULATECONTROLPARAMS  ***---------------------------*//*	sets the scrollbar maximums to correctly scroll the scrollarea. This is called when thebounds or the window frame area changes.----------------------------------------------------------------------------------------*/void	ZScroller::CalculateControlParams(){	// this sets the maximums of the scrollbar to the difference between the content rect and	// the bounds.		Rect	content;	short	hMax,vMax;		SetOrigin( 0, 0 );	ClipRect( WINDOWPORTRECT( GetMacWindow()));		GetContentRect( &content );		hMax = bounds.right  - ( content.right - content.left );	vMax = bounds.bottom - ( content.bottom - content.top );		if ( hMax < 0 )		hMax = 0;			if ( vMax < 0 )		vMax = 0;	if ( theHBar )	{		SetControlMaximum( theHBar, hMax );		SetControlMinimum( theHBar, bounds.left );	}			if ( theVBar )	{		SetControlMaximum( theVBar, vMax );		SetControlMinimum( theVBar, bounds.top );	}		// if we have appearance that supports proportional thumbs, set them up. Note that	// in order to link your project with this enabled, you need "ControlsLib"	#if USE_PROPORTIONAL_SCROLLBARS || TARGET_API_MAC_CARBON		if ( gMacInfo.hasAppearanceMgr )	{		if ( theHBar )			SetControlViewSize( theHBar, content.right - content.left );					if ( theVBar )			SetControlViewSize( theVBar, content.bottom - content.top );	}	#endif}/*-------------------------------***  MAKESCROLLBARS  ***-------------------------------*//*	creates the scrollbars as part of the initialisation----------------------------------------------------------------------------------------*/void	ZScroller::MakeScrollbars(){	// create the scrollbar controls initially. This is done by calling NewControl. We	// figure out the control rects from the window portrect.		Rect	barRect;	Rect	wPortRect;		wPortRect = *WINDOWPORTRECT( GetMacWindow());		if ( hasHBar )	{		barRect = wPortRect;		barRect.right -= kStdScrollbarWidth - 1;		barRect.top = barRect.bottom - kStdScrollbarWidth - 1;		barRect.left -= 1;		OffsetRect(&barRect,0,1);				if ( floating )		{			barRect.top += 2;			barRect.right ++;		}				FailNIL( theHBar = NewControl( GetMacWindow(), &barRect, NULL, FALSE, 0, 0, 0, scrollBarProc, (long) this));			SetControlReference( theHBar, (long) this );	}		if ( hasVBar )	{		barRect = wPortRect;		barRect.bottom -= kStdScrollbarWidth - 1;		barRect.left = barRect.right - kStdScrollbarWidth - 1;		barRect.top -= 1;		OffsetRect( &barRect, 1, 0 );				if ( floating )		{			barRect.left -= 2;			barRect.bottom++;		}		FailNIL(theVBar = NewControl( GetMacWindow(), &barRect, NULL, FALSE, 0, 0, 0, scrollBarProc, (long) this));				SetControlReference( theVBar, (long) this );	}}/*-------------------------------***  MOVESCROLLBARS  ***-------------------------------*//*	moves the scrollbars to the edges of the window. Called when the window frame size changes.The scrollbars should generally be hidden before this operation. This then reshows them ifthe window is active, and recomputes the max values. If the scroll position is forced tochange as a result, this redraws the content in the correct position.----------------------------------------------------------------------------------------*/void	ZScroller::MoveScrollbars(){	// move the scrollbars after the window size has changed. They should be hidden beforehand	// and then shown afterwards. This will only show them if the window is active.		Rect		wPortRect, ctr;	short		w,h,hVal = 0,vVal = 0;	Boolean		isActive;		wPortRect = *WINDOWPORTRECT( GetMacWindow());	isActive = IsActive();		if ( theHBar )	{		hVal = GetControlValue( theHBar );		w = wPortRect.right - wPortRect.left - kStdScrollbarWidth + 2 - leftMargin;		h = kStdScrollbarWidth + 1;				if ( floating )		{			h--;			w++;		}				SizeControl( theHBar, w, h );		MoveControl( theHBar, wPortRect.left - 1 + leftMargin, wPortRect.bottom - ( floating? 14 : kStdScrollbarWidth ));				if ( isActive )			ShowControl( theHBar );				GETCONTROLRECT( theHBar, &ctr );		MZValidWindowRect( GetMacWindow(), &ctr );	}		if ( theVBar )	{		vVal = GetControlValue( theVBar );				h = wPortRect.bottom - wPortRect.top - kStdScrollbarWidth + 2 - topMargin;		w = kStdScrollbarWidth + 1;				if ( floating )		{			w--;			h++;		}				SizeControl(theVBar, w, h );		MoveControl(theVBar, wPortRect.right - ( floating? 14 : kStdScrollbarWidth ),  wPortRect.top - 1 + topMargin );				if ( isActive )			ShowControl( theVBar );				GETCONTROLRECT( theVBar, &ctr );		MZValidWindowRect( GetMacWindow(), &ctr );	}		CalculateControlParams();	// recompute maximums		if ( theVBar )		vVal -= GetControlValue( theVBar );			if ( theHBar )		hVal -= GetControlValue( theHBar );		// if the value of the control changed as a result of altering the maximum, we need to	// ensure that the contents are scrolled to the right place.			if ( hVal || vVal )	{		GetContentRect( &wPortRect );		EraseRect( &wPortRect );	}}/*-------------------------------***  HIDESCROLLBARS  ***-------------------------------*//*	hides the scrollbars prior to performing a resize, etc. If you have a special arrangementin your window (e.g. an info panel in the scrollbar area) you can override this to getinformed when you need to erase such areas, etc.----------------------------------------------------------------------------------------*/void	ZScroller::HideScrollbars( Boolean validateArea ){	Rect	ctr;		if ( theVBar )	{		HideControl( theVBar );				if ( validateArea )		{			GETCONTROLRECT( theVBar, &ctr );			MZValidWindowRect( GetMacWindow(), &ctr );		}	}			if ( theHBar )	{		HideControl( theHBar );				if ( validateArea )		{			GETCONTROLRECT( theHBar, &ctr );			MZValidWindowRect( GetMacWindow(), &ctr );		}	}}/*---------------------------------***  POSTSCROLL  ***---------------------------------*//*	You can override this if you are interested in getting called after the thumb of ascrollbar was dragged.----------------------------------------------------------------------------------------*/void	ZScroller::PostScroll( ControlHandle aCtl ){}/*------------------------------------***  SCROLL  ***----------------------------------*//*	shifts the content by dH and dV, updating the revealed area. This is called by the scrollbar callback function to implement continous scrolling.----------------------------------------------------------------------------------------*/void	ZScroller::Scroll( const short dH, const short dV ){	// scrolls the content rect. This calls scrollrect to move the majority of the	// pixels, then calls DrawContent to fill in the rest.		RgnHandle	updateRgn,saveClip;	Rect		content;	short		fH,fV;		if ( dH == 0 && dV == 0 )		return;		GetContentRect( &content );	updateRgn = NewRgn();		GetClip( saveClip = NewRgn());	ScrollRect( &content, dH, dV, updateRgn );		// need to set the origin of the view to the new location		SetOriginToScroll();		// offset the update region to allow for the origin		GetPosition( &fH, &fV );	OffsetRgn( updateRgn, fH - leftMargin, fV - topMargin );	SetClip( updateRgn );		// draw the update region		ExecuteModifiers( kModifierWindowDraw, NULL );	DrawContent();		// restore the zero origin		SetOrigin( 0, 0 );	SetClip( saveClip );		// we copy the update region to gUtilRgn, since after a scroll, someone might	// want to use this info. ZMouseTracker uses this, for example. Be careful	// not to reuse gUtilRgn until the caller is safely past the scrolling op		CopyRgn( updateRgn, gUtilRgn );		DisposeRgn( saveClip );	DisposeRgn( updateRgn );}/*-----------------------------***  SETORIGINTOSCROLL  ***------------------------------*//*	sets the origin of the grafport to the correct scroll position. This is done to ensurethat the contents get drawn in the right place regardless of where they are scrolled to.----------------------------------------------------------------------------------------*/void	ZScroller::SetOriginToScroll(){	Rect		cr;	short 		vOrigin;	short 		hOrigin;		hOrigin = -leftMargin;	vOrigin = -topMargin;	if ( theVBar )		vOrigin += GetControlValue( theVBar );			if ( theHBar )		hOrigin += GetControlValue( theHBar );			SetOrigin( hOrigin, vOrigin );		GetContentRect( &cr );	ClipRect( &cr );}/*-------------------------------***  SCROLLHANDLER  ***--------------------------------*//*	scrollbar callback function actually changes the scrollbar value as scrolling progressesand scrolls the content accordingly.----------------------------------------------------------------------------------------*/void	ZScroller::ScrollHandler( const ControlHandle aCtl, const short partCode ){	// this actually peforms the scroll of the content rect		short		curValue,page;	Boolean		hitIsVertical;	Rect		content;	RgnHandle	saveClip = NewRgn();		curValue = GetControlValue( aCtl );	GetClip( saveClip );		// are we scrolling the horizontal or the vertical bar? Find out by comparing	// the control with one of our data members		hitIsVertical = ( aCtl == theVBar );		// calculate the page amount. This is the height or width of the window less one	// scale amount.			GetContentRect( &content );		if ( hitIsVertical )		page = content.bottom - content.top - vScale;	else		page = content.right - content.left - hScale; 			switch ( partCode )	{		case kControlUpButtonPart:			SetControlValue( aCtl, GetControlValue(aCtl) - (hitIsVertical? vScale : hScale ));			break;				case kControlDownButtonPart:			SetControlValue( aCtl, GetControlValue(aCtl) + (hitIsVertical? vScale : hScale ));			break;				case kControlPageUpPart:			SetControlValue( aCtl, GetControlValue(aCtl) - page );			break;				case kControlPageDownPart:			SetControlValue( aCtl, GetControlValue(aCtl) + page );			break;				case kControlIndicatorPart:			// called when live scrolling the thumb. Here we need to calculate where the mouse			// is and figure out what the correct control value would be. If the mouse goes outside the			// control too far, the control "springs back" to its previous value, stored in cInitValue.			// we have to keep control here until the mouse is released otherwise the alterations to			// the control value cause problems for the thumb dragging default behaviour if we allow			// control back every time we are called. Yet another annoying toolbox anomaly...					#ifdef _LIVE_SCROLLING						Rect	cr, slopR;			long	cRange, cVal;			Point	curMouse, lastMouse;						GetMouse( &lastMouse );						GETCONTROLRECT( aCtl, &cr );			slopR = cr;			InsetRect( &slopR, -32, -32 );						if ( hitIsVertical )			{				cr.top += kWidthOfScrollArrow;				cr.bottom -= kWidthOfScrollArrow;			}			else			{				cr.left += kWidthOfScrollArrow;				cr.right -= kWidthOfScrollArrow;			}						cRange = GetControlMaximum( aCtl ) - GetControlMinimum( aCtl );						while ( StillDown())			{				GetMouse( &curMouse );								if ( DeltaPoint( curMouse, lastMouse ))				{					lastMouse = curMouse;										// calculate value based on mouse location										if ( PtInRect( curMouse, &slopR ))					{						if ( hitIsVertical )							cVal = ((long)( curMouse.v - cr.top ) * cRange ) / (long)( cr.bottom - cr.top );						else							cVal = ((long)( curMouse.h - cr.left ) * cRange ) / (long)( cr.right - cr.left );												SetControlValue( aCtl, GetControlMinimum( aCtl ) + cVal );					}					else						SetControlValue( aCtl, cInitValue );		// "spring" back...											curValue -= GetControlValue( aCtl );										ClipRect( &content );										if ( hitIsVertical )						Scroll( 0, curValue );					else						Scroll( curValue, 0 );											SetClip( saveClip );					curValue = GetControlValue( aCtl );				}			}						// the control manager will attempt to draw the thumb at this point. We'd rather it didn't			// since we've already moved it. Thus we empty the clip region. A hack, but it works...						SetRect( &cr, 0, 0, 0, 0 );			ClipRect( &cr );					#endif			break;	}		if ( partCode != kControlIndicatorPart )	{		curValue -= GetControlValue( aCtl );				ClipRect( &content );				if ( hitIsVertical )			Scroll( 0, curValue );		else			Scroll( curValue, 0 );					SetClip( saveClip );	}		DisposeRgn( saveClip );}/*-------------------------------***  WRITETOSTREAM  ***--------------------------------*//*write scroll window data to stream	----------------------------------------------------------------------------------------*/void	ZScroller::WriteToStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZWindow::WriteToStream( aStream );		aStream->WriteChar( hasHBar );	aStream->WriteChar( hasVBar );	aStream->WriteRect( &bounds );	aStream->WriteShort( hScale );	aStream->WriteShort( vScale );#endif}/*------------------------------***  READFROMSTREAM  ***--------------------------------*//*read scroll window data from stream	----------------------------------------------------------------------------------------*/void	ZScroller::ReadFromStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZWindow::ReadFromStream( aStream );		aStream->ReadChar((char*) &hasHBar );	aStream->ReadChar((char*) &hasVBar );	aStream->ReadRect( &bounds );	aStream->ReadShort( &hScale );	aStream->ReadShort( &vScale );		MakeScrollbars();	CalculateControlParams();#endif}void	ZScroller::ReportFields(){	ZWindow::ReportFields();	XSHOWFIELD( theHBar, ft_Handle );	XSHOWFIELD( theVBar, ft_Handle );	XSHOWFIELD( bounds, ft_Rect );	XSHOWFIELD( hScale, ft_signedshort );	XSHOWFIELD( vScale, ft_signedshort );	XSHOWFIELD( hasHBar, ft_boolean );	XSHOWFIELD( hasVBar, ft_boolean );	XSHOWFIELD( topMargin, ft_signedshort );	XSHOWFIELD( leftMargin, ft_signedshort );	XSHOWFIELD( dragMask, ft_signedshort );}#pragma mark -static pascal void	ScrollBarZProc( ControlHandle theControl, short partCode ){	// action proc for passing scrolling callbacks back to the object.		ZScroller*	aScroller = (ZScroller*) GetControlReference( theControl );		try	{		if ( aScroller )			aScroller->ScrollHandler( theControl, partCode );	}	catch( ... )	{	}}#ifdef _LIVE_SCROLLING#if TARGET_API_MAC_CARBONstatic pascal void  ThumbZProc( ControlHandle theControl, short partCode )#elsestatic pascal void	ThumbZProc()#endif{	if ( gCurrentScrollbar )	{		ZScroller*	zs = ( ZScroller*) GetControlReference( gCurrentScrollbar );				try		{			if ( zs )				zs->ScrollHandler( gCurrentScrollbar, kControlIndicatorPart );		}		catch( ... )		{		}	}}#endif