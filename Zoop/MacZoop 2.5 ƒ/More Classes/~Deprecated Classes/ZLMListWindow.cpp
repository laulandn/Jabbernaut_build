/****************************************************************************************************			ObjectMacZapp			-- a standard Mac OOP application template****			ZLMListWindow.cpp		-- a window that can display a List Manager list******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZLMListWindow.h"#include	"MacZoop.h"#include	"xDEFJump.h"#include	<LowMem.h>/*---------------------------------***  CONSTRUCTOR  ***--------------------------------*/ZLMListWindow::ZLMListWindow( ZCommander* aBoss, short windID, short rows, short cols )	: ZWindow( aBoss, windID ), MList(){	classID = CLASS_ZLMListWindow;		itsRows = rows;	itsCols = cols;	inSizeOp = FALSE;	headerHeight = 0;		cellSize.h = cellSize.v = 0;		hasVBar = ( rows > 1 );	hasHBar = ( cols > 1 );		owner = this;}/*---------------------------------***  DESTRUCTOR  ***---------------------------------*/ZLMListWindow::~ZLMListWindow(){}/*--------------------------------***  INITZWINDOW  ***---------------------------------*//*Initialise the normal stuff, then the list manager, including vector LDEF & ClickLoop	----------------------------------------------------------------------------------------*/void	ZLMListWindow::InitZWindow(){	ZWindow::InitZWindow();		Focus();		Rect	r;		GetContentRect( &r );		if ( ! hasHBar )		r.bottom -= kStdScrollbarWidth;		MLInit( &r, cellSize, itsRows, itsCols, hasVBar, hasHBar );	MLInstallCallbacks( TRUE, TRUE );		CalcBounds();}/*--------------------------------***  DRAWCONTENT  ***---------------------------------*//*Update the list----------------------------------------------------------------------------------------*/void	ZLMListWindow::DrawContent(){	if ( !inSizeOp )	{		RgnHandle   temp;				FailNIL( temp = NewRgn());		GetClip( temp );		MLUpdate( REGIONBOUNDINGBOX( temp ));		DisposeRgn( temp );				SetOrigin( 0, 0 );		PenNormal();				if ( !hasHBar )		{			ClipRect( WINDOWPORTRECT( GetMacWindow()));			MoveTo( WINDOWPORTRECT( GetMacWindow())->left, WINDOWPORTRECT( GetMacWindow())->bottom - kStdScrollbarWidth );			LineTo( WINDOWPORTRECT( GetMacWindow())->right, WINDOWPORTRECT( GetMacWindow())->bottom - kStdScrollbarWidth );		}				if ( headerHeight > 0 )		{			Rect	hr;						SetRect( &hr, 0, 0, WINDOWPORTRECT( GetMacWindow())->right, headerHeight );			ClipRect( &hr );						MoveTo( 0, headerHeight - 1 );			LineTo( hr.right, headerHeight - 1 );					DrawHeader();		}	}}/*--------------------------------***  DRAWHEADER  ***----------------------------------*//*draw the header. By default, uses appearance if available to draw a blank header----------------------------------------------------------------------------------------*/void	ZLMListWindow::DrawHeader(){#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		Rect	r = *WINDOWPORTRECT( GetMacWindow());				InsetRect( &r, -1, -1 );		r.bottom = headerHeight - 1;				DrawThemeWindowListViewHeader( &r, IsActive()? kThemeStateActive : kThemeStateInactive );	}#endif}/*-----------------------------------***  CLICK  ***------------------------------------*//*Pass on clicks to the list manager, which handles everything itself----------------------------------------------------------------------------------------*/void	ZLMListWindow::Click( const Point mouse, const short modifiers ){	MLClick( mouse, modifiers );}/*--------------------------------***  ADJUSTCURSOR  ***--------------------------------*//*set the plus cursor, if over the cells----------------------------------------------------------------------------------------*/void	ZLMListWindow::AdjustCursor( const Point mouse, const short modifiers ){	Rect	r;		GetContentRect( &r );		if ( PtInRect( mouse, &r ))		SetCursorShape( plusCursor );	else		ZWindow::AdjustCursor( mouse, modifiers );}/*------------------------------------***  TYPE  ***------------------------------------*//*handle keybord navigation----------------------------------------------------------------------------------------*/void	ZLMListWindow::Type( const char theKey, const short modifiers ){	Focus();	MLKeyNavigation( theKey, modifiers );	ZWindow::Type( theKey, modifiers );}/*----------------------------------***  ACTIVATE  ***----------------------------------*//*Activate the list, then the window----------------------------------------------------------------------------------------*/void	ZLMListWindow::Activate(){	ZWindow::Activate();		ClipRect( WINDOWPORTRECT( GetMacWindow()));	MLActivate();		if ( headerHeight > 0 )		DrawHeader();}/*--------------------------------***  DEACTIVATE  ***---------------------------------*//*Deactivate the window, then the list	----------------------------------------------------------------------------------------*/void	ZLMListWindow::Deactivate(){	ZWindow::Deactivate();	ClipRect( WINDOWPORTRECT( GetMacWindow()));	MLDeactivate();		if ( headerHeight > 0 )		DrawHeader();}/*------------------------------***  GETCONTENTRECT  ***--------------------------------*//*return the content rect, allowing for header height----------------------------------------------------------------------------------------*/void	ZLMListWindow::GetContentRect( Rect* contents ){	ZWindow::GetContentRect( contents );		contents->top += headerHeight;		if ( hasVBar )		contents->right -= kStdScrollbarWidth;			contents->bottom -= kStdScrollbarWidth;}/*--------------------------***  GETIDEALWINDOWZOOMSIZE  ***----------------------------*//*return the optimal zoom size for the window----------------------------------------------------------------------------------------*/void	ZLMListWindow::GetIdealWindowZoomSize( Rect* zr ){	CalcBounds();		*zr = bounds;		zr->bottom += headerHeight + kStdScrollbarWidth;		if ( hasVBar )		zr->right += kStdScrollbarWidth;}/*----------------------------------***  SETSIZE  ***-----------------------------------*//*set the list to the same size as the window (moves scrollbars, etc)----------------------------------------------------------------------------------------*/void	ZLMListWindow::SetSize( const short width, const short height ){	short	w, h;	Rect	cr;		Focus();	ZWindow::SetSize( width, height );		if ( lh )	{		MLDisableDrawing();				GetContentRect( &cr );				w = cr.right - cr.left;		h = cr.bottom - cr.top;				MLSetSize( w, h );		MLEnableDrawing();		Draw();	}}/*------------------------------------***  ZOOM  ***------------------------------------*//*Ditto for the zoom case----------------------------------------------------------------------------------------*/void	ZLMListWindow::Zoom( const short partCode ){	short	w, h;		ZWindow::Zoom( partCode );		w = WINDOWPORTRECT( GetMacWindow())->right - WINDOWPORTRECT( GetMacWindow())->left;	h = WINDOWPORTRECT( GetMacWindow())->bottom - WINDOWPORTRECT( GetMacWindow())->top;		if ( hasVBar || hasHBar )	{		w -= kScrollBarWidth;		h -= kScrollBarWidth;	}		MLSetSize( w, h - headerHeight );		Focus();		Draw();	MZValidWindowRect( GetMacWindow(), WINDOWPORTRECT( GetMacWindow()));}/*---------------------------------***  DRAW1CELL  ***----------------------------------*//*called from the vector LDEF to draw a cell. You can override this to create custom lists.This method does pretty much same as the standard system LDEF.	----------------------------------------------------------------------------------------*/void	ZLMListWindow::MLDraw1Cell( Rect* area, Cell aCell, Boolean hilited ){	EraseRect( area );		MList::MLDraw1Cell( area, aCell, hilited );#ifdef _DRAW_LINES_BETWEEN_CELLS	DrawCellLines( area, aCell );#endif}/*-------------------------------***  SETCELLSIZE  ***----------------------------------*//*sets the cell size for the list to that passed. Note that to be effective, this must becalled after (or inside) the constructor but before InitZWindow.----------------------------------------------------------------------------------------*/void	ZLMListWindow::SetCellSize( short aWidth, short aHeight ){	cellSize.h = aWidth;	cellSize.v = aHeight;}/*-----------------------------***  SETLMSCROLLUSAGE  ***-------------------------------*//*sets whether the list can horizontal or vertical scrollbars, or none. To be effective,this should be called after the constructor but before InitZWindow.----------------------------------------------------------------------------------------*/void	ZLMListWindow::SetLMScrollUsage( Boolean aVBar, Boolean aHBar ){	hasHBar = aHBar;	hasVBar = aVBar;}/*--------------------------------***  CALCBOUNDS  ***----------------------------------*//*calculate the bounds rect----------------------------------------------------------------------------------------*/void	ZLMListWindow::CalcBounds()	{	// sets the bounds of the window to the size of the list.		Rect	rb;	short	cw, ch;		cw = cellSize.h;	ch = cellSize.v;		if ( cw <= 0 )		cw = (*lh)->cellSize.h;			if ( ch <= 0 )		ch = (*lh)->cellSize.v;		SetRect( &rb, 0, 0,				cw * (*lh)->dataBounds.right,				ch * (*lh)->dataBounds.bottom );		rb.right  = MAX( rb.right,  cw );	rb.bottom = MAX( rb.bottom, ch );					bounds = rb;		rb.bottom += kScrollBarWidth + headerHeight;	rb.right += kScrollBarWidth;	rb.top = ch;	rb.left = cw;		SetSizeRect( rb );}/*-------------------------------***  DRAWCELLLINES  ***--------------------------------*//*draw the grey lines between cells, if required----------------------------------------------------------------------------------------*/void	ZLMListWindow::DrawCellLines( Rect* area, Cell aCell ){	if ( IsColourPort( WINDOWGRAFPTR( GetMacWindow())))		RGBForeColor( &gLightGray );	else		PenPat( QDGRAYPATTERN );		PenSize( 1, 1 );	PenMode( patCopy );		if ( aCell.v < ((*lh)->dataBounds.bottom - 1 ))	{		MoveTo( area->left, area->top + (*lh)->cellSize.v - 1 );		LineTo( area->right, area->top + (*lh)->cellSize.v - 1 );	}		if ( itsCols > 1 && aCell.h < ((*lh)->dataBounds.right - 1 ))	{		MoveTo( area->left + (*lh)->cellSize.h - 1, area->top );		LineTo( area->left + (*lh)->cellSize.h - 1, area->bottom );	}		ForeColor( blackColor );	PenNormal();}void	ZLMListWindow::ReportFields(){	ZWindow::ReportFields();	MList::ReportFields();	XSHOWFIELD( itsRows, ft_signedshort );	XSHOWFIELD( itsCols, ft_signedshort );	XSHOWFIELD( cellSize, ft_Point );	XSHOWFIELD( inSizeOp, ft_boolean );	XSHOWFIELD( hasVBar, ft_boolean );	XSHOWFIELD( hasHBar, ft_boolean );	XSHOWFIELD( bounds, ft_Rect );	XSHOWFIELD( headerHeight, ft_signedshort );}