/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZDialog.cpp			-- a dialog box******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZDialog.h"#include	"ZDialogItem.h"#include	"MacZoop.h"#include	"ZGrafState.h"#include	<MacWindows.h>#include	<Dialogs.h>#if _DIALOG_EXTENSIONS#include    "ZCustomDItemMaker.h"#endif#ifndef DRAW_MODELESS_FRAME#define DRAW_MODELESS_FRAME  1#endifCLASSCONSTRUCTOR( ZDialog );/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZDialog::ZDialog( ZCommander* aBoss, const short dialogID )	: ZWindow( aBoss, dialogID ){	classID = CLASS_ZDialog;	macDialog = NULL;	isModal = FALSE;	// set up by MakeMacWindow	isInline = FALSE;	// set up by RunModal.	drawReverse = TRUE;	switchItem = 0;	signalDismiss = 0;	exitItem = 0;	baseItems = 0;	ditlID = dialogID;	defaultItem = ok;	escapeItem = cancel;	makers = NULL;	dragTarget = NULL;	FailNIL( itsItems = new ZDialogItemList());		focusItem = NULL;}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZDialog::ZDialog()	: ZWindow(){	classID = CLASS_ZDialog;	macDialog = NULL;	isModal = FALSE;	// set up by MakeMacWindow	isInline = FALSE;	// set up by RunModal.	drawReverse = TRUE;	switchItem = 0;	signalDismiss = 0;	exitItem = 0;	baseItems = 0;	ditlID = 0;	defaultItem = ok;	escapeItem = cancel;	makers = NULL;	dragTarget = NULL;		FailNIL( itsItems = new ZDialogItemList());		focusItem = NULL;}/*---------------------------------***  DESTRUCTOR  ***----------------------------------*/ZDialog::~ZDialog(){	if ( itsItems )	{		itsItems->DisposeAll();		ForgetObject( itsItems );	}	if ( makers )	{		makers->DisposeAll();		ForgetObject( makers );	}	if ( GetMacDialog() != NULL )	{		// save off position in prefs if this feature enabled. No point doing it if the		// dialog is not a moveable type:			#if _AUTO_WPOS_FOR_DIALOGS				short wVar = GetWVariant( GetMacWindow());				if ( !isModal || wVar == movableDBoxProc )			SavePosition();			#endif				if ( MacHasDM())			RemoveDragHandlers();		DisposeDialog( GetMacDialog());	}		macDialog = NULL;	SetMacWindow( NULL );}/*-------------------------------***  INITZWINDOW  ***----------------------------------*//*	construct the dialog and set it up----------------------------------------------------------------------------------------*/void	ZDialog::InitZWindow(){	MakeMacWindow( windID );	// make the dialog box, and set modal flag	if ( MacHasDM())		InstallDragHandlers();			InitSizeFromResource( kDialogSizeLimitResType );	baseItems = CountDITL( GetMacDialog());	Focus();					// make sure dialog is focussed for setup call    AttachMakers();	BuildDialogObjects( 1, ditlID );	SetUp();					// call user's set up method, may change defaults		// if for some reason no items were loaded, set default and escape to 0	if ( defaultItem > itsItems->CountItems())		defaultItem = 0;			if ( escapeItem > itsItems->CountItems())		escapeItem = 0;	// if a default item is present, inform the object so it draws itself correctly		if ( defaultItem > 0 )		GetItemObject( defaultItem )->SetDefaultItem( TRUE );#if _ALL_FLOATERS_ACTIVE	if ( !Floats())	#endif			DisableItem( 0 );			// initially disable everything- will be reset correctly by									// initial activate event									// tell the window manager of our existence. This must be done after the	// full build of the mac window since the window manager needs to get	// information from it. Thus if you override this method, make sure you	// make the same call.		gWindowManager->AddWindow( this );	ResetAlertStage();		// restore position if this feature enabled:	// n.b. does nothing at all if no stored position or no file available, so safe to call	// regardless.	#if _AUTO_WPOS_FOR_DIALOGS	RestorePosition();#endif		GetBounds( &oldBounds );}/*------------------------------***  MAKEMACWINDOW  ***---------------------------------*//*	make a dialog. This tries to construct a dialog using a 'DLOG' resource with the IDpassed. The refcon is set to this object, so do not use it. Sets the modal flag too.----------------------------------------------------------------------------------------*/void	ZDialog::MakeMacWindow( const short dialogID ){	// create the macintosh dialog:		DialogTHndl	dtH = (DialogTHndl) GetResource( 'DLOG', windID );		if ( dtH )	{    	HNoPurge((Handle) dtH );		ditlID = (*dtH)->itemsID;    	    	    	FailNILRes( macDialog = GetNewDialog( dialogID, NULL, (WindowPtr) -1L ));    	    	// deliberatly mangle the pointers so that any casting or direct access bugs show    	// up in classic rather than waiting for OS X to manifest themselves    	    	SetMacWindow((WindowPtr)(((unsigned long) DIALOGWINDOW( macDialog )) ^ WIN_POINTER_MANGLE ));    	macDialog = (DialogPtr)(((unsigned long) macDialog ) ^ DLG_POINTER_MANGLE );    	    	// set our refcon to point to the object. DO NOT USE THE REFCON!    	// n.b. to avoid difficulties with the Mac toolbox assuming stuff if we leave the    	// windowKind set to dialogKind, we change it to our private kind. This effectively    	// allows us complete control over the items in a dialog without interference. The rest    	// of MacZoop is naturally aware of this.    	    	SetWindowKind( GetMacWindow(), IS_ZWINDOW_KIND );    	SetWRefCon( GetMacWindow(), (long) this );    	    	// see whether this is modal or not by examining the style of the window. This    	// flag affects the way commands are processed.    	    	short wVar = GetWVariant( GetMacWindow() );    	    	isModal = ( wVar == dBoxProc 	||    				wVar == plainDBox 	||    				wVar == altDBoxProc ||    				wVar == movableDBoxProc );    			fResizeable = (( wVar == documentProc ) || ( wVar == zoomDocProc ));    	// note that dialogs should normally not set the <isFloating> member, since the window    	// manager knows that dialogs should go in front of floaters anyway. If you use a dialog as    	// a floating window, note that it won't get the menubar and keyboard focus, so you should    	// avoid the use of editable text fields, etc. Though no-one's enforcing any of this, it    	// is bad human interface to have type-in fields in floating windows. Take note, Adobe!    	    	if ( IsColourPort( WINDOWGRAFPTR( GetMacWindow())))    	{    		SETPORTTODIALOG( GetMacDialog());    		    		RGBColor	temp;    		    		GetBackColor( &temp );    		SetBackColour( &temp );    	}	    			// read the auto positioning variable too. This is the last item in the template,		// and follows the title string (variable offset)				unsigned short pv = *(unsigned short*)((Ptr)( &(*dtH)->title ) + (*dtH)->title[0] + 1 + ((*dtH)->title[0] + 1 ) %2 );				// set up autoPos to equivalent behaviour				switch ( pv )		{			case kWindowCenterMainScreen:				autoPos = kCentreOnScreen;				break;							case kWindowAlertPositionMainScreen:				autoPos = kAlertPositionOnScreen;				break;							case kWindowCenterParentWindow:				autoPos = kCentreOnParent;				break;							case kWindowAlertPositionParentWindow:				autoPos = kAlertPositionOnParent;				break;							case kWindowStaggerParentWindow:				autoPos = kStaggerOnParent;				break;						default:			case kWindowDefaultPosition:				autoPos = kNoPosition;				break;		}				// the system floater has a proc of 124. The commonly used "Infinity" windoid		// has a proc of 128.				short	pID = (*dtH)->procID / 16;				// with appearance manager, the WDEF IDs for floating windows are 66 & 67				#if APPEARANCE_MGR_AWARE				if ( gMacInfo.hasAppearanceMgr )			floating |= ( 	pID == kWindowUtilityDefProcResID ||							pID == kWindowUtilitySideTitleDefProcResID );				#endif				floating |= (	pID == kFloatingWindowDefinition ||						pID == kInfinityWindoidDefinition );				HPurge((Handle) dtH );		ReleaseResource((Handle) dtH );	}		if ( floating )		isModal = FALSE;	SetFrame( WINDOWPORTRECT( GetMacWindow()));}/*------------------------------***  MAKEMACWINDOW  ***---------------------------------*/void	ZDialog::MakeMacWindow( Rect* aRect, Str255 title, Boolean visible, short varCode, Boolean hasCloseBox, void* userData ){	if ( gMacInfo.supportsColour )		FailNIL( macDialog = NewColorDialog( NULL, aRect, title, visible, varCode, (WindowPtr) -1L, hasCloseBox, 0, (Handle) userData ));	else		FailNIL( macDialog = NewDialog( NULL, aRect, title, visible, varCode, (WindowPtr) -1L, hasCloseBox, 0, (Handle) userData ));    	SetMacWindow((WindowPtr)(((unsigned long) DIALOGWINDOW( macDialog )) ^ WIN_POINTER_MANGLE ));	    	macDialog = (DialogPtr)(((unsigned long) macDialog ) ^ DLG_POINTER_MANGLE );	SetWindowKind( GetMacWindow(), IS_ZWINDOW_KIND );	SetWRefCon( GetMacWindow(), (long) this );	CopyPString( title, macFile.name );	isModal = ( varCode == dBoxProc 	||				varCode == plainDBox 	||				varCode == altDBoxProc  ||				varCode == movableDBoxProc );}/*-----------------------------------***  DRAW  ***-------------------------------------*//*	redraws the dialog items, responding to update, etc.----------------------------------------------------------------------------------------*/void	ZDialog::Draw(){	RgnHandle		temp, wVis;	Rect			ibr;	ZDialogItem*	di;	short           i, m;		ClipRect( WINDOWPORTRECT( GetMacWindow()));		FailNIL( temp = NewRgn());	FailNIL( wVis = NewRgn());		m = itsItems->CountItems();		for( i = 1; i <= m; i++ )	{		if ( drawReverse )		    di = GetItemObject( m - i + 1 );		else		    di = GetItemObject( i );				di->GetBounds( &ibr );					if ( di->IsDefaultItem() || di == focusItem )			InsetRect( &ibr, -4, -4 );				if ( di->GetType() & editText )			InsetRect( &ibr, -4, -4 );				RectRgn( temp, &ibr );		GETWINDOWVISRGN( GetMacWindow(), wVis );		SectRgn( temp, wVis, temp );				if ( ! EmptyRgn( temp ))		{			if ( di->ExecuteModifiers( kModifierItemDraw, NULL ))				di->Draw();		}	}		DisposeRgn( temp );	DisposeRgn( wVis );	// if appearance on and we are modeless, draw 3D inset frame	#if APPEARANCE_MGR_AWARE && DRAW_MODELESS_FRAME	if ( gMacInfo.hasAppearanceMgr && !isModal)	{		ibr = *WINDOWPORTRECT( GetMacWindow());		InsetRect( &ibr, -1, -1 );		DrawThemeModelessDialogFrame( &ibr, IsActive()? kThemeStateActive : kThemeStateInactive );	}#endif}/*-------------------------------***  DRAWONEITEM  ***----------------------------------*//*	redraws a single item immediately. Call if something needs a quick update in the dialog.----------------------------------------------------------------------------------------*/void	ZDialog::DrawOneItem( const short item ){	ZDialogItem*	di;		Focus();	ClipRect( WINDOWPORTRECT( GetMacWindow() ));		ZGrafState	gs;		di =  GetItemObject( item );		if ( di->ExecuteModifiers( kModifierItemDraw, NULL ))		di->Draw();}/*------------------------------***  DRAWUSERITEM  ***----------------------------------*//*	draws a standard user item. By default this is a grey box.----------------------------------------------------------------------------------------*/void	ZDialog::DrawUserItem( const short item, Rect* bounds, Boolean state ){	// draw default user item ( gray box )		PenNormal();		// remove lower-numbered items from clip region		ClipOutItemsBelow( item );		// if item is only 1-pixel thick, draw an etched line instead		Boolean isLine = (( bounds->bottom - bounds->top ) < 2 ) ||					 (( bounds->right - bounds->left ) < 2 );	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		if ( isLine )			DrawThemeSeparator( bounds, state? kThemeStateActive: kThemeStateInactive );		else			DrawThemePrimaryGroup( bounds, state? kThemeStateActive: kThemeStateInactive );	}	else	{#endif	if ( IsColourPort( WINDOWGRAFPTR( GetMacWindow() )))		EtchGrayRect( bounds );	else	{		PenPat( QDGRAYPATTERN );		FrameRect( bounds );	}#if APPEARANCE_MGR_AWARE	}#endif}/*-----------------------------***  SETDIALOGBASEFONT  ***------------------------------*//*	sets the default font for the dialog if 12 point chicago is not your bag. This affectsonly static and editable text items. This changes all such items in the dialog- ifyou need to set it on an individual item basis, use the 'ictb' mechanism. Call this onceafter InitZWindow(), but before dialog is selected.----------------------------------------------------------------------------------------*/void	ZDialog::SetDialogBaseFont( short fontID, short fontSize, short fontStyle ){	Focus();	TextFont( fontID );	TextFace( fontStyle );	TextSize( fontSize );		TEHandle	th;		// set the same parameters in the textEdit record		th = DIALOGTEXTEDITRECORD( GetMacDialog());		if ( th )	{		(*th)->txFont = fontID;		(*th)->txFace = fontStyle;		(*th)->txSize = fontSize;			FontInfo	fi;				GetFontInfo( &fi );				(*th)->fontAscent = fi.ascent;		(*th)->lineHeight = fi.ascent + fi.descent + fi.leading;				TECalText( th );	}}/*-----------------------------------***  CLICK  ***------------------------------------*//*	handle clicks in the dialog, This determines the item and calls its Click method----------------------------------------------------------------------------------------*/void	ZDialog::Click( const Point mouse, const short modifiers ){	// which item was hit?		ZDialogItem*	di;	Point			mpt = mouse;		ClipRect( WINDOWPORTRECT( GetMacWindow() ));	short	item = FindItem( mouse );		if ( item > 0 )	{		di = GetItemObject( item );				if ( di->ExecuteModifiers( kModifierItemClicked, &mpt ))			di->Click( mpt, modifiers );	}			// see if any user action resulted in a request to dismiss the dialog. This is quite common-	// e.g. a double-click in a list, etc. To close safely, we need to action this right at the end	// of processing a click. To work this, set signalDismiss to ok or cancel in response to your	// action- do not call Close directly or things may not work as you expect, or worse, crash.		if (( item != ok ) && ( item != cancel ) && ( signalDismiss > 0 ))		FakeClick( signalDismiss );}/*------------------------------***  CLICKINSAMEPLACE  ***------------------------------*//*	resolve double-click----------------------------------------------------------------------------------------*/Boolean	ZDialog::ClickInSamePlace( const Point a, const Point b ){	short itemA, itemB;		itemA = FindItem( a );	itemB = FindItem( b );		if (( itemA == itemB ) && itemA != 0 )	{		return GetItemObject( itemA )->ClickInSamePlace( a, b );	}	else		return FALSE;	}/*---------------------------------***  ACTIVATE  ***-----------------------------------*//*	enables all items and rehilites the focused item----------------------------------------------------------------------------------------*/void	ZDialog::Activate(){	ZWindow::Activate();		Focus();	#if _ALL_FLOATERS_ACTIVE	if ( Floats())	{		if ( focusItem && focusItem->IsEnabled())			focusItem->BecomeHandler( TRUE );	}	else	#endif			EnableItem( 0 );#if APPEARANCE_MGR_AWARE && DRAW_MODELESS_FRAME	if ( gMacInfo.hasAppearanceMgr && !isModal )	{		Rect	ibr;				ibr = *WINDOWPORTRECT( GetMacWindow() );		InsetRect( &ibr, -1, -1 );		DrawThemeModelessDialogFrame( &ibr, kThemeStateActive );	}#endif}/*--------------------------------***  DEACTIVATE  ***----------------------------------*//*	disables all items and unhilites the focused item----------------------------------------------------------------------------------------*/void	ZDialog::Deactivate(){	Focus();	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr && !isModal)	{		Rect	ibr;				ibr = *WINDOWPORTRECT( GetMacWindow() );		InsetRect( &ibr, -1, -1 );		DrawThemeModelessDialogFrame( &ibr, kThemeStateInactive );	}#endif	#if _ALL_FLOATERS_ACTIVE	if ( !Floats())	#endif			DisableItem( 0 );	ZWindow::Deactivate();}/*----------------------------------***  SETSIZE  ***-----------------------------------*//*	window resizing- record old size for benefit of items----------------------------------------------------------------------------------------*/void	ZDialog::SetSize( const short width, const short height ){	GetBounds( &oldBounds );	ZWindow::SetSize( width, height );}/*-----------------------------------***  ZOOM  ***-------------------------------------*//*	window zooming- record old size for benefit of items----------------------------------------------------------------------------------------*/void	ZDialog::Zoom( const short partCode ){	GetBounds( &oldBounds );	ZWindow::Zoom( partCode );}/*-------------------------------***  GETMACWINDOW  ***---------------------------------*//*	return the underlying mac toolbox window of the dialog----------------------------------------------------------------------------------------*/WindowPtr	ZDialog::GetMacWindow(){    // NOTE: in Carbon, this returns the WINDOW of the dialog. In classic, this is    // the same pointer. In Carbon/ OS X, this may NOT be the same. Thus be careful    // to use the right call to get the intended value. (ZDialog now adds GetMacDialog    // to get the actual DialogPtr under Carbon        WindowPtr	wp = ZWindow::GetMacWindow();        if ( wp == NULL )    	return NULL;    else    	return (WindowPtr)(((unsigned long) wp ) ^ WIN_POINTER_MANGLE );}	/*-------------------------------***  GETMACDIALOG  ***---------------------------------*//*	return the underlying mac toolbox dialog ref----------------------------------------------------------------------------------------*/DialogPtr	ZDialog::GetMacDialog(){    // NOTE: in Carbon, this returns the ACTUAL DIALOG. In classic, this is    // the same pointer as the window. In Carbon/ OS X, this may NOT be the same. Thus be careful    // to use the right call to get the intended value.    return (DialogPtr)(((unsigned long) macDialog ) ^ DLG_POINTER_MANGLE );}	/*--------------------------------***  GETHANDLER  ***----------------------------------*//*	return focussed item to start command chain----------------------------------------------------------------------------------------*/ZCommander*		ZDialog::GetHandler(){	if ( focusItem == NULL )		return this;	else		return focusItem->GetHandler();}/*-----------------------------------***  TYPE  ***-------------------------------------*//*	handle navigation by keyboard, and map return/enter to OK button, etc.----------------------------------------------------------------------------------------*/void	ZDialog::Type( const char theKey, const short modifiers ){	Boolean			notAutoKey;		notAutoKey = ( modifiers & kFromAutoKeyEvent ) == 0;		Focus();	ClipRect( WINDOWPORTRECT( GetMacWindow() ));	switch ( theKey )				// tab	{		case TAB_KEY:						if ( notAutoKey )			{				Boolean		reverseTab;								reverseTab = ( modifiers & shiftKey ) == shiftKey;								// find the next edit field item that can be set								if ( reverseTab )					SelectPreviousFocus();				else					SelectNextFocus();			}					break;		case RETURN_KEY:			// return		case ENTER_KEY:				// enter			if ( defaultItem > 0 && notAutoKey )			{				ASSERT( "Bad default ID in Type()", defaultItem <= itsItems->CountItems(), defaultItem )								FakeClick( defaultItem );			}				break;					case '.':			if (( modifiers & cmdKey ) == 0 )				break;							// fall through to cancel case for cmd-period			case ESCAPE_KEY:			// escape			if ( escapeItem > 0 && notAutoKey )			{				ASSERT( "Bad escape ID in Type()", escapeItem <= itsItems->CountItems(), escapeItem )								FakeClick( escapeItem );			}				break;					default:			break;	}}/*----------------------------------***  DOCUT  ***-------------------------------------*//*	handle edit command cut.----------------------------------------------------------------------------------------*/void	ZDialog::DoCut(){	gClipboard->Clear();	DialogCut( GetMacDialog());		FailOSErr( TEToScrap());}/*----------------------------------***  DOCOPY  ***------------------------------------*//*	handle edit command copy.----------------------------------------------------------------------------------------*/void	ZDialog::DoCopy(){	gClipboard->Clear();	DialogCopy( GetMacDialog());		FailOSErr( TEToScrap());}/*---------------------------------***  DOPASTE  ***------------------------------------*//*	handle edit command paste.----------------------------------------------------------------------------------------*/void	ZDialog::DoPaste(){	if ( focusItem )	{		if ( PasteDataIsLegal( focusItem->GetID()))		{			FailOSErr( TEFromScrap());			DialogPaste( GetMacDialog());		}		else			SysBeep( 1 );	}}/*---------------------------------***  DOCLEAR  ***------------------------------------*//*	handle edit command clear.----------------------------------------------------------------------------------------*/void	ZDialog::DoClear(){	DialogDelete( GetMacDialog());}/*-------------------------------***  UPDATEMENUS  ***----------------------------------*//*	block menu updates if a modal dialog----------------------------------------------------------------------------------------*/void	ZDialog::UpdateMenus(){	if ( !isModal )		ZWindow::UpdateMenus();}/*----------------------------------***  SETUP  ***-------------------------------------*//*	called when the dialog is built so you can initialise your dialog items. For user items,override DrawUserItem rather than installing your own procs here. By default, this hilitesthe text of the first edit field it finds.----------------------------------------------------------------------------------------*/void	ZDialog::SetUp(){	// override this method to initialise your controls, etc to the desired	// state for your dialog, but call the inherited method as well.		long	id = ((long) windID << 16 ) + windID;		SendMessage( kMsgDialogSetUp, &id );}/*-----------------------------***  ADJUSTCURSOR  ***-----------------------------------*//*	overrides ZWindow to set the cursor to an i-beam over edit fields.----------------------------------------------------------------------------------------*/void	ZDialog::AdjustCursor( const Point mouse, const short modifiers ){	short		item;		item = FindItem( mouse );		if ( item > 0 )		GetItemObject( item )->AdjustCursor( mouse, modifiers );	else		ZWindow::AdjustCursor( mouse, modifiers );}/*----------------------------***  GETBALL0ONHELP  ***----------------------------------*//*	gets the balloon help for the item under the cursor----------------------------------------------------------------------------------------*/Boolean	ZDialog::GetBalloonHelp( const Point mouse,								 Rect* br,								 Point* tip,								 HMMessageRecord* hm ){	short			item, curRes;	Boolean         result;		curRes = CurResFile();	UseResFile( gApplication->GetAppRefnum());	Focus();		item = FindItem( mouse );		if ( item > 0 )		result = GetItemObject( item )->GetBalloonHelp( mouse, br, tip, hm );	else		result = ZWindow::GetBalloonHelp( mouse, br, tip, hm );			UseResFile( curRes );	return result;}/*--------------------------------***  PLACE  ***---------------------------------------*//*	place the dialog according to autoPos parameter----------------------------------------------------------------------------------------*/void	ZDialog::Place(){	if ( autoPos == kNoPosition )	#if _AUTO_WPOS_FOR_DIALOGS		RestorePosition();	#else		ZWindow::Place();	#endif	else	{		ZWindow* parent = dynamic_cast<ZWindow*>( itsBoss );				if ( parent == NULL )			parent = gApplication->GetFrontWindow();				PlaceRelative( parent, autoPos );	}}/*--------------------------------***  CLICKITEM  ***-----------------------------------*//*	an enabled item was clicked (or an enabled field was typed in) This handles check boxesby toggling their state, and OK and Cancel buttons in modal dialogs. It also now handlesgroups of radio buttons. Override to handle clicks in other dialog items, but call theinherited method to deal with these standard items.----------------------------------------------------------------------------------------*/void	ZDialog::ClickItem( const short theItem ){	short			itemType;	GrafPtr			savePort;	ZDialogItem*	di;		GetPort( &savePort );	SETPORTTODIALOG( GetMacDialog());		// get info about the item clicked		di = GetItemObject( theItem );		if ( ExecuteModifiers( kModifierItemPostClick, di ))	{		itemType = di->GetType();				// if a checkbox, toggle its state				if ( itemType == ( ctrlItem + chkCtrl ))			di->SetValue((long) ! di->GetValue());					// if the item is a radio button, handle it if it is part of a group				if ( itemType == ( ctrlItem + radCtrl ))			HandleRButtonGroupClick( theItem );				    // if the item is the autoswitching master item, perform the autoswitching	    	    if ( switchItem > 0 && switchItem == theItem )	        HandleAutoSwitching( GetValue( theItem ));				// if baloon help is displaying, force it to refetch the help message				BalloonHelpRefresh();					// if it is the OK or cancel button, dismiss the dialog if a modal dialog.				if ((( theItem == defaultItem ) || ( theItem == escapeItem )) &&			( itemType & ctrlItem ) &&			isModal )		{			exitItem = theItem;						if ( theItem == defaultItem )			{				Close( kRunning );				// verifies dialog				return;			}			else			{				SetDirty( FALSE );				// suppress save check				SendMessage( kMsgDialogCancelled, &windID );								if ( isInline )					Hide();				else					ZWindow::Close( kRunning );		// does not verify dialog									return;			}		}		else		{			// for other items, send a message about the click. This allows a dialog's boss			// to implement dialog features without needing to override the dialog itself			// for simpler types of dialog. <msgData> is dialog ID in high word, and item			// ID in low word of pointer to long.						long msg = ((long) windID << 16 ) | theItem;			SendMessage( kMsgDialogItemClicked, &msg );		}	}	SetPort( savePort );}/*---------------------------------***  RUNMODAL  ***-----------------------------------*//*	Handle events until OK/Cancel is clicked. Do not abuse this method! Normally you shouldlet dialogs work modelessly (even if modal) and not create dialogs "inline". For somesimple cases it is convenient to create inline dialogs, in which case you can call this toimplement a holding loop which returns TRUE for OK, FALSE for Cancel. This will returnimmediately for non-modal dialogs----------------------------------------------------------------------------------------*/Boolean	ZDialog::RunModal(){	Boolean		okClicked = FALSE;	ZDialog*	topDialog;		if ( GetMacWindow() == NULL )		InitZWindow();		if ( isModal )	{		// make sure we are activated and shown				if ( ! IsVisible())			Select();				isInline = TRUE;	// caller is responsible for deleting this				// The recommended way to do simple dialogs is to wait for the kMsgDialogSuccessfullyClosed		// message in the dialog's boss and respond there, or else subclass ZDialog to implement the		// relevant actions/processing there. The inline technique should only be considered for		// the simplest of dialogs, e.g. those that request a user parameter to a following function.				do		{			gApplication->Process1Event();			topDialog = (ZDialog*) gApplication->GetFrontWindow();		}		while(( topDialog == this ) && IsVisible());				okClicked = ( exitItem == defaultItem );	}		return okClicked;}/*-------------------------------***  DISMISSMODAL  ***---------------------------------*//*Force a modal dialog session to end by passing it a dismissal code (either "ok" or"cancel". This calls ClickItem on that item, hence triggering the dialog dismissal. Thisis very rarely needed- you are discouraged from using this to get rid of dialogs- normallythey will look after themselves without explicit coding for dismissal.	----------------------------------------------------------------------------------------*/void	ZDialog::DismissModal( const short itemDismiss ){	if ( isModal )		FakeClick( itemDismiss );}/*-------------------------------***  CLOSEDIALOG  ***----------------------------------*//*	the dialog is about to close. You can abort the close by returning FALSE. Override toread the values of controls, other items, etc.----------------------------------------------------------------------------------------*/Boolean	ZDialog::CloseDialog(){	// the dialog is about to close. Return FALSE if you can't close (Verify fields?)	// we check if there are any fields that have limits set and are some kind of	// numeric field. If the limits have been exceeded by the user's entry, we	// hilite the offending field, make a noise and prevent the dialog from closing.		return ValidateFields();}/*----------------------------------***  CLOSE  ***-------------------------------------*//*	overrides ZWindow so that closing the dialog correctly maintains the chain of command.This is called when a modeless dialog is closed from the Close menu, or go-away box, orwhen OK was clicked in a modal dialog. ----------------------------------------------------------------------------------------*/Boolean	ZDialog::Close( const short phase ){	// called for a modeless dialog. This calls CloseDialog. If TRUE, the object is	// deleted. This overrides the similar method in ZWindow.		Boolean	wasClosed = CloseDialog();		if ( wasClosed )	{		long	dFudge = ((long) windID << 16 ) + windID;				SendMessage( kMsgDialogSuccessfullyClosed, &dFudge );				// if the dialog is inline, the caller is responsible for deleting it. In which case		// we simply hide ourselves and will get deleted later.				if ( isInline )			Hide();		else			wasClosed = ZWindow::Close( phase );	}	return wasClosed;}/*------------------------------***  VALIDATEFIELDS  ***--------------------------------*//*	For an edit field item, this validates that the contents are acceptable within anyconstraints that may be set for the field, returning TRUE if OK, FALSE otherwise. Forother types of item, this always returns TRUE. Called by CloseDialog(), but you cancall it at any time you need to check the bounds of a field. If <showAlert> is TRUE,this also reports the bounds limits to the user if validation fails.----------------------------------------------------------------------------------------*/Boolean	ZDialog::ValidateFields( Boolean showAlert ){	Boolean			result = TRUE;	ZDialogItem*	di;		for( short i = 1; i <= itsItems->CountItems(); i++ )	{		di = GetItemObject( i );				if ( ! di->Validate( showAlert ))		{			result = FALSE;			break;		}	}		return result;}/*------------------------------***  WINDOWRESIZED  ***---------------------------------*//*	this window changed size, so inform items in case they want to move around.----------------------------------------------------------------------------------------*/void	ZDialog::WindowResized(){	short	i, m = itsItems->CountItems();	Rect	r;		Focus();	GetBounds( &r );	for ( i = 1; i <= m; i++ )		GetItemObject( i )->ParentResized( &oldBounds, &r );}/*------------------------------***  SETITEMSIZING  ***---------------------------------*//*	set automatic resizing for a dialog item----------------------------------------------------------------------------------------*/void	ZDialog::SetItemSizing( const short item, unsigned char sizing ){	GetItemObject( item )->SetAutoSizing( sizing );}/*---------------------------------***  FAKECLICK  ***----------------------------------*//*	fake a click on an BUTTON item (other kinds of items do nothing).----------------------------------------------------------------------------------------*/void	ZDialog::FakeClick( const short item ){	ZDialogItem*	di;	GrafPtr			savePort;	Rect			iBox;		di = GetItemObject( item );		if ( di && di->IsEnabled())	{		if ( di->GetType() & ctrlItem )		{			GetItemBounds( item, &iBox );						GetPort( &savePort );			SETPORTTODIALOG( GetMacDialog());						di->DoHilightSelection( TRUE );			MZDelay( 8 );			di->DoHilightSelection( FALSE );						SetLocalZoomSource( &iBox );			SetPort( savePort );		}		ClickItem( item );	}}/*--------------------------------***  GETITEMTYPE  ***---------------------------------*//*	return the type of the item with ID passed.----------------------------------------------------------------------------------------*/short	ZDialog::GetItemType( const short item ){	ASSERT( "Bad item ID in GetItemType", item <= itsItems->CountItems(), item )	return GetItemObject( item )->GetType();}/*--------------------------------***  SETVALUE  ***------------------------------------*//*	sets the value of the dialog item to <value>. This determines the type of the item anddoes the obvious thing.  Various data types are accepted by overloading the parameters,though for controls, the value must be between -32767 and +32768 or an exception is thrown.----------------------------------------------------------------------------------------*/void	ZDialog::SetValue( const short item, const long value ){	ASSERT( "Bad item ID in SetValue( long )", item <= itsItems->CountItems(), item )	GetItemObject( item )->SetValue( value );}/*--------------------------------***  SETVALUE  ***------------------------------------*/void	ZDialog::SetValue( const short item, const Str255 value ){	ASSERT( "Bad item ID in SetValue( Str255 )", item <= itsItems->CountItems(), item )	GetItemObject( item )->SetValue( value );}/*--------------------------------***  SETVALUE  ***------------------------------------*/void	ZDialog::SetValue( const short item, const double value ){	ASSERT( "Bad item ID in SetValue( double )", item <= itsItems->CountItems(), item )	GetItemObject( item )->SetValue( value );}/*--------------------------------***  GETVALUE  ***------------------------------------*//*	gets the value of the dialog item. This determines the type of the item anddoes the obvious thing. For unknown items, returns 0.----------------------------------------------------------------------------------------*/long	ZDialog::GetValue( const short item ){	ASSERT( "Bad item ID in GetValue", item <= itsItems->CountItems(), item )	return GetItemObject( item )->GetValue();}/*-----------------------------***  GETVALUEASTEXT  ***---------------------------------*//*	get text of item, or if control, convert value to string first (complementary function toGetValue().----------------------------------------------------------------------------------------*/void	ZDialog::GetValueAsText( const short item, Str255 aStr ){	ASSERT( "Bad item ID in GetValueAsText", item <= itsItems->CountItems(), item )	GetItemObject( item )->GetValueAsText( aStr );}/*----------------------------***  GETVALUEASFLOAT  ***---------------------------------*//*	get text of item, then convert it to a floating point number. This is useful to get realnumbers from editable text fields, etc.----------------------------------------------------------------------------------------*/float	ZDialog::GetValueAsFloat( const short item ){	ASSERT( "Bad item ID in GetValueAsFloat", item <= itsItems->CountItems(), item )	return GetItemObject( item )->GetValueAsFloat();}/*------------------------------***  SETMAXIMUM  ***------------------------------------*//*	sets the max value of the item----------------------------------------------------------------------------------------*/void    ZDialog::SetMaximum( const short item, const long aMax ){    ASSERT( "Bad item ID in SetMaximum", item <= itsItems->CountItems(), item )        GetItemObject( item )->SetMaximum( aMax );}/*------------------------------***  SETMINIMUM  ***------------------------------------*//*	sets the min value of the item----------------------------------------------------------------------------------------*/void    ZDialog::SetMinimum( const short item, const long aMin ){    ASSERT( "Bad item ID in SetMinimum", item <= itsItems->CountItems(), item )        GetItemObject( item )->SetMinimum( aMin );}/*------------------------***  GETSELECTEDITEMINGROUP  ***------------------------------*//*	returns the item number of the selected item in a group of radio buttons. If the groupis any other sort of item, the result is undefined.----------------------------------------------------------------------------------------*/short	ZDialog::GetSelectedItemInGroup( const short groupID ){	short			i;	ZDialogItem		*di;		for ( i = 1; i <= itsItems->CountItems(); i++ )	{		di = (ZDialogItem*) GetItemObject( i );			if ( di->GetGroupID() == groupID &&			 di->GetValue() != 0 )			 return i;	}		return 0;}/*----------------------------***  SETITEMGROUPID  ***----------------------------------*//*	sets the group ID of the item----------------------------------------------------------------------------------------*/void	ZDialog::SetItemGroupID( const short item, const short groupID ){	GetItemObject( item )->SetGroupID( groupID );}/*----------------------------***  GETITEMGROUPID  ***----------------------------------*//*	gets the group ID of the item----------------------------------------------------------------------------------------*/short	ZDialog::GetItemGroupID( const short item ){	return GetItemObject( item )->GetGroupID();}/*-----------------------------***  GETITEMBOUNDS  ***----------------------------------*//*	get rect of item----------------------------------------------------------------------------------------*/void	ZDialog::GetItemBounds( const short item, Rect* bounds ){	ASSERT( "Bad item ID in GetItemBounds", item <= itsItems->CountItems(), item )	GetItemObject( item )->GetBounds( bounds );}/*--------------------------------***  FINDITEM  ***------------------------------------*//*	find the item under the mouse point (local coordinates), 0 if no item there----------------------------------------------------------------------------------------*/short	ZDialog::FindItem( const Point localMouse ){	return ( FindDialogItem( GetMacDialog(), localMouse ) + 1 );}/*-------------------------------***  HIDEITEM  ***-------------------------------------*//*	hides the item entirely----------------------------------------------------------------------------------------*/void	ZDialog::HideItem( const short item ){	ASSERT( "Bad item ID in HideItem", item <= itsItems->CountItems(), item )	GetItemObject( item )->Hide();}/*-------------------------------***  SHOWITEM  ***-------------------------------------*//*	re-shows a hidden item----------------------------------------------------------------------------------------*/void	ZDialog::ShowItem( const short item ){	ASSERT( "Bad item ID in ShowItem", item <= itsItems->CountItems(), item )	GetItemObject( item )->Show();}/*------------------------------***  ENABLEITEM  ***------------------------------------*//*	enables a dialog item. If a control, it is undimmed. If static text, it is made into aneditable field and undimmed. This can also be used to enable entire groups of controlsby passing the negative of the group ID. Also, pass 0 to enable everything.----------------------------------------------------------------------------------------*/void	ZDialog::EnableItem( const short item ){	ASSERT( "Bad item ID in EnableItem", item <= itsItems->CountItems(), item )		if ( item <= 0 )	{		ZDialogItem*	di;			// this is a group ID so find all controls in the group and enable them.				for( short i = 1; i <= itsItems->CountItems(); i++ )		{			di = GetItemObject( i );						if ( di && ( item == 0 || (( di->GetGroupID() & 0xFF ) == -item )))				di->Enable( TRUE );		}		CheckFocus();		PerformUpdate();	}	else	{		GetItemObject( item )->Enable( FALSE );		CheckFocus();	}}/*-----------------------------***  DISABLEITEM  ***------------------------------------*//*	disables an item. If a control, the control is dimmed. If an edit field, it is convertedto static text and drawn greyed out (dimmed). This also allows all controls in a groupto be disabled at once- simply pass the negative of the group ID in. You can disableeverything by passing 0. Note that the state history of items is stacked to a max depthof 32- EnableItem/DisableItem should be used in pairs when used for groups.----------------------------------------------------------------------------------------*/void	ZDialog::DisableItem( const short item ){	ASSERT( "Bad item ID in DisableItem", item <= itsItems->CountItems(), item )	if ( item <= 0 )	{		ZDialogItem*	di;		Boolean			reFocus = FALSE;				for( short i = 1; i <= itsItems->CountItems(); i++ )		{			di = GetItemObject( i );					if ( di && ( item == 0 || (( di->GetGroupID() & 0xFF ) == -item )))			{				di->Disable( TRUE );								// check for refocus only if we are disabling a group- if disabling the				// whole lot, we should not do this, otherwise the focus is altered				// incorrectly								if ( di == focusItem )					reFocus = ( item != 0 );			}		}		if ( reFocus )		{			SelectNextFocus();			CheckFocus();		}		PerformUpdate();	}	else	{		Boolean reFocus = FALSE;				if ( focusItem && focusItem->GetID() == item )			reFocus = TRUE;				GetItemObject( item )->Disable( FALSE );				if ( reFocus )		    SelectNextFocus();	}}/*----------------------------***  SETITEMTITLE  ***------------------------------------*//*	allows titles of control items to be changed programmatically----------------------------------------------------------------------------------------*/void	ZDialog::SetItemTitle( const short item, Str255 title ){	ASSERT( "Bad item ID in SetItemTitle", item <= itsItems->CountItems(), item )		GetItemObject( item )->SetTitle( title );}/*-----------------------------***  SELECTITEM  ***-------------------------------------*//*	if the item can take the focus, this sets it as the current one----------------------------------------------------------------------------------------*/void	ZDialog::SelectItem( const short item, Boolean andHilite ){	ZDialogItem*	di;		ASSERT( "Bad item ID in SelectItem", item <= itsItems->CountItems(), item )		di = GetItemObject( item );		if (( di != focusItem ) && ( di != NULL ) && ( di->CanTakeKeyboardFocus()))	{		if ( focusItem )		{			focusItem->BecomeHandler( FALSE );    		if ( andHilite )    		    focusItem->DoHilightSelection( FALSE );	        }		di->BecomeHandler( TRUE );				if ( andHilite )		    di->DoHilightSelection( TRUE );					focusItem = di;	}}/*----------------------------***  SELECTNEXTFOCUS  ***---------------------------------*//*	select next item that can take the focus----------------------------------------------------------------------------------------*/void	ZDialog::SelectNextFocus(){	short			focusID, i, m;	ZDialogItem*	di;		if ( focusItem )		focusID = focusItem->GetID();	else		focusID = 0;			// scan object list for next numbered item that can take the focus, wrapping round	// at the end		m = itsItems->CountItems();	i = focusID;		do	{		i++;				if ( i > m )			i = 0;					if ( i == focusID )			break;					if ( i > 0 )		{				di = GetItemObject( i );						if ( di->IsEnabled() && di->IsVisible() && di->CanTakeKeyboardFocus())			{				SelectItem( i, TRUE );				ClickItem( di->GetID());				break;			}		}	}	while( 1 );}/*-------------------------***  SELECTPREVIOUSFOCUS  ***--------------------------------*//*	select previous item that can take the focus----------------------------------------------------------------------------------------*/void	ZDialog::SelectPreviousFocus(){	short			focusID, i, m;	ZDialogItem*	di;		if ( focusItem )		focusID = focusItem->GetID();	else		focusID = 0;			// scan object list for next numbered item that can take the focus, wrapping round	// at the end		m = itsItems->CountItems();	i = focusID;		do	{		i--;				if ( i < 0 )			i = m;					if ( i == focusID )			break;					if ( i > 0 )		{				di = GetItemObject( i );						if ( di->IsEnabled() && di->IsVisible() && di->CanTakeKeyboardFocus())			{				SelectItem( i, TRUE );				ClickItem( di->GetID());				break;			}		}	}	while( 1 );}/*-------------------------***  COUNTFOCUSABLEITEMS  ***--------------------------------*//*	returns the number of items that can potentially take the keyboard focus. To avoidcounting every time, the data member <focusCount> caches the count- set it to zeroto cause a recalculation.----------------------------------------------------------------------------------------*/short	ZDialog::CountFocusableItems(){	ZDialogItem*	di;	short			fi = 0;		for( short i = 1; i <= itsItems->CountItems(); i++ )	{		di = GetItemObject( i );				if ( di->CanTakeKeyboardFocus() && di->IsEnabled() && di->IsVisible())			fi++;	}		return fi;}/*---------------------------***  PARSERBUTTONTITLE  ***--------------------------------*//*	Finds any group ID "buried" in the button name. This modifies the input string so thatthe extra characters are removed.----------------------------------------------------------------------------------------*/void	ZDialog::ParseRButtonTitle( Str255 buttonTitle, short* groupID, Boolean* isDefault ){	register char	cc = 1;	long			gID = 0;	Str15			subStr;		*groupID = 0;		// in case we find nothing at all	*isDefault = FALSE;		if ( buttonTitle[0] > 0 )	{		// scan the string looking for two consecutive forward slashes:				do		{			if ((buttonTitle[cc] == '/') && (buttonTitle[cc + 1] == '/'))			{				// found two consecutive slashes- now copy the rest of the string into				// subStr.									subStr[0] = buttonTitle[0] - cc - 1;	// length of remainder of string				if (subStr[0])				{						BlockMoveData(&buttonTitle[cc + 2], &subStr[1], subStr[0]);										// look to see if this is the default button in the group. This is indicated					// by the ID number being followed by a '*' character.										if ( subStr[subStr[0]] == '*' )					{						*isDefault = TRUE;												// remove char from string												subStr[0]--;					}					else						*isDefault = FALSE;									// convert substring to a number. Note that results are unpredictable if					// the string does not have a pure number following the two slashes.					// e.g. "My Button//hello" will certainly not work!										StringToNum( subStr, &gID );										// shorten original string by the amount needed to remove extra										buttonTitle[0] = cc - 1;					*groupID = LoWord( gID );										break;				}				}		}		while( ++cc <= buttonTitle[0] );	}}/*------------------------***  HANDLERBUTTONGROUPCLICK  ***-----------------------------*//*	turns off the buttons in the same group as this item, then turns this one on.----------------------------------------------------------------------------------------*/void	ZDialog::HandleRButtonGroupClick( const short item ){	// <item> is already known to be a radio button, so find its "groupies" and turn them	// all off. Then turn this one on.		ZDialogItem	*di, *tdi;	short		tIndex, targetGroup;		di = GetItemObject( item );	targetGroup = di->GetGroupID();		if ( targetGroup > 0 )	{		for( tIndex = 1; tIndex <= itsItems->CountItems(); tIndex++ )		{			tdi = GetItemObject( tIndex );						if (( tdi->GetGroupID() == targetGroup ) && ( tdi->GetType() & radCtrl ) && ( tdi != di ))				tdi->SetValue( 0 );		}				di->SetValue( 1 );	}	}/*---------------------------***  INITITEMFROMICTB  ***---------------------------------*//*	inits the font and colours for the dialog item from an associated 'ictb' resource----------------------------------------------------------------------------------------*/void	ZDialog::InitItemFromICTB( const short item, ictbHandle ictb, const short ictbIndex ){	if (( GetMacWindow() != NULL ) && IsColourPort( WINDOWGRAFPTR( GetMacWindow() )) && ictb )	{		// there is an ictb, so see if this item has a special entry:				ZDialogItem*	di;		ictbItemEntry	ie;		TextStyle		tsRec;		RGBColor		fg, bk;				di = GetItemObject( item );				ie = (*ictb)[ ictbIndex ];				if ( ie.iData != 0 &&			 ie.iOffset != 0 )		{			// yes, there is a special setting for this item- what is it?						ictbTablePtr	tp;						HLock((Handle) ictb );			tp = ( ictbTablePtr ) ((Ptr) *ictb + ie.iOffset );				// tp is now pointing at the text table for the item. Using this table,			// we need to set up a TEStyle record and pass it to TextEdit.						// the font is either already known or can be looked up via its name						if ( ie.iData & fFamChange )			{				if ( ie.iData & fIsFNameOffset )				{					// need to look up the font via the name table. In this case					// txtFont contains the offset to the font's name										GetFNum((unsigned char*) *ictb + tp->txtFont , &tsRec.tsFont);				}				else					tsRec.tsFont = tp->txtFont;			}			else				tsRec.tsFont = PORTTEXTFONT( DIALOGGRAFPTR( GetMacDialog()));							// set simple fields						if ( ie.iData & fFaceChange )				tsRec.tsFace = tp->txtFace;			else				tsRec.tsFace = PORTTEXTFACE( DIALOGGRAFPTR( GetMacDialog()));							if ( ie.iData & fSizeChange )				tsRec.tsSize = tp->txtSize;			else				tsRec.tsSize = PORTTEXTSIZE( DIALOGGRAFPTR( GetMacDialog()));							// set the colours of the port						if ( ie.iData & fFColourChange )				fg =  tp->txtFColour;			else				fg = gBlack;						if ( ie.iData & fBColourChange )				bk =  tp->txtBColour;			else				bk = gWhite;			HUnlock((Handle) ictb );		}		else		{			tsRec.tsFace = PORTTEXTFACE( DIALOGGRAFPTR( GetMacDialog()));			tsRec.tsFont = PORTTEXTFONT( DIALOGGRAFPTR( GetMacDialog()));			tsRec.tsSize = PORTTEXTSIZE( DIALOGGRAFPTR( GetMacDialog()));						// reset the default colours as well						fg = gBlack;			bk = gWhite;		}				di->SetFontInfo( tsRec.tsFont, tsRec.tsSize, tsRec.tsFace );		di->SetForeColour( &fg );		di->SetBackColour( &bk );	}}/*---------------------------***  INITITEMFROMDFTB  ***---------------------------------*//*	inits the font and colours for the dialog item from an associated 'dftb' resource- thisis the preferred method to set up items in OS 8.x and later----------------------------------------------------------------------------------------*/void   ZDialog::InitItemFromDFTB( const short item, dftbHandle dftb, const short dftbIndex ){#if APPEARANCE_MGR_AWARE	if (( GetMacWindow() != NULL ) && IsColourPort( WINDOWGRAFPTR( GetMacWindow() )) && dftb && gMacInfo.hasAppearanceMgr )	{        // entries in the dftb have variable length, so we need to walk through them to obtain        // the right entry                 ZDialogItem*    di;        short           count, font, size;        Style           face;        dftbEntryPtr    dp;        Str255          fName;                if (( dftbIndex >= 0 ) && ( dftbIndex < (*dftb)->dfCount ))        {                 di = GetItemObject( item );            face = font = size = 0;            count = 0;            HLock((Handle) dftb );            dp = &(*dftb)->df[0];                        while( count++ < dftbIndex )            {		    	if( dp->dfType != 0 )		    		dp = (dftbEntry*)((long) dp + dfEntrySize + dp->dfFontNameLen );		     	else		    		dp = (dftbEntry*)((long) dp + 2 );            }                        // now, dp points to the relevant entry, so let's parse that and set up the item                        if ( dp->dfType != 0 && dp->dfFontFlags != 0 )            {                // font flags are present, so interpret them:                                if ( dp->dfFontFlags & kDialogFontUseFaceMask )                    face = dp->dfFontStyle;                                if ( dp->dfFontFlags & kDialogFontUseSizeMask )                    size = dp->dfFontSize;                                    if ( dp->dfFontFlags & kDialogFontUseFontNameMask )                    GetFNum( &dp->dfFontNameLen, &font );                else                {                    if ( dp->dfFontFlags & kDialogFontUseFontMask )                    {                        font = dp->dfFontID;                                        if ( font < 0 )                        {                            // meta-font constant, so get the actual font ID                                                        GetThemeFont((ThemeFontID)((-font) - 1 ), smSystemScript, fName, &size, &face );                            GetFNum( fName, &font );                        }                    }                }                                di->SetFontInfo( font, size, face );                            // now the colours:                                if ( dp->dfFontFlags & kDialogFontUseForeColorMask )                    di->SetForeColour( &dp->dfTextColour );                                    if ( dp->dfFontFlags & kDialogFontUseBackColorMask )                    di->SetBackColour( &dp->dfBackColour );                                if ( dp->dfFontFlags & kDialogFontUseJustMask )                    di->SetFontAlignment( dp->dfTextJust );            }            HUnlock((Handle) dftb );        }    }#endif}/*----------------------------***  PASTEDATAISLEGAL  ***--------------------------------*//*	if the clipboard contains text and the paste target is an edit field, this determinesif the text is in a legal format according to the info stored for the field. This is usedto enforce the field restrictions when pasting.----------------------------------------------------------------------------------------*/Boolean	ZDialog::PasteDataIsLegal( const short targetItem ){	Boolean			legalPaste;	unsigned short	iFlags;	char*			testStr;	long			tSize;	ZDialogItem*	di;		legalPaste = gClipboard->QueryType( 'TEXT' );	if ( legalPaste )	{		// get the flags for the target field. If zero, this is a normal field and all		// text is valid, but we do the test anyway to allow the item to override it.				di = GetItemObject( targetItem );		iFlags = di->GetFilterFlags();				// you can't paste into a password field, so if that flag's set, return FALSE				if ( iFlags & editFieldHiddenChars )			return FALSE;				// in order to check the text, we need to obtain a copy of it				Handle	tx = gClipboard->GetData( 'TEXT' );				if ( tx )		{			// to test the text, we scan through it and call CheckKey() for each			// character until it returns FALSE, indicating that a bad char was			// found in the text.							tSize = GetHandleSize( tx );			HLock( tx );			testStr = (char*) *tx;						while( tSize )			{				if ( ! di->CheckKey( testStr ))				{					legalPaste = FALSE;					break;				}								testStr++;				tSize--;			}			HUnlock( tx );			DisposeHandle( tx );		}		else			legalPaste = FALSE;		// no text, can't paste anyway.	}	return legalPaste;}/*---------------------------***  PARSEEDITFIELDINFO  ***-------------------------------*//*extracts set uyp flags and any min or max associated with a field. This is set in theresource using a specially formatted string similar to the way button groups work.	----------------------------------------------------------------------------------------*/void	ZDialog::ParseEditFieldInfo( Str255 efText, unsigned short* efFlags, long* min, long* max ){	register char	cc = 1, dc;	unsigned char	stPart, ssLen;	long			temp;	Str15			subStr;		*efFlags = 0;	*min = 0;	*max = 0;		do	{		// scan forward looking for two forward slashes				if (( efText[cc] == '/' ) && ( efText[cc + 1] == '/' ))		{			// found two consecutive slashes- note the length of the info and scan for			// delimiters						stPart = 0;			ssLen = efText[0] - cc + 1;						// string will consist of up to three numbers, separated by commas.			// the first number is the flags field, the second (optional) the			// min limit, and the third (optional) the max limit						cc += 2;				dc = cc;						while( dc <= efText[0] )			{				// scan for the next comma or end of string:							if (( dc >= efText[0] ) || ( efText[ dc + 1 ] == ',' ))				{	 					// found a segment- extract it into subStr and convert to number										subStr[0] = dc - cc + 1;					BlockMoveData( &efText[cc], &subStr[1], dc - cc + 1 );					StringToNum( subStr, &temp );										// assign it to the relevant parameter										switch( stPart )					{						case 0:							*efFlags = temp;							break;												case 1:							*min = temp;							break;													case 2:							*max = temp;							break;					}										stPart++;					cc = dc + 2;					dc = cc - 1;				}								dc++;				}						// remove extra data from string:						efText[0] -= ssLen;				break;		}	}	while( ++cc <= efText[0] );}/*---------------------------***  APPENDITEMSTODIALOG  ***------------------------------*//*extends the dialog by appending another 'DITL' resource to it. This calls AppendDITL buthas the additional advantage of allowing our private radio groups and edit-field infostuff to work correctly.----------------------------------------------------------------------------------------*/void	ZDialog::AppendItemsToDialog( const short appDITLID, DITLMethod apMethod ){	Handle 	ditH;	short	existItems;		Focus();		existItems = CountDITL( GetMacDialog());		FailNILRes( ditH = GetResource( 'DITL', appDITLID ));		AppendDITL( GetMacDialog(), ditH, apMethod );	ReleaseResource( ditH );		BuildDialogObjects( existItems + 1, appDITLID );		//CheckFocus();	PostRefresh();	PerformUpdate();}/*---------------------------***  REMOVEAPPENDEDITEMS  ***------------------------------*//*removes any extra items added by the above routine.----------------------------------------------------------------------------------------*/void	ZDialog::RemoveAppendedItems(){	short			numToRemove, items, i;	Rect			ir;	ZDialogItem*	di;	Boolean			reFocus = FALSE;		items = CountDITL( GetMacDialog());	numToRemove = items - baseItems;		if ( numToRemove > 0 )	{		Focus();		PrepareForDrawing();				for( i = items; i > baseItems; i-- )		{			di = GetItemObject( i );						if ( di == focusItem )			{				reFocus = TRUE;				focusItem = NULL;			}						di->GetBounds(&ir );						InsetRect( &ir, -4, -4 );			EraseRect( &ir );							itsItems->DeleteObject( di );		}				ShortenDITL( GetMacDialog(), numToRemove );	}		if ( reFocus )	{		SelectNextFocus();		CheckFocus();	}	PerformUpdate();}/*--------------------------***  CLEARDITLPLACEHOLDERS  ***-----------------------------*//*in order to stream a dialog's item list, the place holder fields must generally becleared. This performs that on what is expected to be a COPY of the dialog items list.----------------------------------------------------------------------------------------*/void	ZDialog::ClearDITLPlaceHolders( Handle ditl ){	FailNILParam( ditl );	HLock( ditl );		long	dl = GetHandleSize( ditl );	long	off = 2;	Ptr		p = *ditl;		while( off <= dl )	{		// clear place holder:				*(long*)( p + off ) = 0;				// calculate offset to next one. This is equal to 13 + the value		// at 14 bytes from current place.				off += 13;		off += *( p + off ) + 1;				// if that's an odd address, increment by one				if ( off & 1 )			off++;	}		HUnlock( ditl );}/*------------------------------***  GETITEMOBJECT  ***---------------------------------*//*return the object for the indexed item----------------------------------------------------------------------------------------*/ZDialogItem*	ZDialog::GetItemObject( const short item ){	return (ZDialogItem*) itsItems->GetObject( item );}/*-----------------------------***  MAKEITEMOBJECT  ***---------------------------------*//*make, initialise and install the object for the indexed dialog item----------------------------------------------------------------------------------------*/ZDialogItem*	ZDialog::MakeItemObject( const short item, const long magicType ){	ZDialogItem*	di = NULL;		// if there is a makers list, look to see if any maker can build the object...		if ( makers )	{		long				m, i;		ZDialogItemMaker*	maker;				m = makers->CountItems();				for( i = 1; i <= m; i++ )		{			maker = (ZDialogItemMaker*) makers->GetObject( i );					di = maker->MakeDialogItem( this, item, magicType );						if ( di )				return di;		}	}		// nothing made- just make a standard item		FailNIL( di = new ZDialogItem( this, item ));		return di;}/*---------------------------***  BUILDDIALOGOBJECTS  ***-------------------------------*//*build the list of item objects that manage each item----------------------------------------------------------------------------------------*/void	ZDialog::BuildDialogObjects( short fromItemNo, const short ictbID ){	ZDialogItem*	di;	short			iCount;	short			groupID, paramCount;	unsigned short	flags;	long			min, max;	Boolean			isDefault;	Str255			cTitle;	ictbHandle		ictb = NULL;	dftbHandle      dftb = NULL;	OSType			magic = 0;	long			params[kMaxMagicParameters];		// load up any specified 'ictb' resource, which is used to initialise the items colours,	// fonts, etc...		if ( IsColourPort( WINDOWGRAFPTR( GetMacWindow() )) && ( ictbID > 0 ))	{		// look for a 'dftb' if we are appearance savvy:			#if APPEARANCE_MGR_AWARE				if ( gMacInfo.hasAppearanceMgr )		{		    dftb = ( dftbHandle ) GetResource( 'dftb', ictbID );				    if ( dftb )		        HNoPurge((Handle) dftb );		    else 		    {          		ictb = ( ictbHandle ) GetResource( 'ictb', ictbID );        			        		if ( ictb )        			HNoPurge((Handle) ictb );		    }      		}		else		{	#endif    		ictb = ( ictbHandle ) GetResource( 'ictb', ictbID );    			    		if ( ictb )    			HNoPurge((Handle) ictb );	#if APPEARANCE_MGR_AWARE        }    #endif	    	}		// loop through items constructing item manager objects		for ( iCount = fromItemNo; iCount <= CountDITL( GetMacDialog()); iCount++ )	{			paramCount = 0;		magic = 0;				// set all unused parameters to zero				for( short pc = 0; pc < kMaxMagicParameters; pc++ )			params[pc] = 0;				// for extension items, parse a static text item looking for magic strings				short	iType;		Handle	iHand;		Rect	iBox;				GetDialogItem( GetMacDialog(), iCount, &iType, &iHand, &iBox );				if ( iType & statText )		{			GetDialogItemText( iHand, cTitle );			ParseStatText( cTitle, &magic, &paramCount, params );			}				if ( magic == 0 )			magic = DMToMagicType( iType );					// try instantiating the appropriate item object				FailNILErr( di = MakeItemObject( iCount, magic ), kUnsupportedTypeErr );				if ( di->ExecuteModifiers( kModifierItemCreated, NULL ))		{			// append to list						itsItems->AppendItem( di );			di->SetXType( magic );						// for control items, set the group ID automatically						if ( di->GetType() & ctrlItem )			{				di->GetTitle( cTitle );								ParseRButtonTitle( cTitle, &groupID, &isDefault );							di->SetTitle( cTitle );				di->SetGroupID( groupID );								if ( isDefault )					di->SetValue( 1 );			}			else			{				// for edit fields, set behaviour flags								if ( di->GetType() & editText )				{					di->GetValueAsText( cTitle );										ParseEditFieldInfo( cTitle, &flags, &min, &max );											di->SetValue( cTitle );					di->SetFilterFlags( flags );					di->SetMinimum( min );					di->SetMaximum( max );				}			}						// after all that, initialise the object's fonts, colours, and any private setup.			// Extracted parameters are passed to InitItem... n.b. Fields of the param array			// beyond <paramCount> are set to zero.						if ( dftb )			    InitItemFromDFTB( iCount, dftb, iCount - fromItemNo );			else			{    			if ( ictb )    				InitItemFromICTB( iCount, ictb, iCount - fromItemNo );			}			di->InitItem( paramCount, params );						// hand off to an overridable dialog method so that you can do further set up			// on every item if you wish. Default method does nothing.						UserInitialise( di );		}		else			ForgetObject( di );	}		if ( dftb )	{	    HPurge((Handle) dftb );	    ReleaseResource((Handle) dftb );	}		if ( ictb )	{	    HPurge((Handle) ictb );		ReleaseResource((Handle) ictb );	}			// set up sizing for items:		InitItemSizingFromRes( ictbID );		// set up autoswitching:		InitAutoSwitching( ditlID );}/*------------------------------***  PARSESTATTEXT  ***---------------------------------*//*	Extract parameters from the static text string. This returns the number of parametersin <paramCount> and an array of the extracted parameters in <params>----------------------------------------------------------------------------------------*/void	ZDialog::ParseStatText( Str255 sText, OSType* typeParam, short* paramCount, long params[] ){	// initially assume we won't find the magic string:		*typeParam = 0;	*paramCount = 0;		// is the string at least 6 chars long? It must consist of two dollar signs followed	// by a four character object code. The additional parameters are optional.		if ( sText[0] >= 6 )	{		// does it begin with two dollar signs?				if (sText[1] == '$' &&			sText[2] == '$' )		{			// yes, so extract the magic object code ( next 4 chars ). Note that heavyweight			// frameworks sometimes do this sort of thing, but with the actual class name,			// which they then pass to new_by_name, or somesuch. Though that allows greater			// generality with less code, it is not really supported in a nice generic way			// by all compilers, so we have opted for this simpler approach.				*typeParam = *(long*) &sText[3];						// any parameters? These should be comma delimited numbers						char	pc = 0;			char	i = 7;			char	t;			long	p;			Str15	seg;						while( i <= sText[0] )			{				if ( sText[i++] == ',' )				{					t = i;										// found a comma, search forward to next comma or					// end of string										while(( sText[t] != ',' ) && ( t <= sText[0] )) t++;										// extract part of string between two commas										BlockMoveData( &sText[i], &seg[1], t - i );					seg[0] = t - i;										StringToNum( seg, &p );										i = t;										// set parameter										params[ MIN( kMaxMagicParameters, pc )] = p;										pc++;				}			}						*paramCount = pc;		}	}}/*----------------------------***  CLIPOUTITEMSBELOW  ***-------------------------------*//*	remove the bounds rects of items up to <item> from the clip region----------------------------------------------------------------------------------------*/void			ZDialog::ClipOutItemsBelow( const short item ){	RgnHandle	temp;	Rect		r;	short       i;		FailNIL( temp = NewRgn());		GetClip( temp );		if ( drawReverse )	{	    for( i = itsItems->CountItems(); i > item; i-- )	    {    		GetItemObject( i )->GetBounds( &r );    		    		RectRgn( gUtilRgn, &r );    		DiffRgn( temp, gUtilRgn, temp );	    }	}	else	{    	for( i = 1; i < item; i++ )    	{    		GetItemObject( i )->GetBounds( &r );    		    		RectRgn( gUtilRgn, &r );    		DiffRgn( temp, gUtilRgn, temp );    	}	    }	SetClip( temp );	DisposeRgn( temp );}/*------------------------------***  DMTOMAGICTYPE  ***---------------------------------*//*	return magic type code for passed in standard Dialog Manager type----------------------------------------------------------------------------------------*/long			ZDialog::DMToMagicType( short dmType ){	long m = 0;		if ( dmType & ctrlItem )	{		switch( dmType & 3 )		{			case 0:				m = kMagicStdPushButton;				break;							case 1:				m = kMagicStdCheckbox;				break;							case 2:				m = kMagicStdRadioButton;				break;							case 3:				m = kMagicStdResControl;				break;		}	}	else	{		switch ( dmType & 0x7B )		{			case iconItem:				m = kMagicStdIcon;				break;							case picItem:				m = kMagicStdPicture;				break;							case editText:				m = kMagicStdEditText;				break;							case statText:				m = kMagicStdStaticText;				break;							case userItem:				m = kMagicStdUserItem;				break;						    case helpItem:		        m = kHelpStdItem;		        break;		}	}		return m;}/*--------------------------***  INITITEMSIZINGFROMRES  ***-----------------------------*//*	set up the item sizing flags for items from a 'ILIM' resource----------------------------------------------------------------------------------------*/void	ZDialog::InitItemSizingFromRes( const short resID )	{	ItemLimHdl		ih;	short			nItems;		ih = (ItemLimHdl) GetResource( kDialogItemSizingResType, resID );		if ( ih )	{		nItems = GetHandleSize((Handle) ih ) / sizeof( ItemLimRecord );				for ( short i = 0; i < nItems; i++ )			SetItemSizing((*ih)[i].item, (*ih)[i].iSizing );					ReleaseResource((Handle) ih );	}}/*----------------------------***  INITAUTOSWITCHING  ***-------------------------------*//*sets up automatic switching of multiple "panels" in response to a master control. Thisuses a 'sitl' resource with the ID passed to set up the switching groups. ClickItem thenwill perform the switching by showing and hiding the items accordingly. If no 'sitl'resource, nothing is done.	----------------------------------------------------------------------------------------*/void    ZDialog::InitAutoSwitching( const short resID ){    sitlResHdl      sH;    ZDialogItem*    di;    short           itemID, i, j;    sitlEntryPtr    sp;        sH = (sitlResHdl) GetResource( 'sitl', resID );        if ( sH )    {        HNoPurge((Handle) sH );                // parse the resource. Master item is the dialog control that does the switching-        // i.e. a tab control, icon list, pop-up, etc.            switchItem = (*sH)->masterItem;                // section count follows. This should match the number of tabs, menu items, etc. Each        // section then contains a list of items. The items with the ID set then take on the        // section ID.                HLock((Handle) sH );        sp = &(*sH)->firstEntry;                for( j = 0; j < (*sH)->sectionCount; j++ )        {            for( i = 0; i < sp->iCount; i++ )            {                    itemID = sp->items[i];                        di = GetItemObject( itemID );                                if ( di )                    di->SetSwitchGroup( j + 1 );            }                        sp = (sitlEntryPtr)((long) sp + ( sp->iCount * sizeof( short )) + sizeof( short ));        }                // initialise to first panel:                if ( switchItem )        {            di = GetItemObject( switchItem );                        if ( di )                di->SetValue( 1 );                            HandleAutoSwitching( 1 );        }        HUnlock((Handle) sH );        HPurge((Handle) sH );        ReleaseResource((Handle) sH );    }}/*----------------------------***  HANDLEAUTOSWITCHING  ***-----------------------------*//*	performs the automatic switching (by showing and hiding) of multiple items grouped intopanels. Called by ClickItem if a 'sitl' resource was found----------------------------------------------------------------------------------------*/void    ZDialog::HandleAutoSwitching( const short switchValue ){    ZDialogItem*    di;    long            m, i;    short           group;    RgnHandle       null;        m = itsItems->CountItems();        // because we want to eliminate flicker yet work correctly with items    // embedded in appearance controls, we suppress all transitory drawing by making the    // vis region empty. At the end, we then draw all the changes in one go by redrawing    // the switch control. If the switch control is not an embedding control, the redraw    // is handled by the following update        null = NewRgn();    SETWINDOWVISRGN( GetMacWindow(), null );        for( i = 1; i<= m; i++ )    {        di = GetItemObject( i );        if ( di )        {            group = di->GetSwitchGroup();                if ( group == switchValue )                di->Show();            else            {                if ( group != 0 )                {                    if ( di->HasKeyboardFocus())                        di->BecomeHandler( FALSE );                    di->Hide();                }            }        }    }        if ( IsVisible())    {        Focus();        RectRgn( null, WINDOWPORTRECT( GetMacWindow() ));        SETWINDOWVISRGN( GetMacWindow(), null );        #if APPEARANCE_MGR_AWARE        if ( gMacInfo.hasAppearanceMgr )            DrawOneItem( switchItem );        else    #endif        PostRefresh();    }    CheckFocus();    if ( focusItem )        focusItem->DoSelectAll();        DisposeRgn( null );}/*--------------------------------***  CHECKFOCUS  ***----------------------------------*//*	checks that some item has the focus, and if not, selects a suitable item----------------------------------------------------------------------------------------*/void	ZDialog::CheckFocus(){	// the focus may need to be checked if e.g. all edit fields are disabled then	// subsequently enabled- the focus will be lost unless this is called. Normally this	// will be done as necessary by the EnableItem method.	ZDialogItem*	di;		// check that something can take the focus:		if ( CountFocusableItems() > 0 )	{		// next check that the focus has been lost...				for( short i = 1; i <= itsItems->CountItems(); i++ )		{			di = GetItemObject( i );					if ( di && di->HasKeyboardFocus())				return; 		}				// yes, focus lost, so select existing focusable item, or first if none:				if ( focusItem && focusItem->IsVisible())		{			short fID = focusItem->GetID();			focusItem = NULL;			SelectItem( fID, FALSE );		}		else			SelectNextFocus();	}}/*------------------------------***  ATTACHITEMMAKER  ***-------------------------------*//*	attach an item maker to our list of makers----------------------------------------------------------------------------------------*/void	ZDialog::AttachItemMaker( ZDialogItemMaker* aMaker ){	// attaches a maker object to the dialog. A maker is a very tiny helper object whose sole	// purpose in life is to make a dialog item of the required type. This allows custom items	// to be created in dialogs without subclassing the dialog itself.		FailNILParam( aMaker );		if ( makers == NULL )		FailNIL( makers = new ZDItemMakerList());			makers->AppendItem( aMaker );}/*-------------------------------***  ATTACHMAKERS  ***---------------------------------*//*	your chance to attach any makers you want to the dialog- default method adds thestandard custom maker if this option enabled----------------------------------------------------------------------------------------*/void    ZDialog::AttachMakers(){#if _DIALOG_EXTENSIONS		AttachItemMaker( new ZCustomDItemMaker());#endif		SendMessage( kMsgDialogHookAttachMaker, NULL );}/*------------------------------***  ACCEPTSFLAVOUR  ***--------------------------------*//*	Accepts a drag flavour if any of the dialog items can accept the flavour----------------------------------------------------------------------------------------*/Boolean	ZDialog::AcceptsFlavour( const OSType aFlavour ){	// returns TRUE if any dialog item can accept the flavour, else FALSE	for( short i = 1; i <= itsItems->CountItems(); i++ )	{		if ( GetItemObject( i )->AcceptsFlavour( aFlavour ))			return TRUE;	}		return FALSE;}/*---------------------------------***  INWINDOW  ***-----------------------------------*//*	looks for items under the mouse when dragging into the window. This allows a dialog itemto be the target of a drg/drop. To actually handle the drop, you must override Drop andpass the data to the item, etc.----------------------------------------------------------------------------------------*/void	ZDialog::InWindow( const DragReference theDrag ){	Point			mpt;	short			id;	ZDialogItem*	di;	unsigned short	dragItemCount;	unsigned short	dragFlavourCount;	ItemReference	iRef;	FlavorType		theFlavour;		GetDragMouse( theDrag, &mpt, NULL );	Focus();	GlobalToLocal( &mpt );		id = FindItem( mpt );		if ( id > 0 )	{		// we are dragging to an item, so hilite the item and ask it to		// continue tracking this drag		di = GetItemObject( id );				// see if the item is willing to handle this drag's data				if ( di->IsEnabled())		{			FailOSErr(CountDragItems(theDrag, &dragItemCount));						if ( dragItemCount )			{				do				{					// for each drag item, count the flavours										FailOSErr( GetDragItemReferenceNumber( theDrag, dragItemCount, &iRef ));					FailOSErr( CountDragItemFlavors( theDrag, iRef, &dragFlavourCount ));										// for each flavour, see if we can accept it. As soon as we get one that we can					// handle, we hilite the window and exit.										do					{						FailOSErr( GetFlavorType( theDrag, iRef, dragFlavourCount, &theFlavour ));												if ( di->AcceptsFlavour( theFlavour ))						{							// the item will accept this one, so hilite it and continue tracking														SelectItem( id );														if ( di != dragTarget )							{								if ( dragTarget )									dragTarget->DragHilite( FALSE, theDrag );															dragTarget = di;								di->DragHilite( TRUE, theDrag );							}							di->TrackDragInItem( theDrag, mpt );							return;						}					}					while( --dragFlavourCount );				}				while( --dragItemCount );			}		}	}		// if all else fails, unhilite any previous target		if ( dragTarget )		dragTarget->DragHilite( FALSE, theDrag );		dragTarget = NULL;}void	ZDialog::ReportFields(){	ZWindow::ReportFields();		DialogPtr	d = GetMacDialog();		SHOWFIELD( "macDialog", d, ft_address );	XSHOWFIELD( itsItems, ft_objectref );	XSHOWFIELD( focusItem, ft_objectref );	XSHOWFIELD( dragTarget, ft_objectref );	XSHOWFIELD( makers, ft_objectref );	XSHOWFIELD( isModal, ft_boolean );	XSHOWFIELD( isInline, ft_boolean );	XSHOWFIELD( drawReverse, ft_boolean );	XSHOWFIELD( switchItem, ft_signedshort );	XSHOWFIELD( ditlID, ft_signedshort );	XSHOWFIELD( signalDismiss, ft_signedshort );	XSHOWFIELD( exitItem, ft_signedshort );	XSHOWFIELD( baseItems, ft_signedshort );	XSHOWFIELD( defaultItem, ft_signedshort );	XSHOWFIELD( escapeItem, ft_signedshort );	XSHOWFIELD( autoPos, ft_signedshort );	XSHOWFIELD( oldBounds, ft_Rect );}