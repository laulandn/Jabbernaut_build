/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZHexEditor.cpp			-- a scroller that displats an editable hex dump******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZHexEditor.h"#include	"ZFile.h"#include	"MacZoop.h"#include	"ZDialog.h"// global find dialog shared by all hex editor windows. Dialog is "owned" by gApplication// but hex editor subscribes to its messages. Only frontmost one responds.ZDialog*	gHexFindDialog = NULL;// global line cache speeds up hex dump drawingstatic char		lineCache[ ( BYTES_PER_LINE * 3 ) + ( BYTES_PER_LINE / COLUMN_GROUP_SIZE ) + 1 ];static char* 	gHex = "0123456789ABCDEF";CLASSCONSTRUCTOR( ZHexEditor );/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZHexEditor::ZHexEditor( ZCommander* aBoss, const short windID )	: ZScroller( aBoss, windID ){	classID = CLASS_ZHexEditor;		dumpArea = NULL;	dumpLength = 0;	selStart = 0;	selEnd = 0;	tempStore = NULL;	edited = FALSE;	hdStart = 76;	caretPhase = FALSE;	nibPhase = FALSE;	halfOff = FALSE;	maxDisplayLength = 32768;	FailNIL( selectionRgn = NewRgn());	printable = TRUE;}ZHexEditor::ZHexEditor()	: ZScroller(){	classID = CLASS_ZHexEditor;	dumpArea = NULL;	dumpLength = 0;	selStart = 0;	selEnd = 0;	tempStore = NULL;	edited = FALSE;	hdStart = 76;	caretPhase = FALSE;	nibPhase = FALSE;	halfOff = FALSE;	maxDisplayLength = 32768;	FailNIL( selectionRgn = NewRgn());	printable = TRUE;}/*--------------------------------***  DESTRUCTOR  ***---------------------------------*/ZHexEditor::~ZHexEditor(){	if ( tempStore )		DisposeHandle( tempStore );		if ( selectionRgn )			DisposeRgn( selectionRgn );}/*--------------------------------***  INITZWINDOW  ***---------------------------------*//*	initialise the window, setting up font, scroll and spacing constants----------------------------------------------------------------------------------------*/void	ZHexEditor::InitZWindow(){	ZScroller::InitZWindow();		leftMargin = 0;	topMargin = 16;		FontInfo	fi;		Focus();	// set up the font. Note that only mono-spaced fonts work since the offset calculations	// are based on a fixed em-space. Also, font sizes smaller than 9 points are unreliable	// as well as unreadable.		TextFont( kFontIDMonaco );	TextSize( 9 );	TextFace( 0 );		GetFontInfo( &fi );		lineHeight = fi.ascent + fi.descent + fi.leading;	ascent = fi.ascent;	emSpace = fi.widMax;	hdStart = emSpace * 9 + 20;	hdEnd = hdStart + emSpace * (( BYTES_PER_LINE * 3 ) + ( BYTES_PER_LINE / COLUMN_GROUP_SIZE ) - 2 );		maxDisplayLength = ( 32000L * BYTES_PER_LINE ) / lineHeight;		SetScrollAmount( emSpace, lineHeight );	SetDumpMemory( NULL, 0 );		if ( gHexFindDialog )		ListenTo( gHexFindDialog );}/*--------------------------------***  DRAWCONTENT  ***---------------------------------*//*	draw the hex dump display----------------------------------------------------------------------------------------*/void	ZHexEditor::DrawContent(){	// if the dump's been edited, make sure that <dumpArea> points to the modified dump		if ( edited && tempStore )	{		HLock( tempStore );		dumpArea = *tempStore;	}		TextMode( srcCopy );	// we are only going to draw what's visible, so get the current clip rect to find out	// what that is.    RgnHandle   temp;	Rect	    cr, r;		FailNIL( temp = NewRgn());	GETCURRENTPORTCLIPRGN( temp );		r = *REGIONBOUNDINGBOX( temp );		// start on a whole line boundary:		r.top -= r.top % lineHeight;		// hex is dumped 16 bytes at a time (one line) so we loop through <dumpLength / 16>		register short	lineStart = r.top + ascent + 1;	register long	loop, excess, hs, he, dl;	register Ptr	base;		Boolean	 bSup;		// compute the offset of the visible area start and end		hs = GetOffset( hdStart, r.top );		bSup = ( hs > dumpLength );		// make sure drawn area is constrained to the dump limits		hs = MAX( 0, MIN( dumpLength, hs ));	he = MAX( 0, MIN( dumpLength, GetOffset( hdStart, r.bottom ) + BYTES_PER_LINE ));		// figure looping parameters:		dl = he - hs;		excess = dl % BYTES_PER_LINE;	loop = dl / BYTES_PER_LINE;	base = dumpArea + hs;		// draw the bulk of the dump:		while( loop-- )	{		MoveTo( 6, lineStart );		DrawHexLine( base );				lineStart += lineHeight;		base += BYTES_PER_LINE;	}		// if there's any data in the trailing line, draw that as well:		MoveTo( 6, lineStart );		if ( excess )	{		DrawHexLine( base, excess );		lineStart += lineHeight;	}		if ( edited && tempStore )		HUnlock( tempStore );	// draw the hilite region		if ( ! isPrinting )	{			SetHiliteMode();		InvertRgn( selectionRgn );				if (! IsActive())		{			CopyRgn( selectionRgn, gUtilRgn );			InsetRgn( gUtilRgn, 1, 1 );			SetHiliteMode();			InvertRgn( gUtilRgn );		}	}		// clear the remainder of the window if we drew the last line	if ( he == dumpLength )	{		GetContentRect( &cr );		cr.top = lineStart - ascent;		ClipRect( &cr );				if ( ! isPrinting )			EraseRect( &cr );				// if last line is completely filled, draw the starting address of the next line			if (( excess == 0 ) && ! bSup )		{			#if SHOW_ABSOLUTE_ADDRESS			DrawLongAsHex((long) base );			#else			DrawLongAsHex( base - dumpArea );			#endif			DrawChar( ':' );		}	}	ForeColor( blackColor );	DisposeRgn( temp );}/*--------------------------------***  CLICKCONTENT  ***--------------------------------*//*	handle click and drag in content area----------------------------------------------------------------------------------------*/void	ZHexEditor::ClickContent( const Point mouse, const short modifiers ){	// click and drag in the editor. This sets up the selection.		Point		pt, oldMouse = { -1, -1 };	long		hs, he;	RgnHandle	selRgn;	short		dblClick = gApplication->GetClicks();	Boolean		shiftClick = ( modifiers & shiftKey ) == shiftKey;		FailNIL( selRgn = NewRgn());		DrawCaret( FALSE );	nibPhase = FALSE;	halfOff = FALSE;		// If shift-click, extend selection. If double-click, select a byte, triple selects a line,	// four clicks selects the whole lot.		he = MIN( dumpLength, MAX( 0, GetOffset( mouse.h, mouse.v )));		if ( shiftClick )	{		if ( he < selStart )			hs = selEnd;		else			hs = selStart;	}	else		hs = he;			if ( dblClick > 1 )	{		if ( dblClick == 2 )			he = hs + 1;		else		{			if ( dblClick == 3 )			{				hs -= hs % BYTES_PER_LINE;				he = hs + BYTES_PER_LINE;			}			else			{					hs = 0;				he = dumpLength;			}		}		CalcSelection( hs, he, selRgn );		SetSelectionRgn( selRgn );	}		if ( !shiftClick )		oldMouse = pt = mouse;		// wait for some movement of the mouse before continuing if it's still down.		if ( !shiftClick && StillDown() && !DeltaPoint( pt, oldMouse ))	{		GetMouse( &pt );	}		// track the mouse drag, setting the selection accordingly		if ( dblClick < 4 )	{		do		{			GetMouse( &pt );						// depending on whether a double or triple-click, modify end point						if ( dblClick == 3 )				pt.h = hdEnd + emSpace + emSpace;						if ( DeltaPoint( pt, oldMouse ))			{				he = MAX( 0, MIN( dumpLength, GetOffset( pt.h, pt.v )));								CalcSelection( hs, he, selRgn );				SetSelectionRgn( selRgn );							oldMouse = pt;								AutoScroll( pt );			}		}		while( WaitMouseUp());				if ( hs == he )		{			SetEmptyRgn( selRgn );			SetSelectionRgn( selRgn );		}	}	DisposeRgn( selRgn );		selStart = MIN( hs, he );	selEnd = MAX( hs, he );}/*------------------------------------***  TYPE  ***------------------------------------*//*	direct typing inserts/appends hex data----------------------------------------------------------------------------------------*/void	ZHexEditor::Type( const char theKey, const short modifiers ){	Focus();		Boolean		shift, option;		shift  = ( modifiers & shiftKey )  == shiftKey;	option = ( modifiers & optionKey ) == optionKey;		switch ( theKey )	{		case BACKSPACE_KEY:			if ( selEnd != selStart )				DoClear();			else			{				if ( selStart > 0 )				{					if ( nibPhase )						MoveCaret( right );					MoveCaret( left );					nibPhase = FALSE;					selEnd = selStart + 1;					PrepareForEdit();					Munge( NULL, 0 );					SetDumpMemory( dumpArea, dumpLength );					RedrawOnType( selStart );										SetDirty( TRUE );				}			}			break;					case LEFT_ARROW_KEY:			nibPhase = FALSE;			MoveCaret( option? toBeginningOfLine : left, shift );			break;					case RIGHT_ARROW_KEY:			nibPhase = FALSE;			MoveCaret( option? toEndOfLine : right, shift );			break;					case UP_ARROW_KEY:			nibPhase = FALSE;			MoveCaret( option? toBeginning : up, shift );			break;					case DOWN_ARROW_KEY:			nibPhase = FALSE;			MoveCaret( option? toEnd : down, shift );			break;					default:			TypeInData( theKey );			break;		}}/*--------------------------------***  ADJUSTCURSOR  ***--------------------------------*//*	cursor shows i-beam over main dump area----------------------------------------------------------------------------------------*/void	ZHexEditor::AdjustCursor( const Point mouse, const short modifiers ){	Rect	r;		Focus();	SetOriginToScroll();	GetContentRect( &r );	r.left = MAX( hdStart, r.left );	//r.right = MIN( hdEnd, r.right );		if ( PtInRect( mouse, &r ) && ( modifiers & cmdKey ) == 0 )		SetCursorShape( iBeamCursor );	else		ZScroller::AdjustCursor( mouse, modifiers );}/*----------------------------------***  ACTIVATE  ***----------------------------------*//*	redisplay hilite region on activation----------------------------------------------------------------------------------------*/void	ZHexEditor::Activate(){	ZScroller::Activate();	if ( ! EmptyRgn( selectionRgn ))	{		SetOriginToScroll();				SetHiliteMode();		CopyRgn( selectionRgn, gUtilRgn );		InsetRgn( gUtilRgn, 1, 1 );		InvertRgn( gUtilRgn );	}	DrawPlacard();}/*---------------------------------***  DEACTIVATE  ***---------------------------------*//*	redisplay hilite region on deactivation----------------------------------------------------------------------------------------*/void	ZHexEditor::Deactivate(){	ZScroller::Deactivate();		SetOriginToScroll();	if ( ! EmptyRgn( selectionRgn ))	{		SetHiliteMode();		CopyRgn( selectionRgn, gUtilRgn );		InsetRgn( gUtilRgn, 1, 1 );		InvertRgn( gUtilRgn );	}	DrawCaret( FALSE );	DrawPlacard();}/*-----------------------------***  CLICKINSAMEPLACE  ***-------------------------------*//*	are sequential clicks part of a double, etc?----------------------------------------------------------------------------------------*/Boolean	ZHexEditor::ClickInSamePlace( const Point a, const Point b ){	long	oa, ob;		oa = GetOffset( a.h, a.v );	ob = GetOffset( b.h, b.v );		return ( oa == ob );}/*------------------------------------***  IDLE  ***------------------------------------*//*	blink the caret----------------------------------------------------------------------------------------*/void	ZHexEditor::Idle(){	static long		blinkTime = 0;	long			bkt;		bkt = TickCount();		if ( bkt > blinkTime + GetCaretTime())	{		blinkTime = bkt;				if ( selStart == selEnd && IsActive())		{			// blink the "caret"			Focus();			SetOriginToScroll();			DrawCaret( !caretPhase );			}	}}/*--------------------------------***  UPDATEMENUS  ***---------------------------------*//*	enable edit commands----------------------------------------------------------------------------------------*/void	ZHexEditor::UpdateMenus(){	gMenuBar->EnableCommand( kCmdSelectAll );		if ( selEnd != selStart )	{		gMenuBar->EnableCommand( kCmdCut );		gMenuBar->EnableCommand( kCmdCopy );		gMenuBar->EnableCommand( kCmdClear );	}		if ( dumpLength > 0 )		gMenuBar->EnableCommand( kCmdFindHexadecimal );		ZScroller::UpdateMenus();}/*-------------------------------***  HANDLECOMMAND  ***--------------------------------*//*	handle commands specific to editor----------------------------------------------------------------------------------------*/void	ZHexEditor::HandleCommand( const long aCmd ){	switch ( aCmd )	{		case kCmdFindHexadecimal:			OpenFindDialog();			break;					default:			ZScroller::HandleCommand( aCmd );			break;	}}/*-----------------------------------***  DOCOPY  ***-----------------------------------*//*	copy selected bytes to the clipboard----------------------------------------------------------------------------------------*/void	ZHexEditor::DoCopy(){	Handle	temp;	long	range = selEnd - selStart;		if ( range > 0 )	{		FailNIL( temp = NewHandle( range ));				if ( edited && tempStore )		{			HLock( tempStore );			dumpArea = *tempStore;		}				BlockMoveData( dumpArea + selStart, *temp, range );				if ( edited && tempStore )			HUnlock( tempStore );					gClipboard->PutData( 'TEXT', temp );				DisposeHandle( temp );	}	}/*----------------------------------***  DOCLEAR  ***-----------------------------------*//*	delete the selected range----------------------------------------------------------------------------------------*/void	ZHexEditor::DoClear(){	PrepareForEdit();	Munge( NULL, 0 );	RecalcBoundsAndSelection();	ScrollToCaret();		SetDirty( TRUE );}/*----------------------------------***  DOPASTE  ***-----------------------------------*//*	replace selection (or insert/append) data on the clipboard----------------------------------------------------------------------------------------*/void	ZHexEditor::DoPaste(){	Handle	t;		// look for text first, to get expected results when copying and pasting from styled TextEdit		t = gClipboard->GetData( 'TEXT' );		if ( t == NULL )		t = gClipboard->GetData( Wild_Card );		if ( t )	{		PrepareForEdit();		DrawCaret( FALSE );		nibPhase = FALSE;		halfOff = FALSE;				HLock( t );		Munge( *t, MIN( maxDisplayLength - dumpLength, GetHandleSize( t )));		HUnlock( t );		DisposeHandle( t );				selStart = selEnd;		RecalcBoundsAndSelection();			ScrollToCaret();				SetDirty( TRUE );	}	else		SysBeep( 1 );}/*-------------------------------***  CANPASTETYPE  ***---------------------------------*//*	can paste if any type is on the clipboard (we use wild card type)----------------------------------------------------------------------------------------*/Boolean	ZHexEditor::CanPasteType(){	return gClipboard->QueryType( Wild_Card );}/*--------------------------------***  DOSELECTALL  ***---------------------------------*//*	select the entire dump----------------------------------------------------------------------------------------*/void	ZHexEditor::DoSelectAll(){	RgnHandle	temp = NewRgn();		Focus();	SetOriginToScroll();	DrawCaret( FALSE );		selStart = 0;	selEnd = dumpLength;		CalcSelection( selStart, selEnd, temp );	SetSelectionRgn( temp );		DisposeRgn( temp );}/*-------------------------------***  RECEIVEMESSAGE  ***-------------------------------*//*	receive "find" message from dialog.----------------------------------------------------------------------------------------*/void	ZHexEditor::ReceiveMessage( ZComrade* aSender, ZoopMessage aMsg, UntypedPtr msgData ){	if ( aSender == gHexFindDialog )	{		switch ( aMsg )		{			case kMsgDialogSuccessfullyClosed:				gHexFindDialog = NULL;				break;							case kMsgDialogItemClicked:				// if this is the window immediately behind the dialog, and the find button was				// clicked, extract the parameters and do the find, setting the selection to				// the found characters, if any.								if ( LoWord( *(long*) msgData ) == kHFindButton &&					 gWindowManager->GetNthWindow( 2 ) == this )				{					Str255		searchStr;					Boolean		convertHex;					Boolean		wrap;					long		dLen, offset;										// extract data from dialog:										gHexFindDialog->GetValueAsText( kHFindTextItem, searchStr );					convertHex = gHexFindDialog->GetValue( kHFindHexStringItem ) == 1;					wrap = gHexFindDialog->GetValue( kHWrapItem ) == 1;										// if we need to convert a hex string, do that:										if ( convertHex )						ConvertHexSearchString( searchStr );											dLen = searchStr[0];					offset = selEnd;										if ( FindByteString((char*) &searchStr[1], dLen, &offset, wrap ))					{						// was found, so set the selection to it.												SetSelection( offset, offset + dLen );					}					else						SysBeep( 1 );				}				break;		}	}} /*------------------------------***  FINDBYTESTRING  ***--------------------------------*//*	find the target data in the dump, starting at <startOffset>. The offset of the founddata is returned in <startOffset>, and the method returns TRUE if found, FALSE if notfound. If <wrap> is true, the search will continue from the beginning after reaching theend of the dump, until the original <startOffset> is reached.----------------------------------------------------------------------------------------*/Boolean	ZHexEditor::FindByteString( Ptr targData,									long targDataLen,									long* startOffset,									Boolean wrap ){	Boolean found = FALSE;	Boolean	sEdit = edited;	long	fOffset;		FailNILParam( targData );		if ( targDataLen > 0 )	{		// make sure we have a handle with the data				PrepareForEdit();				// initial search				fOffset = Munger( tempStore, *startOffset, targData, targDataLen, NULL, 0 );				found = fOffset >= 0;				// if not found but we didn't start at 0 and wanted to wrap, search again from the beginning.				if ( !found && wrap && ( *startOffset > 0 ))		{			fOffset = Munger( tempStore, 0, targData, targDataLen, NULL, 0 );					found = fOffset >= 0;		}				// if found, where?				if ( found )			*startOffset = fOffset;					// if we had to prepare an edit for this operation, undo that, since finding does not		// in itself construe a proper edit operation.				if ( ! sEdit )		{			edited = FALSE;			DisposeHandle( tempStore );			tempStore = NULL;		}	}		return found;}/*----------------------------------***  OPENFILE  ***----------------------------------*//*	dump contents of file passed. We can dump any sort of file- the type is not checked.----------------------------------------------------------------------------------------*/void	ZHexEditor::OpenFile( const OSType fType, Boolean isStationery ){	ZFile		fs( macFile );		PrepareForEdit();		fs.Open();	fs.Read( tempStore );	fs.Close();		ZScroller::OpenFile( fType, isStationery );		SetDumpMemory( *tempStore, GetHandleSize( tempStore ));}/*----------------------------------***  SAVEFILE  ***----------------------------------*//*	save dump in a text file----------------------------------------------------------------------------------------*/void	ZHexEditor::SaveFile(){	if ( macFType == 0 )		macFType = 'TEXT';		PrepareForEdit();		ZFile	fs ( macFile );		if ( ! fs.IsReal())	{		fs.SetType( macFType );		fs.Create();	}	fs.Open();	fs.Write( tempStore );	fs.Close();		ZScroller::SaveFile();}/*------------------------------***  SETDUMPMEMORY  ***---------------------------------*//*	set the area of memory that this window will display. This is called to set the memoryarea that you wish to display, and also internally when the bounds needs recalculating.----------------------------------------------------------------------------------------*/void	ZHexEditor::SetDumpMemory( Ptr dumpThis, long dumpBytes ){	if ( dumpBytes > maxDisplayLength )		FailOSErr( kTooMuchDataToEditErr );		dumpArea = dumpThis;	dumpLength = dumpBytes;		// compute the scrollbounds. This is the number of lines needed to display	// <dumpBytes> 16 bytes at a time.		Rect	r;		SetRect( &r, 0, 0,				hdEnd + ASCII_OFFSET + 6 + ( BYTES_PER_LINE * emSpace ),				1 + ((( dumpBytes / BYTES_PER_LINE ) + 1 ) * lineHeight ));		SetBounds( r );	SetOriginToScroll();	DrawContent();	DrawPlacard();}/*-------------------------------***  SETSELECTION  ***---------------------------------*//*	allows external code to change the selection of the dump----------------------------------------------------------------------------------------*/void	ZHexEditor::SetSelection( long start, long end ){	selStart = MAX( 0, MIN( dumpLength, start ));	selEnd = MIN( dumpLength, MAX( 0, end ));		RgnHandle temp = NewRgn();		Focus();	SetOriginToScroll();	CalcSelection( selStart, selEnd, temp );	SetSelectionRgn( temp );	ScrollToCaret();		DisposeRgn( temp );}/*--------------------------------***  DUMPCHANGED  ***---------------------------------*//*	has the memory dump been edited in any way?----------------------------------------------------------------------------------------*/Boolean	ZHexEditor::DumpChanged(){	return ( edited && IsDirty());}/*-------------------------------***  GETDUMPMEMORY  ***--------------------------------*//*	get the dump memory. If the data has been edited, you'll get the modified copy, otherwiseyou'll get the original copy if the pointer passed is different. You can also pass NULL toquery the size of the data in the dump.----------------------------------------------------------------------------------------*/void	ZHexEditor::GetDumpMemory( Ptr dumpStorage, long* dumpBytes ){	if ( dumpStorage )	{		*dumpBytes = MIN( *dumpBytes, dumpLength );				if ( edited && tempStore )			BlockMoveData( *tempStore, dumpStorage, *dumpBytes );		else		{			if ( dumpStorage != dumpArea )				BlockMoveData( dumpArea, dumpStorage, *dumpBytes );		}	}	else		*dumpBytes = dumpLength;	}/*-------------------------------***  GETDUMPMEMORY  ***--------------------------------*/void	ZHexEditor::GetDumpMemory( Handle aHandle ){	FailNILParam( aHandle );		SetHandleSize( aHandle, dumpLength );	FailMemError();		if ( edited && tempStore )		BlockMoveData( *tempStore, *aHandle, dumpLength );	else		BlockMoveData( dumpArea, *aHandle, dumpLength );			// if the handle is for a resource, call ChangedResource().		if ( HGetState( aHandle ) & 0x20 )		ChangedResource( aHandle );	}/*--------------------------------***  DRAWHEXLINE  ***---------------------------------*//*	draw a single row of the hex dump. This is repeatedly called to create the display.This caches the line into a string for optimum speed.----------------------------------------------------------------------------------------*/void	ZHexEditor::DrawHexLine( register Ptr lineStartAddr, register char bytesInLine ){	// draw a hex dump line 16 bytes long, starting at the current pen position		register Ptr 			p = lineStartAddr;	register unsigned char	c, pc;	register unsigned char	i = 0, t = 0;		// first draw the line address offset. We do this by comparing <lineStartAddr> with	// <dumpArea>		#if SHOW_ABSOLUTE_ADDRESS	DrawLongAsHex((long) lineStartAddr );	#else	DrawLongAsHex( lineStartAddr - dumpArea );	#endif	DrawChar( ':' );	// move to the horizontal position <hdStart>		MoveTo( hdStart, PORTPENLOCATION( CURRENTPORT )->v );		// we build a cache of the line to be drawn since DrawString is much faster than	// repeated calls to DrawChar.		lineCache[0] = BYTES_PER_LINE * 3 + ( BYTES_PER_LINE / COLUMN_GROUP_SIZE );		do	{		// convert byte pointed to by p to hex display.				if ( i < bytesInLine )		{			pc = *p++;			lineCache[ ++t ] = gHex[( pc & 0xF0 ) >> 4];			lineCache[ ++t ] = gHex[ pc & 0x0F ];		}		else		{			lineCache[ ++t ] = ' ';			lineCache[ ++t ] = ' ';		}		lineCache[ ++t ] = ' ';				// add extra space between grouped columns				if ((( i + 1 ) % COLUMN_GROUP_SIZE ) == 0 )			lineCache[ ++t ] = ' ';	}	while( ++i < BYTES_PER_LINE );		#if HD_USE_COLOUR	ForeColor( blueColor );	#endif	DrawString((ConstStr255Param) lineCache );		// dump line as ascii text (unprintable characters drawn as a dot)		MoveTo( hdEnd + ASCII_OFFSET, PORTPENLOCATION( CURRENTPORT )->v );	i = t = 0;	lineCache[0] = BYTES_PER_LINE;	p = lineStartAddr;		do	{		if ( i < bytesInLine )		{			c = *p++;			lineCache[ ++t ] = ( c > 0xD9 || c < 0x20 )? '.' : c; 		}		else			lineCache[ ++t ] = ' ';	}	while( ++i < BYTES_PER_LINE );		#if HD_USE_COLOUR	ForeColor( greenColor );	#endif		DrawString((ConstStr255Param) lineCache );}/*------------------------------***  DRAWLONGASHEX  ***---------------------------------*//*	displays a long value in hexadecimal notation----------------------------------------------------------------------------------------*/void	ZHexEditor::DrawLongAsHex( register long val ){	register char 			c, shift, t = 1;	register unsigned long 	mask;	#if USE_24_BIT_ADDRESS	mask = 0x00F00000;	shift = 20;	lineCache[0] = 6;	Move( CharWidth('m'), 0 );#else	mask = 0xF0000000;	shift = 28;	lineCache[0] = 8;#endif			while( mask )	{		c = ( val & mask ) >> shift;				lineCache[ t++ ] = gHex[c];		mask >>= 4;		shift -= 4;	}	#if HD_USE_COLOUR	ForeColor( redColor );#endif		DrawString((ConstStr255Param) lineCache );}/*---------------------------------***  GETOFFSET  ***----------------------------------*//*	return the byte offset in the dump corresponding to the window pixel location passed.----------------------------------------------------------------------------------------*/long	ZHexEditor::GetOffset( short hLoc, short vLoc ){	// returns the offset address for the coordinate given. The offset starts at 0 and to	// compute an absolute address add <dumpArea>. The point passed in could be a mouse	// location or line offset, depending on the intended use. The horizontal point is	// treated as being to the right of the displayed byte.		Boolean inAscii = hLoc >= ( hdEnd + ASCII_OFFSET );	short	hOffset, hm, lineNum;		lineNum = vLoc / lineHeight;	if ( inAscii )	{		hLoc = MAX( hdEnd + ASCII_OFFSET, MIN( hdEnd + ASCII_OFFSET + ( emSpace * BYTES_PER_LINE ), hLoc ));		hOffset = ( hLoc - ( hdEnd + ASCII_OFFSET ) + ( emSpace / 2 )) / emSpace;	}	else	{		hLoc = MAX( hdStart, MIN( hdEnd + ASCII_OFFSET - 1, hLoc ));				// to allow for grouping, hLoc needs to be corrected to allow one emSpace per group.		// the number of groups to the left of hLoc is given by:				hm = (( hLoc - hdStart - ( emSpace / 2 )) / ( emSpace * 3 )) / COLUMN_GROUP_SIZE;		hLoc -= ( hm * emSpace );				hOffset = ( hLoc - hdStart + emSpace + ( emSpace / 2 )) / ( emSpace * 3 );	}		return (long) lineNum * BYTES_PER_LINE + hOffset;}/*-------------------------------***  CALCSELECTION  ***--------------------------------*//*	return in <aRgn> the selection region corresponding to the offset start and end passed.----------------------------------------------------------------------------------------*/void	ZHexEditor::CalcSelection( long offsetStart, long offsetEnd, RgnHandle aRgn ){	long		swap;	Rect		a, b, c;	RgnHandle	temp, aTemp;	short		sTop, eTop;		if ( offsetEnd <= offsetStart )	{		swap = offsetStart;		offsetStart = offsetEnd;		offsetEnd = swap;	}	// selection consists of a region made up from three rectangles- first line, central	// block and last line. Some of these may be empty.		FailNIL( temp = NewRgn());	FailNIL( aTemp = NewRgn());		sTop = ( offsetStart / BYTES_PER_LINE ) * lineHeight;	eTop = ( offsetEnd / BYTES_PER_LINE ) * lineHeight;	SetRect( &a, CalcCaretHOffset( offsetStart ),				 sTop,				 hdEnd,				 sTop + lineHeight );		SetRect( &c, hdStart,				 eTop,				 CalcCaretHOffset( offsetEnd ),				 eTop + lineHeight );		SetRect( &b, hdStart, a.bottom, hdEnd, c.top );		// if the selection is within a single line, build it from a and c by forcing a	// empty and making c the whole selection:		if ( sTop == eTop )		a.right = c.left = a.left;		RectRgn( aRgn, &b );	RectRgn( temp, &a );	UnionRgn( temp, aRgn, aRgn );	RectRgn( temp, &c );	UnionRgn( temp, aRgn, aRgn );		// now compute the same selection within the ascii dump area...		SetRect( &a, hdEnd + ASCII_OFFSET + (( offsetStart % BYTES_PER_LINE ) * emSpace ),				 sTop,				 hdEnd + ASCII_OFFSET + ( emSpace * BYTES_PER_LINE ),				 sTop + lineHeight );		SetRect( &c, hdEnd + ASCII_OFFSET,				 eTop,				 hdEnd + ASCII_OFFSET + (( offsetEnd % BYTES_PER_LINE ) * emSpace ),				 eTop + lineHeight );		SetRect( &b, c.left, a.bottom, a.right, c.top );	if ( sTop == eTop )		a.right = c.left = a.left;		RectRgn( aTemp, &b );	RectRgn( temp, &a );	UnionRgn( temp, aTemp, aTemp );	RectRgn( temp, &c );	UnionRgn( temp, aTemp, aTemp );	UnionRgn( aRgn, aTemp, aRgn );	InsetRgn( aTemp, 2, 2 );	DiffRgn( aRgn, aTemp, aRgn );		// finally add in a small region on the left representing the range of addresses covered		SetRect( &a, 2, a.top, 7, EmptyRect( &c )? b.bottom : c.bottom );	RectRgn( temp, &a );	UnionRgn( temp, aRgn, aRgn );	InsetRect( &a, 2, 2 );	a.right += 2;	RectRgn( temp, &a );	DiffRgn( aRgn, temp, aRgn );		DisposeRgn( aTemp );	DisposeRgn( temp );		if ( ! EmptyRgn( aRgn ))		OffsetRgn( aRgn, 0, 1 );}/*---------------------------------***  DRAWCARET  ***----------------------------------*//*	draw the caret in the given state. Called by Idle and other methods.----------------------------------------------------------------------------------------*/void	ZHexEditor::DrawCaret( Boolean state  ){	Rect	r;		if ( state != caretPhase )	{		SetRect( &r, CalcCaretHOffset( selStart ) - CARET_WIDTH,					 ( selStart / BYTES_PER_LINE ) * lineHeight,					 CalcCaretHOffset( selStart ),					 (( selStart / BYTES_PER_LINE ) * lineHeight ) + lineHeight + 2 );					 		if ( halfOff )			OffsetRect( &r, emSpace, 0 );					PenNormal();		 		if ( state )			PenMode( patCopy );		else			PenMode( patBic );		PaintRect( &r );				caretPhase = state;	}}/*-------------------------------***  OPENFINDDIALOG  ***-------------------------------*//*	open the global find dialog, or select it if already open. Note that the dialog isshared by all instances of ZHexEditor, so is actually supervised by the application. Thisresponds to it by becoming a listener of it. Only the window immediately behind thedialog will actually respond. The dialog is expected to be a modeless type.----------------------------------------------------------------------------------------*/void	ZHexEditor::OpenFindDialog(){	if ( ! gHexFindDialog )	{		FailNIL( gHexFindDialog = new ZDialog( gApplication, kHexFindDialogResID ));				try		{			gHexFindDialog->InitZWindow();			ListenTo( gHexFindDialog );		}		catch( ZoopError err )		{			ForgetObject( gHexFindDialog );						throw err;		}	}		gHexFindDialog->Select();	}/*------------------------------***  PREPAREFOREDIT  ***--------------------------------*//*	copies the dump into the temporary handle allowing us to change the data.----------------------------------------------------------------------------------------*/void	ZHexEditor::PrepareForEdit(){	if ( ! edited )	{		if ( dumpArea )			FailOSErr( PtrToHand( dumpArea, &tempStore, dumpLength ));		else			FailNIL( tempStore = NewHandle( 0 ));					edited = TRUE;	}}/*-----------------------------------***  MUNGE  ***------------------------------------*//*	basic editing method- actually manipulates bytes to permit insert/append/replace/delete----------------------------------------------------------------------------------------*/void	ZHexEditor::Munge( Ptr dataToInsert, long dataLength ){	// replaces or appends data in the <tempStore> handle with the data passed. This is the	// basic method for doing all kinds of edits. If selStart == selEnd, the data is inserted	// at that point. If a range is covered, the range is replaced with the data. If <data> is	// NULL or length is 0, the selection is deleted. This may modify selEnd (but never	// selStart), but does not change the selection region- you need to recompute that. This	// may also change <dumpLength>, but doesn't recompute the bounds.		FailNILParam( tempStore );		if ( dataToInsert == NULL )		dataLength = 0;		long	ss, se;		ss = MIN( selStart, selEnd );	se = MAX( selStart, selEnd );			long	newSize, deltaSize, selRange = se - ss;		// handle may need to change size- work out by how much, pos or neg.	deltaSize = dataLength - selRange;	newSize = dumpLength + deltaSize;		// if zero, there's no moving to do, since the range is the same length as the inserted data,	// so it can simply be copied over it.		if ( deltaSize != 0 )	{		if ( deltaSize > 0 )		{			// we're getting bigger, so existing data is moved after resizing						SetHandleSize( tempStore, newSize );			FailMemError();						// data from <selEnd> to the end of the array is moved to the end						BlockMoveData( *tempStore + se, *tempStore + se + deltaSize, dumpLength - se ); 				}		else		{			// we're getting smaller, so existing data is moved before resizing					BlockMoveData( *tempStore + se, *tempStore + se + deltaSize, dumpLength - se );						SetHandleSize( tempStore, newSize );			FailMemError();		}		}			selStart = ss;	selEnd = ss + dataLength;	dumpLength = newSize;		if ( dataLength )		BlockMoveData( dataToInsert, *tempStore + ss, dataLength );			edited = TRUE;}/*--------------------------***  RECALCBOUNDSANDSELECTION  ***--------------------------*//*	changes the displayed hilite to match the current selection offsets, and recalculates thebounds of the scroller also.----------------------------------------------------------------------------------------*/void	ZHexEditor::RecalcBoundsAndSelection(){	Focus();	SetOriginToScroll();		RgnHandle	temp = NewRgn();		CalcSelection( selStart, selEnd, temp );	SetSelectionRgn( temp );		DisposeRgn( temp );		SetDumpMemory( dumpArea, dumpLength );}/*---------------------------------***  MOVECARET  ***----------------------------------*//*	moves the position of the caret in the direction given. This changes the values of<selStart> and <selEnd>----------------------------------------------------------------------------------------*/void	ZHexEditor::MoveCaret( short cDirection, Boolean shifted ){	// implements cursor key movement of caret and caret motion when typing, etc.		Focus();	SetOriginToScroll();	DrawCaret( FALSE );		halfOff = FALSE;		// if a range is selected, kill the selection:		if ( ! EmptyRgn( selectionRgn ))	{		SetHiliteMode();		InvertRgn( selectionRgn );		SetEmptyRgn( selectionRgn );	}		// modify selStart according to the direction, constrain it to the overall limits of	// the dump and make selEnd the same:		switch ( cDirection )	{		case left:			selStart--;			break;					case right:			selStart++;			break;					case up:			selStart -= BYTES_PER_LINE;			break;					case down:			selStart += BYTES_PER_LINE;			break;					case halfRight:			halfOff = TRUE;			break;					case toEnd:			selStart = dumpLength;			break;					case toEndOfLine:			selStart += BYTES_PER_LINE - ( selStart % BYTES_PER_LINE );			break;					case toBeginning:			selStart = 0;			break;					case toBeginningOfLine:			selStart -= selStart % BYTES_PER_LINE;			break;	}	selStart = MAX( 0, MIN( dumpLength, selStart ));		if ( ! shifted )		selEnd = selStart;			// if the caret has gone out of view, scroll so it's in view		ScrollToCaret();		if ( ! shifted )		DrawCaret( TRUE );	else	{		RgnHandle temp;				FailNIL( temp = NewRgn());				CalcSelection( selStart, selEnd, temp );		SetSelectionRgn( temp );		DisposeRgn( temp );	}}/*-------------------------------***  REDRAWONTYPE  ***---------------------------------*//*	redraws the display after a change at <offset>. This causes the minimum redrawing neededto correctly update the display after typing in data.----------------------------------------------------------------------------------------*/void	ZHexEditor::RedrawOnType( long offset ){	// redraws one byte at the given offset		Rect		cont, cr;		SetOriginToScroll();	GetContentRect( &cont );		CalcSelection( offset, dumpLength, gUtilRgn );		if ( ! EmptyRgn( gUtilRgn ))	{		cr = *REGIONBOUNDINGBOX( gUtilRgn );		cr.right = cont.right;		cr.left = cont.left;				SectRect( &cont, &cr, &cr );	}	else	{		// must be deleting the very last byte, so set <cr> accordingly.				cr = cont;		cr.top = ( dumpLength / BYTES_PER_LINE ) * lineHeight;		cr.bottom = cr.top + lineHeight;	}		ClipRect( &cr );	DrawContent();}/*---------------------------------***  TYPEINDATA  ***---------------------------------*//*	change dump when typing in new data. Each keystroke corresponds to half a byte.----------------------------------------------------------------------------------------*/void	ZHexEditor::TypeInData( char theKey ){	if (( theKey >= '0' && theKey <= '9' ) ||		( theKey >= 'A' && theKey <= 'F' ) ||		( theKey >= 'a' && theKey <= 'f' ))	{		char					k;		Boolean					replaceRange = ( selEnd != selStart );				// hide the cursor until the mouse is moved again (normal practice):				ObscureCursor();				// we need to accumulate two keystrokes for every byte, so we use binCount to		// tell us whether were editing the high or low nibble. Since the caret advances		// to the right as we type, the high nibble is written first.				if ( theKey <= '9' )			k = theKey - 0x30;		else		{			if ( theKey <= 'F' )				k = theKey - 0x37;			else				k = theKey - 0x57;		}				SetOriginToScroll();		PrepareForEdit();		dumpArea = *tempStore;				Ptr			p = dumpArea + selStart;		static char	c;			if ( nibPhase )			*p = ( c & 0xF0 ) | k;				// low nibble		else		{			c =  k << 4 ;						// high nibble			Munge( &c, 1 );		}				if ( replaceRange )		{			if ( nibPhase )				selStart = selEnd;			RecalcBoundsAndSelection();		}		else		{			RedrawOnType( selStart );			MoveCaret( nibPhase? right : halfRight );			SetDumpMemory( dumpArea, dumpLength );		}				nibPhase = !nibPhase;					SetDirty( TRUE );	}	else		SysBeep( 1 );}/*-------------------------------***  SCROLLTOCARET  ***--------------------------------*//*	scroll view to ensure caret is visible. Also works for general selection since positionis assumed to be <selStart>.----------------------------------------------------------------------------------------*/void	ZHexEditor::ScrollToCaret(){	Rect	cr;	short	ctop, cbot;		SetOriginToScroll();	cbot =  (( selStart / BYTES_PER_LINE ) * lineHeight ) + lineHeight + 2;	ctop = cbot - lineHeight - 2;		GetContentRect( &cr );		// if caret is outside the content rect some scrolling is required.			short	dh = 0, dv = 0;		GetPosition( &dh, &dv );		if ( ctop < cr.top )		ScrollTo( dh, ctop );	else if ( cbot > cr.bottom )		ScrollTo( dh, cbot - ( cr.bottom - cr.top ));			SetOriginToScroll();}/*------------------------------***  SETSELECTIONRGN  ***-------------------------------*//*	set the selection region to that passed, updating visible region as necessary. Port andorigin must be set prior to calling this.----------------------------------------------------------------------------------------*/void	ZHexEditor::SetSelectionRgn( RgnHandle aRgn ){	FailNILParam( aRgn );		// if the window is inactive, the selection will be outlined. To allow the following to	// draw properly, we need to form the correct outline region.		if ( ! IsActive())	{		RgnHandle	temp;			CopyRgn( selectionRgn, temp = NewRgn());		InsetRgn( temp, 1, 1 );		DiffRgn( selectionRgn, temp, gUtilRgn );				CopyRgn( aRgn, temp );		InsetRgn( temp, 1, 1 );		DiffRgn( aRgn, temp, temp );				XorRgn( gUtilRgn, temp, gUtilRgn );				DisposeRgn( temp );	}	else		XorRgn( selectionRgn, aRgn, gUtilRgn );		PenNormal();	SetHiliteMode();	InvertRgn( gUtilRgn );		CopyRgn( aRgn, selectionRgn );}/*--------------------------***  CONVERTHEXSEARCHSTRING  ***----------------------------*//*	converts a string of hexadecimal data to the true underlying data. This removes any white-space then takes each pair of characters and treats it as an 8-bit hex number.----------------------------------------------------------------------------------------*/void	ZHexEditor::ConvertHexSearchString( Str255 aString ){	unsigned char	c, n = aString[0];	char			b, v;	Str255			t;		// first remove whitespace:		for( c = 1; c <= n; c++ )	{		if ( aString[c] == ' ' )		{			BlockMoveData( &aString[c + 1], &aString[c], n - c );			aString[0]--;			n--;			c--;		}	}	// now work through the string in character pairs, converting to true data.	// Data is created in t.		t[0] = 0;		for ( c = 1; c <= aString[0]; c++ )	{		if ( aString[c] >= 'a' )			b = aString[c] - 0x50;		else			b = aString[c] - 0x30;				if ( b > 0x10 )			b -= 7;				if ( c & 1 )			v = b << 4;		else		{			v |= b; 			t[c >> 1] = v;			t[0]++;		}		}		CopyPString( t, aString );}/*------------------------------***  CALCCARETOFFSET  ***-------------------------------*//*	return pixel offset of byte in a row passed. Used for many calculations, such as caretpositioning and selection.----------------------------------------------------------------------------------------*/short	ZHexEditor::CalcCaretHOffset( long offset ){	return MIN( hdEnd, hdStart +					   (( offset % BYTES_PER_LINE ) * emSpace * 3 ) +					   (( offset % BYTES_PER_LINE ) / COLUMN_GROUP_SIZE * emSpace ));}/*-------------------------------***  MOVESCROLLBARS  ***-------------------------------*//*overrides ZScroller to provide space for the placard if switched on.	----------------------------------------------------------------------------------------*/void	ZHexEditor::MoveScrollbars(){	ZScroller::MoveScrollbars();	#if SIZE_PLACARD		if ( hasHBar )	{		Rect	pr = *WINDOWPORTRECT( GetMacWindow());		short	w, h;				w = pr.right - pr.left - kStdScrollbarWidth + 2 - PLACARD_WIDTH;		h = kStdScrollbarWidth + 1;		SizeControl( theHBar, w, h );		MoveControl( theHBar, pr.left - 1 + PLACARD_WIDTH, pr.bottom - kStdScrollbarWidth);	}		#endif}/*-------------------------------***  MOVESCROLLBARS  ***-------------------------------*//*overrides ZScroller to provide space for the placard if switched on.	----------------------------------------------------------------------------------------*/void	ZHexEditor::HideScrollbars( Boolean validateArea ){	ZScroller::HideScrollbars( validateArea );	#if SIZE_PLACARD	Rect	placRect = *WINDOWPORTRECT( GetMacWindow());		placRect.top = placRect.bottom - kStdScrollbarWidth;	placRect.right = placRect.left + PLACARD_WIDTH - 1;		EraseRect( &placRect );	#if TARGET_API_MAC_CARBON	InvalWindowRect( GetMacWindow(), &placRect );#else	InvalRect( &placRect );#endif#endif}/*---------------------------------***  DRAWPLACARD  ***--------------------------------*//*if there's a placard, draw the information	----------------------------------------------------------------------------------------*/void	ZHexEditor::DrawPlacard(){#if SIZE_PLACARD	Focus();	Rect	placRect = *WINDOWPORTRECT( GetMacWindow());		InsetRect( &placRect, -1, -1 );	placRect.top = placRect.bottom - kStdScrollbarWidth - 1;	placRect.right = placRect.left + PLACARD_WIDTH + 1;	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )		DrawThemePlacard( &placRect, IsActive()? kThemeStateActive : kThemeStateInactive );	else	{#endif		InsetRect( &placRect, 1, 1 );		EraseRect( &placRect );#if APPEARANCE_MGR_AWARE    }#endif	Str31	bytesStr;		NumToString( dumpLength, bytesStr );	ConcatPStrings( bytesStr, "\p bytes" );		if ( IsActive())		TextMode( srcOr );	else		TextMode( grayishTextOr );		ForeColor( blackColor );	MoveTo( placRect.left + 6, placRect.top + ascent + 2 );	DrawString( bytesStr );#endif}/*----------------------------------***  DRAWHEADER  ***--------------------------------*//*draw the header panel which providesa title for the columns----------------------------------------------------------------------------------------*/void	ZHexEditor::DrawHeader(){	ForeColor( blackColor );	ZScroller::DrawHeader();    if ( !gMacInfo.hasAppearanceMgr )    {	    MoveTo( 0, topMargin - 3 );	    LineTo( WINDOWPORTRECT( GetMacWindow())->right, topMargin - 3 );    }	if ( IsActive())		TextMode( srcOr );	else		TextMode( grayishTextOr );		MoveTo( 6 + emSpace, 11 );	DrawString( "\pOffset:" );	MoveTo( hdStart - ( emSpace * 2 ), 11 );		for( short i = 0; i < BYTES_PER_LINE; i++ )	{		Move( emSpace * 2, 0 );		if ( i % COLUMN_GROUP_SIZE == 0 )			Move( emSpace, 0 );		DrawChar(( i > 9 )? i + 0x37 :  i + '0' );				}	Move( ASCII_OFFSET, 0 );	DrawString( "\pASCII:" );}