/****************************************************************************************************			ObjectMacZapp		-- a standard Mac OOP application template****			ZCalendarDialogItem.cpp	-- an interactive calendar pane******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZCalendarDialogItem.h"#include	"MacZoop.h"#include	"ZDialog.h"#include	"ZGrafState.h"#include	<IntlResources.h>#include	<Script.h>#include	<icons.h>/*--------------------------------***  CONSTRUCTOR  ***-------------------------------*/ZCalendarDialogItem::ZCalendarDialogItem( ZDialog* aBoss, const short anID )	: ZDialogItem( aBoss, anID ){	iType = kCustomDialogItemType;	canTakeFocus = TRUE;	font = kFontIDGeneva;	fontSize = 9;	fontStyle = 0;	mondayIsDay1 = FALSE;	CalcCalendarFrame( &bounds );			// set the initial date to the current date		unsigned long	dtSecs;	DateTimeRec		dtRec;		GetDateTime( &dtSecs );	SecondsToDate( dtSecs, &dtRec );	selDate = dtRec;		year = dtRec.year;	month = dtRec.month;		dayCell.h = dayCell.v = 0;			// find the resource ID of the itl1 we are going to use to look up	// the month and day names, etc.		dtSecs = GetScriptVariable( smCurrentScript, smScriptDate );	itl1ResID = LoWord( dtSecs );}/*---------------------------------***  DESTRUCTOR  ***--------------------------------*/ZCalendarDialogItem::~ZCalendarDialogItem(){}/*----------------------------------***  INITITEM  ***---------------------------------*//*initialise item from magic string parameter list.---------------------------------------------------------------------------------------*/void	ZCalendarDialogItem::InitItem( const short paramCount, const long params[] ){	// params to this object are:		// [0] = month to display (1-12), 0 or missing = current month	// [1] = year to display (1904-2040), 0 or missing = current year	if ( paramCount >= 1 )		month = params[0];			if ( paramCount >= 2 )		year = params[1];}/*------------------------------------***  DRAW  ***-----------------------------------*//*repaint the calendar---------------------------------------------------------------------------------------*/void	ZCalendarDialogItem::Draw(){	ZGrafState	gs;		PrepareForDrawing();	EraseRect( &bounds );	DrawStdFrame( &bounds );	DrawItem();}/*----------------------------------***  DRAWITEM  ***---------------------------------*//*update the calendar interface---------------------------------------------------------------------------------------*/void	ZCalendarDialogItem::DrawItem(){	Intl1Hndl		iH;	FontInfo		fi;	short			x, y;	Rect			cr;	Str15			yStr;	unsigned long	dtSecs, todaySecs;	DateTimeRec		dtRec, today;	unsigned char	dtCache[42], dt;	Style			dtStyle[42];		// precompute the dates for each cell. This allows the drawing to	// go faster, reducing flicker		dtRec.year = year;	dtRec.month = month;	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );	dtRec.day -= dtRec.dayOfWeek - 1;	if ( mondayIsDay1 )		dtRec.day++;			DateToSeconds( &dtRec, &dtSecs );	GetDateTime( &todaySecs );	SecondsToDate( todaySecs, &today );		// OK, we have the record set up for the page we are drawing, so	// calculate the date of each day on the page, plus the drawing	// style to apply for the item		for ( x = 0; x < 42; x++ )	{		SecondsToDate( dtSecs, &dtRec );		dtSecs += kSecondsIn1Day;		dtCache[x] = dtRec.day;				dtStyle[x] = 0;				if ( dtRec.month == month )		{			dtStyle[x] = bold;						if ( dtRec.year  == today.year  &&			     dtRec.month == today.month &&			     dtRec.day   == today.day )			     dtStyle[x] += outline;		}		else		    dtStyle[x] = italic;	}		// set fonts, etc		TextFace( bold );	TextMode( srcOr );	GetFontInfo( &fi );	PenNormal();	DrawArrowIcon( 0, FALSE );	DrawArrowIcon( 1, FALSE );		// draw two lines to separate title from cells		MoveTo( bounds.left, bounds.top + kTitleAreaHeight );	Line( bounds.right - bounds.left, 0 );	Move( 0, 2 );	Line( -( bounds.right - bounds.left ), 0 );		// draw grid lines		RGBForeColor( &gMediumGray );	PenPat( QDGRAYPATTERN );				for( x = 1; x < kCellsAcross; x++ )	{		MoveTo( bounds.left + ( cellH * x ) - 1, bounds.top + kTitleAreaHeight + 3 );		LineTo( bounds.left + ( cellH * x ) - 1, bounds.bottom - 1 );	}		for( x = 1; x < kCellsDown; x++ )	{		MoveTo( bounds.left, bounds.top + kTitleAreaHeight + ( cellV * x ) + 2 );		LineTo( bounds.right - 1, bounds.top + kTitleAreaHeight + ( cellV * x ) + 2 );	}		PenNormal();	ForeColor( blackColor );		// draw the title above these lines. We obtain the month and day names from the	// current 'intl' resource that the system has set. This means we automatically	// adapt to foreign spellings, etc.		iH = ( Intl1Hndl ) GetResource( 'itl1', itl1ResID );		if ( iH )	{		// let's detach it so we are safe			DetachResource(( Handle) iH );		FailOSErr( ResError());				// ok, lets build a string with <month>,<year>				Str32	ymStr;				CopyPString((*iH)->months[ month - 1 ], ymStr );		ConcatPStrings( ymStr, "\p, " );		NumToString( year, yStr );		ConcatPStrings( ymStr, yStr );				cr = bounds;		cr.bottom = cr.top + fi.ascent + fi.descent + fi.leading + 2;		InsetRect( &cr, 10, 0 );		TETextBox( &ymStr[1], ymStr[0], &cr, teJustCenter );				// now we draw the initials of the days of the week				TextFace( 0 );		GetFontInfo( &fi );				for ( x = 0; x < 7; x++ )		{			// get the day of the week						if ( mondayIsDay1 )			{				if ( x == 6 )					CopyPString((*iH)->days[ 0 ], ymStr );				else					CopyPString((*iH)->days[ x + 1 ], ymStr );			}			else				CopyPString((*iH)->days[ x ], ymStr );					// we're only going to draw the first letter, so calculate			// based on this character only						ymStr[0] = MIN( 2, ymStr[0] );						MoveTo( bounds.left + (cellH * x) + cellH / 2, bounds.top + kTitleAreaHeight - fi.descent - fi.leading );			Move( -StringWidth( ymStr ) / 2, 0 );						if (( x == 0 && ! mondayIsDay1 ) ||				( x == 6 && mondayIsDay1 ))				ForeColor( redColor );			else				ForeColor( blackColor );							DrawString( ymStr );		}				DisposeHandle((Handle) iH );	}		ForeColor( blackColor );	SetRect( &cr, 0, 0, cellH, cellV );	OffsetRect( &cr, bounds.left, bounds.top + kTitleAreaHeight + 3 );	InsetRect( &cr, 1, 1 );		for ( y = 0; y < kCellsDown; y++ )	{		for ( x = 0; x < kCellsAcross; x++ )		{			// get the day corresponding to the cell we are drawing, and the text style			// both are precalculated at the top of this method for speed						dt = dtCache[ y * kCellsAcross + x ];			NumToString( dt, yStr );			TextFace( dtStyle[ y * kCellsAcross + x ] );						if ( x == 0 )				ForeColor( redColor );			else				ForeColor( blackColor );			TETextBox( &yStr[1], yStr[0], &cr, teJustCenter );			OffsetRect( &cr, cellH, 0 );		}				OffsetRect( &cr, -kCellsAcross * cellH, cellV );	}		PenNormal();	ForeColor( blackColor );		if ( SelectionVisible( TRUE ))		HiliteCell( dayCell );}/*-----------------------------------***  CLICK  ***-----------------------------------*//*switch the date (month or day) depending on what and where we clicked---------------------------------------------------------------------------------------*/void	ZCalendarDialogItem::Click( const Point hitPos, const short modifiers ){	Rect			cr;	Boolean			found = FALSE;	short			x, y;		if ( canTakeFocus && !focused )		((ZDialog*) itsBoss)->SelectItem( id );		ZGrafState		gs;		PrepareForDrawing();		// are we in a hotspot?		if ( ! ClickHots( hitPos ))	{		// no, so see if we clicked an item in the date area				SetRect( &cr, 0, 0, cellH, cellV );		OffsetRect( &cr, bounds.left, bounds.top + kTitleAreaHeight + 3 );				// find which cell the mouse click is in				for( y = 0; !found && ( y < kCellsDown ) ; y++ )		{			for ( x = 0; x < kCellsAcross; x++ )			{				if ( PtInRect( hitPos, &cr ))				{					found = TRUE;					break;				}								OffsetRect( &cr, cellH, 0 );			}			OffsetRect( &cr, -cellH * kCellsAcross, cellV );		}				// change the hilite to the clicked cell. To do this we need to figure out the		// day corresponding to the cell.				if ( found )		{		    Point c;		    		    c.h = x;		    c.v = y - 1;		    		    ChangeSelection( c );		}	}}/*------------------------------***  CHANGESELECTION  ***------------------------------*//*change highlighted cell to one passed, updating date, etc as needed---------------------------------------------------------------------------------------*/void   ZCalendarDialogItem::ChangeSelection( Point toCell ){    if ( DeltaPoint( toCell, dayCell ))    {		// unhilite current cell if visible				if ( SelectionVisible())			HiliteCell( dayCell );				// hilite new cell				dayCell = toCell;				HiliteCell( dayCell );				// tell the world				CellToDay( dayCell.h, dayCell.v, &selDate );			unsigned long	dt;		DateToSeconds( &selDate, &dt );				SendMessage( kNewDaySelected, (void*) dt );    }}/*-----------------------------------***  TYPE  ***------------------------------------*//*respond to keyboard (mainly arrow keys)---------------------------------------------------------------------------------------*/void   ZCalendarDialogItem::Type( const char theKey, const short modifiers ){    Point       c = dayCell;    Boolean     command;        // preflight the key so we establish the correct context for ZGrafState -    // this is needed because the inherited Type may close the dialog,    // making the graf state restoration invalid.        if ( theKey == LEFT_ARROW_KEY 	||    	 theKey == RIGHT_ARROW_KEY 	||    	 theKey == UP_ARROW_KEY		||    	 theKey == DOWN_ARROW_KEY )    {	    ZGrafState      gs;	    PrepareForDrawing();	    	    command = ( modifiers & cmdKey ) == cmdKey;	    	    switch( theKey )    	    {	        case LEFT_ARROW_KEY:	            if ( command )	                SetPreviousMonth();	            else	            {    	                c.h = MAX( c.h - 1, 0 );	                ChangeSelection( c );	            }	            break;	            	        case RIGHT_ARROW_KEY:	            if ( command )	                SetNextMonth();	            else	            {	                c.h = MIN( c.h + 1, 6 );	                ChangeSelection( c );	            }	            break;	            	        case UP_ARROW_KEY:	            c.v = MAX( c.v - 1, 0 );	            ChangeSelection( c );	            break;	            	        case DOWN_ARROW_KEY:	            c.v = MIN( c.v + 1, 5 );	            ChangeSelection( c );	            break;     	}    }    else    	ZDialogItem::Type( theKey, modifiers );}/*--------------------------------***  SETCALENDAR  ***--------------------------------*//*switch to month and year passed, optionally refreshing---------------------------------------------------------------------------------------*/void	ZCalendarDialogItem::SetCalendar( const short aYear, const short aMonth, const Boolean reDraw ){	year = aYear;	month = aMonth;		if ( reDraw )		InvalItem();}/*--------------------------------***  CELLTODAY  ***----------------------------------*//*returns day in month of cell passed. (cell starts at 0,0 for top, left) current monthand year affects the outcome, naturally.---------------------------------------------------------------------------------------*/short	ZCalendarDialogItem::CellToDay( const short cellx, const short celly, DateTimeRec* dtr ){	// return the day corresponding to the cell x,y for the current month and year.		unsigned long	dtSecs;	DateTimeRec		dtRec;		dtRec.year = year;	dtRec.month = month;	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );		// the first cell may be several days before this date, so we need to figure out	// how many days so we know what date to use for cell 1.		dtRec.day -= dtRec.dayOfWeek - 1;	if ( mondayIsDay1 )		dtRec.day++;			DateToSeconds( &dtRec, &dtSecs );		// how many days are we on from this day?		dtSecs += ( kSecondsIn1Day * ( celly * 7 + cellx ));	SecondsToDate( dtSecs, &dtRec );		if ( dtr )		*dtr = dtRec;		return dtRec.day;}/*--------------------------------***  CLICKHOTS  ***----------------------------------*//*handle click on "hotspots" which are a couple of fake buttons to switch the month---------------------------------------------------------------------------------------*/Boolean	ZCalendarDialogItem::ClickHots( Point hitPos ){	Boolean inHot = FALSE;		if ( PtInRect( hitPos, &hotLeft ))	{		inHot = TrackArrowIcon( hitPos, 0 );				if ( inHot )		{			month--;						if ( month < 1 )			{				year--;				month = 12;			}		}	}	else	{		if ( PtInRect( hitPos, &hotRight ))		{			inHot = TrackArrowIcon( hitPos, 1 );						if ( inHot )				month++;		}	}		if ( inHot )	{		DateTimeRec 	dtRec;		unsigned long	dtSecs;				// validate date/time				dtRec.year = year;		dtRec.month = month;		dtRec.day = 1;		dtRec.hour = 0;		dtRec.minute = 0;		dtRec.second = 0;		dtRec.dayOfWeek = 1;				DateToSeconds( &dtRec, &dtSecs );		SecondsToDate( dtSecs, &dtRec );				SendMessage( kNewDaySelected, (void*) dtSecs );		month = dtRec.month;		year = dtRec.year;				DrawItem();	}	return inHot;}/*-------------------------------***  DRAWARROWICON  ***-------------------------------*//*draws the "button" icon in the correct place with the state passed. Note that thiscreates the simple 1-bit icon on the fly, so you don't need extra resources.---------------------------------------------------------------------------------------*/void	ZCalendarDialogItem::DrawArrowIcon( const short which, const Boolean state ){	Rect			ir, sr;	unsigned short	arrow[7] = { 0x1818, 0x3C3C, 0x7E5A, 0xFF99, 0x7E5A, 0x3C3C, 0x1818 };	BitMap			abp;		SetRect( &abp.bounds, 0, 0, 16, 7 );	abp.rowBytes = 2;	abp.baseAddr = (Ptr) arrow;		SetRect( &sr, 0, 0, 4, 7 );	ir = sr;	OffsetRect( &ir, bounds.left, bounds.top );		if ( !state )		OffsetRect( &sr, 8, 0 );		if ( which )	{		OffsetRect( &ir, bounds.right - bounds.left - kIconArrowWidth - 2, 2  );		OffsetRect( &sr, 4, 0 );	}	else		OffsetRect( &ir, 2, 2 );		CopyBits( &abp, CURRENTPORTPIXMAP, &sr, &ir, srcCopy, NULL );}/*-----------------------------***  TRACKARROWICON  ***--------------------------------*//*implements normal tracking behaviour for the icon "buttons"---------------------------------------------------------------------------------------*/Boolean	ZCalendarDialogItem::TrackArrowIcon( const Point hitPt, const short which ){	Boolean		wasIn = FALSE;	Boolean		isIn;	Rect		tr;	Point		mouse = hitPt;		if ( which )		tr = hotRight;	else		tr = hotLeft;			while( WaitMouseUp())	{		GetMouse( &mouse );				isIn = PtInRect( mouse, &tr );			if ( isIn != wasIn )		{			wasIn = isIn;					DrawArrowIcon( which, wasIn );		}	}	return wasIn;}/*----------------------------***  CALCCALENDARFRAME  ***------------------------------*//*calculate our frame and cell sizes---------------------------------------------------------------------------------------*/void	ZCalendarDialogItem::CalcCalendarFrame( Rect* toFit ){	Rect	itsFrame = *toFit;	OffsetRect( &itsFrame, -itsFrame.left, -itsFrame.top );		// calculate the size of the cells		cellH = itsFrame.right / kCellsAcross;	cellV = ( itsFrame.bottom - kTitleAreaHeight - 3 ) / kCellsDown;		// the pane needs to be an exact multiple of the cell size, so tweak it:		itsFrame.right = cellH * kCellsAcross;	itsFrame.bottom = cellV * kCellsDown + kTitleAreaHeight + 3;		// set up hotspots		SetRect( &hotLeft, bounds.left, bounds.top, bounds.left + kIconArrowWidth + 16, bounds.top + kIconArrowHeight + 8 );	hotRight = hotLeft;	OffsetRect( &hotRight, itsFrame.right - kIconArrowWidth - 16, 0 );		// tweak bounds to exact multiple of cell height & width		bounds.bottom = bounds.top + itsFrame.bottom - 1;	bounds.right = bounds.left + itsFrame.right - 1;}/*--------------------------------***  HILITECELL  ***---------------------------------*//*hilite the given cell---------------------------------------------------------------------------------------*/void		ZCalendarDialogItem::HiliteCell( Point aCell ){	Rect	cr;		SetRect( &cr, 0, 0, cellH - 1, cellV - 1 );	OffsetRect( &cr, bounds.left + ( aCell.h * cellH ), bounds.top + ( aCell.v * cellV ) + kTitleAreaHeight + 3 );	InsetRect( &cr, 1, 1 );	LMSetHiliteMode( pHiliteBit );		if ( hilited )		InvertRect( &cr );	else	{		PenMode( patXor );		PenSize( 2, 2 );				FrameRect( &cr );		PenNormal();	}}/*-----------------------------***  SELECTIONVISIBLE  ***------------------------------*//*calculates if <selDate> is displayed anywhere in the current calendar. Used to determineif the hilite should be drawn.---------------------------------------------------------------------------------------*/Boolean		ZCalendarDialogItem::SelectionVisible( Boolean recompute ){	short	 		day1, dayN;	DateTimeRec		d1, dN;	unsigned long	t1, tN, tS;		day1 = CellToDay( 0, 0, &d1 );	dayN = CellToDay( kCellsAcross - 1, kCellsDown - 1, &dN );		DateToSeconds( &d1, &t1 );	DateToSeconds( &dN, &tN );	DateToSeconds( &selDate, &tS );		// if the cell is visible, compute its coordinates		if (( tS >= t1 ) && ( tS <= tN ))	{		if ( recompute )		{			dayCell.h = selDate.dayOfWeek - 1;			dayCell.v = ( tS - t1 ) / ( kSecondsIn1Day * kCellsAcross );		}		return TRUE;	}	else		return FALSE;	}void        ZCalendarDialogItem::SetNextMonth(){	DateTimeRec 	dtRec;	unsigned long	dtSecs;		// validate date/time		dtRec.year = year;	dtRec.month = ++month;	if ( dtRec.month > 12 )	{	    dtRec.year++;	    dtRec.month = 1;	}	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );		SendMessage( kNewDaySelected, (void*) dtSecs );	month = dtRec.month;	year = dtRec.year;		DrawItem();}void        ZCalendarDialogItem::SetPreviousMonth(){	DateTimeRec 	dtRec;	unsigned long	dtSecs;		// validate date/time		dtRec.year = year;	dtRec.month = --month;		if ( dtRec.month < 1 )	{	    dtRec.year--;	    dtRec.month = 12;	}	dtRec.day = 1;	dtRec.hour = 0;	dtRec.minute = 0;	dtRec.second = 0;	dtRec.dayOfWeek = 1;		DateToSeconds( &dtRec, &dtSecs );	SecondsToDate( dtSecs, &dtRec );		SendMessage( kNewDaySelected, (void*) dtSecs );	month = dtRec.month;	year = dtRec.year;		DrawItem();}