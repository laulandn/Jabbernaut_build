/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZTextDialogItem.cpp			-- dialog item object that handles a scrolling text box**			****			© 1999, Graham Cox****************************************************************************************************/#include	"ZTextDialogItem.h"#include	"MacZoop.h"#include	"ZDialog.h"#include	"ZGrafState.h"CLASSCONSTRUCTOR( ZTextDialogItem );// static globals for handling scrollingstatic pascal void		ScrollProc( ControlHandle ch, short partCode );static ControlActionUPP	gSBarActionUPP = NewControlActionUPP( ScrollProc );// static globals for handling autoscrollstatic ZTextDialogItem*	gClickedZTDi = NULL;static pascal Boolean	ClickProc( TERec* tr );static TEClickLoopUPP	gAutoscrollUPP = NewTEClickLoopUPP( ClickProc );/*------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZTextDialogItem::ZTextDialogItem( ZDialog* aDialog, const short item )	: ZDialogItem( aDialog, item ){	classID = CLASS_ZTextDialogItem;	iType = kCustomDialogItemType;	macItemHandle = NULL;	isEditable = FALSE;	isSelectable = TRUE;	resID = 0;	lineHeight = 20;	pageHeight = 50;	rtInProgress = FALSE;		bkColour = gWhite;}/*------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZTextDialogItem::ZTextDialogItem()	: ZDialogItem(){	classID = CLASS_ZTextDialogItem; 	iType = kCustomDialogItemType;	macItemHandle = NULL;	isEditable = FALSE;	isSelectable = TRUE;	resID = 0;	lineHeight = 20;	pageHeight = 50;	rtInProgress = FALSE;		bkColour = gWhite;}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZTextDialogItem::~ZTextDialogItem(){}	/*--------------------------------***  INITITEM  ***------------------------------------*//*initialise the item from the parameter list passed----------------------------------------------------------------------------------------*/void		ZTextDialogItem::InitItem( const short paramCount, const long params[] ){	// "magic" parameters to this object are:	// 0: resource ID of 'TEXT' and 'styl' resources to use for this text box	// 1: 0 = not editable, 1 = editable	// 2: default justification, 0= left, 1 = centre, 2 = right	resID = LoWord( params[0] );	isEditable = ( params[1] != 0 );	isSelectable = TRUE;		// get the lineheight and page height of the text		FontInfo	fi;		ZGrafState	gs;	PrepareForDrawing();	GetFontInfo( &fi );	lineHeight = fi.ascent + fi.descent + fi.leading;	pageHeight = bounds.bottom - bounds.top - lineHeight;		// construct the mac stuff		MakeMacTEAndScroll();		if ( paramCount >= 3 )	{		short align = params[2];				if ( align == 2 )			align = teFlushRight;				TESetAlignment( align, pwMirror );	}	// load the initial text// FIX MEBoolean oldVis = visible;visible = FALSE;	PreloadText();visible = oldVis;	// if the text is editable, we can be the handler too		canTakeFocus = TRUE;}/*--------------------------------***  DRAWITEM  ***------------------------------------*//*update the display----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DrawItem(){	Rect	ir = bounds;		ir.right -= kStdScrollbarWidth;	EraseRect( &ir );		TEUpdate( &ir, pwMirror );	Draw1Control((ControlHandle) macItemHandle );		if ( ! hilited )		DrawDisabledBar();	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )		DrawThemeEditTextFrame( &bounds, hilited? kThemeStateActive : kThemeStateInactive );	else	{#endif	DrawStdFrame( &bounds );#if APPEARANCE_MGR_AWARE	}#endif}/*--------------------------------***  CLICKITEM  ***-----------------------------------*//*process a mouse click----------------------------------------------------------------------------------------*/void		ZTextDialogItem::Click( const Point where, const short modifiers ){	ZDialog*	zd;		if ( enabled && hilited )	{		zd = (ZDialog*) itsBoss;				SelfSelect();		zd->Focus();				ZGrafState gs;				PrepareForDrawing();					if ( PtInScrollbar( where ))		{			short			partCode;			ControlHandle	ch;			ZDialog*		zd = (ZDialog*) GetBoss();						partCode = FindControl( where, zd->GetMacWindow(), &ch );						if ( partCode > 0 )			{				if ( partCode == kControlIndicatorPart )				{					short	delta = GetControlValue((ControlHandle) macItemHandle );										partCode = TrackControl((ControlHandle) macItemHandle, where, NULL );										if ( partCode == kControlIndicatorPart )					{						delta -= GetControlValue((ControlHandle) macItemHandle );											Scroll( delta );					}				}				else					partCode = TrackControl((ControlHandle) macItemHandle, where, gSBarActionUPP );			}		}		else		{			if ( isSelectable )			{				gClickedZTDi = this;				TEClick( where, modifiers & shiftKey, pwMirror );				gClickedZTDi = NULL;// FIX ME//				CalScroll();			}		}				zd->ClickItem( id );	}}/*------------------------------***  ADJUSTCURSOR  ***----------------------------------*//*set the cursor shape over this item----------------------------------------------------------------------------------------*/void		ZTextDialogItem::AdjustCursor( const Point where, const short modifiers ){	if ( PtInScrollbar( where ))		SetCursorShape( 0 );	else	{		if ( isSelectable )			SetCursorShape( iBeamCursor );	}}/*----------------------------------***  TYPE  ***--------------------------------------*//*process keyboard input to this item----------------------------------------------------------------------------------------*/void		ZTextDialogItem::Type( const char theKey, const short modifiers ){	char k = theKey;		if ( isEditable && ( k != TAB_KEY 	&&					   k != ENTER_KEY 	&&					   k != ESCAPE_KEY )&&					   ( modifiers & cmdKey ) == 0 )	{		ZGrafState	zg;				PrepareForDrawing();				MZTEKey( k, pwMirror );		RecalText( TRUE );				// if we handled the return key, change the key code so that when passed		// to the dialog, it doesn't do anything. We convert to the forward slash key.		// no significance to this- just a random character that the dialog normally		// ignores.				if ( k == RETURN_KEY )			k = '/';					((ZDialog*) GetBoss())->ClickItem( id );	}	ZDialogItem::Type( k, modifiers );}/*----------------------------------***  IDLE  ***--------------------------------------*//*blink the caret----------------------------------------------------------------------------------------*/void		ZTextDialogItem::Idle(){	if ( isSelectable && focused )	{		FocusBoss();				ZGrafState	gs;				PrepareForDrawing();		TEIdle( pwMirror );	}			ZDialogItem::Idle();}/*----------------------------------***  ACTIVATE  ***----------------------------------*//*	activates the item----------------------------------------------------------------------------------------*/void        ZTextDialogItem::Activate(){    ZDialogItem::Activate();	HiliteControl((ControlHandle) macItemHandle, 0 );		if ( isSelectable )	{		TEActivate( pwMirror );			if ( gFontMenuID )			gMenuBar->EnableCommand( gFontMenuID, 0 );	}}/*---------------------------------***  DEACTIVATE  ***---------------------------------*//*	deactivates the item----------------------------------------------------------------------------------------*/void        ZTextDialogItem::Deactivate(){    ZDialogItem::Deactivate();	HiliteControl((ControlHandle) macItemHandle, 255 );		if ( isSelectable )	{		TEDeactivate( pwMirror );				if ( gFontMenuID )			gMenuBar->DisableCommand( gFontMenuID, 0 );	}}/*---------------------------------***  ENABLE  ***-------------------------------------*//*enable the item----------------------------------------------------------------------------------------*/void		ZTextDialogItem::Enable( Boolean useHistory ){	ZDialogItem::Enable( useHistory );		if ( hilited )		ShowControl((ControlHandle) macItemHandle );}/*--------------------------------***  DISABLE  ***-------------------------------------*//*disable the item----------------------------------------------------------------------------------------*/void		ZTextDialogItem::Disable( Boolean useHistory ){	HideControl((ControlHandle) macItemHandle );	DrawDisabledBar();	ZDialogItem::Disable( useHistory );}#pragma mark -/*----------------------------------***  DOCUT  ***-------------------------------------*//*handle the "Cut" command----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DoCut(){	if ( isEditable )	{		FocusBoss();				ZGrafState	zg;				PrepareForDrawing();		gClipboard->Clear();		TECut( pwMirror );		RecalText();	}}/*---------------------------------***  DOCOPY  ***-------------------------------------*//*handle the "Copy" command----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DoCopy(){	if ( isSelectable )	{		gClipboard->Clear();		TECopy( pwMirror );	}}/*---------------------------------***  DOPASTE  ***------------------------------------*//*handle the "Paste" command----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DoPaste(){	if ( isEditable )	{		FocusBoss();		ZGrafState	zg;				PrepareForDrawing();		TEStylePaste( pwMirror );		RecalText();	}}/*---------------------------------***  DOCLEAR  ***------------------------------------*//*handle the "Clear" command----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DoClear(){	if ( isEditable )	{		FocusBoss();		ZGrafState	zg;				PrepareForDrawing();		TEDelete( pwMirror );		RecalText();	}}/*-------------------------------***  DOSELECTALL  ***----------------------------------*//*handle the "Select All" command----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DoSelectAll(){	if ( isSelectable )	{		FocusBoss();		ZGrafState	zg;				PrepareForDrawing();		TESetSelect( 0, 32767, pwMirror );	}}/*-------------------------------***  CANPASTETYPE  ***---------------------------------*//*check if paste is available----------------------------------------------------------------------------------------*/Boolean		ZTextDialogItem::CanPasteType(){	return ( gClipboard->QueryType( 'TEXT' ) && isEditable );}#pragma mark -/*-------------------------------***  UPDATEMENUS  ***----------------------------------*//*update menus to reflect item's state----------------------------------------------------------------------------------------*/void		ZTextDialogItem::UpdateMenus(){	if ( isSelectable )	{		if ((*pwMirror)->selStart < (*pwMirror)->selEnd )		{			gMenuBar->EnableCommand( kCmdCopy );			if ( isEditable )			{			gMenuBar->EnableCommand( kCmdCut );				gMenuBar->EnableCommand( kCmdClear );			}		}				gMenuBar->EnableCommand( kCmdSelectAll );	}		if ( isEditable )	{		gMenuBar->EnableCommand( kCmdSetLeftJustify );			gMenuBar->EnableCommand( kCmdSetCentreJustify );			gMenuBar->EnableCommand( kCmdSetRightJustify );					// Font/style menus:				TEStyleRunInfo	ri;				TEGetStyleRunInfo( &ri, pwMirror );					gMenuBar->UpdateFontSizeMenu( &ri );		gMenuBar->UpdateStyleMenu( &ri );				gMenuBar->EnableCommand( kCmdSetColourBlack );		gMenuBar->EnableCommand( kCmdSetColourWhite );		gMenuBar->EnableCommand( kCmdSetColourRed );		gMenuBar->EnableCommand( kCmdSetColourGreen );		gMenuBar->EnableCommand( kCmdSetColourBlue );		gMenuBar->EnableCommand( kCmdSetColourCyan );		gMenuBar->EnableCommand( kCmdSetColourMagenta );		gMenuBar->EnableCommand( kCmdSetColourYellow );		gMenuBar->EnableCommand( kCmdSetColourOther );	}		ZDialogItem::UpdateMenus();}/*------------------------------***  HANDLECOMMAND  ***---------------------------------*//*handle style/size, etc. commands when this item has the focus----------------------------------------------------------------------------------------*/void		ZTextDialogItem::HandleCommand( const long aCmd ){	TextStyle		newStyle;	Boolean			wasChanged = TRUE;	ZGrafState		zg;		if ( isEditable )	{		((ZDialog*) itsBoss )->Focus();		PrepareForDrawing();				switch( aCmd )		{			case kCmdPlainText:				newStyle.tsFace = normal;				TESetStyle( doFace, &newStyle, true, pwMirror );				break;						case kCmdBoldText:				newStyle.tsFace = bold;				TESetStyle( doFace + doToggle, &newStyle, true, pwMirror );				break;						case kCmdItalicText:				newStyle.tsFace = italic;				TESetStyle( doFace + doToggle, &newStyle, true, pwMirror );				break;						case kCmdUnderlineText:				newStyle.tsFace = underline;				TESetStyle( doFace + doToggle, &newStyle, true, pwMirror );				break;						case kCmdOutlineText:				newStyle.tsFace = outline;				TESetStyle( doFace + doToggle, &newStyle, true, pwMirror );				break;						case kCmdShadowText:				newStyle.tsFace = shadow;				TESetStyle( doFace + doToggle, &newStyle, true, pwMirror );				break;						case kCmdCondensedText:				newStyle.tsFace = condense;				TESetStyle( doFace + doToggle, &newStyle, true, pwMirror );				break;						case kCmdExtendedText:				newStyle.tsFace = extend;				TESetStyle( doFace + doToggle, &newStyle, true, pwMirror );				break;						case kCmdStdFontSize7:			case kCmdStdFontSize9:			case kCmdStdFontSize10:			case kCmdStdFontSize12:			case kCmdStdFontSize14:			case kCmdStdFontSize18:			case kCmdStdFontSize24:			case kCmdStdFontSize36:			case kCmdStdFontSize48:			case kCmdStdFontSize60:			case kCmdStdFontSize72:				newStyle.tsSize = aCmd - kStdFontSizeBase;				TESetStyle( doSize, &newStyle, true, pwMirror );				break;							case kCmdSetColourRed:				newStyle.tsColor = gRed;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetColourGreen:				newStyle.tsColor = gGreen;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetColourBlue:				newStyle.tsColor = gBlue;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetColourBlack:				newStyle.tsColor = gBlack;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetColourWhite:				newStyle.tsColor = gWhite;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetColourCyan:				newStyle.tsColor = gCyan;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetColourMagenta:				newStyle.tsColor = gMagenta;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetColourYellow:				newStyle.tsColor = gYellow;				TESetStyle( doColor, &newStyle, true, pwMirror );				break;								case kCmdSetLeftJustify:				TESetAlignment( teFlushLeft, pwMirror );				InvalItem();				break;							case kCmdSetCentreJustify:				TESetAlignment( teCenter, pwMirror );				InvalItem();				break;							case kCmdSetRightJustify:				TESetAlignment( teFlushRight, pwMirror );				InvalItem();				break;									default:				ZDialogItem::HandleCommand( aCmd );				wasChanged = FALSE;				break;		}				if ( wasChanged )			RecalText();	}	else		ZDialogItem::HandleCommand( aCmd );}/*------------------------------***  HANDLECOMMAND  ***---------------------------------*//*handle font commands----------------------------------------------------------------------------------------*/void		ZTextDialogItem::HandleCommand( const short menuID, const short itemID ){	if (( menuID == gFontMenuID ) && isEditable )	{		FocusBoss();		ZGrafState	zg;				Str255		itemName;		TextStyle	newStyle;				PrepareForDrawing();				GetMenuItemText( GetMenuHandle( gFontMenuID ), itemID, itemName );		GetFNum( itemName, &newStyle.tsFont );		TESetStyle( doFont, &newStyle, true, pwMirror );		RecalText();	}	else		ZDialogItem::HandleCommand( menuID, itemID );}/*---------------------------------***  SETVALUE  ***-----------------------------------*//*substitute text with string passed----------------------------------------------------------------------------------------*/void		ZTextDialogItem::SetValue( const Str255 strVal ){	Handle	th;		FailOSErr( PtrToHand( &strVal[1], &th, strVal[0] ));	SetText( th, NULL );	DisposeHandle( th );	}/*--------------------------------***  SETBOUNDS  ***-----------------------------------*//*change size to new size----------------------------------------------------------------------------------------*/void		ZTextDialogItem::SetBounds( Rect* newBounds ){	Rect	rView;	if( EqualRect( &bounds, newBounds ))		return;	HideControl( (ControlHandle)macItemHandle );		#if 0	ZDialogItem::SetBounds( newBounds );#else//////		RgnHandle	temp;		RectRgn( gUtilRgn, &bounds );		RectRgn( temp = NewRgn(), newBounds );		DiffRgn( gUtilRgn, temp, temp );		EraseRgn( temp );		DisposeRgn( temp );//////		bounds = *newBounds;			// if a control, move/change it as needed, also update the mac data for this:				SetDialogItem( GetMacDialog(), id, iType, macItemHandle, &bounds );			//		InvalItem();#endif	// move scrollbar:		rView = bounds;	InsetRect( &rView, -1, -1 );	rView.left = rView.right - ( kStdScrollbarWidth + 1 );		SETCONTROLRECT( (ControlHandle)macItemHandle, &rView );	// recalculate scrollbar location and text rects		{		Rect	r, cr;				r = (*pwMirror)->destRect;		GetContentRect( &cr );		r.right = r.left + cr.right - cr.left;		(*pwMirror)->destRect = r;	}	RecalText();			ShowControl( (ControlHandle)macItemHandle );}/*---------------------------------***  SETTEXT  ***------------------------------------*//*install text (optionally with style data) in this item----------------------------------------------------------------------------------------*/void		ZTextDialogItem::SetText( Handle textH, Handle styleH ){	FailNILParam( textH );		ZGrafState		gs;	PrepareForDrawing();		long	tLen = GetHandleSize( textH );		TESetSelect( 0, 32767, pwMirror );	TEDelete( pwMirror );		HLock( textH );	TEStyleInsert( *textH, tLen, (StScrpHandle) styleH, pwMirror );	HUnlock( textH );		TESetSelect( 0, isEditable? 32767 : 0, pwMirror );// FIX ME			RecalText();}/*----------------------------------***  GETTEXT  ***-----------------------------------*//*copy the item's text (and optionally style data) to the Handle(s) passed----------------------------------------------------------------------------------------*/void		ZTextDialogItem::GetText( Handle textH, Handle styleH ){	FailNILParam( textH );		char			hs = HGetState((*pwMirror)->hText );	StScrpHandle	st = NULL;	short			se, ss;		HLock((*pwMirror)->hText );		try	{		FailOSErr( PtrToXHand( *(*pwMirror)->hText, textH, (*pwMirror)->teLength ));				// if the styleH is not NULL, get the style handle too				if ( styleH )		{			se = (*pwMirror)->selEnd;			ss = (*pwMirror)->selStart;						TESetSelect( 0, 32767, pwMirror );						st = TEGetStyleScrapHandle( pwMirror );					if ( st )			{				HLock((Handle) st );							FailOSErr( PtrToXHand( *st, styleH, GetHandleSize((Handle) st )));							HUnlock((Handle) st );				DisposeHandle((Handle) st );			}						TESetSelect( ss, se, pwMirror );		}		}	catch( ZoopError err )	{		HSetState((*pwMirror)->hText, hs );				if ( st )		{			DisposeHandle((Handle) st );			TESetSelect( ss, se, pwMirror );		}				throw err;	}		HSetState((*pwMirror)->hText, hs );}/*---------------------------------***  SCROLL  ***-------------------------------------*//*scroll the text <delta> pixels----------------------------------------------------------------------------------------*/void		ZTextDialogItem::Scroll( short delta ){	TEPinScroll( 0, delta, pwMirror );}/*----------------------------------***  SCROLLTO  ***----------------------------------*//*	moves the content area to the scroll position passed. This immediately redraws the content----------------------------------------------------------------------------------------*/void		ZTextDialogItem::ScrollTo( const short vPosition ){	short	fV, pV;		fV = GetControlValue( (ControlHandle) macItemHandle );	FocusBoss();		if ( GetControlMaximum( (ControlHandle) macItemHandle ) > GetControlMinimum( (ControlHandle) macItemHandle ))		SetControlValue( (ControlHandle) macItemHandle, vPosition );		pV = GetControlValue( (ControlHandle) macItemHandle );	Scroll( fV - pV );}/*--------------------------------***  DOSCROLL  ***------------------------------------*//*handle scrolling when the scrollbar is clicked, etc.----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DoScroll( short partCode ){	short sDelta = 0;		switch ( partCode )	{		case kControlUpButtonPart:			sDelta = -lineHeight;			break;				case kControlDownButtonPart:			sDelta = lineHeight;			break;				case kControlPageUpPart:			sDelta = -pageHeight;			break;				case kControlPageDownPart:			sDelta = pageHeight;			break;	}		short	sv = GetControlValue((ControlHandle) macItemHandle );		SetControlValue((ControlHandle) macItemHandle , sv + sDelta );	sDelta = sv - GetControlValue((ControlHandle) macItemHandle  );		Scroll( sDelta );}/*--------------------------------***  RECALTEXT  ***-----------------------------------*//*calibrate the scrollbar when the text contents change----------------------------------------------------------------------------------------*/void		ZTextDialogItem::RecalText( Boolean scrollToCaret ){	Rect	content, tBounds, vRect;	short 	textHeight, diff;	Boolean needsRedraw = FALSE;	if( ! rtInProgress )	{		ZGrafState	zg;		rtInProgress = TRUE;				FocusBoss();		SetOrigin( 0, 0 );		GetContentRect( &content );		(*pwMirror)->viewRect = content;		TECalText( pwMirror );			textHeight = MZTEHeight( pwMirror );				tBounds = content;//		tBounds.top = -GetControlValue( (ControlHandle)macItemHandle );		tBounds.top = 0;		tBounds.bottom = tBounds.top + textHeight;		vRect = (*pwMirror)->destRect;		OffsetRect( &tBounds, vRect.left - tBounds.left, vRect.top - tBounds.top );		diff = (*pwMirror)->viewRect.bottom - tBounds.bottom;				if ( diff > 0 )		{			OffsetRect( &tBounds, 0 , diff );		    needsRedraw = TRUE;		}			diff = (*pwMirror)->viewRect.top - tBounds.top;				if ( diff < 0 )		{			OffsetRect( &tBounds, 0, diff );		    needsRedraw = TRUE;		}		(*pwMirror)->destRect = tBounds;		// make sure page height is up to date		pageHeight = bounds.bottom - bounds.top - lineHeight;//		SetScrollAmount( emSpace, lineHeight );		if ( scrollToCaret )		{			TEAutoView( TRUE, pwMirror );		    TESelView( pwMirror );			TEAutoView( FALSE, pwMirror );        }		// scrollbar max is set to the height of the lines less the height of bounds				diff = (tBounds.bottom - tBounds.top) - ( content.bottom - content.top );				if ( diff < 0 )			diff = 0;				SetControlMaximum( (ControlHandle)macItemHandle, diff ); 				// compute value				SetControlValue((ControlHandle) macItemHandle, (*pwMirror)->viewRect.top - (*pwMirror)->destRect.top );			if ( needsRedraw )			InvalItem();				rtInProgress = FALSE;	}}/*------------------------------***  GETCONTENTRECT  ***--------------------------------*//*	return the interior area of the item (excludes scrollbars)----------------------------------------------------------------------------------------*/void	ZTextDialogItem::GetContentRect( Rect* r ){	*r = bounds;	r->right -= kStdScrollbarWidth;	InsetRect( r, 3, 3 );}#pragma mark -/*----------------------------***  MAKEMACTEANDSCROLL  ***------------------------------*//*build the Mac TextEdit and scrollbar data structures for the item----------------------------------------------------------------------------------------*/void		ZTextDialogItem::MakeMacTEAndScroll(){	Rect		rView;	ZDialog*	zd;	WindowPtr	w;		zd = (ZDialog*) GetBoss();	w = DIALOGWINDOW( GetMacDialog());		rView = bounds;	rView.right -= kStdScrollbarWidth;			// allow for scrollbar's width	InsetRect( &rView, 3, 3 );		FailNIL( pwMirror = TEStyleNew( &rView, &rView ));	TESetClickLoop( gAutoscrollUPP, pwMirror );// FIX ME	TECalText( pwMirror );//	TEAutoView( TRUE, pwMirror );		// make the scrollbar		rView = bounds;	InsetRect( &rView, -1, -1 );	rView.left = rView.right - ( kStdScrollbarWidth + 1 );		FailNIL( macItemHandle = (Handle)NewControl( w, &rView, NULL, TRUE, 0, 0, 0, scrollBarProc, (long) this ));	HiliteControl( (ControlHandle)macItemHandle, 255 );}/*-------------------------------***  PRELOADTEXT  ***----------------------------------*//*preinstall data from a 'TEXT' and 'styl' resource with <resID>----------------------------------------------------------------------------------------*/void		ZTextDialogItem::PreloadText(){	Handle t, s;		if ( resID > 0 )	{		t = GetResource( 'TEXT', resID );				if ( t )		{			s = GetResource( 'styl', resID );				SetText( t, s );					if ( s )				ReleaseResource ( s );							ReleaseResource( t );		}	}}/*------------------------------***  PTINSCROLLBAR  ***---------------------------------*//*test if the passed point is within the scrollbar or not----------------------------------------------------------------------------------------*/Boolean		ZTextDialogItem::PtInScrollbar( const Point mouse ){	Rect	r = bounds;		r.left = r.right - kStdScrollbarWidth;		return PtInRect( mouse, &r );}/*-----------------------------***  DRAWDISABLEDBAR  ***--------------------------------*//*draw the scrollbar area correctly when bar hidden----------------------------------------------------------------------------------------*/void		ZTextDialogItem::DrawDisabledBar(){	if ( ! hilited )	{		Rect	dummy;		ZGrafState zg;				PenNormal();		RGBBackColor( &gVeryLightGray );		RGBForeColor( &gDarkGray );				GETCONTROLRECT(( ControlHandle ) macItemHandle, &dummy );		EraseRect( &dummy );			MoveTo( bounds.right - kStdScrollbarWidth, bounds.top );		LineTo( bounds.right - kStdScrollbarWidth, bounds.bottom - 1 );	}}/*-----------------------------***  TEXTEDITCLICKLOOP  ***------------------------------*//*	 implements a default clickLoop that autoscrolls the text----------------------------------------------------------------------------------------*/void	ZTextDialogItem::TextEditClickLoop(){	// perform autoscrolling. This is the default click loop action- you can override it	// if you want to do something else in the click loop.		Point	mousePt;	Rect	cr;		FocusBoss();	GetMouse( &mousePt );	{		GetContentRect( &cr );				if ( ! PtInRect( mousePt, &cr ))		{			// mouse moved outside content, so figure out which way and			// scroll it accordingly.					short dV = 0, maxScrollV, pV;						maxScrollV = lineHeight * 4;						if ( mousePt.v > cr.bottom )				dV = MIN( maxScrollV, mousePt.v - cr.bottom );			else			{				if ( mousePt.v < cr.top )					dV = MAX( -maxScrollV, mousePt.v - cr.top );			}						pV = GetControlValue( (ControlHandle) macItemHandle );			ScrollTo( pV + dV );						pV = GetControlValue( (ControlHandle) macItemHandle );		}	}	SetOrigin( 0, 0 );	GetContentRect( &cr );	ClipRect( &cr );}#pragma mark -/*--------------------------------***  SCROLLPROC  ***----------------------------------*//*callback handler for scrolling the text in an overridable way----------------------------------------------------------------------------------------*/static pascal void	ScrollProc( ControlHandle ch, short partCode ){	ZTextDialogItem*	zi = (ZTextDialogItem*) GetControlReference( ch );		try	{		if ( zi )			zi->DoScroll( partCode );	}	catch(...)	{		// do NOT propagate!	}}static pascal Boolean	ClickProc( TERec* tr ){	try	{		if ( gClickedZTDi )			gClickedZTDi->TextEditClickLoop();	}	catch(...)	{		// do NOT propagate	}		return TRUE;}