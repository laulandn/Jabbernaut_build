/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZIconListDialogItem.cpp	-- dialog item object that handles an icon list**			****			© 1999, Graham Cox****************************************************************************************************/#include	"ZIconListDialogItem.h"#include	"MacZoop.h"#include	"ZGrafState.h"#include	<icons.h>CLASSCONSTRUCTOR( ZIconListDialogItem );/*------------------------------***  CONSTRUCTOR  ***-----------------------------------*/ZIconListDialogItem::ZIconListDialogItem()	: ZListDialogItem(){	classID = CLASS_ZIconListDialogItem;		showTitles = TRUE;	smallIcons = FALSE;	iHilite = iconDefaultHilite;}/*------------------------------***  CONSTRUCTOR  ***-----------------------------------*/ZIconListDialogItem::ZIconListDialogItem( ZDialog* aBoss, const short anID )	: ZListDialogItem( aBoss, anID ){	classID = CLASS_ZIconListDialogItem;	showTitles = TRUE;	smallIcons = FALSE;	iHilite = iconDefaultHilite;}/*-------------------------------***  DESTRUCTOR  ***-----------------------------------*/ZIconListDialogItem::~ZIconListDialogItem(){	DisposeIconCells();}/*--------------------------------***  INITITEM  ***------------------------------------*//*initialise the item from its parameter list----------------------------------------------------------------------------------------*/void		ZIconListDialogItem::InitItem( const short paramCount, const long params[] ){	// init basic parameters from 'LIST' resource, if available		// "magic" parameters to this object are:	// 0: resource ID of 'LIST' resource describing basic features, plus same ID	//	  is used to choose 'ICLB' resource describing icons, etc.	IconListBoxHdl	lbH;	ListTemplateHdl	ltH;	Point			cs = { 0, 0 };	Boolean			hasH, hasV;	short			rows, cols, adjustAmount;	FontInfo		fi;		FocusBoss();		ltH = (ListTemplateHdl) GetResource( kListTemplateResType, params[0] );	lbH = (IconListBoxHdl) GetResource( kIconListTemplateResType, params[0] );	ZGrafState	gs;		if ( ltH )	{		GetFNum((*ltH)->fontName, &font );		fontSize = (*ltH)->fontSize;				TextFont( font );		TextSize( fontSize );		TextFace( 0 );				hasH = (*ltH)->hasHorizScroll;		hasV = (*ltH)->hasVertScroll;		rows = (*ltH)->rows;		cols = (*ltH)->columns;		canTakeFocus = (*ltH)->keyboardNav;		visible = (*ltH)->visible;				if ((*ltH)->whiteBk )			bkColour = gWhite;					ReleaseResource((Handle) ltH );	}	else	{		hasH = FALSE;		hasV = TRUE;		rows = 0;		cols = 1;	}		if ( lbH )	{		showTitles = (*lbH)->addTitles;		iHilite = (IconHilite)(*lbH)->hiliteStyle;	}	// compute desired cellsize		GetFontInfo( &fi );		cs.v = kStdIconCellHeight + ( showTitles? fi.ascent + fi.descent + fi.leading : 0 );		if ( hasH )		cs.h = kStdIconCellWidth;			// make the list		MLInit( &bounds, cs, rows, cols, hasV, hasH );		// using local non-standard drawing proc		MLInstallCallbacks( TRUE, FALSE );		// install icons from list		if ( lbH )	{		AddIconCells( lbH );			ReleaseResource((Handle) lbH );	}		// tweak bounds to fit exact number of cells		cs = (*lh)->cellSize;		adjustAmount = ( bounds.bottom - bounds.top - ( hasH? kStdScrollbarWidth : 0 )) % cs.v;	bounds.bottom -= adjustAmount;		adjustAmount = ( bounds.right - bounds.left - ( hasV? kStdScrollbarWidth : 0 )) % cs.h;	bounds.right -= adjustAmount;		LSize( bounds.right - bounds.left - (hasV? kStdScrollbarWidth : 0 ),		   bounds.bottom - bounds.top - (hasH? kStdScrollbarWidth : 0 ),		   lh );		MLSetSelectionFlags( lOnlyOne );}/*------------------------------***  MLDRAW1CELL  ***-----------------------------------*//*overrides MList to implement custom drawing of cells.----------------------------------------------------------------------------------------*/void		ZIconListDialogItem::MLDraw1Cell( Rect* area, Cell theCell, Boolean cellHilite ){	Rect				ir = { 0, 0, 32, 32 };	short				dataLength;	IconInfo 			info;	IconTransformType	iconTransform;	OSErr				err;		dataLength = sizeof( IconInfo );	LGetCell( &info, &dataLength, theCell, lh );		EraseRect( area );		// centre the icon's rect horizontally in the cell		OffsetRect( &ir, ((area->left + area->right) / 2) - (( ir.right - ir.left ) / 2), area->top + 1 );		// set up the icon transform based on the selection options set		if ( cellHilite && ( iHilite & iconHiliteDarken ))		iconTransform = kTransformSelected;	else		iconTransform = kTransformNone;			// plot the icon according to its type	 	switch ( info.iType )	{		case IconIndexed:			PlotIconID( &ir, kAlignNone, iconTransform, info.iconID );			break;				case IconPlain:			if (info.theIcon)			{				LoadResource( info.theIcon );				PlotIcon( &ir, info.theIcon );								if ( cellHilite )					InvertRect( &ir );				}			break;				case IconColour:			if (info.theIcon)			{				// for these icons, the rect may not be 32 x 32, so we need to get the real				// size and centre it accordingly.								CIconHandle	ci = (CIconHandle) info.theIcon; 								ir = (*ci)->iconPMap.bounds;				OffsetRect( &ir, -ir.left, -ir.top );				OffsetRect( &ir, ((area->left + area->right) / 2) - (( ir.right - ir.left ) / 2),							area->top + 33 - ir.bottom - ir.top );								err = PlotCIconHandle( &ir, kAlignNone, iconTransform, ci );			}			break;					default:			break;	}		// if we want bold border as well, draw it. Actually, this is pretty dismal looking	// and I can't imagine why anyone would want it! You have been warned!		if ( iHilite & iconHiliteBoldBorder )	{		InsetRect( &ir, -4, -4 );		PenSize( 3, 3 );				if ( cellHilite )			PenMode( patOr );		else			PenMode( patBic );				FrameRect( &ir );		}		// draw the icon title if required		if ( showTitles )	{		FontInfo	fi;		GetFontInfo( &fi );				short	tLen = StringWidth( info.title );				MoveTo((( area->left + area->right ) / 2 ) - ( tLen / 2 ),  area->top + 33 + fi.ascent );				if ( cellHilite && ( iHilite & iconHiliteInvertTitle))			TextMode( notSrcCopy );		else			TextMode( srcCopy );				DrawString( info.title );	}		// if inversion flag set, do that:		if ( cellHilite && ( iHilite & iconHiliteInvertCell ) == iconHiliteInvertCell )	{		if ( iHilite & iconHiliteUseHColour )			SetHiliteMode();					InvertRect( area );	}	}/*------------------------------***  MLHILITE1CELL  ***---------------------------------*//*hilite message of callback LDEF----------------------------------------------------------------------------------------*/void		ZIconListDialogItem::MLHilite1Cell( Rect* area, Cell theCell, Boolean cellHilite ){	MLDraw1Cell( area, theCell, cellHilite );}/*--------------------------------***  APPENDICON  ***----------------------------------*//*	append an icon to the list programmatically----------------------------------------------------------------------------------------*/void		ZIconListDialogItem::AppendIcon( IconInfo* info ){	Cell		c;	Boolean 	isHList = ((*lh)->hScroll != NULL) && ((*lh)->vScroll == NULL);	// to make the titles look nicer when hilited, we add a space in front and another	// at the end of the title		LSetDrawingMode( FALSE, lh );		BlockMoveData( &info->title[1], &info->title[2], info->title[0] );	info->title[1] = ' ';	info->title[0] += 2;	info->title[ info->title[0]] = ' ';	c.h = (*lh)->dataBounds.right - 1;	c.v = (*lh)->dataBounds.bottom - 1;		if ( isHList )	{		if ( c.v == -1 )			c.v = LAddRow( 1, c.v + 1, lh );		c.h = LAddColumn( 1, c.h + 1, lh );	}	else	{		if ( c.h == -1 )			c.h = LAddColumn( 1, c.h + 1, lh );		c.v = LAddRow( 1, c.v + 1, lh );	}		LSetDrawingMode( TRUE, lh );	LSetCell( info, sizeof( IconInfo ), c, lh );}/*-------------------------------***  ADDICONCELLS  ***---------------------------------*//*	read the icon listbox template and fetch all the icons, etc needed and set them up----------------------------------------------------------------------------------------*/void		ZIconListDialogItem::AddIconCells( IconListBoxHdl lbH ){	short			i;	Cell			c = { 0, 0 };	IconInfo		info;		FailNILParam( lbH );		for( i = 0; i < (*lbH)->numIcons; i++ )	{		// locate each icon and load it as needed				info.iconID = (*lbH)->icons[i].resID;		switch ((*lbH)->icons[i].iconType)		{			case 0:		// plain black & white icon				info.iType = IconPlain;				info.theIcon = GetIcon( info.iconID );				break;						case 1:		// 'cicn' resource				info.iType = IconColour;				info.theIcon = (Handle) GetCIcon( info.iconID );				break;						case 2:		// indexed icon, etc			default:				info.iType = IconIndexed;				info.theIcon = NULL;				break;		}				// get the title string from the relevant string list				GetIndString( info.title, (*lbH)->titleListResID, (*lbH)->icons[i].nameIndex );		info.userData = 0;				AppendIcon( &info );	}}/*-----------------------------***  DISPOSEICONCELLS  ***-------------------------------*//*	disposes the icons when the list is closed----------------------------------------------------------------------------------------*/void		ZIconListDialogItem::DisposeIconCells(){	Cell		c = {0, 0};	short		row, col, len;	IconInfo	info;		for( col = 0; col < (*lh)->dataBounds.right; col++ )	{		for( row = 0; row < (*lh)->dataBounds.bottom; row++ )		{			c.h = col;			c.v = row;			len = sizeof( IconInfo );						LGetCell( &info, &len, c, lh );						// determine the type of icon and release it						if ( info.theIcon )			{				switch( info.iType )				{					case IconPlain:						ReleaseResource( info.theIcon );						break;										case IconColour:						DisposeCIcon((CIconHandle) info.theIcon );							break;										case IconSuite:						DisposeIconSuite( info.theIcon, TRUE );						break;				}			}		}	}}