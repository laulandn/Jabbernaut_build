/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZScrollerDialogItem.cpp			-- dialog item object that handles generic scrolling*			*			based on an idea by Koen van der Drift***			© 1999, Graham Cox****************************************************************************************************/#include	"ZScrollerDialogItem.h"#include	"MacZoop.h"#include	"ZDialog.h"#include	"ZGrafState.h"#include	"ZScroller.h"CLASSCONSTRUCTOR( ZScrollerDialogItem );// static globals for handling scrollingstatic pascal void			DIScrollProc( ControlHandle ch, short partCode );static ControlActionUPP		gDIScrollbarProc = NewControlActionUPP( DIScrollProc );static ControlHandle		gCurrentDIScrollbar = NULL;#ifdef _LIVE_SCROLLING#if TARGET_API_MAC_CARBONstatic pascal void	DIThumbZProc( ControlHandle theControl, short partCode );static ControlActionUPP     gDIThumbProc = NewControlActionUPP( DIThumbZProc );#elsestatic pascal void	DIThumbZProc();static ThumbActionUPP		gDIThumbProc = NewThumbActionProc( DIThumbZProc );#endif#endif/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZScrollerDialogItem::ZScrollerDialogItem( ZDialog* aDialog, const short item )	: ZDialogItem( aDialog, item ){	classID = CLASS_ZScrollerDialogItem;	canTakeFocus = TRUE;	iType = kCustomDialogItemType;	hasVBar = hasHBar = hasGrowBox = FALSE;	bkColour = gWhite;	hScale = 10;	vScale = 10;	theHBar = theVBar = NULL;	dragMask = cmdKey;}/*--------------------------------***  CONSTRUCTOR  ***---------------------------------*/ZScrollerDialogItem::ZScrollerDialogItem()	: ZDialogItem(){	classID = CLASS_ZScrollerDialogItem;	canTakeFocus = TRUE;	iType = kCustomDialogItemType;	hasVBar = hasHBar = hasGrowBox = FALSE;	bkColour = gWhite;	hScale = 10;	vScale = 10;	theHBar = theVBar = NULL;	dragMask = cmdKey;}/*----------------------------------***  INITITEM  ***----------------------------------*//*	initialise the item from parameter list----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::InitItem( const short paramCount, const long params[] ){	// params are:- 	// param 1 - flags, bit 0 = v bar, 1 = hbar, 2 = growbox (not yet implemented)	// param 2 - scrolling width	// param 3 - scrolling height		if ( paramCount > 0 )	{		hasVBar = ( params[0] & 1 ) == 1;		hasHBar = ( params[0] & 2 ) == 2;		hasGrowBox = ( params[0] & 4 ) == 4;	}		if ( paramCount > 2 )		SetRect( &scrollBounds, 0, 0, params[2], params[1] );	else		SetRect( &scrollBounds, 0, 0, 0, 0 );		MakeScrollbars();}/*--------------------------------***  DRAWITEM  ***---------------------------------*//*	update the item. This sets up the basic drawing and calls DrawContent() to draw theinterior area of the item based on <scrollBounds>----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::DrawItem(){	RgnHandle	saveClip;		GetClip( saveClip = NewRgn());		DrawStdFrame( &bounds );	if ( theHBar )		Draw1Control( theHBar );			if ( theVBar )		Draw1Control( theVBar );			if ( ! hilited )		DrawDisabledBars();			SetOriginToScroll();	EraseRect( &scrollBounds );	DrawContent();		SetOrigin( 0, 0 );	SetClip( saveClip );	DisposeRgn( saveClip );}/*-----------------------------------***  CLICK  ***------------------------------------*//*	handle clicks by scrolling, or passing click to ClickContent()----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::Click( const Point mouse, const short modifiers ){	short			partCode;	short			curValue;	ControlHandle	ch;	ZDialog*		zd;	if ( enabled && hilited )	{		zd = ( ZDialog* ) itsBoss;		if ( canTakeFocus && !focused )		{			// force user to make 2 clicks- this is actually nicer in feel			// since the scroll won't jump unexpectedly						SelfSelect();			return;		}		zd->Focus();		ZGrafState gs;		PrepareForDrawing();		partCode = FindControl( mouse, zd->GetMacWindow(), &ch );		if ( partCode != kControlNoPart )		{			gCurrentDIScrollbar = ch;			curValue = GetControlValue( ch );			if ( partCode == kControlIndicatorPart )			{			#ifdef _LIVE_SCROLLING				cInitValue = GetControlValue( ch );				partCode = TrackControl( ch, mouse, (ControlActionUPP) gDIThumbProc );			#else				partCode = TrackControl( ch, mouse, NULL );			#endif			}			else				partCode = TrackControl( ch, mouse, gDIScrollbarProc );			if ( partCode == kControlIndicatorPart )			{				#ifndef _LIVE_SCROLLING				curValue -= GetControlValue( ch );								if ( ch == theHBar )					Scroll( curValue, 0 );				else					Scroll( 0, curValue );				#else				// after live scrolling, redraw the control so that the thumb hilite is cancelled								SetOrigin( 0, 0 );				ClipRect( &bounds );				Draw1Control( ch );				#endif			}							gCurrentDIScrollbar = NULL;		}		else		{			// send mouse point to interior handler, but map coordinates to the scrollbounds						Point soMouse = mouse;						soMouse.h -= bounds.left;			soMouse.v -= bounds.top;			if ( theHBar )				soMouse.h += GetControlValue( theHBar );							if ( theVBar )				soMouse.v += GetControlValue( theVBar );			// set origin & clip to visible content area			SetOriginToScroll();						if (( modifiers & dragMask ) == dragMask )				ClickScroll( soMouse );			else				ClickContent( soMouse, modifiers );							SetOrigin( 0, 0 );		}		zd->ClickItem( id );	}}/*---------------------------------***  CLICKSCROLL  ***--------------------------------*//*	drags the scroller around as the mouse is dragged. Can be used to implement a "hand" tool----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::ClickScroll( const Point mouse ){	Point	sp, old;	long	delta;	short	ph, pv;		SetCursorShape( HAND_CURSOR_CLOSED );		sp = old = mouse;		while( WaitMouseUp())	{		GetMouse( &sp );				delta = DeltaPoint( old, sp );				if ( delta )		{			GetPosition( &ph, &pv );			ScrollTo( ph + LoWord( delta ), pv + HiWord( delta ));						old.h = sp.h + LoWord( delta );			old.v = sp.v + HiWord( delta );		}	}}/*---------------------------------***  ADJUSTCURSOR  ***-------------------------------*//*	if cmdKey is down, show hand cursor----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::AdjustCursor( const Point mouse, const short modifiers ){	Rect	cr;		SetOrigin( 0, 0 );	GetContentRect( &cr );	if ( PtInRect( mouse, &cr ) && ( modifiers & dragMask ) == dragMask )		SetCursorShape( HAND_CURSOR );	else		ZDialogItem::AdjustCursor( mouse, modifiers );}/*----------------------------------***  ACTIVATE  ***----------------------------------*//*	activates the item----------------------------------------------------------------------------------------*/void    ZScrollerDialogItem::Activate(){    ZDialogItem::Activate();        if ( theVBar )    	HiliteControl( theVBar, 0 );    if ( theHBar )    	HiliteControl( theHBar, 0 );}/*---------------------------------***  DEACTIVATE  ***---------------------------------*//*	deactivates the item----------------------------------------------------------------------------------------*/void    ZScrollerDialogItem::Deactivate(){    ZDialogItem::Deactivate();    	if ( theVBar )		HiliteControl( theVBar, 255 );	if ( theHBar )		HiliteControl( theHBar, 255 );}/*-----------------------------------***  ENABLE  ***-----------------------------------*//*	enables the item----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::Enable( Boolean useHistory ){	ZDialogItem::Enable( useHistory );	if ( theHBar )		ShowControl( theHBar );	if ( theVBar )		ShowControl( theVBar );}/*----------------------------------***  DISABLE  ***-----------------------------------*//*	disables the item----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::Disable( Boolean useHistory ){	HideScrollbars();	DrawDisabledBars();	ZDialogItem::Disable( useHistory );}/*------------------------------------***  HIDE  ***------------------------------------*//*	hides the item----------------------------------------------------------------------------------------*/void		ZScrollerDialogItem::Hide(){	ZDialogItem::Hide();	HideScrollbars();	}/*------------------------------------***  SHOW  ***------------------------------------*//*	shows the item----------------------------------------------------------------------------------------*/void		ZScrollerDialogItem::Show(){	ZDialogItem::Show();		if ( hasHBar )		ShowControl( theHBar );			if ( hasVBar )		ShowControl( theVBar );	}/*------------------------------***  HIDESCROLLBARS  ***--------------------------------*//*	hides the scrollbars, e.g. during a resize operation----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::HideScrollbars(){	if ( theHBar )		HideControl( theHBar );	if( theVBar )		HideControl( theVBar );}/*------------------------------***  MOVESCROLLBARS  ***--------------------------------*//*	positions the scrollbars at the sides of the bounds rect, e.g. when a resize occurs----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::MoveScrollbars(){	// move the scrollbars after the window size has changed. They should be hidden beforehand	// and then shown afterwards. This will only show them if the window is active.		Rect		wPortRect, ctr;	short		w, h, hVal = 0, vVal = 0;		wPortRect = bounds;		if ( theHBar )	{		hVal = GetControlValue( theHBar );		w = wPortRect.right - wPortRect.left - ( hasVBar? kStdScrollbarWidth : 0 ) + 2;		h = kStdScrollbarWidth + 1;				SizeControl( theHBar, w, h );		MoveControl( theHBar, wPortRect.left - 1, wPortRect.bottom - kStdScrollbarWidth );				if ( enabled )			ShowControl( theHBar );				GETCONTROLRECT( theHBar, &ctr );		MZValidWindowRect( DIALOGWINDOW( GetMacDialog()), &ctr );	}		if ( theVBar )	{		vVal = GetControlValue( theVBar );				h = wPortRect.bottom - wPortRect.top - ( hasHBar? kStdScrollbarWidth : 0 ) + 2;		w = kStdScrollbarWidth + 1;				SizeControl(theVBar, w, h );		MoveControl(theVBar, wPortRect.right - kStdScrollbarWidth,  wPortRect.top - 1 );				if ( enabled )			ShowControl( theVBar );				GETCONTROLRECT( theVBar, &ctr );		MZValidWindowRect( DIALOGWINDOW( GetMacDialog()), &ctr );	}		CalculateControlParams();	// recompute maximums		if ( theVBar )		vVal -= GetControlValue( theVBar );			if ( theHBar )		hVal -= GetControlValue( theHBar );		// if the value of the control changed as a result of altering the maximum, we need to	// ensure that the contents are scrolled to the right place.			if ( hVal || vVal )	{		GetContentRect( &wPortRect );		EraseRect( &wPortRect );	}}/*---------------------------------***  SETBOUNDS  ***----------------------------------*//*	resize the item when the parent window resizes----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::SetBounds( Rect* newBounds ){	if ( ! EqualRect( &bounds, newBounds ))	{		SetOrigin( 0, 0 );		HideScrollbars();		ZDialogItem::SetBounds( newBounds );		MoveScrollbars();	}}/*-------------------------------***  SETSCROLLRECT  ***--------------------------------*//*	set the scrollable (logical) drawing area of the item----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::SetScrollRect( const Rect& aBounds ){	scrollBounds = aBounds;	CalculateControlParams();}/*-------------------------------***  SETSCROLLRECT  ***--------------------------------*/void	ZScrollerDialogItem::SetScrollRect( short top, short left, short bottom, short right ){	Rect	r;	SetRect( &r, left, top, right, bottom );	SetScrollRect( r );}/*-------------------------------***  SETSCROLLRECT  ***--------------------------------*/void	ZScrollerDialogItem::SetScrollRect( Point tl, Point br ){	Rect	r;	Pt2Rect( tl, br, &r );	SetScrollRect( r );}/*-----------------------------***  SETORIGINTOSCROLL  ***------------------------------*//*	recomputethe origin of the window to allow for scroll offset, and set up clip region----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::SetOriginToScroll(){	short 	vOrigin;	short 	hOrigin;	Rect r;		hOrigin = -bounds.left;	vOrigin = -bounds.top;	if ( theVBar )		vOrigin += GetControlValue( theVBar );	if ( theHBar )		hOrigin += GetControlValue( theHBar );	SetOrigin( hOrigin, vOrigin );		GetContentRect( &r );	OffsetRect( &r, hOrigin, vOrigin );	ClipRect( &r );}/*------------------------------***  GETCONTENTRECT  ***--------------------------------*//*	return the interior area of the item (excludes scrollbars)----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::GetContentRect( Rect* r ){	*r = bounds;	if ( theVBar )		r->right -= kStdScrollbarWidth;			if ( theHBar )		r->bottom -= kStdScrollbarWidth;}/*---------------------------***  CALCULATECONTROLPARAMS  ***---------------------------*//*	set up control parameters as scrollable area changes or item bounds changes----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::CalculateControlParams(){	// this sets the maximums of the scrollbar to the difference between the content rect and	// the bounds.	Rect	r;	short	hMax,vMax;	SetOrigin( 0, 0 );	GetContentRect( &r );	hMax = scrollBounds.right  - ( r.right - r.left );	vMax = scrollBounds.bottom - ( r.bottom - r.top );	if ( hMax < 0 )		hMax = 0;	if ( vMax < 0 )		vMax = 0;	if ( theHBar )	{		SetControlMaximum( theHBar, hMax );		SetControlMinimum( theHBar, scrollBounds.left );	}	if ( theVBar )	{		SetControlMaximum( theVBar, vMax );		SetControlMinimum( theVBar, scrollBounds.top );	}	// if we have appearance that supports proportional thumbs, set them up. Note that	// in order to link your project with this enabled, you need "ControlsLib"#if USE_PROPORTIONAL_SCROLLBARS || TARGET_API_MAC_CARBON	if ( gMacInfo.hasAppearanceMgr )	{		if ( theHBar )			SetControlViewSize( theHBar, r.right - r.left );		if ( theVBar )			SetControlViewSize( theVBar, r.bottom - r.top );	}#endif}/*-----------------------------------***  SCROLL  ***-----------------------------------*//*	scroll the view by dH and dV pixels----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::Scroll( const short dH, const short dV ){	// scrolls the content rect. This calls scrollrect to move the majority of the	// pixels, then calls DrawContent to fill in the rest.		RgnHandle	updateRgn,saveClip;	Rect		content;	short		fH,fV;		if ( dH == 0 && dV == 0 )		return;		GetContentRect( &content );	updateRgn = NewRgn();		GetClip( saveClip = NewRgn());	ScrollRect( &content, dH, dV, updateRgn );		// offset the update region to allow for the origin		SetOriginToScroll();	GetPosition( &fH, &fV );	OffsetRgn( updateRgn, fH - bounds.left, fV - bounds.top );		// draw the update region		SetClip( updateRgn );	DrawContent();		// restore the zero origin		SetOrigin( 0, 0 );	SetClip( saveClip );		DisposeRgn( saveClip );	DisposeRgn( updateRgn );}/*-------------------------------***  GETPOSITION  ***----------------------------------*//*	get relative position of the view when scrolled----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::GetPosition( short* hPosition, short *vPosition ){	if ( theVBar )		*vPosition = GetControlValue( theVBar );	else		*vPosition = 0;			if ( theHBar )		*hPosition = GetControlValue( theHBar );	else		*hPosition = 0;}/*----------------------------------***  SCROLLTO  ***----------------------------------*//*	scroll to a specific offset position in the view----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::ScrollTo( const short hPosition, const short vPosition ){	Rect	content;	short	fH, fV, pH, pV;		GetPosition( &fH, &fV );	FocusBoss();		if ( theHBar && ( GetControlMaximum( theHBar ) > GetControlMinimum( theHBar )))		SetControlValue( theHBar, hPosition );			if ( theVBar && ( GetControlMaximum( theVBar ) > GetControlMinimum( theVBar )))		SetControlValue( theVBar, vPosition );		GetPosition( &pH, &pV );	Scroll( fH - pH, fV - pV );		GetContentRect( &content );	SetOriginToScroll();}/*------------------------------***  MAKESCROLLBARS  ***--------------------------------*//*	create the controls for the scrollbars and position them----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::MakeScrollbars(){	// create the scrollbar controls initially. This is done by calling NewControl. We	// figure out the control rects from the window portrect.		Rect		barRect;	Rect		wPortRect;	WindowPtr	hostWindow;		wPortRect = bounds;	hostWindow = ((ZDialog*) itsBoss)->GetMacWindow();		if ( hasHBar )	{		barRect = wPortRect;		barRect.right -= ( hasVBar? kStdScrollbarWidth : 0 ) - 1;		barRect.top = barRect.bottom - kStdScrollbarWidth - 1;		barRect.left -= 1;		OffsetRect(&barRect, 0, 1 );				FailNIL( theHBar = NewControl( hostWindow, &barRect, NULL, FALSE, 0, 0, 0, scrollBarProc, (long) this));		SetControlReference( theHBar, (long) this );		HiliteControl( theHBar, 255 );	}		if ( hasVBar )	{		barRect = wPortRect;		barRect.bottom -= ( hasHBar? kStdScrollbarWidth : 0 ) - 1;		barRect.left = barRect.right - kStdScrollbarWidth - 1;		barRect.top -= 1;		OffsetRect( &barRect, 1, 0 );				FailNIL(theVBar = NewControl( hostWindow, &barRect, NULL, FALSE, 0, 0, 0, scrollBarProc, (long) this));		SetControlReference( theVBar, (long) this );		HiliteControl( theVBar, 255 );	}		CalculateControlParams();}/*-------------------------------***  SCROLLHANDLER  ***--------------------------------*//*	callback function handles the scroll when called by control action procs etc.----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::ScrollHandler( const ControlHandle aCtl, const short partCode ){	// this actually peforms the scroll of the content rect		short		curValue, page;	Boolean		hitIsVertical;	Rect		content;	RgnHandle	saveClip = NewRgn();		curValue = GetControlValue( aCtl );	GetClip( saveClip );		// are we scrolling the horizontal or the vertical bar? Find out by comparing	// the control with one of our data members		hitIsVertical = ( aCtl == theVBar );		// calculate the page amount. This is the height or width of the window less one	// scale amount.			GetContentRect( &content );		if ( hitIsVertical )		page = content.bottom - content.top - vScale;	else		page = content.right - content.left - hScale; 			switch ( partCode )	{		case kControlUpButtonPart:			SetControlValue( aCtl, GetControlValue(aCtl) - (hitIsVertical? vScale : hScale ));			break;				case kControlDownButtonPart:			SetControlValue( aCtl, GetControlValue(aCtl) + (hitIsVertical? vScale : hScale ));			break;				case kControlPageUpPart:			SetControlValue( aCtl, GetControlValue(aCtl) - page );			break;				case kControlPageDownPart:			SetControlValue( aCtl, GetControlValue(aCtl) + page );			break;				case kControlIndicatorPart:			// called when live scrolling the thumb. Here we need to calculate where the mouse			// is and figure out what the correct control value would be. If the mouse goes outside the			// control too far, the control "springs back" to its previous value, stored in cInitValue.			// we have to keep control here until the mouse is released otherwise the alterations to			// the control value cause problems for the thumb dragging default behaviour if we allow			// control back every time we are called. Yet another annoying toolbox anomaly...					#ifdef _LIVE_SCROLLING						Rect	cr, slopR;			long	cRange, cVal;			Point	curMouse, lastMouse;						GetMouse( &lastMouse );						GETCONTROLRECT( aCtl, &cr );			slopR = cr;			InsetRect( &slopR, -32, -32 );						if ( hitIsVertical )			{				cr.top += kWidthOfScrollArrow;				cr.bottom -= kWidthOfScrollArrow;			}			else			{				cr.left += kWidthOfScrollArrow;				cr.right -= kWidthOfScrollArrow;			}						cRange = GetControlMaximum( aCtl ) - GetControlMinimum( aCtl );						while ( StillDown())			{				GetMouse( &curMouse );								if ( DeltaPoint( curMouse, lastMouse ))				{					lastMouse = curMouse;										// calculate value based on mouse location										if ( PtInRect( curMouse, &slopR ))					{						if ( hitIsVertical )							cVal = ((long)( curMouse.v - cr.top ) * cRange ) / (long)( cr.bottom - cr.top );						else							cVal = ((long)( curMouse.h - cr.left ) * cRange ) / (long)( cr.right - cr.left );												SetControlValue( aCtl, GetControlMinimum( aCtl ) + cVal );					}					else						SetControlValue( aCtl, cInitValue );		// "spring" back...											curValue -= GetControlValue( aCtl );										ClipRect( &content );										if ( hitIsVertical )						Scroll( 0, curValue );					else						Scroll( curValue, 0 );											SetClip( saveClip );					curValue = GetControlValue( aCtl );				}			}						// the control manager will attempt to draw the thumb at this point. We'd rather it didn't			// since we've already moved it. Thus we empty the clip region. A hack, but it works...						SetRect( &cr, 0, 0, 0, 0 );			ClipRect( &cr );					#endif			break;	}		if ( partCode != kControlIndicatorPart )	{		curValue -= GetControlValue( aCtl );				ClipRect( &content );				if ( hitIsVertical )			Scroll( 0, curValue );		else			Scroll( curValue, 0 );					SetClip( saveClip );	}		DisposeRgn( saveClip );}/*-----------------------------***  DRAWDISABLEDBARS  ***-------------------------------*//*	draw the scrollbar areas when the bars are hidden in the correct appearance----------------------------------------------------------------------------------------*/void	ZScrollerDialogItem::DrawDisabledBars(){	if ( ! hilited )	{		Rect	ctr;				PenNormal();		RGBForeColor( &gDarkGray );		RGBBackColor( &gVeryLightGray );		ClipRect( &bounds );				if ( theVBar )		{			GETCONTROLRECT( theVBar, &ctr );			EraseRect( &ctr );		}				if ( theHBar )		{			GETCONTROLRECT( theHBar, &ctr );			EraseRect( &ctr );		}				if ( theVBar )		{				MoveTo( bounds.right - kStdScrollbarWidth, bounds.top );			LineTo( bounds.right - kStdScrollbarWidth, bounds.bottom - 1 );		}				if ( theHBar )		{			MoveTo( bounds.left, bounds.bottom - kStdScrollbarWidth );			LineTo( bounds.right - 1, bounds.bottom - kStdScrollbarWidth );		}				RGBBackColor( &bkColour );		RGBForeColor( &fgColour );	}}#pragma mark -//------------------------------------------------------static pascal void	DIScrollProc( ControlHandle ch, short partCode ){	ZScrollerDialogItem*	zi = ( ZScrollerDialogItem* ) GetControlReference( ch );	try	{		if ( zi )			zi->ScrollHandler( ch, partCode );	}	catch(...)	{		// do NOT propagate!	}}#ifdef _LIVE_SCROLLING#if TARGET_API_MAC_CARBONstatic pascal void  DIThumbZProc( ControlHandle theControl, short partCode )#elsestatic pascal void	DIThumbZProc()#endif{	if ( gCurrentDIScrollbar )	{		ZScrollerDialogItem*	zs = ( ZScrollerDialogItem*) GetControlReference( gCurrentDIScrollbar );				try		{			if ( zs )				zs->ScrollHandler( gCurrentDIScrollbar, kControlIndicatorPart );		}		catch( ... )		{		}	}}#endif