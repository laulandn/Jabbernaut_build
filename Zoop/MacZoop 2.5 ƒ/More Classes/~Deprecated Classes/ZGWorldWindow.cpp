/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZGWorldWindow.cpp	-- a window with an offscreen GWorld. This can open PICT*									images into an offscreen port and correctly uses the*									palette manager, etc******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZGWorldWindow.h"#include	"ZGWorld.h"#include	"ZUndoIPTask.h"#include	"MacZoop.h"#include	"ZGIFFile.h"#include	"ZJPEGFile.h"#include	"ZMouseTracker.h"#include	<Palettes.h>#include	<PictUtils.h>#include	<drag.h>CLASSCONSTRUCTOR( ZGWorldWindow );/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZGWorldWindow::ZGWorldWindow( ZCommander* aBoss, const short windID )	: ZPictWindow( aBoss, windID ){	classID = CLASS_ZGWorldWindow;		itsOffscreen = NULL;	printable = TRUE;	scale = 100;	fatBitsGrid = TRUE;		SetMaxUndoLevels( 4 );}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZGWorldWindow::ZGWorldWindow()	: ZPictWindow(){	classID = CLASS_ZGWorldWindow;		itsOffscreen = NULL;	printable = TRUE;	scale = 100;	fatBitsGrid = FALSE;	SetMaxUndoLevels( 4 );}/*--------------------------------***  DESTRUCTOR  ***---------------------------------*/ZGWorldWindow::~ZGWorldWindow(){	if (itsOffscreen)		ForgetObject(itsOffscreen);}/*-------------------------------***  DRAWCONTENT  ***----------------------------------*//*	render the GWorld into the window----------------------------------------------------------------------------------------*/void	ZGWorldWindow::DrawContent(){	Rect		dr, br, sr;	RgnHandle	maskRgn = NULL, temp;		if ( itsOffscreen )	{		GetBounds( &br );		itsOffscreen->GetSize( &sr );		if ( isPrinting )		{			dr = sr;			OffsetRect( &dr, -dr.left, -dr.top );		}		else		{			dr = br;			if ( fatBitsGrid && ( scale > 400 ))			{				maskRgn = NewRgn();				CalcFatBitsGridMask( dr, maskRgn );								// if the region is too complex, discard it								if ( EmptyRgn( maskRgn ))				{					DisposeRgn( maskRgn );					maskRgn = NULL;				}			}		}				SetPortBlackWhite();		itsOffscreen->CopyOut( CURRENTPORTPIXMAP, &sr, &dr, srcCopy + ditherCopy, maskRgn );				if ( maskRgn )			DisposeRgn( maskRgn );						// if window bigger than image, erase the remainder                FailNIL( temp = NewRgn());        GETCURRENTPORTVISRGN( temp );        		RectRgn( gUtilRgn, &dr );		DiffRgn( temp, gUtilRgn, gUtilRgn );		EraseRgn( gUtilRgn );				DisposeRgn( temp );	}	else		ZPictWindow::DrawContent();}/*-----------------------------***  HANDLECOMMAND  ***----------------------------------*//*	handle the "Invert" command----------------------------------------------------------------------------------------*/void	ZGWorldWindow::HandleCommand( const long theCommand ){	switch ( theCommand )	{		case kCmdFlipHorizontal:		case kCmdFlipVertical:		case kCmdInvert:			if ( itsOffscreen )			{				ZUndoIPTask*	aTask;				Str63			taskStr;				short			taskID = undoInvert;								if ( theCommand == kCmdFlipHorizontal )					taskID = undoFlipHorizontal;				else					if ( theCommand == kCmdFlipVertical )						taskID = undoFlipVertical;																// make a task to actually handle the command. This allows it				// to be undoable.								GetIndString( taskStr, kIPTasksStrResID, taskID );				FailNIL( aTask = new ZUndoIPTask( taskStr, this, taskID ));								// do the task initially								aTask->Do();								// send the task up to the app so that it becomes the current				// undo menu item. Also marks the document as dirty.								SetTask( aTask );			}			break;				case kCmdZoomIn:			ZoomToCentre( FALSE );			break;				case kCmdZoomOut:			ZoomToCentre( TRUE );			break;					case kCmdShowHideGrid:			fatBitsGrid = !fatBitsGrid;			if ( fatBitsGrid && ( scale > 400 ))			{				Rect	br;								Focus();				SetOriginToScroll();				GetBounds( &br );								CalcFatBitsGridMask( br, NULL );			}			else				PostRefresh();			break;				default:			ZPictWindow::HandleCommand( theCommand );			break;	}}/*-------------------------------***  UPDATEMENUS  ***----------------------------------*//*	enable the "Invert" command----------------------------------------------------------------------------------------*/void	ZGWorldWindow::UpdateMenus(){	if (itsOffscreen)	{		gMenuBar->EnableCommand( kCmdInvert );		gMenuBar->EnableCommand( kCmdCopy );		gMenuBar->EnableCommand( kCmdZoomIn );		gMenuBar->EnableCommand( kCmdZoomOut );		gMenuBar->EnableCommand( kCmdFlipHorizontal );		gMenuBar->EnableCommand( kCmdFlipVertical );		gMenuBar->EnableCommand( kCmdShowHideGrid );		gMenuBar->CheckCommand( kCmdShowHideGrid, fatBitsGrid );	}		ZPictWindow::UpdateMenus();}/*---------------------------------***  DOCOPY  ***-------------------------------------*//*	put the image on the clipboard as a PICT----------------------------------------------------------------------------------------*/void	ZGWorldWindow::DoCopy(){	// remove any existing picture		FailNIL(itsOffscreen);	if (thePicture)		KillPicture(thePicture);		// make a new one from the image		FailNIL(thePicture = itsOffscreen->MakePicture());		try	{		// call the inherited method from ZPictWindow to do the work				ZPictWindow::DoCopy();	}	catch(ZoopError err)	{		KillPicture(thePicture);		thePicture = NULL;		throw err;	}		// clean up		KillPicture(thePicture);	thePicture = NULL;}/*--------------------------------***  DOPASTE  ***-------------------------------------*//*	paste any PICT on the clipboard as a new GWorld----------------------------------------------------------------------------------------*/void	ZGWorldWindow::DoPaste(){	// make an empty handle for putting the picture in		thePicture = (PicHandle) NewHandle(0);		// call ZPictWindow to copy the clipboard contents		ZPictWindow::DoPaste();		// convert to a GWorld		if (thePicture)	{		try		{			MakeGWorld();					KillPicture(thePicture);			thePicture = NULL;						Focus();			Draw();		}		catch(...)		{			// if MakeGWorld failed, it will have thrown an exception. In			// this case we do NOT propagate it, but instead let the subclass			// handle the picture directly		}	}}/*-----------------------------***  ACCEPTSFLAVOUR  ***---------------------------------*//*	tell drag manager what we can receive- PICT clippings and files of type PICT----------------------------------------------------------------------------------------*/Boolean	ZGWorldWindow::AcceptsFlavour( const OSType aFlavour ){	return ( aFlavour == 'PICT' ||			 aFlavour == 'hfs ');}/*-----------------------------------***  DROP  ***-------------------------------------*//*	handle drag manager drops of picture clippings, etc----------------------------------------------------------------------------------------*/void	ZGWorldWindow::Drop( const OSType flavour, const Ptr data, const long dataSize, const DragReference theDrag ){	// <data> points to a pict- make a real picture handle by copying it		if (flavour == 'PICT')	{		FailOSErr(PtrToHand(data, (Handle*) &thePicture, dataSize));				// make a new GWorld from the picture				MakeGWorld();				short	sm = ( 4 * scale ) / 100;		SetScrollAmount( sm, sm );				// get rid of the picture- no longer needed				KillPicture(thePicture);		thePicture = NULL;	}	else	{		if ( flavour == 'hfs ' )		{			HFSFlavor*	fSpec;						fSpec = (HFSFlavor*) data;						if ( fSpec->fileType == 'PICT' ||				 fSpec->fileType == 'JPEG' ||				 fSpec->fileType == 'JFIF' ||				 fSpec->fileType == 'GIFf' )			{				// it's a file we can open, so try and open it already!						SetFile( fSpec->fileSpec );				OpenFile( fSpec->fileType );			}			else				FailOSErr( paramErr );	// not a file we can open		}	}	// update everything		Focus();	Draw();}/*---------------------------------***  OPENFILE  ***------------ ----------------------*//*	open a PICT, GIF or JPEG file and make a GWorld out of it----------------------------------------------------------------------------------------*/void	ZGWorldWindow::OpenFile( const OSType fType, Boolean isStationery ){	Rect		r = { 0, 0, 4, 4 };	ZGWorld*	temp;		switch ( fType )	{		case 'PICT':			ZPictWindow::OpenFile( fType, isStationery );						// if OK, then make a GWorld from the picture						if ( thePicture )			{				try				{					MakeGWorld();									KillPicture( thePicture );					thePicture = NULL;				}				catch( ZoopError err )				{					// if MakeGWorld failed, it will have thrown an exception. In					// this case we do NOT propagate it, but instead let the subclass					// handle the picture directly				}			}			break;					case 'JPEG':		case 'JFIF':		{			ZJPEGFile	jf( macFile );						FailNIL( temp = new ZGWorld( r, 1 ));						try			{				jf.Open();				jf.Read( temp );								if ( itsOffscreen )					ForgetObject( itsOffscreen );									itsOffscreen = temp;				CalcBoundsRect( &r );				SetBounds( r );				ZScroller::OpenFile( fType, isStationery );			}			catch( ZoopError err )			{				ForgetObject( temp );				throw err;			}		}		break;					case 'GIFf':		{			ZGIFFile	gf( macFile );						FailNIL( temp = new ZGWorld( r, 1 ));						try			{				gf.Open();				gf.Read( temp );								if ( itsOffscreen )					ForgetObject( itsOffscreen );									itsOffscreen = temp;				CalcBoundsRect( &r );				SetBounds( r );				ZScroller::OpenFile( fType, isStationery );			}			catch( ZoopError err )			{				ForgetObject( temp );				throw err;			}		}		break;	}}/*----------------------------***  SETPICTUREFROMRESOURCE  ***--------------------------*//*	set image from a PICT resource----------------------------------------------------------------------------------------*/void	ZGWorldWindow::SetPictureFromResource( const short pictResID ){	ZPictWindow::SetPictureFromResource( pictResID );	if ( thePicture )	{		try		{			MakeGWorld();					KillPicture( thePicture );			thePicture = NULL;		}		catch( ZoopError err )		{			// if MakeGWorld failed, it will have thrown an exception. In			// this case we do NOT propagate it, but instead let the subclass			// handle the picture directly		}	}}/*--------------------------------***  INSTALLIMAGE  ***--------------------------------*//*	set the window's image from various data types----------------------------------------------------------------------------------------*/void	ZGWorldWindow::InstallImage( PicHandle aPic ){	FailNILParam( aPic );		if ( thePicture )		KillPicture( thePicture );			thePicture = aPic;		MakeGWorld();		KillPicture( thePicture );	thePicture = NULL;}/*--------------------------------***  INSTALLIMAGE  ***--------------------------------*/void	ZGWorldWindow::InstallImage( const short picResourceID ){	SetPictureFromResource( picResourceID );}/*--------------------------------***  INSTALLIMAGE  ***--------------------------------*/void	ZGWorldWindow::InstallImage( ZGWorld* aGWorld ){	this->SetGWorld( aGWorld );		Rect	r;		CalcBoundsRect( &r );	SetBounds( r );}/*---------------------------------***  SAVEFILE  ***------------ ----------------------*//*	save a PICT file from the offscreen GWorld----------------------------------------------------------------------------------------*/void	ZGWorldWindow::SaveFile(){	// if the offscreen exists, kill any existing picture and make a new one. Otherwise	// use whatever picture is there.		if ( itsOffscreen )	{		if ( thePicture )			KillPicture( thePicture );		FailNIL( thePicture = itsOffscreen->MakePicture());	}	// call our ancestor to save the picture to disk		try	{		ZPictWindow::SaveFile();	}	catch( ZoopError err )	{		if ( itsOffscreen )		{			KillPicture( thePicture );			thePicture = NULL;		}				throw err;	}		// get rid of the picture if there's an offscreen image	// - we don't need it any longer		if ( itsOffscreen )	{		KillPicture( thePicture );		thePicture = NULL;	}}/*----------------------------------***  GETNAME  ***-----------------------------------*//*	this window stores the name in the filespec, since the window title has extra info.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::GetName( Str255 name ){	CopyPString( macFile.name, name );}/*---------------------------------***  SETTITLE  ***-----------------------------------*//*	the window title is the file name + the zoom factor as a percentage.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::SetTitle( Str255 name ){	Str63	wtName;	Str15	zfStr;		CopyPString( name, macFile.name );	CopyPString( name, wtName );		NumToString( scale, zfStr );	ConcatPStrings( wtName, "\p @");	ConcatPStrings( wtName, zfStr );	ConcatPStrings( wtName, "\p%" );		SetWTitle( GetMacWindow(), wtName );}	/*--------------------------------***  MAKEGWORLD  ***----------------------------------*//*	construct the GWorld from the picture in <thePicture>----------------------------------------------------------------------------------------*/void	ZGWorldWindow::MakeGWorld(){	Rect	aSize;		FailNILParam( thePicture );		if ( itsOffscreen )		ForgetObject( itsOffscreen );				FailNIL( itsOffscreen = new ZGWorld( thePicture ));		CalcBoundsRect( &aSize );	SetBounds( aSize );		MakePaletteForWindow();}/*--------------------------------***  SETGWORLD  ***-----------------------------------*//*	set the window to manage a new GWorld----------------------------------------------------------------------------------------*/void	ZGWorldWindow::SetGWorld( ZGWorld* aGW ){	itsOffscreen = aGW;	SendMessage( kMsgGWorldChanged, (void*) itsOffscreen );}/*---------------------------***  MAKEPALETTEFORWINDOW  ***-----------------------------*//*	install a palette in the window that best represents the image on a CLUT device.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::MakePaletteForWindow(){	short			gwDepth;	CTabHandle		aCTab;	PaletteHandle	aPalette;		FailNIL( itsOffscreen );		gwDepth = itsOffscreen->GetDepth();		if ( gwDepth > 8 )	{		// for a direct image, there is no colour table immediately available, so we		// need to make one that has the best colours. We can do this by calling the		// Picture Utilities package to give us a reasonable table.			PictInfo		pi;		PixMapHandle	pp;				pp = itsOffscreen->GetPixMap( TRUE );		// lock the GWorld as well				try		{			FailOSErr( GetPixMapInfo( pp, &pi, returnPalette + suppressBlackAndWhite, 254, systemMethod, 0 ));		}		catch( ZoopError err )		{			itsOffscreen->Unlock();						throw err;		}		itsOffscreen->Unlock();		aPalette = pi.thePalette;	}	else	{		// the image is already an indexed image, so use its colour table			aCTab = itsOffscreen->GetColours();				// make a palette from the CTable			aPalette = NewPalette( 256, aCTab, pmTolerant, 0 );		}		// install the palette		SetPalette( GetMacWindow(), aPalette, TRUE );}/*---------------------------------***  SETSCALE  ***-----------------------------------*//*	set the zooming factor for the window. <aScale> is in percent----------------------------------------------------------------------------------------*/void	ZGWorldWindow::SetScale( const short aScale ){	short	sc = MAX( 25, MIN( aScale, 3200 ));		if ( sc != scale )	{		//scale can be from 25% to 3,200%				scale = sc;			Rect	br;				CalcBoundsRect( &br );		SetBounds( br );		// scroll amounts should be factored to give consistent scroll rates				short	sm = ( 4 * scale ) / 100;		SetScrollAmount( sm, sm );				SetTitle( macFile.name );	}}/*-------------------------------***  ZOOMTOPOINT  ***----------------------------------*//*	zoom the display so that it remains centred on <clickPt>. Useful for implmenting amagnifier tool.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::ZoomToPoint( const Point clickPt, Boolean isZoomOut ){	// zoom in or out so that the passed point is centred in the window is possible. This is	// the basis of a "magnifying" tool for doing zooming.		Rect	cont, obr, br;	short	scrollH, scrollV, newScale;	Point	cPt;		Focus();	GetContentRect( &cont );	GetBounds( &obr );		newScale = isZoomOut? ( scale >> 1 ) : ( scale << 1 );		// if drag manager is available, perform a zoom effect		newScale = MAX( 25, MIN( newScale, 3200 ));		if ( newScale != scale )	{		if ( gMacInfo.hasDragManager )		{			Rect	zSrc, zDest;			short	dh, dv;						GetContentRect( &zDest );			Pt2Rect( clickPt, clickPt, &zSrc );			InsetRect( &zSrc, -2, -2 );			GetPosition( &dh, &dv );			OffsetRect( &zSrc, -dh, -dv );						LocalToGlobal( &topLeft( zSrc ));			LocalToGlobal( &botRight( zSrc ));			LocalToGlobal( &topLeft( zDest ));			LocalToGlobal( &botRight( zDest ));						if ( isZoomOut )				FailOSErr( ZoomRects( &zDest, &zSrc, 10, kZoomDecelerate ));			else				FailOSErr( ZoomRects( &zSrc, &zDest, 10, kZoomAccelerate ));		}				SetScale( newScale );		GetBounds( &br );				cPt = clickPt;		MapPt( &cPt, &obr, &br );				scrollH = cPt.h - (( cont.right - cont.left ) / 2 );		scrollV = cPt.v - (( cont.bottom - cont.top ) / 2 );				SetControlValue( theHBar, scrollH );		SetControlValue( theVBar, scrollV );				if ( fatBitsGrid )			EraseRect( &cont );		SetOriginToScroll();		DrawContent();	}	else		SysBeep( 1 );	// hit the buffers!}/*-------------------------------***  ZOOMTOCENTRE  ***---------------------------------*//*	zoom so that the current centre of the view remains in the centre, Useful for a menu-based "zoom" command.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::ZoomToCentre( Boolean isZoomOut ){	Rect	br;	Point	clickPt;		GetContentRect( &br );		clickPt.h = ( br.left + br.right ) / 2;	clickPt.v = ( br.top + br.bottom ) / 2;		clickPt.h += leftMargin + GetControlValue( theHBar );	clickPt.v += topMargin + GetControlValue( theVBar );		ZoomToPoint( clickPt, isZoomOut );}/*------------------------------***  CALCSOURCERECT  ***--------------------------------*//*	returns the rect corresponding to the current content, but scaled back to the source imagewhen the view is zoomed. Take care with this- it may be subject to roundoff errors.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::CalcSourceRect( Rect* aSrcRect ){	// computes the rect that is the corresponding area in the offscreen world that is	// displayed in the aperture of the window.		Rect	ap, br, r;		if ( itsOffscreen )	{		CalcBoundsRect( &br );		GetContentRect( &ap );		itsOffscreen->GetSize( &r );		MapRect( &ap, &br, &r );	}	else		SetRect( &ap, 0, 0, 0, 0 );			*aSrcRect = ap;}/*------------------------------***  CALCBOUNDSRECT  ***--------------------------------*//*	compute and retrurn the bounds rect for the image. This should be called when the size orzooming factor is changed.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::CalcBoundsRect( Rect* aBoundsRect ){	Rect	r;		if ( itsOffscreen )	{		itsOffscreen->GetSize( &r );				OffsetRect( &r, -r.left, -r.top );		r.right = ((long) r.right * (long) scale ) / 100;		r.bottom = ((long) r.bottom * (long) scale ) / 100;	}	else		GetBounds( &r );			*aBoundsRect = r;}/*----------------------------***  CALCFATBITSGRIDMASK  ***-----------------------------*//*	this computes and draws the "fatbits" lines which are drawn after the image is renderedif zoomed up sufficiently. This can do two things- either draw the lines directly, orform a region from them. In the latter case, you can use the region as a mask argumentto CopyBits to blit the "fatbits" effect in one go.----------------------------------------------------------------------------------------*/void	ZGWorldWindow::CalcFatBitsGridMask( const Rect& destRect, RgnHandle maskRgn ){	short		x, y, ff;	Rect		cr;	ZGWorld*	mask = NULL;	CGrafPtr	sp;	GDHandle	sg;		ff = scale / 100;	// display pixels per pixel of projected image	GetContentRect( &cr );	PenNormal();	if ( maskRgn )	{		FailNIL( mask = new ZGWorld( cr, 1 ));			mask->SetPortToGW( &sp, &sg );		mask->Lock();	}	else		ForeColor( whiteColor );		for( x = destRect.left; x < destRect.right; x += ff )	{		if ( x >= cr.left && x <= cr.right )		{			MoveTo( x, destRect.top );			LineTo( x, destRect.bottom );		}	}		for( y = destRect.top; y < destRect.bottom; y += ff )	{		if ( y >= cr.top && y <= cr.bottom )		{			MoveTo( destRect.left, y );			LineTo( destRect.right, y );		}	}		if ( mask )	{		// invert and convert to region		PixMapHandle	pp = mask->GetPixMap();				mask->Invert();		BitMapToRegion( maskRgn, (BitMap*) *pp );				::SetGWorld( sp, sg );		ForgetObject( mask );	}		ForeColor( blackColor );}/*-------------------------------***  WRITETOSTREAM  ***--------------------------------*//*	write the window to a stream----------------------------------------------------------------------------------------*/void	ZGWorldWindow::WriteToStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZScroller::WriteToStream( aStream );		aStream->WriteShort( scale );	aStream->WriteChar( fatBitsGrid );	aStream->WriteObject( itsOffscreen );		if ( itsOffscreen == NULL )		aStream->WriteHandle((Handle) thePicture );#endif}/*------------------------------***  READFROMSTREAM  ***--------------------------------*//*	read the window entirely from a stream----------------------------------------------------------------------------------------*/void	ZGWorldWindow::ReadFromStream( ZStream* aStream ){#if _MACZOOP_STREAMS	ZScroller::ReadFromStream( aStream );		aStream->ReadShort( &scale );	aStream->ReadChar((char*) &fatBitsGrid );	itsOffscreen = (ZGWorld*) aStream->ReadObject();		if ( itsOffscreen == NULL )	{		aStream->ReadHandle((Handle*) &thePicture );			// if OK, then make a GWorld from the picture				if ( thePicture )		{			try			{				MakeGWorld();							KillPicture( thePicture );				thePicture = NULL;			}			catch( ZoopError err )			{				// if MakeGWorld failed, it will have thrown an exception. In				// this case we do NOT propagate it, but instead let the subclass				// handle the picture directly			}		}	}#endif}