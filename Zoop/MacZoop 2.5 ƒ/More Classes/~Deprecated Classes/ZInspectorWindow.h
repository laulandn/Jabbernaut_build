/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZInspectorWindow.h		-- inspector window object******			© 1998, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZINSPECTORWINDOW__#define	__ZINSPECTORWINDOW__#include	"ZScroller.h"DEFINECLASSID( ZInspectorWindow, 'zisp' );class	ZInspectorWindow	: public ZScroller{public:	ZInspectorWindow( ZCommander* aBoss, const short windID, Boolean hBar = FALSE, Boolean vBar = FALSE )		: ZScroller( aBoss, windID, hBar, vBar ) { classID = CLASS_ZInspectorWindow; };		virtual ~ZInspectorWindow() {};		virtual void	InitZWindow();	virtual void	ReceiveMessage( ZComrade* aSender, ZoopMessage aMsg, UntypedPtr msgData );	protected:		virtual Boolean	AcceptWindow( ZWindow* aWindow ) { return TRUE; };		virtual void	WindowBecomeActive( ZWindow* aWindow ) {};	virtual void	WindowBecomeInactive( ZWindow* aWindow ) {};	virtual void	WindowBecomeVisible( ZWindow* aWindow ) {};	virtual void	WindowBecomeHidden( ZWindow* aWindow ) {};	virtual void	WindowCreated( ZWindow* aWindow ) {};	virtual void	WindowDestroyed( ZWindow* aWindow ) {};};/*An inspector window is a useful way to provide some kind of context-sensitive information tothe user. Normally an inspector will float but this is not required. This listens for messagessent by the window manager and dispatches the activities to the handler methods which youcan override to take appropriate action. Note that ALL window activities are passed through-your subclass will need to do whatever to ignore messages from windows it's not interested in.The AcceptWindow() method is the best place to do this filtering. The default method passesall windows.Commonly, an inspector is used to report state data or activity in a particular window type. Thebest way to set this up is to override the WindowBecomeActive() method and if the window isone you want to monitor, to become a listener of it. Override ReceiveMessage() to respond tothat window's particular messages, remembering to call the inherited ReceiveMessage() foranything you aren't interested in, so normal inspector behaviour is maintained. In theWindowBecomeInactive() method, decouple the inspector from the window using StopListeningTo().Tip: record the state data locally and post a refresh. Use the DrawContent() method to updatethe state of the inspector window.*/#endif