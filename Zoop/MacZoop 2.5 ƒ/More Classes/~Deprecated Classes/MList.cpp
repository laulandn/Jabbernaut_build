/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			MList.cpp			-- list manager object mix-in**			****			© 1999, Graham Cox****************************************************************************************************/#include	"MList.h"#include	"MacZoop.h"#include	"ZWindow.h"#include	"ZGrafState.h"#if !TARGET_API_MAC_CARBON#include	"xDEFJump.h"#include    "CarbonList.h"#endif#include    <lists.h>// global procedure is used in ZListDialogItem to handle searching lists for matching// user's keypresses to list items.static pascal short	FindCellCompProc( Ptr dataA, Ptr dataB, short lenA, short lenB );ListSearchUPP	gFindCellCompUPP = NewListSearchUPP( FindCellCompProc );// static function that calls us back from the custom LDEF stub we install. This allows the// drawing of the list cells to be overridden like any other method. Cool, huh?static pascal void	LMListDefVectorProc(	short message,											Boolean selected,											Rect* cellRect,											Cell theCell,											short dataOffset,											short dataLen,											ListHandle theList);											static pascal Boolean	LMListClickLoopProc();static ListHandle	gClickList = NULL;/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/MList::MList(){	owner = NULL;	lastSel = NO_SELECTION;	lh = NULL;		// get the key threshold. This is double the delay time	// set by the user for "delay until repeat" in the global	// keyboard control panel, or two seconds, whichever is shorter.		fThresh = MIN( 120, LMGetKeyThresh() * 2 );	searchStr[0] = 0;	lastKeyTime = 0;	mlViewer = NULL;	usingCustomLDEF = FALSE;	keySearchEnable = TRUE;	autoCellHsize = FALSE;}/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/MList::MList( ZWindow* anOwner ){	FailNILParam( owner = anOwner );	lastSel = NO_SELECTION;	lh = NULL;	mlViewer = NULL;	fThresh = MIN( 120, LMGetKeyThresh() * 2 );	searchStr[0] = 0;	lastKeyTime = 0;	keySearchEnable = TRUE;	usingCustomLDEF = FALSE;	autoCellHsize = FALSE;}/*---------------------------------***  DESTRUCTOR  ***----------------------------------*/MList::~MList(){#if TARGET_API_MAC_CARBON    if ( lh )        LDispose( lh );#else	Handle	temp = (*lh)->listDefProc;		if ( lh )		LDispose( lh );			if ( usingCustomLDEF && temp )		DisposeHandle( temp );#endif			if ( mlViewer )		ForgetObject( mlViewer );}/*----------------------------------***  MLINIT  ***------------------------------------*//*initialise the list according to the passed parameters	----------------------------------------------------------------------------------------*/void	MList::MLInit(  Rect* bounds,						Point cellSize,						short initialRows,						short initialColumns,						Boolean vScroll,						Boolean	hScroll,						short procID ){	Rect	dataBounds, r;	Boolean	grow;		owner->Focus();		SetRect( &dataBounds, 0, 0, initialColumns, initialRows );		r = *bounds;		if ( vScroll )		r.right -= kStdScrollbarWidth;			if ( hScroll )		r.bottom -= kStdScrollbarWidth;			grow = ( hScroll || vScroll );		// for a 1-column list, we allow the cellsize to automatically resize to fit	// the available width if the list is resized. You can change this flag for	// multi-column lists or to prevent this behaviour.		autoCellHsize = ( initialColumns == 1 );#if TARGET_API_MAC_CARBON    // in carbon, we always attach a callback if the proc ID is 0. If the proc ID is not 0,    // you have to register the LDEF code using some so far unpublished method that Apple    // will presumably provide in Carbon. At the moment, the way forward for LDEFs is not    // terribly clear from the headers. However, since this class makes creating custom lists    // very trivial, it may be better to say that, for MacZoop, using a custom LDEF may not    // be supported at all in future, and you can and should attach a MListViewer to implement    // that functionality. That approach is actually much easier anyway- please use it!    if ( procID == 0 )    {        ListDefSpec     ldSpec;                ldSpec.defType = kListDefUserProcType;        ldSpec.u.userProc = NewListDefUPP( LMListDefVectorProc );        FailOSStatus( CreateCustomList( &r, &dataBounds, cellSize, &ldSpec, owner->GetMacWindow(), TRUE, grow, hScroll, vScroll, &lh ));             usingCustomLDEF = TRUE;    }    else	    FailNIL( lh = LNew( &r, &dataBounds, cellSize, procID, owner->GetMacWindow(), TRUE, grow, hScroll, vScroll ));	#else		FailNIL( lh = LNew( &r, &dataBounds, cellSize, procID, owner->GetMacWindow(), TRUE, grow, hScroll, vScroll ));	#endif	SetListRefCon( lh, (SInt32) this );	MLEnableDrawing();}/*----------------------------------***  MLINIT  ***------------------------------------*//*	initialise the list from a 'LIST' resource----------------------------------------------------------------------------------------*/void	MList::MLInit( Rect* bounds, const short listResID ){	// initialise from a LIST resource		ListTemplateHdl		lt;	short				fNum;	Boolean				hasH, hasV;	Rect				r = *bounds;	Point				cellSize = { 0, 0 };		FailNILRes( lt = (ListTemplateHdl) GetResource( kListTemplateResType, listResID ));		HNoPurge((Handle) lt );		// establish font for window, etc		owner->Focus();		ZGrafState	gs;		GetFNum((*lt)->fontName, &fNum );		TextFont( fNum );	TextSize((*lt)->fontSize );	TextFace( 0 );		hasH = (*lt)->hasHorizScroll;	hasV = (*lt)->hasVertScroll;		keySearchEnable = !(*lt)->disableType;		if ( GetHandleSize((Handle) lt ) == sizeof( ListTemplate ))	{		cellSize.h = (*lt)->cellH;		cellSize.v = (*lt)->cellV;	}		MLInit( bounds, cellSize, (*lt)->rows, (*lt)->columns, hasV, hasH, (*lt)->procID );		if ((*lt)->stringsListID > 0 )		MLPreloadFromResource((*lt)->stringsListID );			HPurge((Handle) lt );	ReleaseResource((Handle) lt );	// tweak vertical size of list to accommodate exact number of lines	short	cellHeight = (*lh)->cellSize.v;	short	adjustAmount;		adjustAmount = ( r.bottom - r.top - ( hasH? kStdScrollbarWidth + 2 : 2 )) % cellHeight;	r.bottom -= adjustAmount;		LSize( r.right - r.left - ( hasV? kStdScrollbarWidth + 2 : 2 ),		   r.bottom - r.top - ( hasH? kStdScrollbarWidth + 2 : 2 ),		   lh );}/*---------------------------***  MLPRELOADFROMRESOURCE  ***----------------------------*//*	fill a 1-column list with strings from a STR# resource----------------------------------------------------------------------------------------*/void	MList::MLPreloadFromResource( const short strListID, Boolean alphaOrder ){	Handle	strListH;	short	numItems, i;	Cell	aCell = { 0, 0 };	Str255	temp;		FailNILRes( strListH = GetResource( 'STR#', strListID ));		// how many items in the list?		numItems = **(short**) strListH;		// add each string to the list		LSetDrawingMode( FALSE, lh );	aCell.v = (*lh)->dataBounds.bottom;		for ( i = 1; i <= numItems; i++ )	{		GetIndString( temp, strListID, i );				if ( alphaOrder )			MLAppendRowInAlphaOrder( temp );		else		{			// append to the list					aCell.v = LAddRow( 1, aCell.v + 1, lh );			LSetCell( &temp[1], temp[0], aCell, lh );		}	}		ReleaseResource( strListH );	LSetDrawingMode( TRUE, lh );}						/*---------------------------------***  MLUPDATE  ***-----------------------------------*//*	refresh the list----------------------------------------------------------------------------------------*/void	MList::MLUpdate( Rect* updateRect ){	RectRgn( gUtilRgn, updateRect );	LUpdate( gUtilRgn, lh );}/*----------------------------------***  MLCLICK  ***-----------------------------------*//*	process mouse down in the list----------------------------------------------------------------------------------------*/void	MList::MLClick( const Point mouse, const short modifiers ){	Boolean	dbl;	Cell	aCell = { 0, 0 };		// set up global for clickloop		gClickList = lh;		// process click		dbl = LClick( mouse, modifiers, lh );			// call messaging methods if necessary		MLGetSelection( &aCell );		if ( ! EqualPt( aCell, lastSel ))	{		MLNewCellSelected( aCell );				lastSel = aCell;	}		if ( dbl )		MLCellDoubleClicked( aCell );}/*--------------------------------***  MLACTIVATE  ***----------------------------------*//*	activate the list----------------------------------------------------------------------------------------*/void	MList::MLActivate(){	LActivate( TRUE, lh );}/*-------------------------------***  MLDEACTIVATE  ***---------------------------------*//*	deactivate the list----------------------------------------------------------------------------------------*/void	MList::MLDeactivate(){	LActivate( FALSE, lh );}/*--------------------------------***  MLSETSIZE  ***-----------------------------------*//*	set the viewing dimensions of the list----------------------------------------------------------------------------------------*/void	MList::MLSetSize( const short width, const short height ){	LSize( width, height, lh );	if ( autoCellHsize )	{		// if this flag set, recompute the cell width to fit the list width		// if more than one column, resize proportionally				Cell	cs;				cs = (*lh)->cellSize;				cs.h = width / MLCountCols();				LCellSize( cs, lh );	}}/*---------------------------------***  MLSCROLL  ***-----------------------------------*//*	scroll the list by the number of rows or columns passed----------------------------------------------------------------------------------------*/void	MList::MLScroll( const short rows, const short cols ){	LScroll( cols, rows, lh );}/*------------------------------***  MLENABLEDRAWING  ***-------------------------------*//*	enable drawing for the list----------------------------------------------------------------------------------------*/void	MList::MLEnableDrawing(){	LSetDrawingMode( TRUE, lh );}/*-----------------------------***  MLDISABLEDRAWING  ***-------------------------------*//*	disable drawing for the list----------------------------------------------------------------------------------------*/void	MList::MLDisableDrawing(){	LSetDrawingMode( FALSE, lh );}/*----------------------------***  MLSETSELECTIONFLAGS  ***-----------------------------*//*	set behaviour flags for how list will act on shift-click, etc.----------------------------------------------------------------------------------------*/void	MList::MLSetSelectionFlags( const char sFlags ){	SetListSelectionFlags( lh, sFlags );}/*-------------------------------***  MLSETCELLSIZE  ***--------------------------------*//*set drawn size of the cells	----------------------------------------------------------------------------------------*/void    MList::MLSetCellSize( const short width, const short height ){    Point   cs;        cs.h = width;    cs.v = height;        LCellSize( cs, lh ); }/*------------------------------***  MLGETSELECTION  ***--------------------------------*//*	return the currently selected cell, or NO_SELECTION, if none. Also returns FALSE if noselection, TRUE if there is one. You can also use this to iterate through multipleselections.----------------------------------------------------------------------------------------*/Boolean	MList::MLGetSelection( Cell* aCell ){	Cell		c = *aCell;	Boolean		aSel;		aSel = LGetSelect( TRUE, &c, lh );		if ( aSel )		*aCell = c;	else		*aCell = NO_SELECTION;			return aSel;}/*------------------------------***  MLSETSELECTION  ***--------------------------------*//*	sets the selection to the passed cell, TURNING OFF the previously saved selection.----------------------------------------------------------------------------------------*/void	MList::MLSetSelection( Cell aCell, Boolean retainExisting ){	if ( ! EqualPt(  aCell, lastSel ))	{		if ( ! retainExisting )		{			if ( ! EqualPt( lastSel, NO_SELECTION ))				LSetSelect( FALSE, lastSel, lh );		}			if ( ! EqualPt( aCell, NO_SELECTION ))			LSetSelect( TRUE, aCell, lh );					lastSel = aCell;				MLNewCellSelected( aCell ); 	}}/*----------------------------***  MLSCROLLTOSELECTION  ***-----------------------------*//*	scroll the view until the passed cell is visible----------------------------------------------------------------------------------------*/void	MList::MLScrollToSelection(){	LAutoScroll( lh );}/*--------------------------------***  MLSETCELL  ***-----------------------------------*//*	store some data into the given cell----------------------------------------------------------------------------------------*/void	MList::MLSetCell( Cell theCell, Ptr buf, short length ){	LSetCell( buf, length, theCell, lh );}/*--------------------------------***  MLSETCELL  ***-----------------------------------*//*	store a string into the given cell----------------------------------------------------------------------------------------*/void	MList::MLSetCell( Cell theCell, Str255 aString ){	MLSetCell( theCell, (Ptr) &aString[1], (short) aString[0] );}/*--------------------------------***  MLGETCELL  ***-----------------------------------*//*	return the data stored in the given cell----------------------------------------------------------------------------------------*/void	MList::MLGetCell( Cell theCell, Ptr buf, short* length ){	LGetCell( buf, length, theCell, lh );}/*--------------------------------***  MLGETCELL  ***-----------------------------------*//*	return the string stored in the given cell----------------------------------------------------------------------------------------*/void	MList::MLGetCell( Cell theCell, Str255 aString ){	short	len = 255;		LGetCell( &aString[1], &len, theCell, lh );	aString[0] = len & 0xFF;}/*--------------------------------***  MLAPPENDROW  ***---------------------------------*//*add one row to the bottom of the list- returns the row number of the added row	----------------------------------------------------------------------------------------*/short	MList::MLAppendRow(){	short	rn = -1;		short	dn = (*lh)->dataBounds.bottom + 1;		// check that list is not too big		if ((dn * (*lh)->cellSize.v) > 32760 )		FailOSErr( kListTooBigErr );		rn = LAddRow( 1, dn, lh );	return rn;}/*--------------------------------***  MLAPPENDCOL  ***---------------------------------*//*add one column to the right of the list- returns column number of the added column	----------------------------------------------------------------------------------------*/short	MList::MLAppendCol(){	short	rn = -1;		short	dn = (*lh)->dataBounds.right + 1;		// check that list is not too big		if ((dn * (*lh)->cellSize.h) > 32760 )		FailOSErr( kListTooBigErr );		rn = LAddColumn( 1, dn, lh );	return rn;}/*-----------------------------***  MLAPPENDROWDATA  ***--------------------------------*//*	appends a row, then stores the data in the first column of the added row----------------------------------------------------------------------------------------*/short	MList::MLAppendRowData( Ptr buf, short length ){	Cell	c = { 0, 0 };		c.v = MLAppendRow();		MLSetCell( c, buf, length );		return c.v;	}/*-----------------------------***  MLAPPENDROWDATA  ***--------------------------------*//*	appends a row, then stores the string in the first column of the added row----------------------------------------------------------------------------------------*/short	MList::MLAppendRowData( Str255 aString ){	return MLAppendRowData((Ptr) &aString[1], (short) aString[0] );}/*-----------------------------***  MLAPPENDCOLDATA  ***--------------------------------*//*	appends a column, then stores the data in the first row of the added column----------------------------------------------------------------------------------------*/short	MList::MLAppendColData( Ptr buf, short length ){	Cell	c = { 0, 0 };		c.h = MLAppendCol();		MLSetCell( c, buf, length );		return c.h;}/*-----------------------------***  MLAPPENDCOLDATA  ***--------------------------------*//*	appends a column, then stores the string in the first row of the added column----------------------------------------------------------------------------------------*/short	MList::MLAppendColData( Str255 aString ){	return MLAppendColData((Ptr) &aString[1], (short) aString[0] );}/*-------------------------***  MLAPPENDROWINALPHAORDER  ***----------------------------*//*	appends a row, inserting the passed string in the correct position to maintain alpha-betical order in the list. Optionally, you can avoid inserting duplicate entries bypassing TRUE in <rejectExactMatches>. By default this is FALSE.----------------------------------------------------------------------------------------*/short  MList::MLAppendRowInAlphaOrder( Str255 s, Boolean rejectExactMatches ){	Boolean		found;	short		totalRows, currentRow, cellDataOffset, cellDataLength, match;	Cell		aCell;	char		hState;    ListBounds  db;    Handle      cells;    	found = FALSE;    GetListDataBounds( lh, &db );    cells = GetListDataHandle( lh );    	totalRows = db.bottom - db.top;	currentRow = -1;	while ( !found )	{		currentRow++;    		if ( currentRow == totalRows )  		{     		found = TRUE;     		match = -1;     	}  		else  		{  			SetPt( &aCell, 0, currentRow );      		LGetCellDataLocation( &cellDataOffset, &cellDataLength, aCell, lh );      		hState = HGetState( cells );      		HLock( cells );                        match = CompareText( &s[1],      							((Ptr) cells[0] + cellDataOffset ),              					s[0],              					cellDataLength,              					NULL );              					            if ( match != 1 )     		{         		found = TRUE;     		}			HSetState( cells, hState );   		}	}        if ( match == -1 || ( match == 0 && !rejectExactMatches ))    {    	currentRow = LAddRow( 1, currentRow, lh );    	SetPt( &aCell, 0, currentRow );    	LSetCell( &s[1], s[0], aCell, lh );    }        	return currentRow;}/*--------------------------------***  MLCLEARCELL  ***---------------------------------*//*	deletes a single cell----------------------------------------------------------------------------------------*/void	MList::MLClearCell( Cell theCell ){	LClrCell( theCell, lh );		if ( theCell.h == lastSel.h && theCell.v == lastSel.v )	    lastSel = NO_SELECTION;}/*------------------------------***  MLSETEMPTYLIST  ***--------------------------------*//*	deletes all rows and columns from the list----------------------------------------------------------------------------------------*/void	MList::MLSetEmptyList(){	// empty the list. This leaves it with NO rows OR columns- you must append what you need	// after this call.		LDelRow( 0, 0, lh );	LDelColumn( 0, 0, lh );	lastSel = NO_SELECTION;}/*--------------------------------***  MLDELETEROW  ***---------------------------------*//*	deletes 1 row----------------------------------------------------------------------------------------*/void	MList::MLDeleteRow( short whichRow ){	LDelRow( 1, whichRow, lh );		if ( lastSel.v == whichRow )	    lastSel = NO_SELECTION;}/*--------------------------------***  MLDELETECOL  ***---------------------------------*//*	deletes 1 col----------------------------------------------------------------------------------------*/void	MList::MLDeleteCol( short whichCol ){	LDelColumn( 1, whichCol, lh );		if ( lastSel.h == whichCol )	    lastSel = NO_SELECTION;}	/*-------------------------------***  MLGETBOUNDS  ***----------------------------------*//*	returns the rect of the outside edge of the complete list, including scrollbars----------------------------------------------------------------------------------------*/void	MList::MLGetBounds( Rect* aRect ){#if TARGET_API_MAC_CARBON	GetListViewBounds( lh, aRect );#else    *aRect = (*lh)->rView;#endif		if ( GetListVerticalScrollBar( lh ))		aRect->right += kStdScrollbarWidth;			if ( GetListHorizontalScrollBar( lh ))		aRect->bottom += kStdScrollbarWidth;}/*-------------------------------***  MLSETBOUNDS  ***----------------------------------*//*	resets the size and position of the list. The bounds passed includes any scrollbars.----------------------------------------------------------------------------------------*/void    MList::MLSetBounds( Rect* aRect ){    Rect    r = *aRect;	if ( GetListVerticalScrollBar( lh ))		r.right -= kStdScrollbarWidth;			if ( GetListHorizontalScrollBar( lh ))		r.bottom -= kStdScrollbarWidth;#if TARGET_API_MAC_CARBON	SetListViewBounds( lh, &r );#else    (*lh)->rView = r;#endif        MLSetSize( r.right - r.left, r.bottom - r.top );}/*-----------------------------***  MLKEYNAVIGATION  ***--------------------------------*//*	deal with arrow keys, etc in a list. Also typing first few chars of item selects it, ifdata is a string and is in alphabetical order----------------------------------------------------------------------------------------*/void	MList::MLKeyNavigation( const char theKey, const short modifiers ){	// allow arrow keys to move us around in the list, and for alphabetical selection	// to (optionally) operate		Cell	curCell = { 0, 0 };	Rect	db;	Boolean	cmd = (( modifiers & cmdKey ) == cmdKey );		GetListDataBounds( lh, &db );		db.right--;	db.bottom--;		// find the currently selected cell		MLGetSelection( &curCell );		switch ( theKey )	{		case LEFT_ARROW_KEY:		// left arrow, move left if possible			if ( cmd )				curCell.h = 0;			else				curCell.h = MAX( db.left, curCell.h - 1 );			break;				case RIGHT_ARROW_KEY:		// right arrow, move right if possible			if ( cmd )				curCell.h = db.right;			else				curCell.h = MIN( db.right, curCell.h + 1 );			break;				case UP_ARROW_KEY:			// up arrow, move up if possible			if ( cmd )				curCell.v = 0;			else				curCell.v = MAX( db.top, curCell.v - 1 );			break;				case DOWN_ARROW_KEY:		// down arrow, move down if possible			if ( cmd )				curCell.v = db.bottom;			else				curCell.v = MIN( db.bottom, curCell.v + 1 );			break;					case TAB_KEY:		case ENTER_KEY:		case RETURN_KEY:		case ESCAPE_KEY:		case BACKSPACE_KEY:			return;				default:			if ( keySearchEnable )			{				// handle letter typing to select items in list.											if (( theKey >= 'a' && theKey <= 'z' ) ||					( theKey >= 'A' && theKey <= 'Z' ) ||					( theKey >= '0' && theKey <= '9' ))				{					long	theTime = TickCount();					Cell	findCell = { 0, 0 };										// time to start a new string yet?										if ((theTime > lastKeyTime + fThresh) || (searchStr[0] > 12))					{						// start a new string												searchStr[0] = 0;					}					lastKeyTime = theTime;										// add typed chars to the search string										searchStr[++searchStr[0]] = theKey;										// find a cell that matches this										if ( LSearch( &searchStr[1], searchStr[0], gFindCellCompUPP, &findCell, lh ))					{						// we found one, so make it the selected cell												curCell = findCell;					}				}			}			else				return;							break;	}		// turn off the old cell and hilite the new cell		if ( curCell.h == -1 )		curCell.h = 0;			if ( curCell.v == -1 )		curCell.v = 0;		MLSetSelection( curCell );	MLScrollToSelection();}/*-------------------------------***  MLDRAW1CELL  ***----------------------------------*//*	draw a list cell. This is only called if the custom LDEF callback is installed, and isusually overridden in that case. By default, duplicates basic List Manager behaviour.----------------------------------------------------------------------------------------*/void	MList::MLDraw1Cell( Rect* area, Cell theCell, Boolean hilited ){	Point     ip;	Str255	  aString;			GetListCellIndent( lh, &ip );	MoveTo( area->left + ip.h, area->top + ip.v );		if ( mlViewer )		mlViewer->DrawCell( area, theCell, hilited );	else	{		MLGetCell( theCell, aString );		DrawString( aString );	}}/*------------------------------***  MLHILITE1CELL  ***---------------------------------*//*	hilites a list cell, if cutsom LDEF callback installed----------------------------------------------------------------------------------------*/void	MList::MLHilite1Cell( Rect* area, Cell theCell, Boolean hilited ){	if ( mlViewer )		mlViewer->HiliteCell( area, theCell, hilited );	else	{		SetHiliteMode();		InvertRect( area );	}}/*----------------------------***  MLINSTALLCALLBACKS  ***------------------------------*//*	install callbacks for list drawing (LDEF) and clickloop. Allows you to override objectmethods instead of writing custom routines.----------------------------------------------------------------------------------------*/void	MList::MLInstallCallbacks( Boolean customLDEF, Boolean customClikLoop ){	// install LDEF and ClikLoop stubs for handling callbacks. Note that in Carbon,	// this is almost impossible to do after the list has been created. To get around this,	// Carbon lists are always created with the custom LDEF installed. You are advised to	// use the MListViewer attachment technique with Carbon, rather than using an external	// LDEF (this is unsupported in Carbon anyway, so code has to be revised one way or	// another- you may as well use a MListViewer to replace such an LDEF as it's really	// very much simpler)#if !TARGET_API_MAC_CARBON	if ( customLDEF )	{		Handle	vpHand = GetUniversalFunctionHandle((ProcPtr) LMListDefVectorProc, uppListDefProcInfo );		(*lh)->listDefProc = vpHand;				usingCustomLDEF = TRUE;	}#endif	if ( customClikLoop )	{		// install a click-loop that calls us back				ListClickLoopUPP	clikUPP = NewListClickLoopUPP( LMListClickLoopProc );		SetListClickLoop( lh, clikUPP );	}}void	MList::MLAttachViewer( MListViewer* aViewer ){	// attaches a viewer object. This is subsequently used to draw the cell data.	if ( mlViewer && mlViewer != aViewer )		ForgetObject( mlViewer );			mlViewer = aViewer;		if ( ! usingCustomLDEF )		MLInstallCallbacks( TRUE, FALSE );			if ( mlViewer )		mlViewer->SetOwner( this );}short	MList::MLCountRows(){	ListBounds  dBounds;		GetListDataBounds( lh, &dBounds );		return dBounds.bottom;}short	MList::MLCountCols(){	ListBounds  dBounds;		GetListDataBounds( lh, &dBounds );		return dBounds.right;}void	MList::ReportFields(){	XSHOWFIELD( lh, ft_Handle );	XSHOWFIELD( owner, ft_objectref );	XSHOWFIELD( lastSel, ft_Point );	XSHOWFIELD( searchStr, ft_str255 );	XSHOWFIELD( lastKeyTime, ft_signedlong );	XSHOWFIELD( fThresh, ft_signedshort );	XSHOWFIELD( usingCustomLDEF, ft_boolean );	XSHOWFIELD( keySearchEnable, ft_boolean );	XSHOWFIELD( mlViewer, ft_objectref );}#pragma mark -/*----------------------------***  FindCellCompProc  ***--------------------------------*//*	used to locate suitable cells when typing in a list box----------------------------------------------------------------------------------------*/static pascal short	FindCellCompProc( Ptr dataA, Ptr dataB, short lenA, short lenB ){	short	result = 1;		if ( lenA > 0 )	{		if ( IdenticalText( dataA, dataB, lenA, lenB, NULL ) == 0 )			result = 0;		else		{			if ( CompareText( dataA, dataB, lenA, lenB, NULL ) == 1)				result = 0;		}		}		return result;}/*---------------------------***  LMLISTDEFVECTORPROC  ***------------------------------*//*passes calls to the LDEF back to the object so that we can easily create simple overridablecustom list behaviours. This is pretty neat, since this is otherwise a bit of a chore.----------------------------------------------------------------------------------------*/static pascal void	LMListDefVectorProc(	short message,											Boolean selected,											Rect* cellRect,											Cell theCell,											short dataOffset,											short dataLen,											ListHandle theList){	MList*	zw;		zw = (MList*) GetListRefCon( theList );		if (zw)	{		try		{			switch (message)			{				case lDrawMsg:				    EraseRect( cellRect );					zw->MLDraw1Cell( cellRect, theCell, selected );					if (! selected)						break;								case lHiliteMsg:					zw->MLHilite1Cell( cellRect, theCell, selected );					break;								default:					break;			}		}		catch(...)		{			// do not propagate!!!		}	}}/*---------------------------***  LMLISTCLICKLOOPPROC  ***------------------------------*//*feeds clickloop calls back to the object so a simple override is all that's needed tohave a custom clickloop.----------------------------------------------------------------------------------------*/static pascal Boolean	LMListClickLoopProc(){	MList*			zw;	Boolean			result = TRUE;		zw = (MList*) GetListRefCon( gClickList );		if (zw)	{		try		{			result = zw->MLClickLoop();		}		catch(...)		{			result = FALSE;		}	}	return result;}#pragma mark -void	MListViewer::HiliteCell( Rect* bounds, Cell theCell, Boolean hilited ){    SetHiliteMode();    InvertRect( bounds );}