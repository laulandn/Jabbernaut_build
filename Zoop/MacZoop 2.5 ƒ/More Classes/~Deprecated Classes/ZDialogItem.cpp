/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZDialogItem.cpp			-- dialog item object**			****			© 1999, Graham Cox****************************************************************************************************/#include	"ZDialogItem.h"#include	"ZDialog.h"#include	"ZGrafState.h"#include	"MacZoop.h"#include	<fp.h>#include	<lowmem.h>#include	<icons.h>CLASSCONSTRUCTOR( ZDialogItem );/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZDialogItem::ZDialogItem()	: ZCommander(){	classID = CLASS_ZDialogItem;		id = 0;	iType = 0;	enabled = TRUE;	visible = TRUE;	isDefault = FALSE;	groupID = 0;	shGroup = 0;	efFilterFlags = 0;	hHistory = 0xFFFFFFFF;	maxLim = minLim = 0;	xType = 0;	pwMirror = NULL;	font = 0;	fontSize = 0;	fontStyle = 0;	fontJust = teJustLeft;	focused = FALSE;	canTakeFocus = FALSE;	hilited = TRUE;	fgColour = gBlack;	bkColour = gWhite;	fSizing = 0;}/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZDialogItem::ZDialogItem( ZDialog* aBoss, const short anID )	: ZCommander( aBoss ){	DialogPtr	dp;		FailNILParam( dp = aBoss->GetMacDialog());		classID = CLASS_ZDialogItem;	id = anID;		GetDialogItem( dp, id, &iType, &macItemHandle, &bounds );		enabled = (( iType & 0x80 ) == 0 );		iType &= 0x7F;		visible = TRUE;	isDefault = FALSE;	groupID = 0;	shGroup = 0;	efFilterFlags = 0;	hHistory = 0xFFFFFFFF;	maxLim = minLim = 0;	xType = 0;	pwMirror = NULL;	font = 0;	fontSize = 0;	fontStyle = 0;	fontJust = teJustLeft;	focused = FALSE;	canTakeFocus = ( iType & editText ) == editText;	hilited = TRUE;	aBoss->GetBackColour( &bkColour );	if ( iType & editText )		bkColour = gWhite;	fgColour = gBlack;		if ( iType & ctrlItem )	{		minLim = GetControlMinimum((ControlHandle) macItemHandle );		maxLim = GetControlMaximum((ControlHandle) macItemHandle );	}		fSizing = 0;}	/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZDialogItem::~ZDialogItem(){	if ( pwMirror )		TEDispose( pwMirror );}	/*-----------------------------------***  DRAW  ***-------------------------------------*//*	Draw the item to perform an update, refresh, etc----------------------------------------------------------------------------------------*/void	ZDialogItem::Draw(){	if ( ! visible )		return;		FocusBoss();		ZGrafState	gs;		PrepareForDrawing();	DrawItem();		if ( isDefault )		DrawDefaultOutline();			if ( hilited && focused )		DrawFocusBorder( TRUE );}	/*----------------------------------***  CLICK  ***-------------------------------------*//*	Handle a mouse click within this item----------------------------------------------------------------------------------------*/void	ZDialogItem::Click( const Point mouse, const short modifiers ){	short	 	partCode;	ZDialog*	zd;	TEHandle	dpText;		if ( enabled && hilited )	{		zd = (ZDialog*) itsBoss;				SelfSelect();					if ( iType & ctrlItem )		{			partCode = TrackControl((ControlHandle) macItemHandle, mouse, ( ControlActionUPP ) -1L );					if ( partCode != 0 )			{				// if a button, set the local zoom source rect								if ( iType == ( btnCtrl + ctrlItem ))					SetLocalZoomSource( &bounds );								// if a radio button and already on, do not call dialog's ClickItem method				// in order to avoid the need for application code to care about enable/disable				// states of items controlled by this button				if ((( iType & 3 ) == radCtrl ) && ( GetValue() == 1 ))					return;				zd->ClickItem( id );			}		}		else		{			if ( iType & editText )			{				ZGrafState	zg;										PrepareForDrawing();								dpText = DIALOGTEXTEDITRECORD( GetMacDialog());								// if an edit field, pass click to text edit. If not in the current				// field, switch fields to the one clicked first.								TEClick( mouse, ( modifiers & shiftKey ) == shiftKey, dpText );								// if a password field, make sure selections match								if ( efFilterFlags & editFieldHiddenChars )				{					(*pwMirror)->selStart = (*dpText)->selStart;					(*pwMirror)->selEnd   = (*dpText)->selEnd;				}			}						// all enabled items are passed to ClickItem						zd->ClickItem( id );		}	}}/*-------------------------------***  SELFSELECT  ***-----------------------------------*//*	makes this item the current focus. Call from Click if necessary. If item can't havefocus, this method does nothing.----------------------------------------------------------------------------------------*/void    ZDialogItem::SelfSelect(){	ZDialog*    zd;		zd = (ZDialog*) itsBoss;		if ( enabled && canTakeFocus && !focused )		zd->SelectItem( id, FALSE );}	/*------------------------------***  ADJUSTCURSOR  ***----------------------------------*//*	set the cursor for the item----------------------------------------------------------------------------------------*/void	ZDialogItem::AdjustCursor( const Point mouse, const short modifiers ){	if (( iType & editText ) && hilited )		PauseCursorAnimation( iBeamCursor );	else		SetCursorShape( 0 );}/*-----------------------------***  GETBALLOONHELP  ***---------------------------------*//*	get the balloon help for the item. By default this just looks it up in a 'hdlg' resource,but you could override this to supply help in any way you see fit.----------------------------------------------------------------------------------------*/Boolean	ZDialogItem::GetBalloonHelp( const Point mouseIn,									 Rect* rectOut,									 Point* tipOut,									 HMMessageRecord* hm ){#if TARGET_API_MAC_CARBON	return FALSE;#else	short				ditlID = ((ZDialog*) itsBoss)->GetDITLID();	short				bState;	OSErr				hmErr = noErr;		if ( hilited )	{		bState = kHMEnabledItem;				if ( iType & ctrlItem )		{			if ( GetValue() == 1 )				bState = kHMCheckedItem;			else				if ( GetValue() > 1 )					bState = kHMOtherItem;		}	}	else		bState = kHMDisabledItem;		hmErr = HMExtractHelpMsg( kHMDialogResType, ditlID, id, bState, hm );		*rectOut = bounds;		tipOut->h = bounds.right - 8;	tipOut->v = bounds.bottom - 8;		return ( hmErr == noErr );#endif}/*-------------------------------***  UPDATEMENUS  ***----------------------------------*//*	enable edit menu items if an edit field----------------------------------------------------------------------------------------*/void	ZDialogItem::UpdateMenus(){	if ((( iType & editText ) == editText ) && hilited )	{		gMenuBar->EnableCommand( kCmdCut );		gMenuBar->EnableCommand( kCmdCopy );		gMenuBar->EnableCommand( kCmdClear );		gMenuBar->EnableCommand( kCmdSelectAll );	}		ZCommander::UpdateMenus();}	/*---------------------------------***  INITITEM  ***-----------------------------------*//*	perform any special initialisation for the item----------------------------------------------------------------------------------------*/void	ZDialogItem::InitItem( const short paramCount, const long params[] ){	if (( iType & editText ) &&		( efFilterFlags & editFieldHiddenChars ) &&		( pwMirror == NULL ))	{		Rect r;				SetRect( &r, 10000, 10000, 10500, 10500 );		pwMirror = TENew( &r, &r );	}}	/*-----------------------------***  DRAWFOCUSBORDER  ***--------------------------------*//*	draw the border of a focused item or erase it if losing the focus----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawFocusBorder( Boolean bState, Boolean forceIt ){	if (( canTakeFocus && ((ZDialog*) itsBoss)->CountFocusableItems() > 1 ) || forceIt )	{		Rect		r = bounds;		RGBColor	borderColour = gDarkGray;				if ( iType & editText )			InsetRect( &r, -2, -2 );			#if APPEARANCE_MGR_AWARE			ThemeDrawingState	bkSave;				if ( gMacInfo.hasAppearanceMgr )		{		    GetThemeDrawingState( &bkSave );		    ((ZDialog*) itsBoss)->GetBackColour( &borderColour );		    RGBBackColor( &borderColour );            			DrawThemeFocusRect( &r, bState );            SetThemeDrawingState( bkSave, TRUE );			InsetRect( &r, -2, -2 );		}		else		{	#endif				PenNormal();		PenMode( patOr );		if ( ! bState )			((ZDialog*) itsBoss)->GetBackColour( &borderColour );					RGBForeColor( &borderColour );				InsetRect( &r, -3, -3 );		PenSize( 2, 2 );		FrameRoundRect( &r, 4, 4 );				PenNormal();		RGBForeColor( &fgColour );		#if APPEARANCE_MGR_AWARE		}	#endif		if ( ! bState )		{			RgnHandle	temp;						ClipRect( &r );			RectRgn( gUtilRgn, &r );				InsetRect( &r, 2, 2 );			RectRgn( temp = NewRgn(), &r );			DiffRgn( gUtilRgn, temp, temp );			MZInvalWindowRgn( DIALOGWINDOW( GetMacDialog()), temp );			DisposeRgn( temp );		}	}}/*---------------------------***  DOHIGHLIGHTSELECTION  ***-----------------------------*//*	highlight or unhilite the current selection.----------------------------------------------------------------------------------------*/void	ZDialogItem::DoHilightSelection( Boolean hiliteIt ){	if ( iType & ctrlItem )		HiliteControl((ControlHandle) macItemHandle, hiliteIt? 1 : 0 );			if ((( iType & editText ) == editText ) && hiliteIt )	    DoSelectAll();    }/*---------------------------------***  ACTIVATE  ***-----------------------------------*//*	item is becoming active----------------------------------------------------------------------------------------*/void    ZDialogItem::Activate(){	if( iType & editText )	{		TEHandle	dpText;		ZGrafState	gs;				PrepareForDrawing();				dpText = DIALOGTEXTEDITRECORD( GetMacDialog());				TEActivate( dpText );					if ( efFilterFlags & editFieldHiddenChars )		{			(*pwMirror)->selStart = (*dpText)->selStart;			(*pwMirror)->selEnd   = (*dpText)->selEnd;		}	}	else	{		if ( iType & ctrlItem )			HiliteControl((ControlHandle) macItemHandle, 0 );	}}/*--------------------------------***  DEACTIVATE  ***----------------------------------*//*	item is becoming inactive----------------------------------------------------------------------------------------*/void    ZDialogItem::Deactivate(){	if( iType & editText )	{		TEHandle	dpText;		ZGrafState	gs;				PrepareForDrawing();				dpText = DIALOGTEXTEDITRECORD( GetMacDialog());				TEDeactivate( dpText );	}	else	{		if ( iType & ctrlItem )			HiliteControl((ControlHandle) macItemHandle, 255 );	}}/*----------------------------***  DRAWDEFAULTOUTLINE  ***------------------------------*//*	draw the outline that indicates this this item is the default [i.e. OK button]----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawDefaultOutline(){#if !TARGET_API_MAC_CARBON 	if ( iType == ( ctrlItem + btnCtrl ))	{		Rect r = bounds;				FocusBoss();		ZGrafState	gs;				PrepareForDrawing();				InsetRect( &r, -4, -4 );		PenSize( 3, 3 );				if ( !hilited )		{			if ( IsColourPort( DIALOGGRAFPTR( GetMacDialog())))				RGBForeColor( &gMidGray );			else				PenPat( QDGRAYPATTERN );		}					FrameRoundRect( &r, 16, 16 );		}#endif}/*-----------------------------***  SETDEFAULTITEM  ***---------------------------------*//*	Set this item as the default for the window----------------------------------------------------------------------------------------*/void		ZDialogItem::SetDefaultItem( Boolean is ){	isDefault = is;	#if TARGET_API_MAC_CARBON	SetDialogDefaultItem( GetMacDialog(), id );#endif}/*-----------------------------------***  IDLE  ***-------------------------------------*//*	blink the caret in edit field----------------------------------------------------------------------------------------*/void	ZDialogItem::Idle(){	if ( hilited && focused && ( iType & editText ) == editText )	{		FocusBoss();				ZGrafState	gs;				PrepareForDrawing();		TEIdle( DIALOGTEXTEDITRECORD( GetMacDialog()));	}	ZCommander::Idle();}/*-----------------------------------***  TYPE  ***-------------------------------------*//*	respond to the keyboard----------------------------------------------------------------------------------------*/void	ZDialogItem::Type( const char theKey, const short modifiers ){	if ( theKey == TAB_KEY 		||		 theKey == RETURN_KEY 	||		 theKey == ENTER_KEY 	||		 theKey == ESCAPE_KEY	||		 ( modifiers & cmdKey ) == cmdKey )		ZCommander::Type( theKey, modifiers );	else	{		((ZDialog*) itsBoss)->Focus();				if ( enabled && focused && ( iType & editText ) == editText )		{			ZGrafState	gs;			char		key = theKey;			TEHandle	dpText;						PrepareForDrawing();						dpText = DIALOGTEXTEDITRECORD( GetMacDialog());					// here, we need to check filter flags, etc for valid keys						if ( CheckKey( &key ))			{				MZTEKey( key, dpText, modifiers );								// if a password field, echo the real key to the mirror record								if (( efFilterFlags & editFieldHiddenChars ) && pwMirror )					MZTEKey( theKey, pwMirror, modifiers );							((ZDialog*) itsBoss)->ClickItem( id );			}			else				SysBeep( 1 );		}	}}	/*----------------------------------***  ENABLE  ***------------------------------------*//*	enable this item and show it in an enabled state----------------------------------------------------------------------------------------*/void	ZDialogItem::Enable( Boolean useHistory ){	Boolean		wasHilited = hilited;		if ( useHistory )		hilited = PopStateHistory();	else		hilited = TRUE;			if ( hilited != wasHilited )	{		FocusBoss();				if ( iType & ctrlItem )		{			HiliteControl((ControlHandle) macItemHandle, hilited? 0 : 255 );			if ( isDefault )				DrawDefaultOutline();			ValidItem();			return;		}				// if edit field, re-enable by converting from static item					if ( hilited && ( iType & editText ) == editText )		{			// this is a disabled edit field really, so convert it back to an edit field,			// clear the disable flag we are keeping and redraw the item.						short	dType;			Handle	iHand;			Rect	iBox;						GetDialogItem( GetMacDialog(), id, &dType, &iHand, &iBox );			dType = ( dType & 0x80 ) | editText;			SetDialogItem( GetMacDialog(), id, dType, iHand, &iBox );		}				if (( iType & 0x807C ) == userItem )		    DrawUserItem();		else		    InvalItem();	}}	/*---------------------------------***  DISABLE  ***------------------------------------*//*	disable the item and show it an a disabled state----------------------------------------------------------------------------------------*/void	ZDialogItem::Disable( Boolean useHistory ){	Boolean	wasHilited = hilited;		if ( useHistory )		PushStateHistory( hilited );		hilited = FALSE;		if ( hilited != wasHilited )	{		FocusBoss();				if ( focused )		{			DrawFocusBorder( FALSE, TRUE );			Deactivate();			focused = FALSE;		}		if ( iType & ctrlItem )		{			HiliteControl((ControlHandle) macItemHandle, 255 );			if ( isDefault )				DrawDefaultOutline();			ValidItem();			return;		}					// if edit text, convert to static				if ( iType & editText )		{			short	dType;			Handle	iHand;			Rect	iBox;						GetDialogItem( GetMacDialog(), id, &dType, &iHand, &iBox );			dType = ( dType & 0x80 ) | statText;			SetDialogItem( GetMacDialog(), id, dType, iHand, &iBox );		}				if (( iType & 0x807C ) == userItem )		    DrawUserItem();		else		    InvalItem();	}}	/*----------------------------------***  SHOW  ***--------------------------------------*//*	make this item visible----------------------------------------------------------------------------------------*/void	ZDialogItem::Show(){	if ( ! visible )	{		ShowDialogItem( GetMacDialog(), id );		if ( iType & ctrlItem )			ShowControl((ControlHandle) macItemHandle );		visible = TRUE;				//Draw();	}}	/*----------------------------------***  HIDE  ***--------------------------------------*//*	make this item invisible----------------------------------------------------------------------------------------*/void	ZDialogItem::Hide(){	if ( visible )	{		HideDialogItem( GetMacDialog(), id );		if ( iType & ctrlItem )			HideControl((ControlHandle) macItemHandle );		visible = FALSE;	}}	/*------------------------------***  CANPASTETYPE  ***----------------------------------*//*	query whether data on clipboard can be pasted----------------------------------------------------------------------------------------*/Boolean	ZDialogItem::CanPasteType(){	// you can't paste into a password or disabled field		if ((( iType & editText ) == editText ) && hilited )	{		if ( efFilterFlags & editFieldHiddenChars )			return FALSE;		else			return gClipboard->QueryType( 'TEXT' );	}	else		return FALSE;}/*----------------------------------***  DOCUT  ***-------------------------------------*//*	Do cut edit operation----------------------------------------------------------------------------------------*/void	ZDialogItem::DoCut(){	if ( iType & editText )	{		itsBoss->DoCut();		InvalItem();				if ( efFilterFlags & editFieldHiddenChars )			TEDelete( pwMirror );	}}/*---------------------------------***  DOCOPY  ***-------------------------------------*//*	Do copy edit operation----------------------------------------------------------------------------------------*/void	ZDialogItem::DoCopy(){	if ( iType & editText )		itsBoss->DoCopy();}/*---------------------------------***  DOPASTE  ***------------------------------------*//*	Do paste edit operation----------------------------------------------------------------------------------------*/void	ZDialogItem::DoPaste(){	// you can't paste into a password field		if ( iType & editText )	{		if (( efFilterFlags & editFieldHiddenChars ) == 0 )		{			itsBoss->DoPaste();			InvalItem();		}	}}/*---------------------------------***  DOCLEAR  ***------------------------------------*//*	Do clear edit operation----------------------------------------------------------------------------------------*/void	ZDialogItem::DoClear(){	if ( iType & editText )	{		itsBoss->DoClear();		InvalItem();				if ( efFilterFlags & editFieldHiddenChars )			TEDelete( pwMirror );	}}/*-------------------------------***  DOSELECTALL  ***----------------------------------*//*	Do select all edit operation----------------------------------------------------------------------------------------*/void	ZDialogItem::DoSelectAll(){	if ( iType & editText && focused )	{		TEHandle	dpText;		ZGrafState	gs;				PrepareForDrawing();				dpText = DIALOGTEXTEDITRECORD( GetMacDialog());				TESetSelect(  0, 32767, dpText ); 				if ( efFilterFlags & editFieldHiddenChars )		{			(*pwMirror)->selStart = (*dpText)->selStart;			(*pwMirror)->selEnd   = (*dpText)->selEnd;		}	}}/*--------------------------------***  SETVALUE  ***------------------------------------*//*	set the item's value to that passed----------------------------------------------------------------------------------------*/void	ZDialogItem::SetValue( const long aValue ){	if (( iType & ctrlItem ) == ctrlItem ) 	{		FocusBoss();				ZGrafState	gs;				PrepareForDrawing();						if ( aValue < -32767 || aValue > 32768 )			FailOSErr( paramErr );		else		{			// work around toolbox inconsistency for buttons- hilite instead						if (( iType & ( chkCtrl | radCtrl )) == 0 )				HiliteControl((ControlHandle) macItemHandle, aValue? 1 : 0 );			else 				SetControlValue(( ControlHandle ) macItemHandle, aValue );		}	}	else	{			// for text items: convert long to string, and set item text				if ( iType & ( editText | statText ))		{			Str255	iText;						NumToString( aValue, iText );			SetValue( iText );		}	}}	/*--------------------------------***  SETVALUE  ***------------------------------------*/void	ZDialogItem::SetValue( const Str255 value ){	if ( iType & ( editText | statText ))	{		if (( efFilterFlags & editFieldHiddenChars ) == editFieldHiddenChars &&		    ( iType & editText ) == editText &&		    ( pwMirror != NULL ))		{            short   i;            Str255  bulletStr;                        // set the text into the real record and put bullets into            // the displayed one            SetDialogItemText((*pwMirror)->hText, value );                        // make up string of right number of bullets                        i = bulletStr[0] = value[0];            while( i > 0 )                bulletStr[i--] = '¥';                            SetDialogItemText( macItemHandle, bulletStr );        }        else		    SetDialogItemText( macItemHandle, value );				// make sure TextEdit is properly aware of the string if the item is focused		   		if ((( iType & editText ) == editText ) && focused )		    SetUpTextEdit();		    		Draw();	}}	/*--------------------------------***  SETVALUE  ***------------------------------------*/void	ZDialogItem::SetValue( const double value ){	if (( iType & ctrlItem ) == ctrlItem )	{		SetValue((long) value );	}	else	{		if ( iType & ( editText | statText ))		{			Str255	iText;			RealToString( value, iText );			SetValue( iText );		}	}}	/*--------------------------------***  GETVALUE  ***------------------------------------*//*	return the item's current value----------------------------------------------------------------------------------------*/long	ZDialogItem::GetValue(){	if (( iType & ctrlItem ) == ctrlItem )		return GetControlValue(( ControlHandle ) macItemHandle );			if (( iType & editText ) == editText )	{		long	value;		Str255	iText;				GetDialogItemText( macItemHandle, iText );		StringToNum( iText, &value );				return value;	}		return 0;}	/*-----------------------------***  GETVALUEASTEXT  ***---------------------------------*//*	get the item's current value as a string----------------------------------------------------------------------------------------*/void	ZDialogItem::GetValueAsText( Str255 aStr ){	if ( iType & ( statText | editText ))	{		// if this is an edit field with the password flag set, return the text		// from the mirror instead of the visible field.		if (( efFilterFlags & editFieldHiddenChars ) && pwMirror )			GetDialogItemText((*pwMirror)->hText, aStr );		else			GetDialogItemText( macItemHandle, aStr );	}	else	{		if ( iType & ctrlItem )		{			long	v = GetValue();					NumToString( v, aStr );		}	}}	/*-----------------------------***  GETVALUEASFLOAT  ***--------------------------------*//*	return the item's current value as a floating point value----------------------------------------------------------------------------------------*/float	ZDialogItem::GetValueAsFloat(){	Str255	itxt;	decimal	d;	short	vp, ix = 1;		GetValueAsText( itxt );		// make sure it can be read as a null-terminated string		itxt[itxt[0] + 1 ] = 0;		str2dec((const char*) itxt, &ix, &d, &vp);	return dec2f( &d );}	/*-------------------------------***  SETMAXIMUM  ***-----------------------------------*//*	set the item's maximum to that passed----------------------------------------------------------------------------------------*/void	ZDialogItem::SetMaximum( const long max ){	maxLim = max;		if ( iType & ctrlItem )		SetControlMaximum((ControlHandle) macItemHandle, max );}	/*-------------------------------***  SETMINIMUM  ***-----------------------------------*//*	set the item's minimum to that passed----------------------------------------------------------------------------------------*/void	ZDialogItem::SetMinimum( const long min ){	minLim = min;		if ( iType & ctrlItem )		SetControlMinimum((ControlHandle) macItemHandle, min );}	/*--------------------------------***  GETLIMITS  ***-----------------------------------*//*	return the min and max for the item----------------------------------------------------------------------------------------*/void	ZDialogItem::GetLimits( long* min, long* max ){	*min = minLim;	*max = maxLim;}	/*--------------------------------***  VALIDATE  ***------------------------------------*//*	check if the value within the item is within permissable limits.----------------------------------------------------------------------------------------*/Boolean	ZDialogItem::Validate( Boolean showAlert ){	Boolean valid = TRUE;	short	reason = 0;		if ( ExecuteModifiers( kModifierDialogItemValidate, &valid ))	{		if ( hilited && ( iType & editText ))		{			if ( efFilterFlags & editFieldCantBeEmpty )			{				// not valid if this flag set and field empty							Str255	efText;								GetValueAsText( efText );				if ( efText[0] == 0 )				{					reason = kEditFieldIsEmpty;					valid = FALSE;				}			}						if ( valid )			{				long	v = GetValue();								if ( efFilterFlags & ( editFieldHasMinValue | editFieldHasMaxValue ))				{					// we need to check limits, so do that										if ((( efFilterFlags & editFieldHasMinValue ) && ( v < minLim )) ||						(( efFilterFlags & editFieldHasMaxValue ) && ( v > maxLim )))					{						reason = kEditFieldOutOfRange;						valid = FALSE;					}				}			}		}	}			if ( ! valid )		ValidationAlert( showAlert, reason );			return valid;}	/*------------------------------***  BECOMEHANDLER  ***---------------------------------*//*	take on the focus or relinquish it, redrawing border state accordingly----------------------------------------------------------------------------------------*/void	ZDialogItem::BecomeHandler( Boolean isBecoming ){	FocusBoss();		ZGrafState	gs;		PrepareForDrawing();		if ( isBecoming )	{		if ( canTakeFocus )		{			SetUpTextEdit();			focused = TRUE;			Activate();			DrawFocusBorder( TRUE );		}	}	else	{		focused = FALSE;		Deactivate();			if ( IsVisible())		    DrawFocusBorder( FALSE );		((ZDialog*) itsBoss)->PerformUpdate();	}}	/*------------------------------***  SETFONTINFO  ***-----------------------------------*//*	set the font paramaters for the item. Will take effect next time the item is drawn----------------------------------------------------------------------------------------*/void	ZDialogItem::SetFontInfo( const short fontID, const short size, const Style style ){	font = fontID;	fontSize = size;	fontStyle = style;}	/*------------------------------***  SETBACKCOLOUR  ***---------------------------------*//*	set background colour of the item----------------------------------------------------------------------------------------*/void	ZDialogItem::SetBackColour( RGBColor* aColour ){	bkColour = *aColour;}	/*------------------------------***  SETFORECOLOUR  ***---------------------------------*//*	set foreground colour for the item----------------------------------------------------------------------------------------*/void	ZDialogItem::SetForeColour( RGBColor* aColour ){	fgColour = *aColour;}	/*--------------------------------***  SETTITLE  ***------------------------------------*//*	set the item's title to that passed----------------------------------------------------------------------------------------*/void	ZDialogItem::SetTitle( Str255 aTitle ){	if ( iType & ctrlItem )		SetControlTitle((ControlHandle) macItemHandle, aTitle );}/*--------------------------------***  GETTITLE  ***------------------------------------*//*	get the current title of the item----------------------------------------------------------------------------------------*/void	ZDialogItem::GetTitle( Str255 aTitle ){	if ( iType & ctrlItem )		GetControlTitle((ControlHandle) macItemHandle, aTitle );}/*--------------------------------***  CHECKKEY  ***------------------------------------*//*	determine if the passed key character is permitted to be typed in this item, andtranslate the key if necessary----------------------------------------------------------------------------------------*/Boolean	ZDialogItem::CheckKey( char* theKey ){	Boolean			keyLegal = TRUE;	Boolean			numeric;	Boolean			isControlChar;	Boolean			handleIt;	char			k = *theKey;	keyInfo			mk;	if ( iType & editText )	{		// give a modifier a chance to handle this:				mk.legal = keyLegal;		mk.key = k;				handleIt = ExecuteModifiers( kModifierDialogItemCheckKey, &mk );				keyLegal = mk.legal;		k = mk.key;				if ( handleIt )		{				// if flags are all zero, this is a normal field and all chars are allowed,			// otherwise we're limited to certain sets of characters according to exactly			// which flags are set.						if ( efFilterFlags )			{				keyLegal = TRUE;								// these keys are always considered legal:				isControlChar =	( k == BACKSPACE_KEY 	||				                  k == FORWARD_DELETE_KEY   ||							   	  k == UP_ARROW_KEY		||							      k == DOWN_ARROW_KEY	||							      k == LEFT_ARROW_KEY	||							      k == RIGHT_ARROW_KEY 	||							      k == RETURN_KEY		||							      k == ENTER_KEY		||							      k == ESCAPE_KEY );								if ( !isControlChar )				{					numeric = ( k >= '0' && k <= '9' );										// alphabetic only eliminates all ascii chars below the @ symbol:										if ( efFilterFlags & editFieldAlphabeticOnly )						keyLegal = ( k >= '@' || k < '0' );											// signed integer allows only numbers and - sign										if ( efFilterFlags & editFieldSignedInteger )							keyLegal = numeric || ( k == '-' );										// signed float additionally allows decimal point											if ( efFilterFlags & editFieldSignedFloat )						keyLegal = numeric || (k == '-' ) || ( k == '.' );										// unsigned integer disallows - sign											if ( efFilterFlags & editFieldUnsignedInteger )						keyLegal = numeric;											// unsigned float allows decimal point but not - sign										if ( efFilterFlags & editFieldUnsignedFloat )						keyLegal = numeric || ( k == '.' );										// password field? all chars permitted, but transmutes the character.										if ( efFilterFlags & editFieldHiddenChars )					{						// if not a control character, transmute to a bullet:												*theKey = '¥';					}										// count limit? if the next char would exceed the limit, reject it. The					// limit is only applicable if no lower limit flag, as it is stored in the					// min data member										if (( efFilterFlags & ( editFieldCharCountLimit + editFieldHasMinValue )) == editFieldCharCountLimit )					{						// how many chars in field?												TEHandle	dp = DIALOGTEXTEDITRECORD( GetMacDialog());						short 		chars = (*dp)->teLength;											if ( chars >= minLim )							keyLegal = FALSE;					}				}			}		}	}	return keyLegal;}void		ZDialogItem::GetDebugInfoString( Str255 s ){	Str31 ss;		CopyPString( "\pitem# ", s );	NumToString( id, ss );	ConcatPStrings( s, ss );	ConcatPStrings( s, "\p, type = " );	NumToString( iType, ss );	ConcatPStrings( s, ss );	ConcatPStrings( s, "\p, magic = " );	*(long*) &ss[1] = xType;	ss[0] = 4;	ConcatPStrings( s, ss );}void		ZDialogItem::ReportFields(){	ZCommander::ReportFields();	XSHOWFIELD( iType, ft_signedshort );	XSHOWFIELD( id, ft_signedshort );	XSHOWFIELD( efFilterFlags, ft_unsignedshort );	XSHOWFIELD( hHistory, ft_unsignedlong );	XSHOWFIELD( maxLim, ft_signedlong );	XSHOWFIELD( minLim, ft_signedlong );	XSHOWFIELD( xType, ft_fourcharcode );	XSHOWFIELD( bounds, ft_Rect );	XSHOWFIELD( font, ft_FontID );	XSHOWFIELD( fontSize, ft_signedshort );	XSHOWFIELD( fontStyle, ft_FontStyle );	XSHOWFIELD( fontJust, ft_signedshort );	XSHOWFIELD( enabled, ft_boolean );	XSHOWFIELD( focused, ft_boolean );	XSHOWFIELD( canTakeFocus, ft_boolean );	XSHOWFIELD( hilited, ft_boolean );	XSHOWFIELD( visible, ft_boolean );	XSHOWFIELD( isDefault, ft_boolean );	XSHOWFIELD( fSizing, ft_unsignedshort );	XSHOWFIELD( macItemHandle, ft_Handle );	XSHOWFIELD( pwMirror, ft_Handle );	XSHOWFIELD( bkColour, ft_RGBColor );	XSHOWFIELD( fgColour, ft_RGBColor );		Str255	ts;		if ( iType & ctrlItem )	{		GetTitle( ts );		SHOWFIELD( "->GetTitle()", ts, ft_str255 );	}	else	{		GetValueAsText( ts );		SHOWFIELD( "->GetValueAsText()", ts, ft_str255 );	}}	/*-------------------------------***  SETBOUNDS  ***------------------------------------*//*	set the bounds rect of the item. This moves or stretches the item as needed and posts therequisite updates----------------------------------------------------------------------------------------*/void		ZDialogItem::SetBounds( Rect* newBounds ){	Rect	oldBounds = bounds;		if ( ! EqualRect( &oldBounds, newBounds ))	{		EraseRect( &oldBounds );		bounds = *newBounds;			// if a control, move/change it as needed, also update the mac data for this:				SetDialogItem( GetMacDialog(), id, iType, macItemHandle, &bounds );			if ( iType & ctrlItem )			SETCONTROLRECT((ControlHandle) macItemHandle, &bounds );						// if an edit field and currently active, update the TextEdit record with the		// new bounds also				if ( enabled && focused && ( iType & editText ) == editText )		{			TEHandle dp = DIALOGTEXTEDITRECORD( GetMacDialog());					(*dp)->viewRect = bounds;					TECalText( dp );		}					InvalItem();	}}/*-----------------------------***  PARENTRESIZED  ***----------------------------------*//*	dialog containing this item has been resized- change size/position of this item accordingto flags set for the item----------------------------------------------------------------------------------------*/void		ZDialogItem::ParentResized( Rect* oldParentBounds, Rect* newParentBounds ){	Rect	newBounds = bounds;		// compute the new boundary based on the parent window and the resizing flags set		switch( TOPEDGESIZING( fSizing ))	{		case NONE:			break;					case FIXEDTOP:			newBounds.top = newParentBounds->top + ( bounds.top - oldParentBounds->top );			break;					case FIXEDBOTTOM:			newBounds.top = newParentBounds->bottom - ( oldParentBounds->bottom - bounds.top );				break;					case PROPORTIONAL:			// move the edge in proportion to the amount the window moved- i.e. ratio of			// distance from top and bottom window edges remains constant			newBounds.top = ((long) bounds.top * (long)(newParentBounds->bottom - newParentBounds->top)) / (long)( oldParentBounds->bottom - oldParentBounds->top );			break;	}			switch( LEFTEDGESIZING( fSizing ))	{		case NONE:			break;					case FIXEDLEFT:			newBounds.left = newParentBounds->left + ( bounds.left - oldParentBounds->left );			break;					case FIXEDRIGHT:			newBounds.left = newParentBounds->right - ( oldParentBounds->right - bounds.left );				break;					case PROPORTIONAL:			newBounds.left = ((long) bounds.left * (long)(newParentBounds->right - newParentBounds->left)) / (long)( oldParentBounds->right - oldParentBounds->left );			break;	}			switch( BOTTOMEDGESIZING( fSizing ))	{		case NONE:			break;					case FIXEDTOP:			newBounds.bottom = newParentBounds->top + ( bounds.bottom - oldParentBounds->top );			break;					case FIXEDBOTTOM:			newBounds.bottom = newParentBounds->bottom - ( oldParentBounds->bottom - bounds.bottom );				break;					case PROPORTIONAL:			newBounds.bottom = ((long) bounds.bottom * (long)(newParentBounds->bottom - newParentBounds->top)) / (long)( oldParentBounds->bottom - oldParentBounds->top );			break;	}			switch( RIGHTEDGESIZING( fSizing ))	{		case NONE:			break;					case FIXEDLEFT:			newBounds.right = newParentBounds->left + ( bounds.right - oldParentBounds->left );			break;					case FIXEDRIGHT:			newBounds.right = newParentBounds->right - ( oldParentBounds->right - bounds.right );				break;					case PROPORTIONAL:			newBounds.right = ((long) bounds.right * (long)(newParentBounds->right - newParentBounds->left)) / (long)( oldParentBounds->right - oldParentBounds->left );			break;	}				SetBounds( &newBounds );}/*-------------------------------***  SETAUTOSIZING  ***--------------------------------*//*	set the automatic sizing for the item. This is easier using the AUTOSIZE macro within theparameter list here. Each edge can be positioned relative to a window edge.----------------------------------------------------------------------------------------*/void		ZDialogItem::SetAutoSizing( Sizing sizeOptions ){	fSizing = sizeOptions;}/*---------------------------------***  DRAGHILITE  ***---------------------------------*//*	When an item can be the target of a drag, this is called to do the item hilite. Normally,just the bounds is used, but some items need more fiddling.----------------------------------------------------------------------------------------*/void		ZDialogItem::DragHilite( Boolean state, DragReference theDrag ){	RgnHandle	dragHiliteRgn;	ZGrafState	gs;		PrepareForDrawing();	if ( state )	{		FailNIL( dragHiliteRgn = NewRgn());			RectRgn( dragHiliteRgn, &bounds );				if ( iType & ( editText | ctrlItem ))			InsetRgn( dragHiliteRgn, -2, -2 );				(void) ShowDragHilite( theDrag, dragHiliteRgn, TRUE );				DisposeRgn( dragHiliteRgn );	}	else		(void) HideDragHilite( theDrag );}#pragma mark -#pragma mark ####   protected methods   ####/*----------------------------***  PREPAREFORDRAWING  ***-------------------------------*//*	set up the port ready for drawing this item----------------------------------------------------------------------------------------*/void	ZDialogItem::PrepareForDrawing(){	PenNormal();    BackPat( QDWHITEPATTERN );	    	// if font or size is zero, use whatever is currently set for the whole dialog		if ( font )		TextFont( font );			if ( fontSize )		TextSize( fontSize );		TextFace( fontStyle );    TextMode( srcOr );	RGBForeColor( &fgColour );	RGBBackColor( &bkColour );}/*------------------------------***  GETMACDIALOG  ***----------------------------------*//*	return the underlying Mac WindowPtr of the dialog this item is part of----------------------------------------------------------------------------------------*/DialogPtr	ZDialogItem::GetMacDialog(){	return ((ZDialog*) itsBoss)->GetMacDialog();}/*-----------------------------***  POPSTATEHISTORY  ***--------------------------------*//*	pop off the top bit of the history stack and return it----------------------------------------------------------------------------------------*/Boolean	ZDialogItem::PopStateHistory(){	Boolean sh;		sh = ( hHistory & 1 ) == 1;	hHistory = (hHistory >> 1 ) | 0x80000000;		return sh;}/*----------------------------***  PUSHSTATEHISTORY  ***--------------------------------*//*	push the bit onto the state history stack----------------------------------------------------------------------------------------*/void	ZDialogItem::PushStateHistory( Boolean aState ){	hHistory <<= 1;	hHistory |= ( aState? 1: 0 );}	/*---------------------------***  SUBSTITUTEPARAMTEXT  ***------------------------------*//*	insert paramtext into the passed string----------------------------------------------------------------------------------------*/void		ZDialogItem::SubstituteParamText( Str255 aString ){	StringHandle	pa, temp;	Boolean			nul = FALSE;	char			fa[2];		FailNIL( temp = NewString( aString ));		fa[0] = '^';		for ( short i = 0; i < 4; i++ )	{		fa[1] = i + '0';				#if TARGET_API_MAC_CARBON		// this is poor- I'll make it more elegant later		Str255			a, b, c, d;		GetParamText( a, b, c, d );				switch( i )		{			case 0:				pa = NewString( a );				break;							case 1:				pa = NewString( b );				break;							case 2:				pa = NewString( c );				break;							case 3:				pa = NewString( d );				break;		}				#else		pa = LMGetDAStrings( i );		#endif		// if the string is NULL, we substitute the empty string				if ( pa == NULL )		{			FailNIL( pa = NewString( "\p" ));		// make an empty string			nul = TRUE;		}				// search and replace ^0, ^1, etc...				HLock((Handle) pa );		Munger((Handle) temp, 1, fa, 2, (Ptr)(*pa) + 1, **pa );		HUnlock((Handle) pa );				if ( nul )		{			DisposeHandle((Handle) pa );			nul = FALSE;		}	}		**temp = ( GetHandleSize((Handle) temp ) - 1 ) & 0xFF;	CopyPString( *temp, aString );		DisposeHandle((Handle) temp );}/*-----------------------------***  ValidationAlert  ***--------------------------------*//*	display alert indicating reason why edit field could not be validated----------------------------------------------------------------------------------------*/void	ZDialogItem::ValidationAlert( const Boolean showAlert, const short reason ){	// invalid field, so show alert if wanted and abort	// set the value in the field to a legal one...		long			val, min, max;	unsigned short	iFlags;	short			alertID;	GetLimits( &min, &max );	val = GetValue();		// hilite ourselves...	SelfSelect();	DoSelectAll();			// show the alert...	if ( showAlert )	{		Str15 	ma, mb;		Str32	sa, sb;				iFlags = GetFilterFlags();				switch ( reason )		{			case kEditFieldOutOfRange:				alertID = kFieldRangeAlertID;				NumToString( min, ma );				NumToString( max, mb );								if (( iFlags & ( editFieldHasMinValue + editFieldHasMaxValue )) ==							   ( editFieldHasMinValue + editFieldHasMaxValue ))				{					GetIndString( sa, kEditFieldValidationStringsID, kEditFieldIsBetween );					GetIndString( sb, kEditFieldValidationStringsID, kEditFieldAnd );				}				else				{					sb[0] = 0;					mb[0] = 0;										if ( iFlags & editFieldHasMinValue )						GetIndString( sa, kEditFieldValidationStringsID, kEditFieldIsGreaterThan );					else					{						GetIndString( sa, kEditFieldValidationStringsID, kEditFieldIsLessThan );						NumToString( max, ma );					}				}				break;							case kEditFieldIsEmpty:				alertID = kFieldEmptyAlertID;				break;		}				ParamText( sa, ma, sb, mb );		NotifyAlert( alertID );	}	else		SysBeep( 1 );		// set nearest valid value			SetValue( MIN( MAX( val, min ), max ));	DoSelectAll();}/*-------------------------------***  DRAWSTDFRAME  ***---------------------------------*//*	draws a standard frame for the item, taking into account colour, hilited state, etc.----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawStdFrame( Rect* frame ){	Boolean		colour = IsColourPort( DIALOGGRAFPTR( GetMacDialog()));	Rect		r = *frame;			if ( ! hilited )	{		if ( colour )			RGBForeColor( &gMidGray );		else			PenPat( QDGRAYPATTERN );	}		InsetRect( &r, -1 , -1 );	FrameRect( &r );	PenNormal();		if ( colour )	{		if ( hilited )			FrameGrayRect( &r );		else		{			// erase 3D border						InsetRect( &r , -1, -1 );						RGBColor winBack;						((ZDialog*) itsBoss )->GetBackColour( &winBack );			RGBForeColor( &winBack );			FrameRect( &r );			RGBForeColor( &fgColour );		}	}}/*--------------------------------***  DRAWITEM  ***------------------------------------*//*	draw or update the item in the current port, font, colours, etc. Called by Draw().----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawItem(){	switch ( iType & 0x7C )	{		case userItem:			DrawUserItem();			break;					case picItem:			DrawPictureItem();			break;					case iconItem:			DrawIconItem();			break;					case ctrlItem:			DrawControlItem();			break;					default:			DrawTextItem();			break;	}}/*-------------------------------***  DRAWUSERITEM  ***---------------------------------*//*	draw standard user item----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawUserItem(){	((ZDialog*) itsBoss)->DrawUserItem( id, &bounds, hilited );}/*-----------------------------***  DRAWPICTUREITEM  ***--------------------------------*//*	draw standard picture item----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawPictureItem(){	if ( macItemHandle )	{		LoadResource( macItemHandle );		DrawPicture((PicHandle) macItemHandle, &bounds );				if ( groupID == 99 )			FrameRect( &bounds );	}}/*-------------------------------***  DRAWICONITEM  ***---------------------------------*//*	draw standard icon item----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawIconItem(){	// need to determine if icon is classic ICON or cicn type	// and deal with it accordingly. If handle is exactly 128	// bytes, we assume ICON, else cicn		if ( macItemHandle )	{		if ( GetHandleSize( macItemHandle ) == 128 )		{			CIconHandle		si = NULL;			long checksum = ChecksumHandle( macItemHandle );						// workaround a bug (which I don't really understand) where icons 0, 1 and 2			// are not displayed in colour. We look for the special signature checksums			// of these icons and deal with them as a special case. Other icons appear to work			// correctly. This technique relies on the design of the black and white icon not changing.						switch ( checksum )			{				case kStopIconChecksum:					si = GetCIcon( stopIcon );					break;									case kNoteIconChecksum:					si = GetCIcon( noteIcon );					break;									case kCautionIconChecksum:					si = GetCIcon( cautionIcon );					break;								default:					PlotIcon( &bounds, macItemHandle );										if ( ! hilited )					{						PenPat( QDGRAYPATTERN );						PenMode( patBic );						PaintRect( &bounds );					}			}						if ( si )			{				PlotCIconHandle( &bounds, kAlignNone, hilited? kTransformNone : kTransformDisabled, si );				DisposeCIcon( si );			}		}		else			PlotCIconHandle( &bounds, kAlignNone, hilited? kTransformNone : kTransformDisabled, (CIconHandle) macItemHandle );	}}/*-----------------------------***  DRAWCONTROLITEM  ***--------------------------------*//*	draw standard control item----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawControlItem(){	if ( macItemHandle )		Draw1Control((ControlHandle) macItemHandle );}/*------------------------------***  DRAWTEXTITEM  ***----------------------------------*//*	draw standard text item----------------------------------------------------------------------------------------*/void	ZDialogItem::DrawTextItem(){	Rect 		r = bounds;	Boolean		stat = ( iType & statText ) == statText;	TEHandle	dp = DIALOGTEXTEDITRECORD( GetMacDialog());	Boolean		colour = IsColourPort( DIALOGGRAFPTR( GetMacDialog()));	RgnHandle	saveClip;		// erase to background colour		GetClip( saveClip = NewRgn());		if ( ! stat )	{		InsetRect( &r, -2, -2 );		EraseRect( &r );	}		ClipRect( &r );		if ( focused )		TEUpdate( &bounds, dp ); 	else	{		// have to mimic the edit field using TETextBox			Str255	iText;				GetDialogItemText( macItemHandle, iText );				// need to substitute paramtext for static items				if ( stat )			SubstituteParamText( iText );					// draw greyed out if disabled				if ( hilited )			TextMode( srcOr );		else		{			TextMode( grayishTextOr );						// there's a bug in MacOS 8.5 in that grayishTextOr doesn't work right			// for non-colour windows, so let's work around it...						if ( ! colour && ( gMacInfo.systemVersion == 0x0850 ))				TextMode( srcOr );		}					TETextBox( &iText[1], iText[0], &bounds, fontJust );				// workaround 8.5 bug...				if ( ! colour && ! hilited && ( gMacInfo.systemVersion == 0x0850 ))		{			PenPat( QDGRAYPATTERN );			PenMode( patBic );			PaintRect( &bounds );			PenNormal();		}	}		SetClip( saveClip );	DisposeRgn( saveClip );		if ( ! stat )	{	#if APPEARANCE_MGR_AWARE				if ( gMacInfo.hasAppearanceMgr )			DrawThemeEditTextFrame( &r, hilited? kThemeStateActive : kThemeStateInactive );		else		{	#endif			DrawStdFrame( &r );			#if APPEARANCE_MGR_AWARE		}	#endif	}}void       ZDialogItem::SetUpTextEdit(){    if ( iType & editText )    {        TEHandle  	dp = DIALOGTEXTEDITRECORD( GetMacDialog());        Rect        r;		FontInfo	fi;                (*dp)->hText = macItemHandle;        (*dp)->teLength = GetHandleSize( macItemHandle );        TESetAlignment( fontJust, dp );                r = bounds;        (*dp)->viewRect = r;        switch( fontJust )        {            default:            case teJustLeft:                r.right = r.left + 500;                break;                            case teJustCenter:                r.left  -= 240;                r.right += 240;                break;                            case teJustRight:                r.left = r.right - 500;                break;        }        (*dp)->destRect = r;        		GetFontInfo( &fi );				(*dp)->lineHeight = fi.ascent + fi.descent + fi.leading;		(*dp)->fontAscent = fi.ascent;				(*dp)->txFont = PORTTEXTFONT( CURRENTPORT );		(*dp)->txSize = PORTTEXTSIZE( CURRENTPORT );		(*dp)->txFace = PORTTEXTFACE( CURRENTPORT );		(*dp)->txMode = srcOr;		        TECalText( dp );                // set edit field value in dialog record- this is necessary so that        // the DM and MacZoop are in agreement about which item has the focus,        // since embedded appearance controls require this info from the DM                if ( shGroup != 0 )            SelectDialogItemText( GetMacDialog(), id, (*dp)->selStart, (*dp)->selEnd );    }}/*--------------------------------***  VALIDITEM  ***-----------------------------------*//*	mark item as valid (remove from update region)----------------------------------------------------------------------------------------*/void		ZDialogItem::ValidItem(){	Rect	r;		if ( visible )	{		r = bounds;				InsetRect( &r, -2, -2 );		if ( focused || isDefault )			InsetRect( &r, -2, -2 );				if ( iType & editText )			InsetRect( &r, -2, -2 );					if ( iType == userItem )		{			RgnHandle	temp;						RectRgn( gUtilRgn, &r );			InsetRect( &r, 2, 2 );			RectRgn( temp = NewRgn(), &r );			DiffRgn( gUtilRgn, temp, temp );			MZValidWindowRgn( DIALOGWINDOW( GetMacDialog()), temp );			DisposeRgn( temp );		}		else		    MZValidWindowRect( DIALOGWINDOW( GetMacDialog()), &r );	}}/*--------------------------------***  INVALITEM  ***-----------------------------------*//*	mark item as invalid (add to update region)----------------------------------------------------------------------------------------*/void		ZDialogItem::InvalItem(){	Rect	r;		r = bounds;		InsetRect( &r, -2, -2 );		if ( focused || isDefault )		InsetRect( &r, -2, -2 );		if ( iType & editText )		InsetRect( &r, -2, -2 );			// if the item is a standard user-item, we only should invalidate the	// border, not the whole interior, since if surrounding a control, this	// will cause unnecessary redrawing. However, if you are using a user item	// for some other type of item, you may want to set the <kNonGroupFrameUserItem>	// bit in iType in order to get the full invalidation		if ( iType == userItem )	{		RgnHandle	temp;				RectRgn( gUtilRgn, &r );		InsetRect( &r, 2, 2 );		RectRgn( temp = NewRgn(), &r );		DiffRgn( gUtilRgn, temp, temp );		MZInvalWindowRgn( DIALOGWINDOW( GetMacDialog()), temp );		DisposeRgn( temp );	}	else		MZInvalWindowRect( DIALOGWINDOW( GetMacDialog()), &r );}/*--------------------------------***  FOCUSBOSS  ***-----------------------------------*//*	set the boss of this item as the current port----------------------------------------------------------------------------------------*/void	ZDialogItem::FocusBoss(){	((ZDialog*) itsBoss )->Focus();}