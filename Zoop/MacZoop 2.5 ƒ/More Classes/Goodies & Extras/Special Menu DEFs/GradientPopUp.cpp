/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			GradientPopUp.cpp	-- high level functions for handling gradient picker pop-ups******			© 2000, Graham Cox*****************************************************************************************************/#include    "GradientPopUp.h"#include    "MacZoop.h"#include    "xDEFJump.h"static void DrawGradMenu( GradientMenuHandle theMenu, Rect* menuRect, short chipsH, short chipsV, short initIndex );static void ChooseGradMenuItem( MenuHandle theMenu, short* whichItem, Rect* menuRect, Point hitPt, short chipsH, short chipsV );static void CalcGradMenuSize( MenuHandle theMenu, short chipsH, short chipsV );static void CalcPopGradMenuSize( Point hitPt, Rect* mRect, short chipsH, short chipsV );#if TARGET_API_MAC_CARBONstatic void FindGradMenuItem( Point mouse, Rect* mRect, short chipsH, short chipsV, MenuTrackingData* trackData );static void HiliteGradMenuItem( Rect* mRect, short chipsH, short chipsV, HiliteMenuItemData* hiliteData );#endif#define		kSwatchSize		32#define		kSwatchOffset	2#define		kMaxSwatchesH	6GradientMenuHandle  NewGradientMenu( short menuID, Handle gradList ){	GradientMenuHandle 	theMenu = (GradientMenuHandle) NewHandleClear( sizeof( GradientMenuRecord ));	if ( theMenu )	{		(*theMenu)->initIndex = 0;		(*theMenu)->menuRefCon = 0;		(*theMenu)->menuGradList = gradList;		if ( gradList )		{    		// copy the gradient list handle so we can be sure it's ours    		    		HLock((Handle) theMenu );    		HandToHand( &(*theMenu)->menuGradList );    		HUnlock((Handle) theMenu );		}    #if TARGET_API_MAC_CARBON        MenuRef         mNew;        MenuDefSpec     mDefSpec;        OSStatus        err;                mDefSpec.defType = kMenuDefProcPtr;        mDefSpec.u.defProc = NewMenuDefUPP( GradMDEFFunction );                err = CreateCustomMenu( &mDefSpec, menuID, 0, &mNew );                 if ( err == noErr )        {            (*theMenu)->theMenu = mNew;                    // attach this structure as menu refcon data to the menu                        SetMenuItemRefCon( mNew, 0, (UInt32) theMenu );            CalcMenuSize( mNew );        }       #else	    Handle      mdefHandle;	    		mdefHandle = GetUniversalFunctionHandle((ProcPtr) GradMDEFFunction, uppMenuDefProcInfo );				(*theMenu)->menuRecord.menuProc = mdefHandle;		(*theMenu)->menuRecord.menuID = menuID;				CalcMenuSize((MenuHandle) theMenu );	#endif	}		return theMenu;}void                DisposeGradientMenu(  GradientMenuHandle gm ){#if TARGET_API_MAC_CARBON    MenuDefSpec  defSpec;        GetMenuDefinition((*gm)->theMenu, &defSpec );     DisposeMenu((*gm)->theMenu );    DisposeMenuDefUPP( defSpec.u.defProc );#else	Handle	mdefHandle = (*gm)->menuRecord.menuProc;		if ( mdefHandle )		DisposeHandle( mdefHandle );#endif		if ((*gm)->menuGradList )	    DisposeHandle((*gm)->menuGradList );	DisposeHandle((Handle) gm );}long                PopUpGradientMenu( Point loc, Handle gradList, short initialItem ){	GradientMenuHandle	theMenu;	MenuHandle          realMenu;	long			    mSelect = 0;		// create menu data structure:		theMenu = NewGradientMenu( kGradientPopUpMenuID, gradList );		if ( theMenu )	{		(*theMenu)->initIndex = initialItem;	#if TARGET_API_MAC_CARBON		    realMenu = (*theMenu)->theMenu;		#else	    realMenu = (MenuHandle) theMenu;	#endif					InsertMenu( realMenu, hierMenu );				// menu installed and ready to go, now we pop it up and track it.		// This uses std menu manager call.				mSelect = PopUpMenuSelect( realMenu, loc.v, loc.h, 1 );				// delete and dispose of the menu now we've finished with it 				DeleteMenu( kGradientPopUpMenuID );		DisposeGradientMenu( theMenu );	}		return mSelect;}Handle              NewGradientList(){    return NewHandleClear( 0 );}void                AddGradientToList( Handle gradList, UGradient* gradient ){    GradientRecHdl  gr;        FailNILParam( gradient );    FailNILParam( gradList );        gr = gradient->GetGradHandle();        FailOSErr( HandAndHand((Handle) gr, gradList ));        DisposeHandle((Handle) gr );   }GradientRecHdl      GetIndGradient( Handle gradList, short index ){    GradientRecHdl  h = NULL;    GradientRecPtr  tgp;        if ( gradList )    {        short   mx = GetHandleSize( gradList ) / sizeof( GradientRecord );        if ( index >= 0 && index < mx )        {        	HLock( gradList );        	tgp = (GradientRecPtr) *gradList;                    tgp += index;                        FailOSErr( PtrToHand((Ptr) tgp, (Handle*) &h, sizeof( GradientRecord )));            HUnlock( gradList );	        }    }        return h;} void			    DrawStandardGradientSelector( Rect *bounds, UGradient* gradient ){	/* assumes current port */		Rect			temp;	Point           centre;	RGBColor		saveBack;		temp = *bounds;	temp.right--;	temp.bottom--;		GetBackColor( &saveBack );	RGBForeColor( &gBlack );	RGBBackColor( &gWhite );	EraseRect( &temp );	FrameRect( &temp );		MoveTo( temp.left + 2, temp.bottom );	LineTo( temp.right, temp.bottom );	LineTo( temp.right, temp.top + 2 );		InsetRect( &temp, 3, 3 );		centre.h = ( bounds->left + bounds->right ) / 2;	centre.v = ( bounds->top + bounds->bottom ) / 2;        if ( gradient )	    gradient->GradientFillRectInPort( &temp, centre );		RGBBackColor( &saveBack );	DrawSICN( kStdPopUpArrowSICN, 2, topLeft( temp ));}#pragma mark -pascal void	GradMDEFFunction( short message, MenuHandle theMenu,							  Rect *menuRect, Point hitPt, short *whichItem ){	GradientMenuHandle  gm;	short			    chipsH,chipsV;	short			    numSwatches;	static Boolean	    isInited = FALSE;		try	{    	if ( theMenu )    	{    	#if TARGET_API_MAC_CARBON    	    GetMenuItemRefCon( theMenu, 0, (UInt32*) &gm );    	#else	    		gm = (GradientMenuHandle) theMenu;    	#endif	    		// set up the number of rows and columns in the menu    		    		if ((*gm)->menuGradList )    		    numSwatches = GetHandleSize((*gm)->menuGradList ) / sizeof( GradientRecord );    		else    		    numSwatches = 0;    		        		chipsH = MIN( numSwatches, kMaxSwatchesH );    		chipsV = MAX( 1, numSwatches / chipsH );    		    		switch(message)    		{    			case mDrawMsg:    				DrawGradMenu( gm, menuRect, chipsH, chipsV, (*gm)->initIndex );    				isInited = FALSE;    				break;    			    			case mChooseMsg:    				if (isInited)    					ChooseGradMenuItem( theMenu, whichItem, menuRect, hitPt, chipsH, chipsV );    				else    				{    					if (PtInRect(hitPt,menuRect))    					{    						*whichItem = (*gm)->initIndex;    						isInited = TRUE;    					}    				}    				break;    			    			case mSizeMsg:    				CalcGradMenuSize( theMenu, chipsH, chipsV );    				break;    			    			case mPopUpMsg:    				CalcPopGradMenuSize( hitPt, menuRect, chipsH, chipsV );    				break;    			    		#if TARGET_API_MAC_CARBON    		    case kMenuFindItemMsg:    		        FindGradMenuItem( hitPt, menuRect, chipsH, chipsV, (MenuTrackingData*) whichItem );    		        break;    		            		    case kMenuHiliteItemMsg:    		        HiliteGradMenuItem( menuRect, chipsH, chipsV, (HiliteMenuItemData*) whichItem );    		        break;    		#endif    			default:    				break;    		}    	}    }    catch( ... )    {    }}void DrawGradMenu( GradientMenuHandle theMenu, Rect* menuRect, short chipsH, short chipsV, short initIndex ){	// draws the menu		short			h, v, i;	short 			swatchWidth,swatchHeight;	Rect			sr;	Point			zero = {0,0}, centre;	GradientRecHdl  tempGrad;	UGradient*      tg;		swatchWidth = swatchHeight = kSwatchSize;		SetRect( &sr, kSwatchOffset, kSwatchOffset, swatchWidth + kSwatchOffset, swatchHeight + kSwatchOffset );	OffsetRect( &sr, menuRect->left, menuRect->top );	PenNormal();	SetPortBlackWhite();	EraseRect(menuRect);		tg = new UGradient();	i = 0;		for ( v = 0; v < chipsV; v++ )	{		for ( h = 0; h < chipsH; h++ )		{		    tempGrad = GetIndGradient((*theMenu)->menuGradList, i );						if ( tempGrad )			{			    tg->SetGradHandle( tempGrad );			    DisposeHandle((Handle) tempGrad );			}						centre.h = ( sr.left + sr.right ) / 2;			centre.v = ( sr.top + sr.bottom ) / 2;						tg->GradientFillRectInPort( &sr, centre );						i++;						FrameRect(&sr);			OffsetRect( &sr, swatchWidth + kSwatchOffset, 0 );		}		OffsetRect( &sr, -chipsH * (swatchWidth + kSwatchOffset), swatchHeight + kSwatchOffset );	}		HUnlock((*theMenu)->menuGradList );	ForgetObject( tg );		ChooseGradMenuItem((MenuHandle) theMenu, &initIndex, menuRect, zero, chipsH, chipsV );}void ChooseGradMenuItem( MenuHandle theMenu, short* whichItem, Rect* menuRect, Point hitPt, short chipsH, short chipsV ){	// tracks mouse in menu	Rect 			mRect,swatchRect,oldSwatchRect;	short			sv,sh,item,oh,ov;	PenState		penSave;	short			numSwatches;	short 			swatchWidth,swatchHeight;		swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;	numSwatches = chipsH * chipsV;		GetPenState( &penSave );	PenMode( patXor );	PenSize( kSwatchOffset + 1, kSwatchOffset + 1 );			mRect = *menuRect;	InsetRect( &mRect, 1, 1 );	SetRect( &swatchRect, 0, 0, swatchWidth + kSwatchOffset, swatchHeight + kSwatchOffset );	OffsetRect( &swatchRect, menuRect->left, menuRect->top );	oldSwatchRect = swatchRect;		if ( PtInRect( hitPt, &mRect ))	{		/* mouse is in the menu, see which item it's in */				for ( sv = 0; sv < chipsV; sv++ )		{			for ( sh = 0; sh < chipsH; sh++ )			{				if ( PtInRect( hitPt, &swatchRect ))					goto found;				else					OffsetRect( &swatchRect, swatchWidth, 0 );			}			OffsetRect( &swatchRect, -chipsH * swatchWidth, swatchHeight );		}	found:				item = ( sv * chipsH + sh ) + 1;		if ( item <= numSwatches && item != *whichItem )		{			/* a new one, so unhighlight old one and hilite new one */						if ( *whichItem != 0 )			{				/* there really is an old one, so calc the hilite */				oh = ( *whichItem - 1 ) % chipsH;				ov = ( *whichItem - 1 ) / chipsH;				OffsetRect( &oldSwatchRect, oh * swatchWidth, ov * swatchHeight );				FrameRect( &oldSwatchRect );									/*Xor it out */			}			FrameRect( &swatchRect );											/*Xor it in */			*whichItem = item;		}	}	else	{		if ( *whichItem != 0 )		{			oh = ( *whichItem - 1 ) % chipsH;			ov = ( *whichItem - 1 ) / chipsH;			OffsetRect( &oldSwatchRect, oh * swatchWidth, ov * swatchHeight );			FrameRect( &oldSwatchRect );						*whichItem = 0;		}	}		SetPenState( &penSave );}void CalcGradMenuSize( MenuHandle theMenu, short chipsH, short chipsV ){	// computes the menu's dimensions		short swatchWidth,swatchHeight;		swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;#if TARGET_API_MAC_CARBON    SetMenuWidth( theMenu, (swatchWidth * chipsH) + kSwatchOffset );    SetMenuHeight( theMenu, (swatchHeight * chipsV) + kSwatchOffset );#else	(*theMenu)->menuWidth = (swatchWidth * chipsH) + kSwatchOffset;	(*theMenu)->menuHeight = (swatchHeight * chipsV) + kSwatchOffset;#endif}void CalcPopGradMenuSize( Point hitPt, Rect* mRect, short chipsH, short chipsV ){	// dimensions for pop-up menu	Rect 		sRect;	GDHandle	mainScreen;	short 		swatchWidth,swatchHeight;		swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;	mRect->top = hitPt.h;	/* point order is reversed */	mRect->left = hitPt.v;	mRect->right = mRect->left + (swatchWidth * chipsH) + kSwatchOffset;	mRect->bottom = mRect->top + (swatchHeight * chipsV) + kSwatchOffset;		mainScreen = GetMainDevice();	if (mainScreen)	{		sRect = (*(*mainScreen)->gdPMap)->bounds;		InsetRect(&sRect,4,4);	}	if (mRect->right > sRect.right)		OffsetRect(mRect,-(mRect->right - sRect.right),0); 		if (mRect->bottom > sRect.bottom)		OffsetRect(mRect,0,-(mRect->bottom - sRect.bottom)); }#if TARGET_API_MAC_CARBONstatic void FindGradMenuItem( Point mouse, Rect* mRect, short chipsH, short chipsV, MenuTrackingData* trackData ){    // locate the item under the hit Pt and pass its rect back        if ( PtInRect( mouse, mRect ))    {		short   sv, sh, swatchWidth, swatchHeight, numSwatches, item;		Rect    swatchRect;		    	swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;    	numSwatches = chipsH * chipsV;    	SetRect( &swatchRect, 0, 0, swatchWidth, swatchHeight );    	OffsetRect( &swatchRect, mRect->left, mRect->top );		for ( sv = 0; sv < chipsV; sv++ )		{			for ( sh = 0; sh < chipsH; sh++ )			{				if ( PtInRect( mouse, &swatchRect ))					goto found;				else					OffsetRect( &swatchRect, swatchWidth, 0 );			}			OffsetRect( &swatchRect, -chipsH * swatchWidth, swatchHeight );		}        trackData->itemSelected = 0;        trackData->itemUnderMouse = 0;		return;		found:		item = ( sv * chipsV + sh ) + 1;        trackData->itemSelected = item;        trackData->itemUnderMouse = item;    }    else    {        trackData->itemSelected = 0;        trackData->itemUnderMouse = 0;    }}static void HiliteGradMenuItem( Rect* mRect, short chipsH, short chipsV, HiliteMenuItemData* hiliteData ){	PenState penSave;	short   swatchWidth, swatchHeight, numSwatches, oh, ov;	Rect    swatchRect, oldSwatchRect;		GetPenState( &penSave );	PenMode( patXor );	PenSize( kSwatchOffset + 1, kSwatchOffset + 1 );	    swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;	numSwatches = chipsH * chipsV;	SetRect( &swatchRect, 0, 0, swatchWidth + kSwatchOffset, swatchHeight + kSwatchOffset );	OffsetRect( &swatchRect, mRect->left, mRect->top );    oldSwatchRect = swatchRect;    	if ( hiliteData->previousItem != 0 )	{		/* there really is an old one, so calc the hilite */		oh = ( hiliteData->previousItem - 1 ) / chipsH;		ov = ( hiliteData->previousItem - 1 ) % chipsH;		OffsetRect( &oldSwatchRect, ov * swatchWidth, oh * swatchHeight );		FrameRect( &oldSwatchRect );	}	if ( hiliteData->newItem != 0 )	{		/* there really is an old one, so calc the hilite */		oh = ( hiliteData->newItem - 1 ) / chipsH;		ov = ( hiliteData->newItem - 1 ) % chipsH;		OffsetRect( &swatchRect, ov * swatchWidth, oh * swatchHeight );		FrameRect( &swatchRect );	}        SetPenState( &penSave );}#endif