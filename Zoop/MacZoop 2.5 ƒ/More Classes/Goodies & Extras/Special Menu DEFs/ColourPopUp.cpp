/****************************************************************************************************			MacZoop - "the framework for the rest of us"			 ****			ColourPopUp.c			-- high level functions for handling colour picker pop-ups******			© 1994, Graham Cox (created 15/7/94, modified for MacZoop 97-99)*****************************************************************************************************/#include	"ColourPopUp.h"#include    "MacZoop.h"#include	<Palettes.h>RGBColor	gCurrentPopUpColour = { 0xDDDD, 0xDDDD, 0xDDDD };#if APPEARANCE_MGR_AWARE#include <appearance.h>#endif/*-----------------------------***  NEWCOLOURMENU  ***----------------------------------*//*	create a new colour menu handle. Uses passed colour table, but does NOT become owner ofit- caller is responsible for its later disposal. This sets up the embedded MDEF tothe PalMDEF code.----------------------------------------------------------------------------------------*/#if TARGET_API_MAC_CARBON#include <menus.h>CPMenuHandle	NewColourMenu( short menuID, CTabHandle aCTab ){    CPMenuHandle    theMenu = NULL;    MenuDefSpec     mDefSpec;    MenuRef         mNew;        theMenu = (CPMenuHandle) NewHandle( sizeof( CPMenuRecord ));        (*theMenu)->menuColours = aCTab;    (*theMenu)->initIndex = 0;        // make a carbon menu        mDefSpec.defType = kMenuDefProcPtr;    mDefSpec.u.defProc = NewMenuDefUPP( PalMDEFFunction );        FailOSStatus( CreateCustomMenu( &mDefSpec, menuID, 0, &mNew ));        (*theMenu)->theMenu = mNew;    // attach this structure as menu refcon data to the menu        SetMenuItemRefCon( mNew, 0, (UInt32) theMenu );    CalcMenuSize( mNew );       return theMenu;}#else#include	"xDEFjump.h"CPMenuHandle	NewColourMenu( short menuID, CTabHandle aCTab ){	Handle			mdefHandle;	CPMenuHandle 	theMenu = (CPMenuHandle) NewHandleClear( sizeof( CPMenuRecord ));	if( theMenu )	{		mdefHandle = GetUniversalFunctionHandle((ProcPtr) PalMDEFFunction, uppMenuDefProcInfo );				(*theMenu)->menuRecord.menuProc = mdefHandle;		(*theMenu)->menuRecord.menuID = menuID;		(*theMenu)->initIndex = 0;		(*theMenu)->allowTearOff = FALSE;				(*theMenu)->menuColours = aCTab;				CalcMenuSize((MenuHandle) theMenu );	}	return theMenu;}#endif/*---------------------------***  DISPOSECOLOURMENU  ***--------------------------------*//*	dispose a colour menu handle.----------------------------------------------------------------------------------------*/#if TARGET_API_MAC_CARBONvoid        DisposeColourMenu( CPMenuHandle aCMenu ){    MenuDefSpec  defSpec;        GetMenuDefinition((*aCMenu)->theMenu, &defSpec );     DisposeMenu((*aCMenu)->theMenu );    DisposeMenuDefUPP( defSpec.u.defProc );    DisposeHandle((Handle) aCMenu );}#elsevoid		DisposeColourMenu( CPMenuHandle aCMenu ){	Handle	mdefHandle = (*aCMenu)->menuRecord.menuProc;		if ( mdefHandle )		DisposeHandle( mdefHandle );		DisposeHandle((Handle) aCMenu );}#endif/*------------------------------***  SETTEARABLE  ***-----------------------------------*//*	set whether the menu can be "torn off" or not. Normally, a colour menu can't be torn offso call this if you want that behaviour. Note that PopUpColourTable sets this TRUE.----------------------------------------------------------------------------------------*/void		SetTearable( CPMenuHandle aCMenu, Boolean canBeTorn ){#if ! TARGET_API_MAC_CARBON	if ( aCMenu )		(*aCMenu)->allowTearOff = canBeTorn;#endif}/*---------------------------***  POPUPCOLOURTABLE  ***---------------------------------*//*	pop up a colour table menu at the given global location. This returns the menu ID andchosen item just as PopUpMenuSelect would. Pass <initialItem> to select the existinghilite. Picked colour is returned in <selectedColour>----------------------------------------------------------------------------------------*/long		PopUpColourTable( Point location, CTabHandle aCTable, RGBColor *selectedColour, short initialItem ){	CPMenuHandle	theMenu;	MenuHandle      realMenu;	short			menuID,itemID;	long			mSelect = 0;		// create menu data structure:		theMenu = NewColourMenu( kColourPopUpMenuID, aCTable );		if ( theMenu )	{		(*theMenu)->initIndex = initialItem;		SetTearable( theMenu, FALSE );			#if TARGET_API_MAC_CARBON	    realMenu = (*theMenu)->theMenu;	#else	    realMenu = (MenuHandle) theMenu;	#endif	                // insert menu into list and pop it up, track it, etc...        		InsertMenu( realMenu, hierMenu );		mSelect = PopUpMenuSelect( realMenu, location.v, location.h, 1 );				// delete and dispose of the menu now we've finished with it 				DeleteMenu( kColourPopUpMenuID );		DisposeColourMenu( theMenu );				// now determine if we chose anything, and extract the colour if we did				menuID = HiWord( mSelect );		itemID = LoWord( mSelect );				if ( menuID == kColourPopUpMenuID && aCTable )			*selectedColour = (*aCTable)->ctTable[itemID -1].rgb;	}		return mSelect;}/*--------------------------***  POPUPCOLOURPALETTE  ***--------------------------------*//*	as above, but accepts a 'clut' resource ID----------------------------------------------------------------------------------------*/long		PopUpColourPalette( Point location, short cTableID, RGBColor *selectedColour, short initialItem ){	/*	When you get a mouse down in the place you want to pop the menu up, call this function. The	'clut' resource specified by the <cTableID> is loaded and displayed in the menu. The <location>	parameter specifies the desired top,left point of the menu in global coordinates. The menu	itself will be constrained by the monitor dimensions. The function returns the menuID in the	high order word, and the index of the selected colour in the low order word. In addition,	the chosen colour is returned in <selectedColour>. This saves you from reloading the clut to	obtain the chosen colour. If no colour was picked, this result is undefined, and the function	returns 0 as its result. Normally, the menu ID value should be ignored as it is created and	destroyed on the fly by this function, and does not refer to a currently installed menu. Note	that you are responsible for performing the highlighting (if any) of the clicked area.	*/	CTabHandle		theColours;	long			mSelect = 0;		FailNILRes( theColours = GetCTable( cTableID ));		if ( theColours )	{		mSelect = PopUpColourTable( location, theColours, selectedColour, initialItem );		DisposeCTable( theColours );	}	return mSelect;}/*----------------------***  DRAWSTANDARDCOLOURSELECTOR  ***----------------------------*//*	draw a standard pop-up box for a colour menu, within <bounds> and with the colourpassed.----------------------------------------------------------------------------------------*/void		DrawStandardColourSelector( Rect *bounds, RGBColor *theColour ){	/* assumes current port */	Rect			temp;	RGBColor		saveBack;	unsigned short	avgColour;		temp = *bounds;/*	#if APPEARANCE_MGR_AWARE	if ( gMacInfo.hasAppearanceMgr )	{		ThemeButtonDrawInfo		tbdi, prev;				tbdi.state = kThemeStateActive;		tbdi.value = kThemeButtonOff;		tbdi.adornment = kThemeAdornmentNone;				DrawThemeButton( &temp, kThemePopupButton, &tbdi, &prev, NULL, NULL, 0 );				InsetRect( &temp, 3, 3 );		temp.right -= 21;				RGBForeColor( theColour );		PaintRoundRect( &temp, 5, 5 );		ForeColor( blackColor );		FrameRoundRect( &temp, 5, 5 );				}	else	{#endif	*/	temp.right--;	temp.bottom--;	GetBackColor( &saveBack );	BackColor( whiteColor );	EraseRect( &temp );	RGBBackColor( &saveBack );	FrameRect( &temp );		MoveTo( temp.left + 2, temp.bottom );	LineTo( temp.right, temp.bottom );	LineTo( temp.right, temp.top + 2 );		InsetRect( &temp, 3, 3 );	RGBForeColor( theColour );	PaintRect( &temp );		// determine if the arrow should be drawn in black or white, for best contrast. Since the human eye	// perceives brightness differently according to the percentage of the colour components, we need	// to compensate when doing the calculation. In addition, we threshold at 44% rather than 50,	// which looks better		// weighting applied is Red- 30%, Green- 59%, Blue- 11%		avgColour = (unsigned short)(((float) theColour->red   * 0.3  ) +				 				 ((float) theColour->green * 0.59 ) +				 				 ((float) theColour->blue  * 0.11 ));		if ( avgColour > 0x7F7F )		ForeColor( blackColor );	else		ForeColor( whiteColor );		temp.left = temp.right - 17;	temp.top = temp.bottom - 15;		DrawSICN( kStdPopUpArrowSICN, 2, TOPLEFTPOINT( temp ));	ForeColor( blackColor );/*#if APPEARANCE_MGR_AWARE	}#endif*/}/*----------------------***  INVERTSTANDARDCOLOURSELECTOR  ***--------------------------*//*	invert the frame of a colour selector. Usually done while menu is popped up. Call againto unhilite.----------------------------------------------------------------------------------------*/void		InvertStandardColourSelector( Rect *bounds ){	PenState	pnState;	Rect		temp;		GetPenState( &pnState );		temp = *bounds;	temp.right--;	temp.bottom--;	InsetRect( &temp, 1, 1 );		PenSize( 2, 2 );	PenMode( patXor );	FrameRect( &temp );		SetPenState( &pnState );}