/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			PalMDEF.c			-- MDEF for colour palette popup******			©1992, Graham Cox****************************************************************************************************/#include	"ColourPopUp.h"#include	"MacZoop.h"#include 	<Menus.h>#include	<Gestalt.h>#include	<MacWindows.h>enum{	kDefaultSwatchWidth		= 17,	kDefaultSwatchHeight	= 17};void	DrawCPMenu( MenuHandle theMenu, Rect *mBounds, short chipsH, short chipsV, short initItem, CTabHandle colours );#if TARGET_API_MAC_CARBONstatic void FindCPItem( Point mouse,  Rect* mRect, short chipsH, short chipsV, MenuTrackingData* trackData );static void HiliteCPItem( Rect* mRect, short chipsH, short chipsV, HiliteMenuItemData* hiliteData );#endifpascal void	PalMDEFFunction( short message, MenuHandle theMenu,							 Rect *menuRect, Point hitPt, short *whichItem ){	CPMenuHandle    cpH;	short			chipsH,chipsV;	short			numSwatches = 0, pDepth;	long			gResponse;	OSErr			theErr;	GDHandle		gmScreen;	CTabHandle		colours = NULL;	static Boolean	hasBeenInited = FALSE;		if ( theMenu )	{	#if TARGET_API_MAC_CARBON	    GetMenuItemRefCon( theMenu, 0, (UInt32*) &cpH );		#else	    cpH = (CPMenuHandle) theMenu;		#endif				if ( cpH )		    colours = (*cpH)->menuColours;		if ( colours )			numSwatches = (*colours)->ctSize + 1;		else		{			theErr = Gestalt( gestaltQuickdrawVersion, &gResponse );			if ( theErr == noErr && ( gResponse >= 0x0100 ))			{				gmScreen = GetMainDevice();				if ( gmScreen )				{					pDepth = (*(*gmScreen)->gdPMap)->pixelSize;					switch( pDepth )					{						case 4:							numSwatches = 16;							break;												case 8:						case 16:						case 32:							numSwatches = 81;							break;												default:							numSwatches = 2;							break;					}				}			}			else				numSwatches = 2;		}		switch ( numSwatches )		{			case 256:				chipsH = 16;				break;						default:				chipsH = 9;				break;						case 16:				chipsH = 4;				break;						case 2:				chipsH = 2;				break;		}				chipsV = numSwatches / chipsH;				switch( message )		{			case mDrawMsg:				DrawCPMenu( theMenu, menuRect, chipsH, chipsV, (*cpH)->initIndex, colours );				hasBeenInited = FALSE;				break;						case mChooseMsg:				if ( hasBeenInited )					ChooseCPMenuItem( theMenu, whichItem, menuRect, hitPt, chipsH, chipsV );				else				{					if ( PtInRect( hitPt, menuRect ))					{						*whichItem = (*cpH)->initIndex;						hasBeenInited = TRUE;					}				}				break;						case mSizeMsg:				CalcCPMenuSize( theMenu, chipsH, chipsV );				break;						case mPopUpMsg:				CalcPopupMenuSize( hitPt, *whichItem, menuRect, chipsH, chipsV );				#if TARGET_API_MAC_CARBON				    SetMenuWidth( theMenu, menuRect->right - menuRect->left );				    SetMenuHeight( theMenu, menuRect->bottom - menuRect->top );				#endif				break;						#if TARGET_API_MAC_CARBON		    		    case kMenuFindItemMsg:		        FindCPItem( hitPt, menuRect, chipsH, chipsV, (MenuTrackingData*) whichItem );		        break;		        		    case kMenuHiliteItemMsg:		        HiliteCPItem( menuRect, chipsH, chipsV, (HiliteMenuItemData*) whichItem );		        break;		#endif						default:				break;		}	}}void CalcCPMenuSize( MenuHandle theMenu, short chipsH, short chipsV ){	/* calculates the size of the menu. This is determined by the size of each colour		square, which is 16 * 16, with 1 pixel surrounding each */		short swatchWidth, swatchHeight;		if (chipsH <= 9)		swatchWidth = swatchHeight = kDefaultSwatchWidth;	else		swatchWidth = swatchHeight = 12;#if TARGET_API_MAC_CARBON    SetMenuWidth( theMenu, swatchWidth * chipsH );    SetMenuHeight( theMenu, swatchHeight * chipsV );#else	(*theMenu)->menuWidth = swatchWidth * chipsH;	(*theMenu)->menuHeight = swatchHeight * chipsV;#endif}void CalcPopupMenuSize( Point hitPt, short item, Rect *mRect, short chipsH, short chipsV ){	/* calculates rectangle for pop-up menu. NOTE THAT THIS SHOULD be pinned to the frame of the		monitor that contains the largest area */			Rect 		sRect;	GDHandle	mainScreen;	short 		swatchWidth,swatchHeight;		if (chipsH <= 9)		swatchWidth = swatchHeight = kDefaultSwatchWidth;	else		swatchWidth = swatchHeight = 12;	mRect->top = hitPt.h;	/* point order is reversed */	mRect->left = hitPt.v;	mRect->right = mRect->left + (swatchWidth * chipsH);	mRect->bottom = mRect->top + (swatchHeight * chipsV);		mainScreen = GetMainDevice();	if (mainScreen)	{		sRect = (*(*mainScreen)->gdPMap)->bounds;		InsetRect(&sRect,4,4);	}	if (mRect->right > sRect.right)		OffsetRect(mRect,-(mRect->right - sRect.right),0); 		if (mRect->bottom > sRect.bottom)		OffsetRect(mRect,0,-(mRect->bottom - sRect.bottom)); }void DrawCPMenu( MenuHandle theMenu, Rect *mBounds, short chipsH, short chipsV, short initItem, CTabHandle colours ){	/* draws the menu. The colour info is taken from the menuinfo data structure, which		is extended and the handle to the colour table is tacked on the end. */	Rect		swatchRect;	register	short			v,h;	short 		swatchWidth,swatchHeight;	Point		zero = {0,0};#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )		DrawThemeMenuBackground( mBounds, kThemeMenuTypePopUp );#endif		if (chipsH <= 9)		swatchWidth = swatchHeight = kDefaultSwatchWidth;	else		swatchWidth = swatchHeight = 12;		if ( colours )	{		SetRect( &swatchRect, 0, 0, swatchWidth, swatchHeight );		OffsetRect( &swatchRect, mBounds->left, mBounds->top );				if ( chipsH <= 9 )			InsetRect( &swatchRect, 2, 2 );		for (v = 0;v < chipsV;v++)		{			for (h = 0;h < chipsH;h ++)			{				RGBForeColor(&(*colours)->ctTable[v * chipsV + h].rgb);				PaintRect( &swatchRect );				if ( chipsH > 9 )					ForeColor( whiteColor );				else					ForeColor( blackColor );				FrameRect( &swatchRect );				OffsetRect( &swatchRect, swatchWidth, 0 );			}			OffsetRect( &swatchRect, -chipsH * swatchWidth, swatchHeight );		}		ForeColor( blackColor );				ChooseCPMenuItem( theMenu, &initItem, mBounds, zero, chipsH, chipsV );	}}void ChooseCPMenuItem( MenuHandle theMenu, short *theItem, Rect *mBounds, Point mHit, short chipsH, short chipsV ){	/* highlights the selection */		Rect 			mRect,swatchRect,oldSwatchRect;	short			sv,sh,item,oh,ov;	PenState		penSave;	short			numSwatches;	short 			swatchWidth,swatchHeight;	Boolean 		toPermitted = FALSE;#if !TARGET_API_MAC_CARBON		toPermitted = (*(CPMenuHandle) theMenu)->allowTearOff;#endif		if ( chipsH <= 9 )		swatchWidth = swatchHeight = kDefaultSwatchWidth;	else		swatchWidth = swatchHeight = 12;	numSwatches = chipsH * chipsV;		GetPenState( &penSave );	PenMode( patXor );	PenSize( 2, 2 );			mRect = *mBounds;	InsetRect( &mRect, 1, 1 );	SetRect( &swatchRect, 0, 0, swatchWidth, swatchHeight );	OffsetRect( &swatchRect, mBounds->left, mBounds->top );	oldSwatchRect = swatchRect;		if ( PtInRect( mHit, &mRect ))	{		/* mouse is in the menu, see which item it's in */				for ( sv = 0; sv < chipsV; sv++ )		{			for ( sh = 0; sh < chipsH; sh++ )			{				if ( PtInRect( mHit, &swatchRect ))					goto found;				else					OffsetRect( &swatchRect, swatchWidth, 0 );			}			OffsetRect( &swatchRect, -chipsH * swatchWidth, swatchHeight );		}	found:				item = ( sv * chipsV + sh ) +1;		if ( item <= numSwatches && item != *theItem )		{			/* a new one, so unhighlight old one and hilite new one */						if ( *theItem != 0 )			{				/* there really is an old one, so calc the hilite */				oh = ( *theItem -1 ) / chipsH;				ov = ( *theItem -1 ) % chipsH;				OffsetRect( &oldSwatchRect, ov * swatchWidth, oh * swatchHeight );				FrameRect( &oldSwatchRect );									/*Xor it out */			}			FrameRect( &swatchRect );											/*Xor it in */			*theItem = item;		}	}	else	{		if (*theItem != 0)		{			oh = ( *theItem -1 ) / chipsH;			ov = ( *theItem -1 ) % chipsH;			OffsetRect( &oldSwatchRect, ov * swatchWidth, oh * swatchHeight );			FrameRect( &oldSwatchRect );						*theItem = 0;		}	}		SetPenState( &penSave );}		#if TARGET_API_MAC_CARBONstatic void FindCPItem( Point mouse, Rect* mRect, short chipsH, short chipsV, MenuTrackingData* trackData ){    // locate the item under the hit Pt and pass its rect back        if ( PtInRect( mouse, mRect ))    {		short   sv, sh, swatchWidth, swatchHeight, numSwatches, item;		Rect    swatchRect;		    	if ( chipsH <= 9 )    		swatchWidth = swatchHeight = kDefaultSwatchWidth;    	else    		swatchWidth = swatchHeight = 12;    	numSwatches = chipsH * chipsV;    	SetRect( &swatchRect, 0, 0, swatchWidth, swatchHeight );    	OffsetRect( &swatchRect, mRect->left, mRect->top );		for ( sv = 0; sv < chipsV; sv++ )		{			for ( sh = 0; sh < chipsH; sh++ )			{				if ( PtInRect( mouse, &swatchRect ))					goto found;				else					OffsetRect( &swatchRect, swatchWidth, 0 );			}			OffsetRect( &swatchRect, -chipsH * swatchWidth, swatchHeight );		}        trackData->itemSelected = 0;        trackData->itemUnderMouse = 0;		return;		found:		item = ( sv * chipsV + sh ) + 1;        trackData->itemSelected = item;        trackData->itemUnderMouse = item;    }    else    {        trackData->itemSelected = 0;        trackData->itemUnderMouse = 0;    }}static void HiliteCPItem( Rect* mRect, short chipsH, short chipsV, HiliteMenuItemData* hiliteData ){	PenState penSave;	short   swatchWidth, swatchHeight, numSwatches, oh, ov;	Rect    swatchRect, oldSwatchRect;		GetPenState( &penSave );	PenMode( patXor );	PenSize( 2, 2 );		if ( chipsH <= 9 )		swatchWidth = swatchHeight = kDefaultSwatchWidth;	else		swatchWidth = swatchHeight = 12;	numSwatches = chipsH * chipsV;	SetRect( &swatchRect, 0, 0, swatchWidth, swatchHeight );	OffsetRect( &swatchRect, mRect->left, mRect->top );    oldSwatchRect = swatchRect;    	if ( hiliteData->previousItem != 0 )	{		/* there really is an old one, so calc the hilite */		oh = ( hiliteData->previousItem - 1 ) / chipsH;		ov = ( hiliteData->previousItem - 1 ) % chipsH;		OffsetRect( &oldSwatchRect, ov * swatchWidth, oh * swatchHeight );		FrameRect( &oldSwatchRect );	}	if ( hiliteData->newItem != 0 )	{		/* there really is an old one, so calc the hilite */		oh = ( hiliteData->newItem - 1 ) / chipsH;		ov = ( hiliteData->newItem - 1 ) % chipsH;		OffsetRect( &swatchRect, ov * swatchWidth, oh * swatchHeight );		FrameRect( &swatchRect );	}        SetPenState( &penSave );}#endif	