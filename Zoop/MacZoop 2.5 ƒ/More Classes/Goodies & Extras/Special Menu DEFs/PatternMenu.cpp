/*************************************************************************************************		Name:  			PatternMenu.c*		Description:	A MDEF for displaying patterns, B & W or colour.***		Date Created:		December 20th, 1995*		Author:				Graham Cox*		*		Revision History:	**       18/5/2000- updated for Carbon**		Notes:*	************************************************************************************************/#include	"PatternMenu.h"#include	"MacZoop.h"#if !TARGET_API_MAC_CARBON#include	"xDEFJump.h"#endifenum{	kSwatchSize		= 32,	kSwatchOffset	= 2,	kMaxSwatchesH	= 6};static void DrawPatMenu(CPatMenuHandle theMenu,Rect* menuRect,short chipsH,short chipsV,short initIndex);static void ChoosePatMenuItem(MenuHandle theMenu,short* whichItem,Rect* menuRect,Point hitPt,short chipsH,short chipsV);static void CalcPatMenuSize(MenuHandle theMenu,short chipsH,short chipsV);static void CalcPopPatMenuSize(Point hitPt,Rect* menuRect,short chipsH,short chipsV);#if TARGET_API_MAC_CARBONstatic void FindPatMenuItem( Point mouse, Rect* mRect, short chipsH, short chipsV, MenuTrackingData* trackData );static void HilitePatMenuItem( Rect* mRect, short chipsH, short chipsV, HiliteMenuItemData* hiliteData );#endifpascal void	CPatMDEFFunction( short message, MenuHandle theMenu,								Rect *menuRect, Point hitPt, short *whichItem ){	short			chipsH,chipsV;	short			numSwatches;	static Boolean	isInited = FALSE;		CPatMenuHandle  cpm;		if (theMenu)	{	#if TARGET_API_MAC_CARBON	    GetMenuItemRefCon( theMenu, 0, (UInt32*) &cpm );	#else	    cpm = (CPatMenuHandle) theMenu;	#endif				// set up the number of rows and columns in the menu				if ((*cpm)->patListType == patListColour)			numSwatches = (*(*cpm)->patListHdl)->numPatterns;		else			numSwatches = 36;				chipsH = MIN( numSwatches, kMaxSwatchesH );		chipsV = MAX( 1, numSwatches / chipsH );				switch(message)		{			case mDrawMsg:				DrawPatMenu( cpm, menuRect, chipsH, chipsV, (*cpm)->initIndex );				isInited = FALSE;				break;						case mChooseMsg:				if ( isInited )					ChoosePatMenuItem( theMenu, whichItem, menuRect, hitPt, chipsH, chipsV );				else				{					if ( PtInRect( hitPt, menuRect ))					{						*whichItem = (*cpm)->initIndex;						isInited = TRUE;					}				}				break;						case mSizeMsg:				CalcPatMenuSize( theMenu, chipsH, chipsV );				break;						case mPopUpMsg:				CalcPopPatMenuSize( hitPt, menuRect, chipsH, chipsV );				break;		#if TARGET_API_MAC_CARBON		    case kMenuFindItemMsg:		        FindPatMenuItem( hitPt, menuRect, chipsH, chipsV, (MenuTrackingData*) whichItem );		        break;		        		    case kMenuHiliteItemMsg:		        HilitePatMenuItem( menuRect, chipsH, chipsV, (HiliteMenuItemData*) whichItem );		        break;		#endif			default:				break;		}	}}void CalcPatMenuSize(MenuHandle theMenu,short chipsH,short chipsV){	// computes the menu's dimensions		short swatchWidth,swatchHeight;		swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;#if TARGET_API_MAC_CARBON    SetMenuWidth( theMenu, (swatchWidth * chipsH) + kSwatchOffset );    SetMenuHeight( theMenu, (swatchHeight * chipsV) + kSwatchOffset );#else	(*theMenu)->menuWidth = (swatchWidth * chipsH) + kSwatchOffset;	(*theMenu)->menuHeight = (swatchHeight * chipsV) + kSwatchOffset;#endif}void CalcPopPatMenuSize(Point hitPt,Rect* mRect,short chipsH,short chipsV){	// dimensions for pop-up menu	Rect 		sRect;	GDHandle	mainScreen;	short 		swatchWidth,swatchHeight;		swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;	mRect->top = hitPt.h;	/* point order is reversed */	mRect->left = hitPt.v;	mRect->right = mRect->left + (swatchWidth * chipsH) + kSwatchOffset;	mRect->bottom = mRect->top + (swatchHeight * chipsV) + kSwatchOffset;		mainScreen = GetMainDevice();	if (mainScreen)	{		sRect = (*(*mainScreen)->gdPMap)->bounds;		InsetRect(&sRect,4,4);	}	if (mRect->right > sRect.right)		OffsetRect(mRect,-(mRect->right - sRect.right),0); 		if (mRect->bottom > sRect.bottom)		OffsetRect(mRect,0,-(mRect->bottom - sRect.bottom)); }void DrawPatMenu(CPatMenuHandle theMenu,Rect* menuRect,short chipsH,short chipsV,short initIndex){	// draws the menu		short			h,v;	short 			swatchWidth,swatchHeight;	Rect			sr;	CPatListHdl		thePatH;	PixPatHandle	cPat;	Pattern			bwPat;	Point			zero = {0,0};		swatchWidth = swatchHeight = kSwatchSize;	thePatH = (*theMenu)->patListHdl;		SetRect(&sr,kSwatchOffset,kSwatchOffset,swatchWidth + kSwatchOffset,swatchHeight + kSwatchOffset);	OffsetRect(&sr,menuRect->left,menuRect->top);	PenNormal();	ForeColor(blackColor);	BackColor(whiteColor);	EraseRect(menuRect);		for (v = 0;v < chipsV;v++)	{		for (h = 0;h < chipsH;h++)		{			switch((*theMenu)->patListType)			{				case patListColour:						cPat = GetPixPat((*thePatH)->patID[v * chipsH + h]);					if (cPat)					{						FillCRect(&sr,cPat);						DisposePixPat(cPat);					}					break;								case patListSysList:					GetIndPattern(&bwPat,0,v * chipsH + h + 1);					FillRect(&sr,&bwPat);					break;								case patListBW:					GetIndPattern(&bwPat,(*theMenu)->patListID,v * chipsH + h + 1);					FillRect(&sr,&bwPat);					break;								case patListBWColourised:					RGBForeColor(&(*theMenu)->patFore);					RGBBackColor(&(*theMenu)->patBack);					GetIndPattern(&bwPat,(*theMenu)->patListID,v * chipsH + h + 1);					FillRect(&sr,&bwPat);					ForeColor(blackColor);					BackColor(whiteColor);					break;								default:					break;			}			FrameRect(&sr);			OffsetRect(&sr,swatchWidth + kSwatchOffset,0);		}		OffsetRect(&sr,-chipsH * (swatchWidth + kSwatchOffset),swatchHeight + kSwatchOffset);	}		ChoosePatMenuItem((MenuHandle) theMenu,&initIndex,menuRect,zero,chipsH,chipsV);}void ChoosePatMenuItem(MenuHandle theMenu,short* whichItem,Rect* menuRect,Point hitPt,short chipsH,short chipsV){	// tracks mouse in menu	Rect 			mRect,swatchRect,oldSwatchRect;	short			sv,sh,item,oh,ov;	PenState		penSave;	short			numSwatches;	short 			swatchWidth,swatchHeight;		swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;	numSwatches = chipsH * chipsV;		GetPenState(&penSave);	PenMode(patXor);	PenSize( kSwatchOffset + 1, kSwatchOffset + 1 );			mRect = *menuRect;	InsetRect(&mRect,1,1);	SetRect(&swatchRect,0,0,swatchWidth + kSwatchOffset,swatchHeight + kSwatchOffset);	OffsetRect(&swatchRect,menuRect->left,menuRect->top);	oldSwatchRect = swatchRect;		if (PtInRect(hitPt,&mRect))	{		/* mouse is in the menu, see which item it's in */				for (sv = 0;sv < chipsV;sv ++)		{			for (sh = 0;sh < chipsH;sh ++)			{				if (PtInRect(hitPt,&swatchRect))					goto found;				else					OffsetRect(&swatchRect,swatchWidth,0);			}			OffsetRect(&swatchRect,-chipsH * swatchWidth,swatchHeight);		}	found:				item = (sv * chipsH + sh) +1;		if (item <= numSwatches && item != *whichItem)		{			/* a new one, so unhighlight old one and hilite new one */						if (*whichItem != 0)			{				/* there really is an old one, so calc the hilite */				oh = (*whichItem -1) % chipsH;				ov = (*whichItem -1) / chipsH;				OffsetRect(&oldSwatchRect,oh * swatchWidth,ov * swatchHeight);				FrameRect(&oldSwatchRect);									/*Xor it out */			}			FrameRect(&swatchRect);											/*Xor it in */			*whichItem = item;		}	}	else	{		if (*whichItem != 0)		{			oh = (*whichItem -1) % chipsH;			ov = (*whichItem -1) / chipsH;			OffsetRect(&oldSwatchRect,oh * swatchWidth,ov * swatchHeight);			FrameRect(&oldSwatchRect);						*whichItem = 0;		}	}		SetPenState(&penSave);}#if TARGET_API_MAC_CARBONstatic void FindPatMenuItem( Point mouse, Rect* mRect, short chipsH, short chipsV, MenuTrackingData* trackData ){    // locate the item under the hit Pt and pass its rect back        if ( PtInRect( mouse, mRect ))    {		short   sv, sh, swatchWidth, swatchHeight, numSwatches, item;		Rect    swatchRect;		    	swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;    	numSwatches = chipsH * chipsV;    	SetRect( &swatchRect, 0, 0, swatchWidth, swatchHeight );    	OffsetRect( &swatchRect, mRect->left, mRect->top );		for ( sv = 0; sv < chipsV; sv++ )		{			for ( sh = 0; sh < chipsH; sh++ )			{				if ( PtInRect( mouse, &swatchRect ))					goto found;				else					OffsetRect( &swatchRect, swatchWidth, 0 );			}			OffsetRect( &swatchRect, -chipsH * swatchWidth, swatchHeight );		}        trackData->itemSelected = 0;        trackData->itemUnderMouse = 0;		return;		found:		item = ( sv * chipsV + sh ) + 1;        trackData->itemSelected = item;        trackData->itemUnderMouse = item;    }    else    {        trackData->itemSelected = 0;        trackData->itemUnderMouse = 0;    }}static void HilitePatMenuItem( Rect* mRect, short chipsH, short chipsV, HiliteMenuItemData* hiliteData ){	PenState penSave;	short   swatchWidth, swatchHeight, numSwatches, oh, ov;	Rect    swatchRect, oldSwatchRect;		GetPenState( &penSave );	PenMode( patXor );	PenSize( kSwatchOffset + 1, kSwatchOffset + 1 );	    swatchWidth = swatchHeight = kSwatchSize + kSwatchOffset;	numSwatches = chipsH * chipsV;	SetRect( &swatchRect, 0, 0, swatchWidth + kSwatchOffset, swatchHeight + kSwatchOffset );	OffsetRect( &swatchRect, mRect->left, mRect->top );    oldSwatchRect = swatchRect;    	if ( hiliteData->previousItem != 0 )	{		/* there really is an old one, so calc the hilite */		oh = ( hiliteData->previousItem - 1 ) / chipsH;		ov = ( hiliteData->previousItem - 1 ) % chipsH;		OffsetRect( &oldSwatchRect, ov * swatchWidth, oh * swatchHeight );		FrameRect( &oldSwatchRect );	}	if ( hiliteData->newItem != 0 )	{		/* there really is an old one, so calc the hilite */		oh = ( hiliteData->newItem - 1 ) / chipsH;		ov = ( hiliteData->newItem - 1 ) % chipsH;		OffsetRect( &swatchRect, ov * swatchWidth, oh * swatchHeight );		FrameRect( &swatchRect );	}        SetPenState( &penSave );}#endif#pragma mark -CPatMenuHandle  NewPatMenu( const short menuID, PatternType theType, short patListID, short initItem ){    CPatMenuHandle  theMenu;	CPatListHdl		thePats;    	theMenu = (CPatMenuHandle) NewHandleClear( sizeof( CPatMenuRecord ));		if (theMenu)	{		(*theMenu)->initIndex = initItem;				if ( theType == patListColour )			    thePats = GetCPatternList( patListID );		else		    thePats = NULL;		    		(*theMenu)->patListHdl = thePats;		(*theMenu)->patListID = patListID;		(*theMenu)->patListType = theType;		(*theMenu)->patFore = gBlack;		(*theMenu)->patBack = gWhite;    #if TARGET_API_MAC_CARBON        // Carbon works quite differently:                MenuRef         mNew;        MenuDefSpec     mDefSpec;                mDefSpec.defType = kMenuDefProcPtr;        mDefSpec.u.defProc = NewMenuDefUPP( CPatMDEFFunction );                FailOSStatus( CreateCustomMenu( &mDefSpec, menuID, 0, &mNew ));                 (*theMenu)->theMenu = mNew;            // attach this structure as menu refcon data to the menu                SetMenuItemRefCon( mNew, 0, (UInt32) theMenu );        CalcMenuSize( mNew );    #else    	Handle			mdefHandle;			mdefHandle = GetUniversalFunctionHandle((ProcPtr) CPatMDEFFunction, uppMenuDefProcInfo );		(*theMenu)->menuRecord.menuProc = mdefHandle;		(*theMenu)->menuRecord.menuID = menuID;		CalcMenuSize((MenuHandle) theMenu );	#endif	}		return theMenu;}void            DisposePatMenu( CPatMenuHandle theMenu ){    if ( theMenu )    {		Handle  thePats = (Handle)(*theMenu)->patListHdl;				if ( thePats )		    ReleaseResource((Handle) thePats );		#if TARGET_API_MAC_CARBON        MenuDefSpec  defSpec;                GetMenuDefinition((*theMenu)->theMenu, &defSpec );         DisposeMenu((*theMenu)->theMenu );        DisposeMenuDefUPP( defSpec.u.defProc );        DisposeHandle((Handle) theMenu );	#else		Handle  mdefHandle = (*theMenu)->menuRecord.menuProc;		DisposeHandle((Handle) theMenu );		DisposeHandle( mdefHandle );	#endif	}}long	PopUpCPatternMenu( Point globalLoc, short patListID, short initialItem ){	CPatMenuHandle	theMenu;	MenuHandle      realMenu;	long			mSelect = 0;		theMenu = NewPatMenu( kPatternMenuID, patListColour, patListID, initialItem );		if ( theMenu )	{	#if TARGET_API_MAC_CARBON	    realMenu = (*theMenu)->theMenu;	#else	    realMenu = (MenuHandle) theMenu;	#endif			InsertMenu( realMenu, hierMenu );				mSelect = PopUpMenuSelect( realMenu, globalLoc.v, globalLoc.h, 1 );				DeleteMenu( kPatternMenuID );		DisposePatMenu( theMenu );	}	return mSelect;}long	PopUpBWPatternMenu( Point globalLoc, short patListID, short initialItem ){	CPatMenuHandle	theMenu;	MenuHandle      realMenu;	long			mSelect = 0;    	theMenu = NewPatMenu( kPatternMenuID, (patListID == 0)? patListSysList : patListBW, patListID, initialItem );		if ( theMenu )	{	#if TARGET_API_MAC_CARBON	    realMenu = (*theMenu)->theMenu;	#else	    realMenu = (MenuHandle) theMenu;	#endif    		InsertMenu( realMenu, hierMenu );				mSelect = PopUpMenuSelect( realMenu, globalLoc.v, globalLoc.h, 1 );				DeleteMenu( kPatternMenuID );		DisposePatMenu( theMenu );	}	return mSelect;}long	PopUpBWColourisedMenu( Point globalLoc, short patListID, short initialItem, RGBColor* fClr, RGBColor* bClr ){	CPatMenuHandle	theMenu;	MenuHandle      realMenu;	long			mSelect = 0;		theMenu = NewPatMenu( kPatternMenuID, patListBWColourised, patListID, initialItem );		if ( theMenu )	{	    SetPatForeColour( theMenu, fClr );	    SetPatBackColour( theMenu, bClr );		#if TARGET_API_MAC_CARBON	    realMenu = (*theMenu)->theMenu;	#else	    realMenu = (MenuHandle) theMenu;	#endif    		InsertMenu( realMenu, hierMenu );				mSelect = PopUpMenuSelect(  realMenu, globalLoc.v, globalLoc.h, 1 );				DeleteMenu( kPatternMenuID );		DisposePatMenu( theMenu );	}	return mSelect;}CPatListHdl		GetCPatternList(short patListID){	return (CPatListHdl) GetResource( kCPatListResType, patListID );}PixPatHandle	GetIndCPattern( short patListID, short index ){	// obtains the actual pattern handle from a 'PPT#' resource with ID and index, or NULL	// if anything wasn't found.		PixPatHandle	aCpat = NULL;	CPatListHdl		cList;	short			patID;		cList = GetCPatternList( patListID );		if (cList)	{		// does the list contain the index we want?				if (index > 0 && index <= (*cList)->numPatterns)		{			patID = (*cList)->patID[index - 1];			aCpat = GetPixPat(patID);		}		ReleaseResource((Handle) cList);	}	return aCpat;}void    DrawStandardPatternSelector( Rect* bounds, Pattern* thePat, const RGBColor* fg, const RGBColor* bk ){	/* assumes current port */	Rect			temp;	RGBColor		saveBack;		temp = *bounds;	temp.right--;	temp.bottom--;		GetBackColor( &saveBack );	RGBForeColor( &gBlack );	RGBBackColor( &gWhite );	EraseRect( &temp );	FrameRect( &temp );		MoveTo( temp.left + 2, temp.bottom );	LineTo( temp.right, temp.bottom );	LineTo( temp.right, temp.top + 2 );		InsetRect( &temp, 3, 3 );	RGBForeColor( fg );	RGBBackColor( bk );	PenPat( thePat );	PaintRect( &temp );	RGBBackColor( &saveBack );	RGBForeColor( &gBlack );	PenNormal();		temp.left = temp.right - 17;	temp.top = temp.bottom - 15;		DrawSICN( kStdPopUpArrowSICN, 2, TOPLEFTPOINT( temp ));}void    DrawStandardCPatternSelector( Rect* bounds, PixPatHandle cPat ){	Rect			temp;	RGBColor		saveBack;		temp = *bounds;	temp.right--;	temp.bottom--;		GetBackColor( &saveBack );	RGBForeColor( &gBlack );	RGBBackColor( &gWhite );	EraseRect( &temp );	FrameRect( &temp );		MoveTo( temp.left + 2, temp.bottom );	LineTo( temp.right, temp.bottom );	LineTo( temp.right, temp.top + 2 );    InsetRect( &temp, 3, 3 );		if ( cPat )    	FillCRect( &temp, cPat );	RGBBackColor( &saveBack );	RGBForeColor( &gBlack );	PenNormal();		temp.left = temp.right - 17;	temp.top = temp.bottom - 15;		DrawSICN( kStdPopUpArrowSICN, 2, TOPLEFTPOINT( temp ));}void            SetPatForeColour( CPatMenuHandle theMenu, RGBColor* fore ){    (*theMenu)->patFore = *fore;}void            SetPatBackColour( CPatMenuHandle theMenu, RGBColor* back ){    (*theMenu)->patBack = *back;}