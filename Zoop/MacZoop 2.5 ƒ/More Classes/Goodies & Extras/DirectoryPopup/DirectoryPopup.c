/* *	Project:		DirectoryPopup * *	Filename: 		DirectoryPopup.c * *	Author: 		Marco Piovanelli, <mailto:marco.piovanelli@pobox.com> * *	Version:		1.0.3, November 1997 * */#include "DirectoryPopup.h"#include "Utilities.h"/*#ifndef __APPEARANCE__#include <Appearance.h>#endif*/#ifndef __DEVICES__#include <Devices.h>#endif#ifndef __FOLDERS__#include <Folders.h>#endif#ifndef __GESTALT__#include <Gestalt.h>#endif#ifndef __ICONS__#include <Icons.h>#endif#ifndef __TEXTUTILS__#include <TextUtils.h>#endif//	volume kindsenum{	kVolumeKindCDROM		=	'Appl' ,		//	CD-ROM	kVolumeKindDiskImage	=	'Mung' ,		//	disk image	kVolumeKindShrinkWrap	=	'Shri' ,		//	ShrinkWrap 2.1+ disk image	kVolumeKindFloppy		=	'Sony' ,		//	floppy	kVolumeKindFileServer	=	'AFPT' ,		//	AppleShare file server	kVolumeKindRAMDisk		=	'EDis'			//	RAM disk} ;//	other constantsenum{	kDirectoryPopupMenuID 	= 	93 ,			//	directory pop-up menu ID	kFinderIconIndicator	=	0x1A ,			//	menu item cmd for "Finder" icons	kFinderIconBaseID		=	-4000 ,	kStandardFileStrings	=	-6046 ,	kIndTrashName			=	2} ;static OSType GetVolumeKind ( SInt16 inVolumeRefNum ){	OSType volumeKind = 0 ;	HParamBlockRec pb ;	DCtlPtr pDCtlEntry ;	DRVRHeaderPtr pDriver ;	//	get volume info	BlockClear ( & pb, sizeof ( pb ) ) ;	pb . volumeParam . ioVRefNum = inVolumeRefNum ;	if ( PBHGetVInfoSync ( & pb ) == noErr )	{		//	get a pointer to the driver control entry of the volume's driver		pDCtlEntry = * GetDCtlEntry ( pb . volumeParam . ioVDRefNum ) ;		//	get a pointer to the driver itself		pDriver = ( DRVRHeaderPtr ) pDCtlEntry -> dCtlDriver ;		//	if the driver is RAM-based, dCtlDriver is really a handle		if ( pDCtlEntry -> dCtlFlags & dRAMBasedMask )		{			pDriver = * ( DRVRHeaderHandle ) pDriver ;		}		//	extract driver "tag" from driver name (letters 2 to 5)		volumeKind = * ( OSType * ) ( & pDriver -> drvrName [ 2 ] ) ;	}	return volumeKind ;}static Boolean HasModernStandardFile ( void ){	SInt32 response ;	return ( ( Gestalt ( gestaltStandardFileAttr, & response ) == noErr ) &&			 ( response & ( 1L << gestaltStandardFileHasDynamicVolumeAllocation ) ) ) ;}static Boolean HasAppearance ( void ){	/*	SInt32 response ;	return ( ( Gestalt ( gestaltAppearanceAttr, & response ) == noErr ) &&			 ( response & ( 1L << gestaltAppearanceExists ) ) ) ;	*/		return FALSE;}pascal MenuHandle BuildDirectoryPopup ( const FSSpec * inFileSpec ){	MenuHandle popup = nil ;	FSSpec spec = * inFileSpec ;	Str255 trashName ;	SInt16 item ;	SInt16 icon ;	SInt32 desktopDirectory = 0 ;	SInt32 trashDirectory = 0 ;	SInt32 thisDirectory ;	SInt32 trashNameLength ;	SInt16 volume ;	OSType volumeKind ;	OSStatus err ;	//	find the IDs of the desktop and trash directories for the specified volume	FindFolder ( spec . vRefNum, kDesktopFolderType, kDontCreateFolder, & volume, & desktopDirectory ) ;	FindFolder ( spec . vRefNum, kTrashFolderType, kDontCreateFolder, & volume, & trashDirectory ) ;	//	create an uninitialized menu from scratch	if ( ( popup = NewMenu ( kDirectoryPopupMenuID, "\px" ) ) == nil )	{		return popup ;	}	item = 0 ;	thisDirectory = -1 ;	do	{		//	add a new item to the menu		item ++ ;		AppendMenu ( popup, "\px" ) ;		//	find out which icon to use for this item		if ( item == 1 )		{			//	first item in the pop-up menu uses a document icon			icon = kGenericDocumentIconResource ;		}		else if ( spec . parID == fsRtParID )		{			//	use a disk icon for root level directory			//	default icon is the generic hard disk icon			icon = kGenericHardDiskIconResource ;			//	find out volume kind			volumeKind = GetVolumeKind ( spec . vRefNum ) ;			//	use special icons for floppy and file server volumes			if ( ( volumeKind == kVolumeKindFloppy ) ||				 ( volumeKind == kVolumeKindDiskImage ) ||				 ( volumeKind == kVolumeKindShrinkWrap ) )			{				icon = kFloppyIconResource ;			}			else if ( volumeKind == kVolumeKindFileServer )			{				icon = kGenericFileServerIconResource ;			}			else if ( HasModernStandardFile ( ) )			{				//	the Standard File package that comes with System 7.0 Update 3.0				//	(built in System 7.5 and newer) has additional small icons				//	for CD-ROM and RAM disk volumes				if ( volumeKind == kVolumeKindCDROM )				{					icon = kGenericCDROMIconResource ;				}				else if ( volumeKind == kVolumeKindRAMDisk )				{					icon = kGenericRAMDiskIconResource ;				}			}		}		else if ( thisDirectory == trashDirectory )		{			//	if this directory is the trash directory, use the trash icon			//	and the real trash name			icon = kTrashIconResource ;			GetIndString ( trashName, kStandardFileStrings, kIndTrashName ) ;			trashNameLength = StrLength ( trashName ) ;			if ( ( trashNameLength > 0 ) && ( trashNameLength <= 63 ) )			{				BlockMoveData ( trashName, & spec . name, trashNameLength + 1 ) ;			}		}		else		{			//	in all other cases, use the open folder icon			icon = kOpenFolderIconResource ;		}		//	set name and icon of current Finder object		SetMenuItemText ( popup, item, spec . name ) ;		SetItemIcon ( popup, item, icon - kFinderIconBaseID ) ;		SetItemCmd ( popup, item, kFinderIconIndicator ) ;		//	break out if we have reached a desktop child or the trash directory		if ( ( spec . parID == desktopDirectory ) || ( thisDirectory == trashDirectory ) )		{			break ;		}		//	otherwise, find the file specification of the parent directory		thisDirectory = spec . parID ;		err = FindParentSpec ( & spec ) ;	}	while ( err == noErr ) ;	return popup ;}static OSStatus GetWindowTitleTextRgn ( WindowPtr inWindow, RgnHandle ioTitleTextRgn ){#if 0#if TARGET_RT_MAC_CFM	if ( & GetWindowRegion != nil )#else	if ( HasAppearance ( ) )#endif	{		return GetWindowRegion ( inWindow, kWindowTitleTextRgn, ioTitleTextRgn ) ;	}	else#endif	{		Rect structRect ;		Rect contentRect ;		Rect titleTextRect ;		SInt16 titleWidth ;		//	get the bounding box of the structure region		structRect = ( * ( ( WindowPeek ) inWindow ) -> strucRgn ) -> rgnBBox ;		//	and the bounding box of the content region		contentRect = ( * ( ( WindowPeek ) inWindow ) -> contRgn ) -> rgnBBox ;		//	get title width		titleWidth = GetWindowTitleWidth ( inWindow ) ;		//	calculate the title text rect		titleTextRect . left = structRect . left +			( ( ( structRect . right - structRect . left ) - titleWidth - 1 ) / 2 ) ;		titleTextRect . right = titleTextRect . left + titleWidth ;		titleTextRect . top = structRect . top + 2 ;		titleTextRect . bottom = contentRect . top - 2 ;		//	convert this rectangle to a region		RectRgn ( ioTitleTextRgn, & titleTextRect ) ;		return noErr ;	}}pascal Boolean TrackDirectoryPopup ( FSSpec * ioFileSpec, WindowPtr inWindow, Point inHitPt ){	//	call this function when you detect a command-click in a window's drag bar	//	on entry, ioFileSpec points to the file associated with the window	//	on exit, ioFileSpec points to the selected folder (if a selection was made)	//	if this function determines that this click should show a directory	//	pop-up menu, it displays it and does all the mouse tracking.	//	It then returns true if a selection was made.	RgnHandle titleTextRgn = nil ;	MenuHandle popup = nil ;	Point corner ;	SInt16 menuChoice ;	Boolean result = false ;	//	make sure inWindow is selected	if ( ! IsWindowHilited ( inWindow ) ) goto cleanup ;	//	get title text region	if ( ( titleTextRgn = NewRgn ( ) ) == nil ) goto cleanup ;	if ( GetWindowTitleTextRgn ( inWindow, titleTextRgn ) != noErr ) goto cleanup ;	//	determine whether the hit point went into the title text area	if ( ! PtInRgn ( inHitPt, titleTextRgn ) ) goto cleanup ;	//	calculate the coordinates of the top/left corner of the pop-up menu	corner = * ( Point * ) ( & ( * titleTextRgn ) -> rgnBBox ) ;	corner . h -= 21;	corner . v += 1 ;	//	build the directory pop-up menu	if ( ( popup = BuildDirectoryPopup ( ioFileSpec ) ) == nil ) goto cleanup ;	//	insert the menu into the hierarchical portion of the menu list	InsertMenu ( popup, -1 ) ;	//	pop up the menu	menuChoice = ( SInt16 ) PopUpMenuSelect ( popup, corner . v, corner . h, 1 ) ;	//	remove the pop-up menu from the menu list	DeleteMenu ( kDirectoryPopupMenuID ) ;	//	see if an item up in the hierarchy was selected	if ( menuChoice > 1 )	{		for ( ; menuChoice > 1 ; menuChoice -- )		{			FindParentSpec ( ioFileSpec ) ;		}		result = true ;	}cleanup :	if ( titleTextRgn != nil )	{		DisposeRgn ( titleTextRgn ) ;	}	if ( popup != nil )	{		DisposeMenu ( popup ) ;	}	return result ;}