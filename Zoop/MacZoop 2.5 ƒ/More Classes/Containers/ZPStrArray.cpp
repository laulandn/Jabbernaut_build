/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZPStrArray.cpp			-- efficient string storage******			©2000, Graham Cox*****************************************************************************************************/#include	"ZPStrArray.h"#include	"MacZoop.h"/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZPStrArray::ZPStrArray()	: ZArray((unsigned long) 0 ){	classID = CLASS_ZPStrArray;		// make sure that external code allocates enough space when recovering data	// the real block size is variable.		blkSize = 256;	physicalBlks = 1;}/*--------------------------------***  GetArrayItem  ***--------------------------------*//*access:			publicoverrides:		description: 	return indexed datains: 			<item> pointer to valid storage for item				<index> index position of data to retrieveouts: 			nonenotes:			you must allocate adequate storage for the item buffer----------------------------------------------------------------------------------------*/void	ZPStrArray::GetArrayItem( void* item, const long index ){	long	off, len;		off = FindOffset( index );	len = GetDataLength( off );		if ( len > 0 )		BlockMoveData( *a + off, item, len );}/*--------------------------------***  SetArrayItem  ***--------------------------------*//*access:			publicoverrides:		description: 	copy data into the array at indexins: 			<item> pointer to data for item				<index> index position to store dataouts: 			nonenotes:			data MUST be pascal string with preceding length byte----------------------------------------------------------------------------------------*/void	ZPStrArray::SetArrayItem( void* item, const long index ){	long	off, len;		off = FindOffset( index );	len = GetDataLength( off );		if ( len > 0 )		DeleteData( off, len );		len = ((StringPtr) item)[0] + 1;	InsertData( item, len, off );	SendMessage( msgArrayItemChanged, (void*) index );}/*---------------------------------***  AppendItem  ***---------------------------------*//*access:			publicoverrides:		description: 	append a string to the end of the arrayins: 			<item> pointer to data for itemouts: 			nonenotes:			data MUST be pascal string with preceding length byte----------------------------------------------------------------------------------------*/void	ZPStrArray::AppendItem( void* item ){	long	len, off;		len = ((StringPtr) item)[0] + 1;	off = GetHandleSize( a );		InsertData( item, len, off );	numElements++;	SendMessage( msgArrayItemAdded, (void*) numElements );}/*---------------------------------***  InsertItem  ***---------------------------------*//*access:			publicoverrides:		description: 	insert a string at the given indexins: 			<item> pointer to data for item				<index> position to store it atouts: 			nonenotes:			data MUST be pascal string with preceding length byte----------------------------------------------------------------------------------------*/void	ZPStrArray::InsertItem( void* item, const long index ){	long	len, off;		off = FindOffset( index );	len = ((StringPtr) item)[0] + 1;		InsertData( item, len, off );	numElements++;		SendMessage( msgArrayItemInserted, (void*) index );}/*---------------------------------***  DeleteItem  ***---------------------------------*//*access:			publicoverrides:		description: 	remove data from the array at indexed positionins: 			<index> index of data to deleteouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZPStrArray::DeleteItem( const long index ){	long	off, len;		off = FindOffset( index );	len = GetDataLength( off );		if ( len > 0 )		DeleteData( off, len );			--numElements;	SendMessage( msgArrayItemDeleted, (void*) index );}/*-----------------------------------***  Compare  ***----------------------------------*//*access:			publicoverrides:		description: 	compare two strings for sorting purposesins: 			<itema> first string				<itemb> second string				<ref> unused in this classouts: 			nonenotes:			n.b. sorting ops in this class are quite a bit slower than ZArray 8-)----------------------------------------------------------------------------------------*/short	ZPStrArray::Compare( void* itema, void* itemb, const long ref ){	return RelString((StringPtr) itema, (StringPtr) itemb, TRUE, TRUE );}/*-------------------------------***  GetStringLength  ***------------------------------*//*access:			publicoverrides:		description: 	return length of string (plus 1)ins: 			<index> index of string to query sizeouts: 			nonenotes:			can be used to determine storage needed prior to retrieving data----------------------------------------------------------------------------------------*/long	ZPStrArray::GetStringLength( const long index ){	return GetDataLength( FindOffset( index ));}/*---------------------------------***  CountItems  ***---------------------------------*//*access:			publicoverrides:		description: 	return number of strings storedins: 			noneouts: 			count of stringsnotes:			----------------------------------------------------------------------------------------*/long	ZPStrArray::CountItems(){	long			len, off, i = 0;		off = len = 0;		while( off < GetHandleSize( a ))	{		len = GetDataLength( off );		off += len;		++i;	}		return i;}/*----------------------------------***  DeleteAll  ***---------------------------------*//*access:			publicoverrides:		description: 	delte all items in arrayins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZPStrArray::DeleteAll(){	numElements = 0;	physicalBlks = 1;		SetHandleSize( a, 0 );		SendMessage( msgArrayAllDeleted, NULL );}/*---------------------------------***  FindOffset  ***---------------------------------*//*access:			protectedoverrides:		description: 	determine byte offset of string for given indexins: 			<index> index of string whos byte offset we wantouts: 			the byte offset in the storage handlenotes:			returns -1 if index invalid----------------------------------------------------------------------------------------*/long	ZPStrArray::FindOffset( const long index ){	long			len, off, i = 0;		off = len = 0;		do	{		off += len;				if ( off > GetHandleSize( a ))		{			off = -1;			break;		}					len = GetDataLength( off );		++i;	}	while( i != index );		return off;}/*---------------------------------***  InsertData  ***---------------------------------*//*access:			protectedoverrides:		description: 	extend handle and insert data at given offsetins: 			<data> data to insert				<dataLength> length of data in bytes				<offset> the byte offset to insert it atouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZPStrArray::InsertData( void* data, const long dataLength, const long offset ){	long	len = GetHandleSize( a );		SetHandleSize( a, len + dataLength );	FailMemError();		// shift up following data		BlockMoveData( *a + offset, *a + offset + dataLength, len - offset );		// insert new data		BlockMoveData( data, *a + offset, dataLength );}/*---------------------------------***  DeleteData  ***---------------------------------*//*access:			protectedoverrides:		description: 	remove data at given offset & shrink handleins: 			<offset> remove data from here				<dataLength> length of data in bytes to removeouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void	ZPStrArray::DeleteData( const long offset, const long dataLength ){	long	len = GetHandleSize( a );		// copy following data to fill space		BlockMoveData( *a + offset + dataLength, *a + offset, len - dataLength - offset );		// shrink handle		SetHandleSize( a, len - dataLength );}/*--------------------------------***  GetDataLength  ***-------------------------------*//*access:			protectedoverrides:		description: 	get data length at given offsetins: 			<offset> data offset to queryouts: 			length of data at offsetnotes:			----------------------------------------------------------------------------------------*/long	ZPStrArray::GetDataLength( const long offset ){	unsigned char len;		len = *( *a + offset );		return len + 1;}