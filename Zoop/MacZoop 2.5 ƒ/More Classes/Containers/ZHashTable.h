/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZHashTable.h			-- dictionary container object******			© 2000, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZHASHTABLE__#define	__ZHASHTABLE__#include	"ZComrade.h"// size of actual hash table - doesn't usually need to be changed#define		HASH_ENTRIES		79// string space grows in lumps of this many bytes (default usually fine)#define		SS_CLUMP_SIZE		512// each entry consists of this header structure, followed by your own private datastruct ht_entry{	struct ht_entry* 	htnext;				// link to next entry in collision chain	unsigned long		ssKey;				// offset of key name in string space	short				ssScope;			// scope indicator of symbol	unsigned short		ssKeyLength;		// length of key name	char				userData;			// first byte of user data};typedef struct ht_entry ht_entry, *htEntryPtr;	// the class:class ZHashTable	: public ZComrade{protected:	Handle				strSpace;				// bulk storage for key names	unsigned long		ssLength;				// logical length of string space	unsigned long		ssCount;				// count of symbolic entries 	long				ssUDSize;				// size of user data	long				ssDataSize;				// true size of element		short				ssScope;				// current scope level	htEntryPtr			ht[ HASH_ENTRIES ];		// the table itselfpublic:	ZHashTable( const long dataSize = sizeof( Ptr ));	virtual ~ZHashTable();// basic storage of key/value pairs in the table:		virtual Boolean			AddSymbol( const char* name, void* symbolData );	virtual void			DeleteSymbol( const char* name );	virtual void*			GetSymbol( const char* name );			// the hash function:		virtual unsigned long	Hash( const char* name );// resetting the table:	virtual void			Clear();// establishing name scope:		virtual void			OpenScope();	virtual void			CloseScope();// info:		inline	unsigned long	CountSymbols() { return ssCount; };	virtual void*			GetNextSymbol( char* name );	protected:// internal maintenance stuff:	unsigned long			SSAdd( const char* name );	htEntryPtr				SSChain( const char* name, unsigned long htIndex, Boolean checkScope = TRUE );	Boolean					SSCompare( const char* name, unsigned long keyOffset, unsigned short keyLength );	void					SSPrepend( unsigned long htIndex, unsigned long keyOffset, unsigned short keyLength, void* userData );	void					SSDispose( htEntryPtr htp ); };// messages:// this class sends one message, which allows you to delete any private storage you attached to an entry:enum{	msgHashTableEntryDeleted 	= '#tb-'};/*This class is a specialised type of container class useful for jobs such asdictionaries or symbol tables. It is organised along classic practical linesusing chaining to resolve hash collisions. The default hash function is a simplemultiplication of the key characters, modulo the table size. This can be overridden.This approach to hash tables is one widely used in practice, where collisions areresolved by forming short linked chains starting at the hash table entry. The hashfunction should produce a uniform distribution in the table, so collision chainswill usually be short and therefore very fast to search. Search times are in the orderof 1 + n/2m, where m is the table size, and n the number of symbols stored.You can store any data you wish associated with the key. The data you associate withthe key name can be anything you like, but it must be of fixed size, or else a pointerto some other storage. You pass the size when you make the class, much like ZArray. Thedefault is the size of a pointer. The data you pass is copied into the table when youcall AddSymbol, and GetSymbol returns a pointer to this data.Note that key names are C strings, not pascal strings, and can be any length. Allcharacters and case are significant.This class makes an ideal symbol table implementation for any compiler or otherparser, but can be used for many other jobs as well. Anywhere you need to store key/valuepairs, consider this class. Handy! Note- for dictionaries containing large numbers ofkeys that differ only slightly (i.e. spellchecker dictionaries), this may not yieldvery optimum storage efficiency. a B*-tree may work better in such cases.*****************************************************************************************A note about scope:It can be ignored! If you don't care about scope, everything works fine with every symbolhaving the same (global) scope. If you want scoped symbols, as in a block-structured language,you can call OpenScope() as you pass from an outer scope to an inner one, and call CloseScope()on the way back out. Symbols with the same names are allowed if they have different scopes. TheGetSymbol() method finds the symbol with the innermost scope if more than one exists with thesame name, which is exactly what you want!OpenScope() and CloseScope() calls can (naturally) be nested but must balance.Scope level 0 usually means the outer-most scope possible (usually global scope).If you want to know more about this, why it's useful, and why this is such an incrediblyelegant implementation, read:"Crafting a compiler with C", by Fischer and LeBlanc, ISBN 0-8053-2166-7, chapter 8.*****************************************************************************************A note about memory usage:The key names are stored in a "string space" which is a Handle. This handle grows assymbols are added, but does not shrink as they are deleted, unless the symbol countgoes to zero. This gives us lots of speed, but if adding and deleting large numbersof symbols, you may want to recover this unused space from time to time. Thisgarbage collection is left as an exercise - most standard uses for this class won'trequire it.Note that when adding symbols with the same names in different scopes, the key nameis not added to the string space twice. This gives useful memory efficiency improvementat virtually no cost.*/#endif