/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZClassRegistry.cpp		-- registry of classes used for persistent objects******			© 1998, Graham Cox*****************************************************************************************************/#include	"ZClassRegistry.h"#include	"ZStream.h"#include	"MacZoop.h"ZClassRegistry*	ZClassRegistry::sRegistryHead = NULL;/*--------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZClassRegistry::ZClassRegistry()	: ZArray( sizeof( Object_Info )){	classID = CLASS_ZClassRegistry;		// link ourselves into private list of available registries. This is done	// so that if there are multiple registries, a search can be performed through all	// of them, no matter which one was called. This is a convenience for the programmer,	// who can just make registries as needed and they all act together.		fNext = sRegistryHead;	gClasses = sRegistryHead = this;}/*---------------------------------***  DESTRUCTOR  ***----------------------------------*/ZClassRegistry::~ZClassRegistry(){	// clean up - dispose of names in registry as required	Object_Info		oi;		for( long i = 1; i <= CountItems(); i++ )	{		GetArrayItem( &oi, i );			if ( oi.classname )			DisposePtr((Ptr) oi.classname );	}		// unlink from list of registries		if ( sRegistryHead == this )		sRegistryHead = fNext;	else	{		ZClassRegistry*	t = sRegistryHead;				while( t && ( t->fNext != this ))			t = t->fNext;					if ( t )			t->fNext = fNext;	}		gClasses = sRegistryHead;}/*--------------------------------***  RegisterClass  ***-------------------------------*//*access:			publicoverrides:		description: 	register a classins: 			<aType> class identifier				<aFunc> constructor function that will instantiate the class				<aName> the class name				<refCon> additional information stored in the registryouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZClassRegistry::RegisterClass( const OSType aType, ConstructorFunction aFunc, Str255 aName, const long refCon ){	long			indx;	Object_Info		oi;		if (( indx = FindClass( aType )) == 0 )	{		oi.classid = aType;		oi.newfunc = aFunc;		oi.refCon = refCon;				if ( aName )		{			oi.classname = (char*) NewPtr( aName[0] + 1 );			CopyPToCString( aName, oi.classname );		}		else			oi.classname = NULL;					AppendItem( &oi );	}	else	{		// the ID already exists. While it's OK to attempt to register a class twice,		// it's an error to have the same ID allocated to two different classes, so		// check if this is the case and throw exception if so.		// This is important as we move to the RAD tool for		// views, since programmers MUST provide unique IDs for all views. The presence		// of this error will hopefully encourage you to ensure this is the case!				if ( aName && ( FindClass( aName ) != indx ))			FailOSErr( kClassHasNonUniqueIDErr );	}}/*--------------------------------***  RegisterClass  ***-------------------------------*//*access:			publicoverrides:		description: 	register a class based on an example objectins: 			<exampleClass> an instance of the class to register				<aFunc> constructor function for classouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZClassRegistry::RegisterClass( ZObject& exampleClass, ConstructorFunction aFunc ){	char*	className;	Str255	pClassName;		FailNILParam( &exampleClass );		className = (char*) typeid( exampleClass ).name();	CopyCToPString( className, pClassName );		RegisterClass( exampleClass.GetClassRef(), aFunc, pClassName, 0 );}/*-------------------------------***  GetNameOfClass  ***-------------------------------*//*access:			publicoverrides:		description: 	get the name of a registered class from its IDins: 			<aType> the class ID				<aName> receives the nameouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZClassRegistry::GetNameOfClass( const OSType aType, Str255 aName ){	Object_Info		oi;	long			index = FindClass( aType );		if ( index > 0 )	{		GetArrayItem( &oi, index );		CopyCToPString( oi.classname, aName );	}	else	{		// try next registry:				if ( fNext )			fNext->GetNameOfClass( aType, aName );		else			FailOSErr( kClassTypeUnknownErr );	}}/*------------------------------***  InstantiateClass  ***-------------------------------*//*access:			publicoverrides:		description: 	instantiate an object with the given class IDins: 			<aType> the class IDouts: 			the object creatednotes:			----------------------------------------------------------------------------------------*/ZObject*	ZClassRegistry::InstantiateClass( const OSType aType ){	ZObject*		obj = NULL;	Object_Info		oi;	long			index;		index = FindClass( aType );		if ( index > 0 )	{		GetArrayItem( &oi, index );				if ( oi.newfunc == NULL )			FailOSErr( kBadConstructorFuncErr );				obj = (*oi.newfunc)();	}	else	{		// not found here, try the next registry in the chain:				if ( fNext )			obj = fNext->InstantiateClass( aType );		else			FailOSErr( kClassTypeUnknownErr );	}	return obj;}/*------------------------------***  InstantiateClass  ***-------------------------------*//*access:			publicoverrides:		description: 	instantiate an object with the given class nameins: 			<aname> the class nameouts: 			the object creatednotes:			----------------------------------------------------------------------------------------*/ZObject*	ZClassRegistry::InstantiateClass( const Str255 aName ){	ZObject*		obj = NULL;	Object_Info		oi;	long			index;		index = FindClass( aName );		if ( index > 0 )	{		GetArrayItem( &oi, index );				if ( oi.newfunc == NULL )			FailOSErr( kBadConstructorFuncErr );				obj = (*oi.newfunc)();	}	else	{		// not found here, try the next registry in the chain:				if ( fNext )			obj = fNext->InstantiateClass( aName );		else			FailOSErr( kClassTypeUnknownErr );	}	return obj;}/*---------------------------------***  FindClass  ***----------------------------------*//*access:			publicoverrides:		description: 	look up the class IDins: 			<aType> class Id to look upouts: 			index position of the class in the registry, or 0 if not foundnotes:			----------------------------------------------------------------------------------------*/long		ZClassRegistry::FindClass( const OSType aType ){	Object_Info		oi;	long			i;		for( i = 1; i <= CountItems(); i++ )	{		GetArrayItem( &oi, i );				if ( oi.classid == aType )			return i;	}		return 0;}/*---------------------------------***  FindClass  ***----------------------------------*//*access:			publicoverrides:		description: 	look up the class nameins: 			<aName> class name to look upouts: 			index position of the class in the registry, or 0 if not foundnotes:			name lookup is not case-sensitive----------------------------------------------------------------------------------------*/long		ZClassRegistry::FindClass( const Str255 aName ){	Object_Info		oi;	long			i;	Str255			pClassName;		if ( aName )	{		for( i = 1; i <= CountItems(); i++ )		{			GetArrayItem( &oi, i );			CopyCToPString( oi.classname, pClassName );						if ( EqualString( pClassName, aName, FALSE, TRUE ))				return i;		}	}	return 0;}#pragma mark -/*---------------------------***  InstantiateFromStream  ***----------------------------*//*access:			publicoverrides:		description: 	instantiate an object from a streamins: 			<aStream> stream we are reading fromouts: 			the object creatednotes:			called as needed - do not call directly----------------------------------------------------------------------------------------*/ZObject*	ZClassRegistry::InstantiateFromStream( ZStream* aStream )		{	ZObject*	root = NULL;	OSType		rootClassID;	FailNILParam( aStream );		// class ID must be next data in stream		aStream->ReadLong((long*) &rootClassID );	aStream->Skip( sizeof( long ));	// ignore instance ID stored in stream		// instantiate this class:		FailNIL( root = InstantiateClass( rootClassID ));		// read the rest of the object's data (and other objects if necessary) into object		root->ReadFromStream( aStream );		return root;}/*--------------------------------***  ReportFields  ***--------------------------------*//*access:			publicoverrides:		description: 	report data members to inspectorins: 			noneouts: 			nonenotes:			----------------------------------------------------------------------------------------*/void		ZClassRegistry::ReportFields()	{	ZArray::ReportFields();	XSHOWFIELD( fNext, ft_objectref );}