/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZHashTable.cpp			-- dictionary container object******			© 2000, Graham Cox*****************************************************************************************************/#include	"ZHashTable.h"#include	"MacZoop.h"#include 	<string.h>/*-------------------------------***  CONSTRUCTOR  ***----------------------------------*/ZHashTable::ZHashTable( const long dataSize )	: ZComrade(){	FailNIL( strSpace = NewHandle( SS_CLUMP_SIZE ));	ssLength = 0;	ssUDSize = dataSize;	ssDataSize = dataSize - sizeof( char ) + sizeof( ht_entry );	ssCount = 0;	ssScope = 0;		// make sure all initial entries are NULL:		for( long i = 0; i < HASH_ENTRIES; i++ )		ht[i] = NULL;}/*--------------------------------***  DESTRUCTOR  ***----------------------------------*/ZHashTable::~ZHashTable(){	Clear();		if ( strSpace )		DisposeHandle( strSpace );	}/*---------------------------------***  AddSymbol  ***----------------------------------*//*access:			public	overrides:description: 	add a symbol to the tableins: 			<name> key name to associate with data				<symbolData> pointer to data you supplyouts: 			TRUE if symbol already exists, FALSE otherwisenotes:----------------------------------------------------------------------------------------*/Boolean			ZHashTable::AddSymbol( const char* name, void* symbolData ){	Boolean 		exists = FALSE;	unsigned long	hf;	htEntryPtr		hte;		hf = Hash( name );		// check whether the symbol exists regardless of scope		if ( hte = SSChain( name, hf, FALSE ))	{		// we got a match. If the scope is different, we need a new entry, but we can save		// space in the stringspace because the name is identical - both point to the same name.				if ( hte->ssScope != ssScope )			SSPrepend( hf, hte->ssKey, hte->ssKeyLength, symbolData );		else		{			// you can change the data of an existing symbol with this as well,			// or you can pass NULL to query or add the key name only						if ( symbolData )				BlockMoveData((Ptr) symbolData, (Ptr) &hte->userData, ssUDSize );			exists = TRUE;		}	}	else	{		// not in any chain at all, so prepend it to the table.				SSPrepend( hf, SSAdd( name ), strlen( name ), symbolData );	}		return exists;}/*--------------------------------***  DeleteSymbol  ***--------------------------------*//*access:			public	overrides:description: 	delete a symbol from the tableins: 			<name> key name to deleteouts: 			nonenotes:----------------------------------------------------------------------------------------*/void			ZHashTable::DeleteSymbol( const char* name ){	// deletes the symbol with the given key name, if it exists. This does not	// bother removing the name from the stringSpace, but this is OK since that is never	// searched. The key name can be reused if needed after this. If scoping is used,	// this removes the matching symbol with the current scope only		unsigned long	hf = Hash( name );	htEntryPtr		htp, htn, htt;		htt = SSChain( name, hf, TRUE );		if ( htt )	{		// the symbol does exist in this chain, so lets get rid of it.		// we need to walk the chain so we have a reference to the link in front				htp = ht[hf];			if ( htp == htt )			ht[hf] = htt->htnext;		else		{			while( htp )			{				htn = htp->htnext;								if ( htn == htt )				{					htp->htnext = htn->htnext;					break;				}				htp = htn;			}		}				SSDispose( htt );		}	}/*---------------------------------***  GetSymbol  ***----------------------------------*//*access:			public	overrides:description: 	get user data for a symbolins: 			<name> key name for the symbolouts: 			the user data, or NULL if the symbol was not foundnotes:----------------------------------------------------------------------------------------*/void*			ZHashTable::GetSymbol( const char* name  ){	// returns pointer to the user data for the key name passed, or NULL if not found.	// this returns the symbol for the most local scope if scoping is used - i.e. what	// you would naturally expect.		htEntryPtr		htp;		// look for the matching symbol with the nearest scope		htp = SSChain( name, Hash( name ), FALSE );		if ( htp )		return &htp->userData;	else		return NULL;}		/*-----------------------------------***  Hash  ***-------------------------------------*//*access:			public	overrides:description: 	calculate a hash value for the key nameins: 			<name> key name to hashouts: 			index into hash tablenotes:			Very important that the hash value returned is less than HASH_ENTRIES----------------------------------------------------------------------------------------*/unsigned long	ZHashTable::Hash( const char* name ){	register unsigned long	h = 1;	register char*			p = (char*) name;	register char			c;		// the default algorithm is very simple - we simply multiply all the character	// values together, then take the result modulo the table length. This gives	// surprisingly good results, and is fast for CPUs that have multiply instructions.		while(( c = *p++ ) != 0 )		h *= (unsigned long) c;		return h % HASH_ENTRIES;}/*----------------------------------***  Clear  ***-------------------------------------*//*access:			public	overrides:description: 	empty the table entirely so we can use it againins: 			noneouts: 			nonenotes:			deletes everything in the table----------------------------------------------------------------------------------------*/void			ZHashTable::Clear(){	htEntryPtr	htp, htn;		// delete the actual table entries and user data		for( long i = 0; i < HASH_ENTRIES; i++ )	{		htp = ht[i];		ht[i] = NULL;				// start of possible chain?:		while ( htp )		{			htn = htp->htnext;						SSDispose( htp );			htp = htn;			}	}}/*---------------------------------***  OpenScope  ***----------------------------------*//*access:			public	overrides:description: 	open a new scope to establish a context for symbolsins: 			noneouts: 			nonenotes:			only use if taking advantage of the scoping facilities!----------------------------------------------------------------------------------------*/void			ZHashTable::OpenScope(){	++ssScope;}/*---------------------------------***  CloseScope  ***---------------------------------*//*access:			public	overrides:description: 	delete all symbols that have the current scope, and close that scopeins: 			noneouts: 			nonenotes:			only use if taking advantage of the scoping facilities!----------------------------------------------------------------------------------------*/void			ZHashTable::CloseScope(){	htEntryPtr		htp;		for( long i = 0; i < HASH_ENTRIES; i++ )	{		do		{			htp = ht[i];						if ( htp )			{				if ( htp->ssScope >= ssScope )				{					ht[i] = htp->htnext;					SSDispose( htp );				}				else					break;	// if the scope doesn't match, forget the rest of the chain. There is							// no likelihood of later entries matching our scope because entries							// are always prepended and chains are thus sorted in scope order.			}			else				break;		}		while( 1 );	}	--ssScope;}/*-------------------------------***  GetNextSymbol  ***--------------------------------*//*access:			public	overrides:description: 	allows you to iterate all symbolsins: 			<name> pointer for symbol key name. If NULL, no name is returnedouts: 			user data, or NULL if no more entriesnotes:			intended for listing symbol table contents, normally called in a loop----------------------------------------------------------------------------------------*/void*			ZHashTable::GetNextSymbol( char* name ){	static htEntryPtr		last = NULL;	static unsigned long	i = 0;		void*	uData = NULL;		// if part of a chain, follow the chain		if( last )		last = last->htnext;		if ( last == NULL )	{		// try next available chain in table				do		{			last = ht[i++];		}		while(( last == NULL ) && ( i < HASH_ENTRIES ));	}	if ( last )	{		// we got one, return the info to the caller			uData = &last->userData;				// copy key name to <name> if not NULL				if ( name )		{			HLock( strSpace );			BlockMoveData( *strSpace + last->ssKey, name, last->ssKeyLength );			name[ last->ssKeyLength ] = 0;			HUnlock( strSpace );		}	}	else	{		// must have hit the end, so reset everything for a future call			i = 0;		last = NULL;		if ( name )			name[0] = 0;	}		return uData;}/*-----------------------------------***  SSAdd  ***------------------------------------*//*access:			protected	overrides:description: 	append the name to the string spaceins: 			<name> key name to add to string spaceouts: 			offset of name in the string spacenotes:----------------------------------------------------------------------------------------*/unsigned long	ZHashTable::SSAdd( const char* name ){	// the string space is just a big lump of relocatable memory. We store the symbol	// key names one after another in this block. The table entries include the	// offset and length of the key names in the string space. The block expands to	// accommodate data as it is added, but for efficiency we add a largeish clump	// when necessary.		unsigned short	nLength;	unsigned long	keyOffset;		nLength = strlen( name );	keyOffset = ssLength;		// will the string fit?		while (( ssLength + nLength ) > GetHandleSize( strSpace ))	{		// no - grow the string space by the clump size			SetHandleSize( strSpace, GetHandleSize( strSpace ) + SS_CLUMP_SIZE );		FailMemError();	}		// OK, it will fit now...	// we know the name is unique since we are only called if it is, so we can simply	// add the name		BlockMoveData((Ptr) name, *strSpace + ssLength, nLength );		ssLength += nLength;		return keyOffset;}/*----------------------------------***  SSChain  ***-----------------------------------*//*access:			protected	overrides:description: 	search a chain for the key nameins: 			<name> key name to search for in the chain				<htIndex> hash table index to start the chainouts: 			pointer to the symbol entry if a match was found, NULL if notnotes:----------------------------------------------------------------------------------------*/htEntryPtr			ZHashTable::SSChain( const char* name, unsigned long htIndex, Boolean checkScope ){	// searches a collision chain for the given key, starting with the indexed	// table entry. returns the entry if found, NULL if not		htEntryPtr match = NULL;		// simple case: if the table entry is empty, return NULL		if ( ht[ htIndex ] )	{		// the table entry isn't empty, so follow the chain and compare keys and scopes			htEntryPtr		htp;		unsigned short	nLength;				htp = ht[ htIndex ];		nLength = strlen( name );				while( htp )		{			// optionally check whether the scope requested is in scope...						if ( !checkScope || ( htp->ssScope == ssScope ))			{				// check length so we can discard trivial mismatches				// to boost performance								if ( nLength == htp->ssKeyLength )				{					// length matches, so we have to do a full compare:								if ( SSCompare( name, htp->ssKey, nLength ))					{						match = htp;						break;					}				}								htp = htp->htnext;			}			else				break;	// out of scope		}		}		return match;		}/*---------------------------------***  SSCompare  ***----------------------------------*//*access:			protected	overrides:description: 	perform a comparison of a key name with the string spaceins: 			<name> key name to compare				<keyOffset> string space offset to compare against				<keyLength> the length of the keyouts: 			TRUE if key name matched, FALSE if notnotes:----------------------------------------------------------------------------------------*/Boolean			ZHashTable::SSCompare( const char* name, unsigned long keyOffset, unsigned short keyLength ){	// compares a string against the entry in the string space, return TRUE if it	// matches, FALSE otherwise. Fully case sensitive.		register char	*p, *q;	Boolean			result = TRUE;		HLock( strSpace );	p = (char*) name;	q = (char*)( *strSpace + keyOffset );		while( keyLength-- )	{		if ( *p++ != *q++ )		{			result = FALSE;			break;		}	}		HUnlock( strSpace );	return result;}/*---------------------------------***  SSPrepend  ***----------------------------------*//*access:			protected	overrides:description: 	create and prepend a new entry in the tableins: 			<htIndex> table index				<keyOffset> string space offset for entry				<keyLength> the length of the key				<userData> additional user dataouts: 			nonenotes:----------------------------------------------------------------------------------------*/void			ZHashTable::SSPrepend( unsigned long htIndex, unsigned long keyOffset, unsigned short keyLength, void* userData ){	htEntryPtr		hte;		FailNIL( hte = (htEntryPtr) operator new ( ssDataSize ));		hte->ssKey = keyOffset;	hte->ssKeyLength = keyLength;	hte->ssScope = ssScope;	hte->htnext = ht[htIndex];		if ( userData )		BlockMoveData((Ptr) userData, (Ptr) &hte->userData, ssUDSize );		ht[htIndex] = hte;	++ssCount;}/*---------------------------------***  SSDispose  ***----------------------------------*//*access:			protected	overrides:description: 	dispose a table entryins: 			<htp> entry to dispose ofouts: 			nonenotes:			entries that form part of a collision chain must be removed from the				chain prior to calling this----------------------------------------------------------------------------------------*/void			ZHashTable::SSDispose( htEntryPtr htp ) {	// give caller a chance to delete any private storage:		SendMessage( msgHashTableEntryDeleted, &htp->userData );		--ssCount;		delete htp;		// if ssCount reaches zero, we can recover the string space. This	// gives us slightly better memory efficiency if we are reusing a table	// over a long period and adding and deleting lots of stuff.		if ( ssCount <= 0 )	{		SetHandleSize( strSpace, SS_CLUMP_SIZE );		ssLength = 0;	}}