/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZStream.h			-- a generic stream (abstract class- use ZHandleStream or*																		ZFileStream ).******			© 1998, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZSTREAM__#define	__ZSTREAM__#include    "MacZoopTypes.h"#include	<QuickDraw.h>class	ZObject;class	ZArray;typedef struct{	ZObject*	theObject;	long		instanceID;	long		classID;}ObjRef_T_Entry;// class definition:class	ZStream{protected:	unsigned long	idSeed;	unsigned long	mark;	ZArray*			refTable;public:	ZStream();	virtual ~ZStream();		virtual void		Reset() { mark = 0; };// reading data from stream		virtual void		ReadChar( char* aChar );	virtual void		ReadShort( short* aShort );	virtual void		ReadLong( long* aLong );	virtual void		ReadFloat( float* aFloat );	virtual void		ReadString( Str255 aString );	virtual void		ReadData( Ptr aBuf, long* dataLen );	virtual void		ReadHandle( Handle* aHand );	virtual ZObject*	ReadObject();	virtual void		ReadRect( Rect* aRect );	virtual void		ReadPoint( Point* aPoint );	virtual void		ReadGrafPort( GrafPtr aPort );	virtual void		ReadColour( RGBColor* rgb );	// writing data to the stream	virtual void		WriteChar( char aChar );	virtual void		WriteShort( short aShort );	virtual void		WriteLong( long aLong );	virtual void		WriteFloat( float aFloat );	virtual void		WriteString( Str255 aString );	virtual void		WriteData( Ptr aBuf, long dataLen );	virtual void		WriteHandle( Handle aHand );	virtual void		WriteObject( ZObject* anObject );	virtual void		WriteRect( Rect* aRect );	virtual void		WritePoint( Point aPoint );	virtual void		WriteGrafPort( GrafPtr aPort );	virtual void		WriteColour( RGBColor* rgb );		virtual void		Skip( long skipBytes ) { mark += skipBytes; };	protected:// low level stuff	virtual void		PutTo( UntypedPtr data, long size ) = 0;	virtual void		GetFrom( UntypedPtr data, long* size ) = 0;	virtual long		FindObjectReference( ZObject* anObject );	virtual long		FindObjectReference( long classID, long instanceID );};enum{	kNoMoreDataInStreamErr	= 611,		// tried to read beyond the end-of-stream (eos)	kStreamsNotPresentErr};/*Use STREAMS to save and restore any data. ZStream is an abstract class and as such does nothing,but implements the basic behaviour used by ZHandleStream and ZFileStream. Since both have thesame API, saving data in memory or on disk follows exactly the same protocol. You can writewhole objects to a stream as long as they are derived from ZObject- just call the object'sWriteToStream method, passing the stream object. To read an object from a stream, you need tomake the object using the default constructor, then call its ReadFromStream method, passingthe stream, which will set up the object from the stream. Internally, the objects make callsto the stream's methods here to write data members, etc to the stream. They can also causeother objects to be written there by calling their WriteToStream, etc. This is the basis ofpersistent objects.In order to resolve object references when more than one object may wish to write it to astream, you must call WriteObjectReference for every object that you are going to try toput in the stream- this is done by the default WriteToStream() method in ZObject (objectsMUST be saved to the stream in class hierarchy order, with the root class first, etc. ZStreamkeeps track of objects it has already written out and instead of doing it again will store aspecial code in the stream to indicate a shared object. If WriteObjectReference() returns TRUE,the object has not been seen and you should go ahead and save the object's data. If FALSE,the stream already has the object so you can skip the data save.When reading in an object, the ReadFromStream() method should initialise itself from theroot class upwards. If it needs to pull in another object, it must call the ReadObjectReferencemethod here, which will return the object- either a new one built from the stream, or apointer to an existing one if it was created already- in fact you do not need to care which itis, since the thing is fully initialised. Unlike the write to stream case, you should notexplicitly call the object's ReadFromStream method.Data is saved in the stream in the order it's appended, so it should clearly be read back inin the same order. Ensuring this is up to your code- basically, the read and write methods ofan object should have identical structures, or use Skip() to ignore data on the stream.Streams are extremely powerful for implementing files, drag/drop, cut/paste, undo and a wholehost of other useful behaviours. Using persistent objects allows you to save and restore anentire hierarchy of objects, and also opens the door to building applications visually in themanner of visual C++, etc. */#endif