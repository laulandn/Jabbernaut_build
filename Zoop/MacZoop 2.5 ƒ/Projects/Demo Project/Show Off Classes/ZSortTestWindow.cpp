/****************************************************************************************************			ObjectMacZapp		-- a standard Mac OOP application template****			ZSortTestWindow.cpp			-- a window that demonstrates the sort function******			© 1996, Graham Cox*****************************************************************************************************/#include	"ZSortTestWindow.h"#include	"MacZoop.h"#include	"ZPStrArray.h"#include	"ZFile.h"#include	"ZDialog.h"#include	"ZProgress.h"#include	"ZHandleStream.h"#include	"ZFileStream.h"#include	<Timer.h>static short MyCompareFunc( void* a, void* b, long ref );CLASSCONSTRUCTOR( ZSortTestWindow );ZSortTestWindow::ZSortTestWindow( ZCommander* aBoss, short windID )	: ZScroller( aBoss, windID ){	// the array will hold Str63s. This is a seriously inefficient way to store lots	// of strings, but this is only a test.		FailNIL(itsArray = new ZPStrArray());	unsigned long rs;	GetDateTime( &rs );	SETQDRANDSEED( rs );		sortTime = -1;	classID = CLASS_ZSortTestWindow;		topMargin = 24;	tPhase = FALSE;	lastInsert = -1;}ZSortTestWindow::ZSortTestWindow(){	itsArray = NULL;	sortTime = -1;	classID = CLASS_ZSortTestWindow;		topMargin = 24;	tPhase = FALSE;	lastInsert = -1;}ZSortTestWindow::~ZSortTestWindow(){	ForgetObject( itsArray );}void	ZSortTestWindow::InitZWindow(){	ZScroller::InitZWindow();		printable = TRUE;		Focus();	TextFont( kFontIDGeneva );	TextSize( 9 );		SetMillisecondTimer( this, 1, 500 );}void	ZSortTestWindow::DrawContent(){	Rect		cr, lr;	long		i, n, linePos;	short		lineHeight;	FontInfo	fi;	Str255		s;		TextFont( kFontIDGeneva );	TextSize( 9 );	TextFace( 0 );	TextMode( srcOr );		if (isPrinting )		GetBounds( &cr );	else	{		GetContentRect( &cr );		EraseRect( &cr );	}	// calculate the lineheight		GetFontInfo( &fi );	lineHeight = fi.ascent + fi.descent + fi.leading;		linePos = fi.ascent;		PenNormal();		// draw each string to the window		n = itsArray->CountItems();		for (i = 1; i<= n; i++)	{		MoveTo( 8, linePos );						// calculate the line rect and only draw strings that intersect the		// content rect. (This is just an optimisation for faster drawing).				SetRect(&lr, 0, linePos - fi.ascent, cr.right, linePos + fi.descent + fi.leading);				if (SectRect( &lr, &cr, &lr ))		{			if ( i == lastInsert )				TextFace( bold + underline );			else				TextFace( 0 );							NumToString( i, s );			DrawString( s );			DrawString( "\p.");						MoveTo( 40, linePos );						itsArray->GetArrayItem( s, i );						DrawString( s );		}		linePos += lineHeight;	}}void	ZSortTestWindow::DrawHeader(){	ZScroller::DrawHeader();		Str255	s;		TextFont( kFontIDGeneva );	TextSize( 9 );	TextFace( bold );	TextMode( IsActive()? srcOr : grayishTextOr ); 		MoveTo( 8, 14 );			DrawString("\pNumber of items: ");	NumToString( itsArray->CountItems(), s );	DrawString( s );		if (sortTime != -1)	{		DrawString("\p. Sort/Scramble/Insert took about ");		NumToString( sortTime, s );		DrawString( s );		DrawString("\p mS");	}		DrawTicker();}void	ZSortTestWindow::Activate(){	ZScroller::Activate();		gMenuBar->AppendMenuToBar( 177 );}void	ZSortTestWindow::Deactivate(){	ZScroller::Deactivate();		gMenuBar->RemoveMenuFromBar( 177 );}	void	ZSortTestWindow::UpdateMenus(){	gMenuBar->EnableCommand( kCmdSort );	gMenuBar->EnableCommand( kCmdScramble );	gMenuBar->EnableCommand( kCmdTestBinarySearch );	//gMenuBar->EnableCommand( kCmdSaveToBlockFile );		ZScroller::UpdateMenus();}void	ZSortTestWindow::HandleCommand( const long aCmd ){	UnsignedWide	w;		switch ( aCmd )	{		case kCmdSort:			SetBeachBallCursor();			Microseconds( &sTime );			itsArray->Sort();			Microseconds( &w );			sortTime = ( w.lo - sTime.lo ) / 1000;			PostRefresh( WINDOWPORTRECT( GetMacWindow()));			SetDirty( TRUE );			lastInsert = -1;			break;				case kCmdScramble:			SetBeachBallCursor();			Microseconds( &sTime );			itsArray->Randomise();			Microseconds( &w );			sortTime = ( w.lo - sTime.lo ) / 1000;			PostRefresh( WINDOWPORTRECT( GetMacWindow()));			SetDirty( TRUE );			lastInsert = -1;			break;					case kCmdTestBinarySearch:			TestBinSearch();			break;					case kCmdSaveToBlockFile:			//SaveToBlockFile();			break;				}	ZScroller::HandleCommand( aCmd );}void	ZSortTestWindow::OpenFile( const OSType aType, Boolean isStationery ){	// builds the initial array by reading a file of strings. This is a text file called	// "test_strings.txt". The code here should not be regarded as a particularly good	// way to read strings from a file- it is a quick and dirty implementation that is	// far from optimum. The data in the file is actually scanned twice for example, which	// could be easily avoided with a little work.		ZFile		aFile( macFile );	long		bytes, prevMark;	short		len, c;	char		fChar;	Str255		fStr;		aFile.Open();		ZProgress	zPD( this, kStdProgressResID, aFile.GetLength(), kProportionalProgress, kCancelType );	zPD.SetDelay( 60 );	zPD.SetMessage("\pReading text file...");	zPD.SetTitle( macFile.name );		try	{		// discard any existing items in the array by removing it		// and making a new one				ForgetObject( itsArray );		FailNIL( itsArray = new ZPStrArray());				// scan for strings. We look for a return (0x0D) or the char count going		// over what we can store in one array entry (63 chars).				while( true )		{			prevMark = aFile.GetMark();			fChar = 0;			bytes = 1;			c = 0;			while((fChar != 0x0D) && (++c < 255))				aFile.Read( &fChar, &bytes );							// found CR or string of max length, so get the length of that string						len = aFile.GetMark() - prevMark;						// if len is only 1 or less, skip it- we don't want lots of empty strings!						if (len > 1)			{				// extract the string from the file. Be careful that we don't go off the end				// of the string- the local string buffer has 255 bytes, the array can store 62.								aFile.SetMark( prevMark );				bytes = MIN( 255, len);				aFile.Read((Ptr) &fStr[1], &bytes );				fStr[0] = bytes;								aFile.SetMark( prevMark + len );								// set string into the array								itsArray->AppendItem( fStr );			}			// update the progress indicator						if (! zPD.InformProgress( aFile.GetMark()))				FailOSErr( userCanceledErr );			}	}	catch( ZoopError err )	{		// it was probably only the end-of-file, or the user cancelling, in which		// case carry on as normal. Other errors are thrown.				if (err != eofErr)			throw err;	}		CalcBounds();		// inherited method sets title of window, etc		ZScroller::OpenFile( aType, isStationery );}void	ZSortTestWindow::CalcBounds(){	// calculate the scrollbounds. Again, this is crude, since a file with more than	// about 2,500 strings will cause the coordinates to overflow. We take no pre-	// cautions against this, so things may become a bit odd if this occurs.		FontInfo	fi;	Rect		sb;		Focus();	GetFontInfo( &fi );	SetRect(&sb, 0, 0,			(63 * fi.widMax) + 8,			((fi.ascent + fi.descent + fi.leading) * itsArray->CountItems()) + 1); 			SetBounds( sb );	SetScrollAmount( fi.widMax, fi.ascent + fi.descent + fi.leading); }void	ZSortTestWindow::WriteToStream( ZStream* aStream ){	ZScroller::WriteToStream( aStream );	aStream->WriteObject( itsArray );}void	ZSortTestWindow::ReadFromStream( ZStream* aStream ){	ZScroller::ReadFromStream( aStream );	ForgetObject( itsArray );		itsArray = (ZArray*) aStream->ReadObject();		CalcBounds();}void	ZSortTestWindow::HandleTimer( ZTimer* t ){	// to demo the timer, we just use it to flash a square in the header area		tPhase = !tPhase;	DrawTicker();}void	ZSortTestWindow::DrawTicker(){	Rect	r;		r = *WINDOWPORTRECT( GetMacWindow());		InsetRect( &r, 4, 5 );	r.left = r.right - 10;	r.bottom = topMargin - 8;	if ( tPhase )	{		ForeColor( redColor );		PaintOval( &r );		ForeColor( blackColor );	}	else		EraseOval( &r );}void	ZSortTestWindow::TestBinSearch(){	ZDialog	d( this, kBinSearchInputDlogID );		UnsignedWide	w;	FontInfo		fi;	Str255			s;		if ( d.RunModal())	{		d.GetValueAsText( kBinSearchStrItem, s );				Microseconds( &sTime );				lastInsert = itsArray->InsertSortedItem( s, MyCompareFunc, 0 );				Microseconds( &w );		sortTime = ( w.lo - sTime.lo ) / 1000;				CalcBounds();		SetDirty( TRUE );				GetFontInfo( &fi );		short sp = (fi.ascent + fi.descent + fi.leading) * ( lastInsert - 1 );				ScrollTo( 0, sp );		PostRefresh( WINDOWPORTRECT( GetMacWindow()));	}}#pragma mark -static short MyCompareFunc( void* a, void* b, long ref ){	// a and b are pointers to Str255's. We can simply call the toolbox to compare them.		return RelString((ConstStr255Param) a, (ConstStr255Param) b, TRUE, TRUE );}