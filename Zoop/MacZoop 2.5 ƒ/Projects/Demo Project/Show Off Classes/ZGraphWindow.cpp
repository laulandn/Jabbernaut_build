/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			ZGraphWindow.cpp		-- Graph window******			© 2000, Graham Cox*****************************************************************************************************/#include	"ZGraphWindow.h"#include	"MacZoop.h"#include	"ZExpParser.h"#include	"ZGWorld.h"#include	"ZViewDialog.h"#include 	<fp.h>#include	<string.h>#include	<stdlib.h>ZGraphWindow::ZGraphWindow( ZCommander* aBoss, const short id )	: ZWindow( aBoss, id ){	classID = CLASS_ZGraphWindow;		expr = (char*) NewPtr( 255 );	strcpy( expr, "a*sin(x)" );	aa = 1.0;		buf = NULL;}ZGraphWindow::~ZGraphWindow(){	if ( expr )		DisposePtr((Ptr) expr );		if ( buf )		FORGETOBJECT( buf );}void	ZGraphWindow::InitZWindow(){	Rect	cr;		ZWindow::InitZWindow();		GetContentRect( &cr );		// if we can buffer the window, we will, if not, it will still work,	// but it will flicker on mouse drags		try	{		FailNIL( buf = new ZGWorld( cr, 8 ));	}	catch( ZoopError err )	{	}}void	ZGraphWindow::DrawContent(){	double_t	x1, x2, y, xi, yi;	Rect		r;	short		xx, yy, ox, oy, yo;	CGrafPtr	sp;	GDHandle	sd;		ZExpParser	ep;		// the horizontal range of the graph is fixed at ±3¹		x1 = -3*pi;	x2 = 3*pi;		GetContentRect( &r );		// set up the buffer, clearing it to the background colour		if ( buf )	{		buf->SetPortToGW( &sp, &sd );		buf->Lock();		RGBBackColor( &gStraw );		buf->Clear();	}	else	{		RGBBackColor( &gStraw );		EraseRect( &r );	}		// set up the basic variables for plotting the curve		xi = ( x2 - x1 ) / ( r.right - r.left );	ox = xx = r.left - 1;	yo = oy = yy = ( r.top + r.bottom ) / 2;	yi = ( r.bottom - r.top ) / -6.0;		// take account of any mouse-driven change in the value "a"		ep.SetSymbolValue( "a", aa );		// draw the zero datum		RGBForeColor( &gMidGray );	PenPat( QDGRAYPATTERN );	MoveTo( ox, oy );	LineTo( r.right, oy );		PenNormal();	RGBForeColor( &gBlue );		// now plot the actual graph of the function by	// iterating across the x axis and forming the x,y	// point to plot from the expression		try	{		// scan across, plotting the result for each value of x				for(; xx <= r.right; xx++ )		{			// set the value of x in the expression						ep.SetSymbolValue( "x", x1 );						// calculate the result (y)						y = ep.Evaluate( expr );						// scale it to fit the graph window vertically						yy = ( y * yi ) + yo;						// plot a line from this point to the last one drawn						MoveTo( xx, yy );			LineTo( ox, oy );						ox = xx;			oy = yy;					x1 += xi;		}	}	catch( ZoopError err )	{		// don't propagate syntax errors				MoveTo( 10, 30 );		DrawString( "\pOops, syntax error in expression!" );	}		// and finally, clean up & display		if ( buf )	{		buf->Unlock();		::SetGWorld( sp, sd );				// blit result to window				buf->CopyOut( CURRENTPORTPIXMAP, &r, &r );	}}void	ZGraphWindow::Click( const Point mouse, const short modifiers ){	// dragging the mouse vertically in the window affects the value of the variable	// "a" in any function you declare. If the expression doesn't contain "a", then	// this will have no visible effect.		Point	m, om;	long	d;	Rect	cr;		if ( gApplication->GetClicks() > 1 )	{		Rect	r;				Pt2Rect( mouse, mouse, &r );		SetLocalZoomSource( &r );		HandleCommand( kCmdOpenExpressionDialog );	}	else	{		Focus();		GetContentRect( &cr );				m = om = mouse;				do		{			GetMouse( &m );						if ( DeltaPoint( m, om ))			{				d = DeltaPoint( m, mouse );								aa = (float) HiWord( d )/ 50;								DrawContent();								om = m;			}		}		while( WaitMouseUp());	}}void	ZGraphWindow::SetExpression( const char* anExpr ){	strcpy( expr, anExpr );	PostRefresh();	}void	ZGraphWindow::UpdateMenus(){	gMenuBar->EnableCommand( kCmdOpenExpressionDialog );		ZWindow::UpdateMenus();}void	ZGraphWindow::HandleCommand( const ZoopCommand cmd ){	switch( cmd )	{		case kCmdOpenExpressionDialog:			DoExpDialog();			break;					default:			ZWindow::HandleCommand( cmd );			break;	}}void	ZGraphWindow::DoExpDialog(){	// open a dialog in which the user may type any expression to be plotted	// as a graph in this window.		Str255			ex;	ZViewDialog		ed( this, kCmdOpenExpressionDialog );		ed.InitZWindow();		CopyCToPString( expr, ex );	ed.SetValue( 4, ex );		if ( ed.RunModalDialog())	{		char*		exp;				ed.GetValueAsText( 4, ex );				exp = (char*) malloc( ex[0] + 1 );		CopyPToCString( ex, exp );				SetExpression( exp );				free( exp );	}	}void	ZGraphWindow::WindowResized(){	Rect	r;	if ( buf )	{		GetContentRect( &r );		buf->SetSize( r, TRUE );		buf->Clear();				PostRefresh();	}}