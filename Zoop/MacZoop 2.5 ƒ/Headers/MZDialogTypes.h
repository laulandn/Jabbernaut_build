/****************************************************************************************************			MacZoop - "the framework for the rest of us"		 ****			DialogTypes.h		-- types used by both dialog classes******			©2000, Graham Cox*****************************************************************************************************/#pragma once#ifndef __DIALOGTYPES__#define	__DIALOGTYPES__#include	<dialogs.h>// 'ictb' parsing stuff:#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif// first part of resource is array of these:typedef struct{	unsigned short	iData;			// item data flags (enumerated below)	unsigned short	iOffset;		// offset to data table}ictbItemEntry, *ictbPtr, **ictbHandle;// text info stored in tables like this:typedef struct{	short			txtFont;		// font ID or offset to name	Style			txtFace;		// face- plain, bold, etc	char			filler;	short			txtSize;		// font size	RGBColor		txtFColour;		// text colour	RGBColor		txtBColour;		// background colour	short			txtMode;		// transfer mode}ictbTextStyleTable, *ictbTablePtr;// iData is bitfield arranged thus:enum{	fFamChange		= 1,			// change the font	fFaceChange		= 2,			// change the face	fSizeChange		= 4,			// change the size	fFColourChange	= 8,			// change the colour	fAddFontSize	= 16,			// add the size	fBColourChange	= 8192,			// change the background colour	fModeChange		= 16384,		// change the mode	fIsFNameOffset	= 32768			// txtFont is offset to font name};// item sizing can be obtained from a 'ILIM' resource with the DITL ID. It consists// of a simple list of item ID numbers and flag bytes. MacZoop 2.5 supports this, but// recent developments make this resource rather limited.// Therefore it is preferable to use the newer 'ISIZ' type below, which is easier to set// up and is rather less limited.// ILIM record:typedef struct{	unsigned char	item;			// item ID	unsigned char	iSizing;		// sizing flags for the item}ItemLimRecord, *ItemLimPtr, **ItemLimHdl;// ISIZ record:typedef struct{	short			itemID;			// item ID	short			itemFlags;		// reserved - set to 0		unsigned char	top;			// top sizing constant	unsigned char	left;			// left sizing constant	unsigned char	bottom;			// bottom sizing constant	unsigned char	right;			// right sizing constant	}ItemSizeRecord, *ItemSizePtr, **ItemSizeHdl;// resource is a simple array of these recordsenum{	kDialogItemSizingResType	= 'ILIM',	kDialogItemSizeResType		= 'ISIZ'};// appearance uses 'dftb' resource for item set-up- we will use this if availabletypedef struct{    short           dfType;    unsigned short  dfFontFlags;    short           dfFontID;    short           dfFontSize;    short           dfFontStyle;    short           dfTextMode;    short           dfTextJust;    RGBColor        dfTextColour;    RGBColor        dfBackColour;    unsigned char   dfFontNameLen;}dftbEntry, *dftbEntryPtr;// NOTE: don't rely on "sizeof(dftbEntry)" because it's off by one due to// word alignment. Instead use the dfEntrySize constant.enum{	dfEntrySize    = 27};typedef struct{    short           dfVersion;    short           dfCount;    dftbEntry       df[1];}dtfb, *dftbPtr, **dftbHandle;// 'dlgx' resource:typedef struct{    short           dlVersion;    unsigned long   dlFlags;}dlgx, *dlgxPtr, **dlgxHdl;// 'sitl' resource (switchable item list)typedef struct{    short   iCount;    short   items[1];}sitlEntry, *sitlEntryPtr;typedef struct{    short       masterItem;    short       sectionCount;    sitlEntry   firstEntry;}sitlRes, *sitlResPtr, **sitlResHdl;// 'DITL' resources are a list of items. Each one is a variable length,// but has a fixed header thus:typedef struct{	long			placeHolder;		// ignore	Rect			itemFrame;			// rect	unsigned char	itemType;			// dialog manager type	unsigned char	iDataLen;			// bytes of data to follow	short			iData;				// other data (don't assume this *IS* a short)										// it might be a string, etc.}DITLItemHeader;// these headers always start on an even address, even if the data length indicates// otherwise - therefore you need to add pad bytes if necessarytypedef struct{	short			itemCount;	DITLItemHeader	i;}DITL, *DITLPtr, **DITLHdl;	#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif// message sent to dialog's boss when dialog closed OK. You can listen for this// so that you get informed when the user closes the dialog. The boss listens for// this anyway- you just need to override ReceiveMessage to take action.enum{	kMsgDialogSuccessfullyClosed = 'dlg$',	kMsgDialogCancelled			 = 'dlg-',	kMsgDialogItemClicked		 = 'dlg~',	kMsgDialogSetUp				 = 'dlg!',	kMsgDialogHookAttachMaker	 = 'dlg^',		// not used with new dialogs	kMsgDialogPreSetUp			 = 'dlg<',		// not available with old dialogs	kFieldRangeAlertID			 = 137,	kUnsupportedTypeErr			 = 124,	kNoDialogItemsRegisteredErr	 = 125,	kMaxMagicParameters			 = 10,			// used by old dialogs	kMaxNumOfMagicParameters	 = 16			// used by view-based dialogs};// for dialog extensions, these are the "magic" string constants. "Magic" constants// are also assigned to standard items, for your programming convenience.enum{	kMagicStringListbox			= 'LIST',		// implemented	kMagicStringScrollbox		= 'TEXT',		// implemented	kMagicStringScrollingText	= 'TEXT',		// implemented (new name for above)	kMagicStringIconList		= 'ICLB',		// implemented	kMagicStringColourMenu		= 'CPOP',		// implemented	kMagicStringProgressBar		= 'PBAR',		// implemented	kMagicStringCounterDisplay	= 'DIGI',		// implemented  	kMagicStringClockDisplay	= 'CLOK',		// implemented  	kMagicStringGWorldScroller	= 'GWRP',		// implemented	kMagicStringGenericScroller = 'SCRL',		// implemented	kMagicStringArrayBrowser	= 'ZARB',		// implemented  	kMagicStringGeneralControl	= 'CTRL',		// implemented  		kMagicStringFrameBox		= 'FRAM',		// implemented  		kMagicStringPopUpCmdMenu	= 'POPM',		//  	kMagicStringPatternMenu		= 'PPOP',		// implemented  	kMagicStringGradientMenu	= 'GRAD',		//  	kMagicStringEnhancedText	= 'TXT+',		// implemented  	kMagicStringTabSelector		= 'TAB#',		// implemented  	kMagicStringCalendarView	= 'DCAL',		// implemented  	kMagicStringRulerView		= 'RULR',		// implemented  	kMagicStringRulerScroller	= 'RULS',		// implemented  	kMagicStringHexEditorScroll = 'HEXE',		// implemented  	kMagicStringAuxiliaryDITL	= 'DITL',		// implemented  	kMagicStringZoopVersion		= 'MZVN',		// implemented  	kMagicStringAppVersion		= 'VERS',		// implemented  //--------------------------------------------	kMagicStdStaticText			= 'stat',	kMagicStdEditText			= 'edit',	kMagicStdPushButton			= 'butt',	kMagicStdCheckbox			= 'chek',	kMagicStdRadioButton		= 'radi',	kMagicStdResControl			= 'cntl',	kMagicStdIcon				= 'icon',	kMagicStdPicture			= 'pict',	kMagicStdUserItem			= 'user',	kHelpStdItem                = 'help'};//   these items are not supported by older ZDialog/ZDialogItem code// modifier (aka "attachments") messages:enum{	kModifierItemClicked		= 'mick',	kModifierItemCreated		= 'mict',	kModifierItemDraw			= 'midw',	kModifierItemPostClick		= 'mpck'};// these "mangles" are used to throw out bugs when the <macWindow> member is// misused. This helps to track down bugs as we move to Carbon under OS X. The direct// value of the dialogPtr is mangled, but using the correct accessor returns the proper// thing. Any code that is using the wrong accessor will crash, so the bug can be identified// and fixed.#define		DLG_POINTER_MANGLE		0xAA38FF01#define		WIN_POINTER_MANGLE		0x55DA01FE// Functions that create dialog items must be of this form, which is basically the same as creating any view.// The function doesn't need to be built with the following macros, any suitable function can be registered, and// for many custom or compound items, this will be the case. For simple items, the macros below will automatically// set up a suitable function.typedef ZView* (*DialogItemConstructorFunction)( ZView*, Rect*, ... );// these macros simplify specifying your item constructor function if it's a simple kind#define 	DIALOGITEMCONSTRUCTOR( classType )		ZView*	DICF_##classType##( ZView* parent, Rect* frame, short param ) \																		 { return new classType( parent, frame, param ); }#define		DICONSTRUCTORPROTOTYPE( classType )		ZView* DICF_##classType##( ZView* parent, Rect* frame, short param )#define		DICONSTRUCTORFUNCTION( classType )		((DialogItemConstructorFunction) DICF_##classType )#endif