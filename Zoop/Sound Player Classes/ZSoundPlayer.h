/****************************************************************************************************			MacZoop - "the framework for the rest of us"	 ****			ZSoundPlayer.h		-- manages multiple sounds******			© 2000, Graham Cox*****************************************************************************************************/#pragma once#ifndef __ZSOUNDPLAYER__#define __ZSOUNDPLAYER__#include    "ZSound.h"#include	"ZObjectArray.h"typedef enum{    channel_Idle     = 0,    channel_Busy,    channel_Complete}SndStatus;class   ZChannel{protected:    SndChannelPtr   macChannel;    long            trigTime;    SndStatus       status;    SndCallBackUPP  callback;    ZSound*         curSound;public:    ZChannel();    virtual ~ZChannel();        virtual void        Play( ZSound* aSound );    virtual void        ShutUp();    virtual void        PitchBend( UnsignedFixed amount );        void                Reset();        static pascal void  CallbackProc( SndChannelPtr chan, SndCommand *cmd );        inline  long        GetTrigTime() { return trigTime; };    inline  SndStatus   GetStatus() { return status; };};#define     kAnyChannel             0#define     kZChannelCallbackID     15792class   ZSoundPlayer{protected:    ZObjectList*        sounds;    ZObjectList*        channels;    short               map;public:    ZSoundPlayer( const short mapResID = 0, const short numChannels = 4 );    ~ZSoundPlayer();            virtual short   PlaySound( const short resID, const short onChannel = kAnyChannel );    virtual short   PlaySound( Handle aSound, const short onChannel = kAnyChannel, Boolean autoDispose = TRUE );        virtual void    Idle();    virtual void    Mute( const short whichChannel );    virtual void    MuteAll( Boolean andDispose = FALSE );    virtual void    MakeSoundObject( const short resID );    virtual void    AddSoundObject( ZSound* aSound );        virtual void    PitchBend( const short channel, UnsignedFixed amount );    protected:    virtual void    Init( short numChannels );    ZChannel*       GetChannel( const short which );    ZChannel*       GetFreeChannel( short* index = NULL );    ZChannel*       GetOldestChannel( short* index = NULL );    ZSound*         FindSound( const short resID );    ZChannel*       ObtainChannel( short id, short* index = NULL );};/*This class is very simple. It maintains a list of sounds and a list of channels.It plays the sounds asynchronously on the channels.The idea is that you preload all of the sound resources initially by passing a 'SMAP'resource ID which lists the 'snd ' resources, or 0 to simply register all sounds in thecurrent resource fork (easier). The resources remain unlocked (but non-purgeable) as longas they're not in use. When played, the sounds are "acquired", which locks them with arefCount so they're only unlocked when all channels have finished playing it (a singlesound may be played simultaneously on different channels with each playing a differentpart of the sound).You can allocate any number of channels up to the maximum your hardware supports- thedefault is 4, which is usually enough.To play a sound, pass the resource ID to PlaySound(), and optionally a channel. It willbe played on that channel, stopping any existing sound playing on that channel. Pass 0 tohave either a free channel used, or if there aren't any, the sound that's been playing thelongest is killed and that channel used.The idea is to keep the sound going... other libraries seem to take the view that what'splaying is important and reject new requests. In games, it's usually better to play thelatest sound at the expense of older ones.Being object-oriented, this may get expanded to deal with sound files and other soundsources later.*/#endif