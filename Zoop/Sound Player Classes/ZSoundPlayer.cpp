/****************************************************************************************************			MacZoop - "the framework for the rest of us"	 ****			ZSoundPlayer.cpp		-- manages multiple sounds******			© 2000, Graham Cox*****************************************************************************************************/#include	"ZSoundPlayer.h"#include	"MacZoop.h"#include <stdlib.h>ZChannel::ZChannel(){	macChannel = NULL;	FailNIL( callback = NewSndCallBackUPP( CallbackProc ) );	FailOSErr( SndNewChannel( &macChannel, sampledSynth, initStereo, callback ));	status = channel_Idle;	trigTime = TickCount();	curSound = NULL;}ZChannel::~ZChannel(){	if ( macChannel )	{		(void) SndDisposeChannel( macChannel, TRUE );		DisposeSndCallBackUPP( callback );	}}	void		ZChannel::Play( ZSound* aSound ){	ASSERT("macChannel == NULL",macChannel != NULL,0);	SndListHandle	sh;	SndCommand		command;		if ( aSound )	{		// acquire the sound:				curSound = aSound;		curSound->Acquire();				// we're busy now:				status = channel_Busy;				// record when we started:				trigTime = TickCount();				// play the sound:				FailNIL( sh = curSound->GetMacSound() ); 		FailOSErr( SndPlay( macChannel, sh, TRUE ));				// queue up callback		command.cmd = callBackCmd;		command.param1 = kZChannelCallbackID;						command.param2 = (long) this;				FailOSErr( SndDoCommand( macChannel, &command, FALSE ));	}}void		ZChannel::ShutUp(){	ASSERT("macChannel == NULL",macChannel != NULL,0);	if ( curSound && ( status == channel_Busy ))	{		SndCommand	cmd;		// Dump the rest of the commands in the queue (including our callbackCmd).				cmd.cmd = flushCmd;		cmd.param1 = 0;		cmd.param2 = (long) this;		FailOSErr( SndDoImmediate( macChannel, &cmd ));				// Shut up this minute!				cmd.cmd = quietCmd;		cmd.param1 = 0;		cmd.param2 = (long) this;		FailOSErr( SndDoImmediate( macChannel, &cmd ));	}			// reset the channel:		Reset();}void		ZChannel::PitchBend( UnsignedFixed amount ){	ASSERT("macChannel == NULL",macChannel != NULL,0);	SndCommand	cmd;		if ( status == channel_Busy )	{		amount = UnsignedFixedMulDiv( amount, 0x10000, rate22khz );				cmd.param1 = 0;		cmd.param2 = (long) amount;		cmd.cmd = rateCmd;				FailOSErr( SndDoImmediate( macChannel, &cmd ));	}}void		ZChannel::Reset(){	ASSERT("macChannel == NULL",macChannel != NULL,0);	if ( curSound )	{		curSound->Release();				// automatically discard temporary sound objects if they are temp and		// the sound has been released:				if ( curSound->IsTempSound())			ForgetObject( curSound );	}			curSound = NULL;	status = channel_Idle;}pascal void	ZChannel::CallbackProc( SndChannelPtr chan, SndCommand *cmd ){	ZChannel*	ch;		ch = (ZChannel*)cmd->param2;		if ( ch && ( cmd->param1 == kZChannelCallbackID ))		ch->status = channel_Complete;}#pragma mark -ZSoundPlayer::ZSoundPlayer( const short mapResID, const short numChannels ){	FailNIL( sounds = new ZObjectList());	FailNIL( channels = new ZObjectList());	map = mapResID;		Init( numChannels );}ZSoundPlayer::~ZSoundPlayer(){	if ( channels )	{		MuteAll( TRUE );		ForgetObject( channels );	}		if ( sounds )	{		sounds->DisposeAll();		ForgetObject( sounds );	}}short	ZSoundPlayer::PlaySound( const short resID, const short onChannel ){	// find the channel, or a free channel, and play the sound, Returns the channel	// number on which the sound is playing		ZChannel*	chan;	ZSound*		sound;	short		chanIndex = 0;		// locate the sound:			sound = FindSound( resID );		if ( sound )	{		chan = ObtainChannel( onChannel, &chanIndex );			// and play it!			chan->Play( sound ); 	}	return chanIndex;}short	ZSoundPlayer::PlaySound( Handle aSound, const short onChannel, Boolean autoDispose ){	// play an existing sound handle. This makes a temporary ZSound object to manage	// the sound. The sound will be automatically released or disposed when all channels	// have finished playing it.		ZChannel*	chan;	ZSound*		sound;	short		chanIndex;		FailNILParam( aSound );		chan = ObtainChannel( onChannel, &chanIndex );	FailNIL( sound = new ZSound( aSound, TRUE, autoDispose ));		chan->Play( sound );		return chanIndex;}void	ZSoundPlayer::Idle(){	// look for completed channels and reset them ready for another go. This must be called	// regularly... (insert a call to this from your main event loop)		ZChannel*	chan;	short		m, i;		m = channels->CountItems();		for( i = 1; i <= m; i++ )	{		chan = GetChannel( i );				if ( chan->GetStatus() == channel_Complete )			chan->Reset();	}}void	ZSoundPlayer::Mute( const short whichChannel ){	// mute the given channel		ZChannel*	chan;		chan = GetChannel( whichChannel );		chan->ShutUp();}void	ZSoundPlayer::MuteAll( Boolean andDispose ){	// mute all of the channels, and optionally dispose them. WARNING! Make sure you	// don't try to use the channels after passing TRUE to this.		short	i, m;		m = channels->CountItems();		for ( i = 1; i <= m; i++ )	{		Mute( i );				if ( andDispose )		{			ZChannel*	chan;						chan = GetChannel( i );						ForgetObject( chan );		}	}		if ( andDispose )		channels->DeleteAll();}void	ZSoundPlayer::MakeSoundObject( const short resID ){	ZSound*	 so;		try	{		FailNIL( so = new ZSound( resID ) );		AddSoundObject( so );	}	catch( ZoopError err )	{		// don't propagate		}}void	ZSoundPlayer::AddSoundObject( ZSound* aSound ){	sounds->AppendItem( aSound );}void	ZSoundPlayer::PitchBend( const short channel, UnsignedFixed amount ){	ZChannel*	chan;		chan = GetChannel( channel );		chan->PitchBend( amount );}void	ZSoundPlayer::Init( short numChannels ){	// first allocate a number of channels		ZChannel*	aChannel;	while( numChannels-- )	{		FailNIL( aChannel = new ZChannel());		channels->AppendItem( aChannel );	}	// now preload the sounds:		if ( map == 0 )	{		// preload all of the 'snd ' resources				short	resID, i, sc = Count1Resources( soundListRsrc );		ResType	resType;		Handle	temp;		Str255	resName;		 		for( i = 1; i <= sc; i++ )		{			temp = Get1IndResource( soundListRsrc, i );					if ( temp )			{				GetResInfo( temp, &resID, &resType, resName );				MakeSoundObject( resID );			}		}	}	else	{		// use 'SND#' resource. This is a simple list of resource ID's				short**	smap;		short	i, n, sID;				smap = (short**) GetResource( 'SND#', map );				if ( smap )		{			n = GetHandleSize((Handle) smap ) / sizeof( short );						for( i = 0; i < n; i++ )			{				sID = (*smap)[i];						MakeSoundObject( sID );			}						ReleaseResource((Handle) smap );		}	}}ZChannel*	ZSoundPlayer::GetChannel( const short which ){	return (ZChannel*) channels->GetObject( which );}ZChannel*	ZSoundPlayer::GetFreeChannel( short* index ){	// return the first free channel		short		m, i;	ZChannel*	chan;		m = channels->CountItems();		for( i = 1; i <= m; i++ )	{		chan = GetChannel( i );				if ( chan->GetStatus() != channel_Busy )		{			if ( index )				*index = i;			return chan;		}	}		return NULL;}ZChannel*	ZSoundPlayer::GetOldestChannel( short* index ){	// return the oldest channel, busy or not...		short		m, i, oc;	long		t, ct, tDelt;	ZChannel*	chan;		t = TickCount();	m = channels->CountItems();	tDelt = 0;	oc = 1;		for( i = 1; i <= m; i++ )	{		chan = GetChannel( i );			ct = chan->GetTrigTime();				if (( t - ct ) > tDelt )		{			tDelt = t - ct;			oc = i;		}	}		if ( index )		*index = oc;			return GetChannel( oc );}ZSound*		ZSoundPlayer::FindSound( const short resID ){	short	m, i;	ZSound*	so;		m = sounds->CountItems();		for( i = 1; i <= m; i++ )	{		so = (ZSound*) sounds->GetObject( i );				if ( so->GetResID() == resID )			return so;	}	return NULL;}ZChannel*	ZSoundPlayer::ObtainChannel( short id, short* index ){	// find a channel to play the sound on:		ZChannel*	chan = NULL;		if ( id == 0 )	{		chan = GetFreeChannel( index );			if ( chan == NULL )			chan = GetOldestChannel( index );	}	else	{		chan = GetChannel( id );		*index = id;	}		// we must always play the sound- so if the channel's in use,	// shut it up first:	if ( chan->GetStatus() != channel_Idle )		chan->ShutUp();	return chan;}