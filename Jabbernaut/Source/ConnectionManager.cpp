///--------------------------------------------------------------------------------------//	File:		ConnectionManager.cpp//	Project:	Jabbernaut////	Purpose:	<default>//	Created:	Sundday, 2000-04-16//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"ZProgress.h"#include	<iostream>#ifndef TOQ  #include	"AgentsManager.h"#endif#include	"ConnectionManager.h"#include	"ErrorManager.h"#include	"JabberApplication.h"#include	"JabberClient.h"#include	"JabberUtils.h"#include	"PresenceManager.h"#include	"RosterManager.h"#include	"PrefsManager.h"#include	"Profile.h"#include	"Messages.h"#include	"ExpatStream.h"#include	"SSLConnection.h"#include	"UniqueID.h"///- Macros -----------------------------------------------------------------------------#pragma mark -#pragma mark === Macros ===//// This macro is used to simplify the code in DoOpenConnection.// It watches a given condition, and repeatedly gives time to other threads.// It also makes sure the progress bar keeps moving. It will throw an error// if the connection the connection is closed.//#define		YieldTillConditionOrTimeout(cond, p, timeoutDuration)					\					while( !(cond) )												\					{																\						long	timeoutStart = TickCount();							\						if( (timeoutStart + (timeoutDuration)*60) < TickCount() )	\							throw (ZoopError)kTimeOutErr;							\						YieldToAnyThread();											\						p.InformProgress( 1 );										\						if( IsDisconnected() )										\							throw (ZoopError)kConnectionDied;						\					}#pragma mark -#pragma mark [Class Init]///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------ConnectionThread::ConnectionThread()	: ZThread(){	mClient = NULL;	mState = kConnectionClosed;	mError = noErr;	mUnexpectedDisconnect = false;		try	{		FailNIL( mLink = new SSLConnection() );		FailNIL( mClient = new JabberClient( mLink, new ExpatStream() ) );	}	catch( ZoopError err )	{		if( mClient )			ForgetObject( mClient );				throw err;	}}///--------------------------------------------------------------------------------------//	¥ Destructor:///--------------------------------------------------------------------------------------ConnectionThread::~ConnectionThread(){	ASSERT("mClient == NULL",mClient != NULL,0);	// First, let's make sure the connections is closed properly	if( mClient->getConnectionState() != kConnectionStateDisconnected )		mClient->disconnect();		// Now we can safely dispose of the connection objects	if( mClient )		ForgetObject( mClient );}#pragma mark -///--------------------------------------------------------------------------------------//	OpenConnection://		Issue the command to open a connection//		//	Changes://		2000-07-13	MH		Created///--------------------------------------------------------------------------------------void	ConnectionThread::OpenConnection(){		ASSERT("OpenConnection: connection must be in closed state!",mState == kConnectionClosed,0);		mState = kConnectionDoOpen;#ifndef TOQ	mLink->setSSLMode( PrefsManager::GetPrefsRec().mUseSSL );#endif}///--------------------------------------------------------------------------------------//	CloseConnection://		Issue the command to close a connection//		//	Changes://		2000-07-13	MH		Created///--------------------------------------------------------------------------------------void	ConnectionThread::CloseConnection(){	//	ASSERT("CloseConnection: connection must be in opened state!",mState == kConnectionOpen,0);	if( (mState != kConnectionClosing) && (mState != kConnectionClosed) )		mState = kConnectionDoClose;}///--------------------------------------------------------------------------------------//	PostMessage://		posts a BaseMsg to the message queue.//		//	Changes://		2000-07-13	MH		Created///--------------------------------------------------------------------------------------void	ConnectionThread::PostMessage( MacJLib::BaseMsg *aMsg ){		ASSERT("aMsg == NULL",aMsg != NULL,0);	ASSERT("mClient == NULL",mClient != NULL,0);	mClient->queueMessage( aMsg );}#pragma mark -///--------------------------------------------------------------------------------------//	Do://		Act, depending on the next issued command//		//	Changes://		2000-07-13	MH		Created///--------------------------------------------------------------------------------------void	ConnectionThread::Do(){	ASSERT("mClient == NULL",mClient != NULL,0);	MacJLibError	err;		switch( mState )	{	case kConnectionDoOpen:		mState = kConnectionOpenening;		err = mClient->connect(Profile::GetServer(), Profile::GetPort() );		if( err != noError )		{			mState = kConnectionClosed;			// FIX ME			// ErrorManager::Error("Failed to open connection to server")			FailOSErr( err );		}		break;	case kConnectionDoClose:		mState = kConnectionClosing;		err = mClient->disconnect();		if( (err != noError) && (err != -3155) )			// FIX ME error -3155 happens if the connection expired (e.g. on a dial up system)			// but only for a OTClientConnection... <dough> :-/			FailOSErr( err );		break;	case kConnectionOpenening:		if( mClient->getConnectionState() == kConnectionStateConnected )			mState = kConnectionOpen;		break;	case kConnectionClosing:		if( mClient->getConnectionState() == kConnectionStateDisconnected )			mState = kConnectionClosed;		break;	}		err = mClient->processOut();	if( err != noError )		HandleUnexpectedDisconnect( err );	err = mClient->processIn();	if( err != noError )		HandleUnexpectedDisconnect( err );	if( mClient->getConnectionState() == kConnectionStateDisconnected )	{		if( mState == kConnectionOpen )			HandleUnexpectedDisconnect(-1);		mState = kConnectionClosed;	}}///--------------------------------------------------------------------------------------//	ThreadEntry://		Overrid ThreadEntry to catch ZoopErrors//		//	Changes://		2000-07-13	MH		Created///--------------------------------------------------------------------------------------void	ConnectionThread::ThreadEntry(){	while( !IsDone() )	{		try		{			Do();		}		catch( ZoopError err )		{			// somehow tell the app about the thrown error			mError = err;		} 	 		// sleep for itsPeriod ticks  		SleepTicks( itsPeriod ); 	} 	 	itsID = kNoThreadID;}///--------------------------------------------------------------------------------------//	HandleUnexpectedDisconnect://		This is called in case of an unexpected disconnect.//		//	Changes://		2000-11-03	MH		Created///--------------------------------------------------------------------------------------void	ConnectionThread::HandleUnexpectedDisconnect(ZoopError err){extern void kill_resolver (void);extern void start_resolver (void);	mClient->disconnect();//	kill_resolver();		mState = kConnectionClosed;//	we should add a flag that tells the main thread it should take appropriate actions	mUnexpectedDisconnect = true;// FIX ME//	ErrorManager::ReportFailure( kErrorStrID, kUnexpectedDisconnectIndex, err );}///- Static Members ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Globals ===bool				ConnectionManager::msLoggedIn = false;ConnectionThread	*ConnectionManager::msConnectionThread = NULL;#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Give this manager a chance to initate static members etc.//		//	Changes://		2000-04-16	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::Init(){	ASSERT("msConnectionThread != NULL",msConnectionThread == NULL,0);		FailNIL( msConnectionThread = new ConnectionThread() );	msConnectionThread->Start();}///--------------------------------------------------------------------------------------//	Deinit://		Give this manager a chance to dispose static members etc.//		//	Changes://		2000-04-16	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::Deinit(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		if( msConnectionThread->mState == ConnectionThread::kConnectionOpen )	{		long	timer = TickCount();		msConnectionThread->CloseConnection();#if 1		while( (msConnectionThread->mState != ConnectionThread::kConnectionClosed)				&& ((timer+10*60) > TickCount()) )		{			YieldToAnyThread();		}#endif	}	msConnectionThread->Stop();	ForgetObject( msConnectionThread );}#pragma mark -///--------------------------------------------------------------------------------------//	PostMessage://		posts a BaseMsg to the message queue.//		//	Changes://		2000-04-16	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::PostMessage( BaseMsg *aMsg ){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		msConnectionThread->PostMessage( aMsg );}#pragma mark -/*///--------------------------------------------------------------------------------------//	IsConnected://		Check whether we are already connected/currently connecting//		//	Changes://		2000-04-16	MH		Created///--------------------------------------------------------------------------------------bool	ConnectionManager::IsConnected(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		ConnectionState	cs = msClient->getConnState();	return (cs == kConnectionStateConnected)			|| (cs == kConnectionStateConnecting);}///--------------------------------------------------------------------------------------//	GetConnectionState://		Return the connection state of the underlying client//		//	Changes://		2000-05-09	MH		Created///--------------------------------------------------------------------------------------ConnectionState	ConnectionManager::GetConnectionState(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		return msClient->getConnectionState();}*////--------------------------------------------------------------------------------------//	IsConnected://		Return whether the connection is open//		//	Changes://		2000-05-09	MH		Created///--------------------------------------------------------------------------------------bool	ConnectionManager::IsConnected(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		return msConnectionThread->mState == ConnectionThread::kConnectionOpen;}///--------------------------------------------------------------------------------------//	IsDisconnected://		Return whether the connection is closed//		//	Changes://		2000-05-09	MH		Created///--------------------------------------------------------------------------------------bool	ConnectionManager::IsDisconnected(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		return msConnectionThread->mState == ConnectionThread::kConnectionClosed;}///--------------------------------------------------------------------------------------//	GetClient://		Return the Client object//		//	Changes://		2000-09-25	MH		Created///--------------------------------------------------------------------------------------Client	*ConnectionManager::GetClient(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		return msConnectionThread->mClient;}///--------------------------------------------------------------------------------------//	DoOpenConnection://		Starts connection, and returns only when it is either fully opened or it failed//		//	Changes://		2000-09-14	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::DoOpenConnection( bool reLogin, long connectTimeoutSecs, long transferTimeoutSecs ){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);#ifdef TOQ	//	// In TOQ, we want to ask for the password upon each login. So we do it here	//	Str255	username = "\pblue_fingolfin";	Str255	password = "\pgeheim";	char	cStr[256];	StopCursorAnimation();	CopyCToPString( Profile::GetUsername().c_str(), username );	CopyCToPString( Profile::GetPassword().c_str(), password );retryPassword:	{		ZDialog	d( gApplication, 3000 );		d.InitZWindow();				d.SetValue( 5, username );	// set the old value of the username as default		if( username[0] )			// if there was an username, focus the password field			d.SelectItem( 7 );				if( d.RunModal() )		{			d.GetValueAsText( 5, username );			d.GetValueAsText( 7, password );		}		else		{			// Cancel -> do nothing			return;		}	}	if( (username[0] == 0) || (password[0] == 0) )	{		// ERROR		SysBeep(1);		goto retryPassword;	}	CopyPToCString( username, cStr );	Profile::SetUsername( cStr );	CopyPToCString( password, cStr );	Profile::SetPassword( cStr );#endif		//	// Open a progress dialog to show the user we are doing something	//		ZProgress	aPD( gApplication, kStdProgressResID, 1, kCancelType, kIndeterminateProgress );		// Give it two seconds - if it's not finished then, show a progress dialog	aPD.SetDelay( kTwoSeconds );		// Tell the thread to begin opening the connection	msConnectionThread->OpenConnection();		//	// Open the socket, and open the XML stream. Retry 5 times	// FIX ME - add a pref to determine how often to retry!	//		short	retriesLeft = 5;		while( retriesLeft > 0 )	{		try		{			// a) connect to the server			if( reLogin )				aPD.SetMessage( 702, 2 );			else				aPD.SetMessage( 702, 1 );			YieldTillConditionOrTimeout( ConnectionManager::IsConnected(), aPD, connectTimeoutSecs );						// b) open the XML stream			aPD.SetMessage( 702, 3 );			YieldTillConditionOrTimeout( ConnectionManager::IsLoggedIn(), aPD, connectTimeoutSecs );#ifndef TOQ			// c) transfer the agent list			aPD.SetMessage( 702, 4 );			YieldTillConditionOrTimeout( AgentsManager::IsAgentsListTransfered(), aPD, transferTimeoutSecs );#endif						// d) transfer the roster			aPD.SetMessage( 702, 5 );			YieldTillConditionOrTimeout( RosterManager::IsRosterTransfered(), aPD, transferTimeoutSecs );		}		catch( ZoopError err )		{			// Make sure the connection is closed			msConnectionThread->CloseConnection();						// Check if the user canceld. If yes, return immediatly.			if( err == userCanceledErr )				return;						// Decrement the retries left			retriesLeft--;						// if we have a try left, start login over again.			if( retriesLeft > 0 )				continue;							// So we have no tries left. Report our error.				if( err == kTimeOutErr )				ErrorManager::ReportFailure( kErrorStrID, kLoginFailedTimeoutIndex, err );			else if( err == kConnectionDied )			{				// FIX ME				// what if ConnectionManager::OnLoginFailed() already reported an error on this?				// grmbl...				// maybe those should throw as well? hm				ErrorManager::ReportFailure( kErrorStrID, kLoginFailedIndex, err );			}			else				throw err;		}		break;	}}///--------------------------------------------------------------------------------------//	DoCloseConnection://		Starts closing the connection, and return when it closed//		//	Changes://		2000-09-14	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::DoCloseConnection(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		msConnectionThread->CloseConnection();	while( msConnectionThread->mState != ConnectionThread::kConnectionClosed )	{		// FIX ME - we should add a timeout here! (and maybe a ZProgress dialog)		YieldToAnyThread();	}}///--------------------------------------------------------------------------------------//	OpenConnectionAsync://		Tell the connection thread to start a connection (asynchronous)//		//	Changes://		2000-04-16	MH		Created//		2000-09-14	MH		Renamed to OpenConnectionAsync() for clarity///--------------------------------------------------------------------------------------void	ConnectionManager::OpenConnectionAsync(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		msConnectionThread->OpenConnection();}///--------------------------------------------------------------------------------------//	CloseConnectionAsync://		Tell the connection thread to end the connection (asynchronous)//		//	Changes://		2000-04-16	MH		Created//		2000-09-14	MH		Renamed to CloseConnectionAsync() for clarity///--------------------------------------------------------------------------------------void	ConnectionManager::CloseConnectionAsync(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		msConnectionThread->CloseConnection();}///--------------------------------------------------------------------------------------//	Idle://		check if the connection thread threw an error, and if yes, throw it again...//		//	Changes://		2000-04-16	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::Idle(){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		OSErr	err = msConnectionThread->mError;	if( err != noErr )	{		msConnectionThread->mError = noErr;		FailOSErr( err );	}	if( msConnectionThread->mUnexpectedDisconnect )	{		msConnectionThread->mUnexpectedDisconnect = false;		if( PrefsManager::GetPrefsRec().mAutoRelogin )		{			ConnectionManager::DoOpenConnection( true );		}	}}#pragma mark -///--------------------------------------------------------------------------------------//	OnLogin://		put your description here//		//	Changes://		2000-05-01	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::OnLogin(){	msLoggedIn = true;#ifndef TOQ	//	//	Get Agents	//	AgentsManager::OnLogin();#endif		//	//	Get Roster	//	RosterManager::OnLogin();			//	//	Send presence	//	PresenceManager::BroadcastPresence( kOnlinePresenceStatus, "Online" );			//	//	Check if a newer version of us is available (except if the user turned it off)	//#ifndef TOQ	if( PrefsManager::GetPrefsRec().mCheckVersion )	{		MacJLib::JID	updateJID("960367145@update.jabber.org");		updateJID.setResource(JabberUtils::GetVersionString());		PresenceManager::SendPresence( updateJID );	}#endif		//	//	Tell prefsmanager (so it can prevent editing the account info)	//	PrefsManager::OnLogin();			//	//	Update menu item	//	gMenuBar->SetCommandText( kCmdLoginLogout, 4220, 2 );}///--------------------------------------------------------------------------------------//	OnLogout://		put your description here//		//	Changes://		2000-05-01	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::OnLogout(){	if( msLoggedIn )	{		msLoggedIn = false;		// attention: call RosterManager::OnLogout() only from here, to prevent		//  reentry problems.		RosterManager::OnLogout();#ifndef TOQ		AgentsManager::OnLogout();#endif				//		//	Tell prefsmanager (so it can enable editing the account info)		//		PrefsManager::OnLogout();		gMenuBar->SetCommandText( kCmdLoginLogout, 4220, 1 );	}}///--------------------------------------------------------------------------------------//	OnRegister://		put your description here//		//	Changes://		2000-05-01	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::OnRegister(){	// register worked -> we should inform the user about this!	// note that JabberClient will try login immediatly hereafter!//	msClient->Login();	Profile::SetNeedsRegister( false );	ErrorManager::ReportSuccess( kSuccessStrID, kRegisterAccountSucceded );}///--------------------------------------------------------------------------------------//	OnRegisterFailed://		put your description here//		//	Changes://		2000-05-01	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::OnRegisterFailed( MacJLib::IQErrorMsg &inError ){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		msConnectionThread->CloseConnection();		// error 409 - name already taken	if( inError.getErrorType() == 409 )		ErrorManager::ReportFailure( kErrorStrID, kRegisterAccountFailedNameTakenIndex, inError.getErrorType() );	else		ErrorManager::ReportFailure( kErrorStrID, kRegisterAccountFailedIndex, inError.getErrorType() );	Profile::SetNeedsRegister( false );		// we should "revert" here somehow.	}///--------------------------------------------------------------------------------------//	OnLoginFailed://		put your description here//		//	Changes://		2000-05-01	MH		Created///--------------------------------------------------------------------------------------void	ConnectionManager::OnLoginFailed( MacJLib::IQErrorMsg &inError ){	ASSERT("msConnectionThread == NULL",msConnectionThread != NULL,0);		msConnectionThread->CloseConnection();		if( inError.getErrorType() == 401 )		ErrorManager::ReportFailure( kErrorStrID, kLoginFailedUsernameIndex, inError.getErrorType() );	else		ErrorManager::ReportFailure( kErrorStrID, kLoginFailedIndex, inError.getErrorType() );}