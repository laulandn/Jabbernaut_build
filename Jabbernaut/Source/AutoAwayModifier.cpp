///--------------------------------------------------------------------------------------//	File:		AutoAwayModifier.cpp//	Project:	Jabbernaut////	Purpose:	Detect auto away by plugin into the event chain//	Created:	Sunday, 2000-06-25//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"ZApplication.h"#include	"AutoAwayModifier.h"#include	"ConnectionManager.h"#include	"PrefsManager.h"#include	"PresenceManager.h"///- Globals ----------------------------------------------------------------------------#pragma mark -#pragma mark === Globals ===///- Static Globals ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Globals ===///- Prototypes -------------------------------------------------------------------------#pragma mark -#pragma mark === Prototypes ===#pragma mark -#pragma mark [Class Init]///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------AutoAwayModifier::AutoAwayModifier()	 : ZModifier(){	mLastTime = 0L;	mOldMousePos.h = 0;	mOldMousePos.v = 0;		mDidAutoAway = false;	mDidExtendedAutoAway = false;}///--------------------------------------------------------------------------------------//	¥ Destructor:///--------------------------------------------------------------------------------------AutoAwayModifier::~AutoAwayModifier(){}#pragma mark -///--------------------------------------------------------------------------------------//	Execute://		detect auto away by listening for kModifierEventDispatch//		//	Changes://		2000-06-25	MH		Created///--------------------------------------------------------------------------------------void	AutoAwayModifier::Execute( ZCommander* caller, const long modMessage, UntypedPtr modData ){	if( (modMessage == kModifierEventDispatch)		&& (modData != NULL)		&& ConnectionManager::IsLoggedIn() )	{		EventRecord	*theEvent = (EventRecord *)modData;				switch ( theEvent->what )		{			case nullEvent:				if( (PresenceManager::GetPresenceStatus() != kNAPresenceStatus)					&& (theEvent->where.h == mOldMousePos.h) && (theEvent->where.h == mOldMousePos.h) )				{					KeyMap	theKeys;										GetKeys( theKeys );					if ( !theKeys[0] && !theKeys[1] && !theKeys[2]							&& !theKeys[3] && !Button())				//check for key down or button					{						long	diffTime = theEvent->when - mLastTime;					//if( not already extended autoAway )						if( PrefsManager::GetPrefsRec().mExtendedAutoAway							&& (diffTime >= 3600*PrefsManager::GetPrefsRec().mExtendedAutoAwayDelay) )						{							mDidExtendedAutoAway = true;							//if( not already autoAway )							//   backup old state							if( !mDidAutoAway )							{								mOldPresenceStatus = PresenceManager::GetPresenceStatus();								mOldGetStatusString = PresenceManager::GetStatusString();							}							PresenceManager::BroadcastPresence( kNAPresenceStatus, "Extended Auto Away" );						}					//if( not already autoAway or extended autoAway )						else if( PrefsManager::GetPrefsRec().mAutoAway								&& (diffTime >= 3600*PrefsManager::GetPrefsRec().mAutoAwayDelay) )						{							if( PresenceManager::GetPresenceStatus() != kAwayPresenceStatus )							{								mDidExtendedAutoAway = false;								mDidAutoAway = true;								mOldPresenceStatus = PresenceManager::GetPresenceStatus();								mOldGetStatusString = PresenceManager::GetStatusString();								PresenceManager::BroadcastPresence( kAwayPresenceStatus, "Auto Away" );							}						}						break;					}				}			default:				//if( autoAway or extended autoAway )				//	restore old state				if( PrefsManager::GetPrefsRec().mAutoEndAuoAway && (mDidAutoAway || mDidExtendedAutoAway) )				{					mDidAutoAway = mDidExtendedAutoAway = false;					PresenceManager::BroadcastPresence( mOldPresenceStatus, mOldGetStatusString );				}				mLastTime = theEvent->when;				mOldMousePos = theEvent->where;				break;		}	}}