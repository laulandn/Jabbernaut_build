///--------------------------------------------------------------------------------------//	File:		ChatDialogItem.cpp//	Project:	Jabbernaut////	Purpose:	<default>//	Created:	Monday, 2000-05-15//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"ChatDialogItem.h"#include	"MacZoop.h"#include	"ZDialog.h"#include	"ZGrafState.h"#include	"JID.h"#include	"MacJLibUtils.h"#pragma mark -#pragma mark [Class Init]enum{	kMaxTextSize	= 32767};CLASSCONSTRUCTOR( ChatDialogItem );///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------ChatDialogItem::ChatDialogItem( ZDialog* aDialog, const short item )	: inherited( aDialog, item ){	classID = CLASS_ChatDialogItem;		// make sure we are not editable but selectable!	isEditable = FALSE;	isSelectable = TRUE;		mEditLineItem = NULL;}///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------ChatDialogItem::ChatDialogItem()	: inherited(){	classID = CLASS_ChatDialogItem;		// make sure we are not editable but selectable!	isEditable = FALSE;	isSelectable = TRUE;		mEditLineItem = NULL;}#pragma mark -///--------------------------------------------------------------------------------------//	InitItem://		This is a trick to set a defaul font//		//	Changes://		2000-05-15	MH		Created///--------------------------------------------------------------------------------------void	ChatDialogItem::InitItem( const short paramCount, const long params[] ){	inherited::InitItem( paramCount, params );#if MACZOOP_VERSION < 0x0250    if ( theVBar )    	HiliteControl( theVBar, 0 );    if ( theHBar )    	HiliteControl( theHBar, 0 );#endif	if ( isSelectable && GetTextEditHandle() )		TEActivate( GetTextEditHandle() );}///--------------------------------------------------------------------------------------//	Type://		//		//	Changes://		2000-05-27	MH		Created///--------------------------------------------------------------------------------------void	ChatDialogItem::Type( const char theKey, const short modifiers ){	if ( theKey == TAB_KEY 		||		 theKey == RETURN_KEY 	||		 theKey == ENTER_KEY 	||		 theKey == ESCAPE_KEY	||		 ( modifiers & cmdKey ) == cmdKey )		ZCommander::Type( theKey, modifiers );	else	{		// if we have an associated edit field, hand over the input to it.		if( mEditLineItem )		{			((ZDialog*)itsBoss)->SelectItem( mEditLineItem->GetID() );			mEditLineItem->Type( theKey, modifiers );		}	}}///--------------------------------------------------------------------------------------//	SetBounds://		//		//	Changes://		2000-07-27	MH		Created///--------------------------------------------------------------------------------------void	ChatDialogItem::SetBounds( Rect* newBounds ){	ASSERT("GetTextEditHandle() == NULL",GetTextEditHandle(),0);	short		selStart, selEnd;	selStart = (**GetTextEditHandle()).selStart;	selEnd = (**GetTextEditHandle()).selEnd;	inherited::SetBounds(newBounds);		TESetSelect( 32767, 32767, GetTextEditHandle() );	RecalText(TRUE);	if( selStart != selEnd )		TESetSelect( selStart, selEnd, GetTextEditHandle() );}///--------------------------------------------------------------------------------------//	Deactivate://		//		//	Changes://		2000-09-15	MH		Created///--------------------------------------------------------------------------------------void	ChatDialogItem::Deactivate(){	ZDialogItem::Deactivate();	if ( isSelectable )	{		ZGrafState	gs;		PrepareForDrawing();		TEDeactivate( GetTextEditHandle() );	}	if ( gFontMenuID )		gMenuBar->DisableCommand( gFontMenuID, 0 );}#pragma mark -///--------------------------------------------------------------------------------------//	AppendChatData://		Appends the specified data, using different styles for message/name//		//	Changes://		2000-05-15	MH		Created///--------------------------------------------------------------------------------------void	ChatDialogItem::AppendChatData( const MacJLib::JID &inJID, const std::string &message, const RGBColor &aColor, bool useTimestamp, std::time_t utcSecs ){	ASSERT("GetTextEditHandle() == NULL",GetTextEditHandle(),0);	long			overrun;	TextStyle		newStyle;	std::string		nick;	std::string		text;	bool			ME_Msg;	short			selStart, selEnd;		ZGrafState		mainZG;	FocusBoss();	{		ZGrafState	innerZG;		PrepareForDrawing();		//		// Build the nick str from the supplied JID		//		ME_Msg = (0 == message.compare(0,3,"/me") );		if( ME_Msg )		{			nick = "* " + inJID.getResource();			text = message.substr(3);		}		else		{			if( inJID.hasResource() )				nick = inJID.getResource();			else				nick = inJID.getFull();			if( nick.empty() )				nick = "### ";			else				nick = "<" + nick + ">: ";			text = message;		}				//		// Prepend the timestamp if flag is set		//		if( useTimestamp )		{			Str255			pStr;			char			cStr[256];						if( utcSecs == 0 )				utcSecs = MacJLib::GetTimeSeconds();			else				utcSecs += MacJLib::TimeZoneOffsetInSeconds();			TimeString( utcSecs, false, pStr, NULL );						ConcatPStrings( pStr, "\p " );			CopyPToCString( pStr, cStr );			nick = cStr + nick;		}				//		// Store the current selection		//		selStart = (**GetTextEditHandle()).selStart;		selEnd = (**GetTextEditHandle()).selEnd;						//		// Check if we're about to exceed TextEdit's 32k limit. If yes, then		//    delete some stuff before appending.		overrun = ((**GetTextEditHandle()).teLength + nick.size() + text.size() + 1) - kMaxTextSize;		if( overrun > 0 )		{			RgnHandle	    clip;			Rect			emptyRect = {0,0,0,0};			FailNIL( clip = NewRgn());			GetClip( clip );			ClipRect( &emptyRect );			if( overrun > kMaxTextSize)				overrun = kMaxTextSize;			TESetSelect( 0, overrun, GetTextEditHandle() );			TEDelete( GetTextEditHandle() );			SetClip( clip );		    DisposeRgn( clip );		    		    // we have to correct the selection after an overrun			if( selStart < overrun )				selStart = 0;			else				selStart -= overrun;			if( selEnd < overrun )				selEnd = 0;			else				selEnd -= overrun;		}				//		// Make sure we add to the end of the text		//		TESetSelect( 32767, 32767, GetTextEditHandle() );						//		// Activate the custom color if supplied		//		newStyle.tsColor = aColor;		TESetStyle( doColor, &newStyle, true, GetTextEditHandle() );		//		// Go to the next line (unless this is the very first entry)		//		if( (**GetTextEditHandle()).teLength > 0 )		{			const char * myStr = "\r";			TEInsert( myStr, sizeof(char), GetTextEditHandle() );		}		//		// Insert the nick (in bold face)		//		newStyle.tsFace = bold;		TESetStyle( doFace, &newStyle, true, GetTextEditHandle() );		TEInsert( nick.data(), nick.size(), GetTextEditHandle() );				//		// Insert the message (plain style)		//		newStyle.tsFace = normal;		TESetStyle( doFace, &newStyle, true, GetTextEditHandle() );		TEInsert( text.data(), text.size(), GetTextEditHandle() );		//		// Scroll the chat as appropriate:		//	- if we were at the end, scroll to the end again		//	- otherwise, show the scroll offset as before.		#if MACZOOP_VERSION < 0x0250		if( theVBar && (			GetControlValue( theVBar ) >= GetControlMaximum( theVBar ) ) )		{			TESetSelect( 32767, 32767, GetTextEditHandle() );			RecalText(TRUE);		}		else#endif		{			RecalText(FALSE);		}				//		// Restore the selection		//		if( selStart != selEnd )			TESetSelect( selStart, selEnd, GetTextEditHandle() );		else			TEDeactivate( GetTextEditHandle() );	// HACK to erase the caret			}}///--------------------------------------------------------------------------------------//	ClearChatData://		Empty the chat item//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	ChatDialogItem::ClearChatData(){	ASSERT("GetTextEditHandle() == NULL",GetTextEditHandle(),0);	ZGrafState		gs;	PrepareForDrawing();	TESetSelect( 0, 32767, GetTextEditHandle() );	TEDelete( GetTextEditHandle() );	TESetSelect( 0, isEditable? 32767 : 0, GetTextEditHandle() );			RecalText(TRUE);}