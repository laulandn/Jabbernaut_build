///--------------------------------------------------------------------------------------//	File:		GroupChatManager.cpp//	Project:	Jabbernaut////	Purpose:	<default>//	Created:	Thursday, 2000-05-18///	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"GroupChatDialog.h"#include	"GroupChatJoinDialog.h"#include	"GroupChatManager.h"#include	"PrefsManager.h"#include	"PresenceManager.h"#include	"SoundManager.h"#include	"Messages.h"///- Static Members ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Members ===GroupChatDialogList		*GroupChatManager::msGroupChatDialogs = NULL;#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Give this manager a chance to initate static members etc.//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	GroupChatManager::Init(){	ASSERT("msGroupChatDialogs != NULL",msGroupChatDialogs == NULL,0);	FailNIL( msGroupChatDialogs = new GroupChatDialogList() );}///--------------------------------------------------------------------------------------//	Deinit://		Give this manager a chance to dispose static members etc.//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	GroupChatManager::Deinit(){	if( msGroupChatDialogs )		ForgetObject( msGroupChatDialogs );}#pragma mark -///--------------------------------------------------------------------------------------//	DoJoinGroupChat://		Open a "Join Groupchat" dialog//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	GroupChatManager::DoJoinGroupChat(){	GroupChatJoinDialog	*aDialog;		FailNIL( aDialog = new GroupChatJoinDialog());		try	{		aDialog->InitZWindow();		aDialog->Place();		aDialog->Select();	}	catch( ZoopError err )	{		ForgetObject( aDialog );				throw err;	}}#pragma mark -#if !_DEBUG_/*First, try the old protocol. If error 405 is returned, switch to the new one. Remember which one is used using a new member var mNewProtocol.We also need GroupchatMsg class for it.<message type='error' from='jabber-devel@conference.jabber.org/Fingolfin'>  <error code='405'>Invalid Groupchat Protocol</error></message>*/#endif///--------------------------------------------------------------------------------------//	DispatchMessageMsg://		Check if there's a dialog open to handle the message, otherwise create one//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	GroupChatManager::DispatchMessageMsg( const MacJLib::MessageMsg &aMsg ){	ASSERT("msGroupChatDialogs == NULL",msGroupChatDialogs,0);		GroupChatDialog*	theGroupChatDialog;		theGroupChatDialog = FindGroupChatDialog( aMsg.getFrom() );		if ( theGroupChatDialog )	{		// It was a message from a group we're in, so just hand it through to the dialog		theGroupChatDialog->OnMessage( aMsg );	}	else	{		// Check if this an invite://		if( getSubject() == "invite:" + Profile::GetJID().c_str() )//			OpenAskGroupJoinDialog...#if 0		// HACK		// FIX ME		std::string nick(PrefsManager::GetPrefsRec().mDefaultNick);			// FIX ME		if( nick.empty() )			nick = "dummy";			theGroupChatDialog = JoinGroupChat( aMsg.getFrom(), nick );		theGroupChatDialog->OnMessage( aMsg );#endif			}}///--------------------------------------------------------------------------------------//	DispatchPresenceMsg://		Only dispatch Presence if there's a matching dialog open.//		//	Changes://		2000-05-22	MH		Created///--------------------------------------------------------------------------------------void	GroupChatManager::DispatchPresenceMsg( const MacJLib::PresenceMsg &aMsg ){	GroupChatDialog*	theGroupChatDialog;	if( !aMsg.getType().empty() && (aMsg.getType() != "available") && (aMsg.getType() != "unavailable") )		return;	theGroupChatDialog = FindGroupChatDialog( aMsg.getFrom() );		if( theGroupChatDialog )		theGroupChatDialog->OnPresence( aMsg );}///--------------------------------------------------------------------------------------//	FindGroupChatDialog://		Searches a groupchat dialog matching inGroup and returns it - or NULL//		//	Changes://		2000-05-22	MH		Created///--------------------------------------------------------------------------------------GroupChatDialog*	GroupChatManager::FindGroupChatDialog( const MacJLib::JID& inGroup ){	ASSERT("msGroupChatDialogs == NULL",msGroupChatDialogs,0);		GroupChatDialog*	theGroupChatDialog;	long				i;		for ( i = 1; i <= msGroupChatDialogs->CountItems(); i++ )	{			FailNIL( theGroupChatDialog = (GroupChatDialog*) msGroupChatDialogs->GetObject( i ) );		// Attention: we use here the fact that JID operator== ignores the resource!		if ( theGroupChatDialog->mTargetJID == inGroup )			return theGroupChatDialog;	}		return NULL;}///--------------------------------------------------------------------------------------//	JoinGroupChat://		Join a group chat by creating a new window for it//		//	Changes://		2000-05-22	MH		Created///--------------------------------------------------------------------------------------GroupChatDialog*	GroupChatManager::JoinGroupChat( const MacJLib::JID& inGroup, const std::string &inNick ){	ASSERT("msGroupChatDialogs == NULL",msGroupChatDialogs,0);		GroupChatDialog*	theGroupChatDialog;		// Check if there's already a group chat window for this group	theGroupChatDialog = FindGroupChatDialog( inGroup );		// If none is there, open a new one.	if( !theGroupChatDialog )	{		FailNIL( theGroupChatDialog = new GroupChatDialog( inGroup, inNick ));		try		{			theGroupChatDialog->InitZWindow();			theGroupChatDialog->Place();		}		catch( ZoopError err )		{			ForgetObject( theGroupChatDialog );						throw err;		}		msGroupChatDialogs->AppendItem( theGroupChatDialog );	}		// Join the group! (or, if we already were in it, change our nick - luckily, this is the same code)	MacJLib::JID	targetJID( inGroup );	targetJID.setResource( inNick );	PresenceManager::SendPresence( targetJID );	// Show the dialog on top since the user requested it!	theGroupChatDialog->Select();		return theGroupChatDialog;}///--------------------------------------------------------------------------------------//	RemovedGroupChatDialog://		This is called whenever a GroupChatDialog is closed so we can remove it from our list//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	GroupChatManager::RemovedGroupChatDialog( GroupChatDialog* dead ){	ASSERT("msGroupChatDialogs == NULL",msGroupChatDialogs,0);		FailNILParam( dead );		msGroupChatDialogs->DeleteObject( dead );}#pragma mark -///--------------------------------------------------------------------------------------//	MaybeDispatchMessageMsg://		This method is called by the ChatManager when appropriate, to allow us to deliver//		private messages, and messages from the server.//		//	Changes://		2000-07-24	MH		Created///--------------------------------------------------------------------------------------bool	GroupChatManager::MaybeDispatchMessageMsg( const MacJLib::MessageMsg &aMsg ){	ASSERT("msGroupChatDialogs == NULL",msGroupChatDialogs,0);	GroupChatDialog*	theGroupChatDialog;	long				i;	std::string			resource;	bool				dispatched = false;		resource = aMsg.getFrom().getResource();		if( resource.empty() )	{		std::string		server(aMsg.getFrom().getServer());		for ( i = 1; i <= msGroupChatDialogs->CountItems(); i++ )		{				FailNIL( theGroupChatDialog = (GroupChatDialog*) msGroupChatDialogs->GetObject( i ) );			if( theGroupChatDialog->mTargetJID.getServer() == server )			{				// FIX ME - currently, we take the first matching dialog. However, we should				// realls use the *topmost* matching dialog				theGroupChatDialog->OnMessage( aMsg );				dispatched = true;				break;			}		}	}	else	{		for ( i = 1; i <= msGroupChatDialogs->CountItems(); i++ )		{				FailNIL( theGroupChatDialog = (GroupChatDialog*) msGroupChatDialogs->GetObject( i ) );			if( (theGroupChatDialog->mTargetJID == aMsg.getFrom()) && theGroupChatDialog->ContainsNick(resource) )			{				theGroupChatDialog->OnMessage( aMsg );				dispatched = true;			}		}	}		return dispatched;}