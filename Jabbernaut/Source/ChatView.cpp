///--------------------------------------------------------------------------------------//	File:		ChatView.cpp//	Project:	Jabbernaut////	Purpose:	A View derived from ZTextView that implements special features for chats//	Created:	Friday, 2001-01-05//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	© 2000-2001 Max Horn, All rights reserved worldwide.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"ZGrafState.h"#include	"ChatView.h"#include	"JID.h"#include	"MacJLibUtils.h"///- Contants ---------------------------------------------------------------------------#pragma mark -#pragma mark === Contants ===enum{	kMaxTextSize	= 32767};#pragma mark -#pragma mark [Class Init]///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------ChatView::ChatView( ZView* aParent, Rect* aFrame )	: ZTextView( aParent, aFrame, FALSE, TRUE, FALSE ){	mEditLineItem = NULL;		SetFlags( kTVSelectable | kTVTreatReturnAsEnter );	SetFontInfo( kFontIDGeneva, 9, 0 );}///--------------------------------------------------------------------------------------//	¥ Destructor:///--------------------------------------------------------------------------------------ChatView::~ChatView(){}#pragma mark -///--------------------------------------------------------------------------------------//	AppendChatData://		Appends the specified data, using different styles for message/name//		//	Changes://		2000-05-15	MH		Created//		2001-01-05	MH		Adapted for ChatView (was part of ChatDialogItem)///--------------------------------------------------------------------------------------void	ChatView::AppendChatData( const MacJLib::JID &inJID,									const std::string &message,									const RGBColor &aColor,									bool useTimestamp,									std::time_t utcSecs ){	ASSERT("GetMacTextEdit() == NULL",GetMacTextEdit(),0);	long			overrun;	TextStyle		newStyle;	std::string		nick;	std::string		text;	short			selStart, selEnd;		ZGrafState		zg;		Focus();	PrepareForDrawing();	FocusForContent();	//	// Build the nick str from the supplied JID	//	if( 0 == message.compare(0,3,"/me")  )	{		nick = "* " + inJID.getResource();		text = message.substr(3);	}	else	{		if( inJID.hasResource() )			nick = inJID.getResource();		else			nick = inJID.getFull();		if( nick.empty() )			nick = "### ";		else			nick = "<" + nick + ">: ";		text = message;	}		//	// Prepend the timestamp if flag is set	//	if( useTimestamp )	{		Str255			pStr;		char			cStr[256];				if( utcSecs == 0 )			utcSecs = MacJLib::GetTimeSeconds();		else			utcSecs += MacJLib::TimeZoneOffsetInSeconds();		TimeString( utcSecs, false, pStr, NULL );				ConcatPStrings( pStr, "\p " );		CopyPToCString( pStr, cStr );		nick = cStr + nick;	}		//	// Store the current selection	//	selStart = (**GetMacTextEdit()).selStart;	selEnd = (**GetMacTextEdit()).selEnd;			//	// Check if we're about to exceed TextEdit's 32k limit. If yes, then	//    delete some stuff before appending.	overrun = ((**GetMacTextEdit()).teLength + nick.size() + text.size() + 1) - kMaxTextSize;	if( overrun > 0 )	{		RgnHandle	    clip;		Rect			emptyRect = {0,0,0,0};		FailNIL( clip = NewRgn());		GetClip( clip );		ClipRect( &emptyRect );		if( overrun > kMaxTextSize)			overrun = kMaxTextSize;		TESetSelect( 0, overrun, GetMacTextEdit() );		TEDelete( GetMacTextEdit() );		SetClip( clip );	    DisposeRgn( clip );	    	    // we have to correct the selection after an overrun		if( selStart < overrun )			selStart = 0;		else			selStart -= overrun;		if( selEnd < overrun )			selEnd = 0;		else			selEnd -= overrun;	}		//	// Make sure we add to the end of the text	//	TESetSelect( 32767, 32767, GetMacTextEdit() );			//	// Activate the custom color if supplied, defaults to black	//	newStyle.tsColor = aColor;	TESetStyle( doColor, &newStyle, TRUE, GetMacTextEdit() );	//	// Go to the next line (unless this is the very first entry)	//	if( (**GetMacTextEdit()).teLength > 0 )		TEInsert( "\r", sizeof(char), GetMacTextEdit() );	//	// Insert the nick (in bold face)	//	newStyle.tsFace = bold;	TESetStyle( doFace, &newStyle, TRUE, GetMacTextEdit() );	TEInsert( nick.data(), nick.size(), GetMacTextEdit() );		//	// Insert the message (plain style)	//	newStyle.tsFace = normal;	TESetStyle( doFace, &newStyle, TRUE, GetMacTextEdit() );	TEInsert( text.data(), text.size(), GetMacTextEdit() );	SetFontInfo( kFontIDGeneva, 9, 0 );	//	// Scroll the chat as appropriate:	//	- if we were at the end, scroll to the end again	//	- otherwise, show the scroll offset as before.	//	if( theVBar && (//		GetControlValue( theVBar ) >= GetControlMaximum( theVBar ) ) )	if( HasVBar() && (		GetControlValue( GetVBar() ) >= GetControlMaximum( GetVBar() ) ) )	{		TESetSelect( 32767, 32767, GetMacTextEdit() );		RecalText(TRUE);	}	else	{		RecalText(FALSE);	}		//	// Restore the selection	//	if( selStart != selEnd )		TESetSelect( selStart, selEnd, GetMacTextEdit() );	else		TEDeactivate( GetMacTextEdit() );	// HACK to erase the caret	}///--------------------------------------------------------------------------------------//	ClearChatData://		Empty the chat item//		//	Changes://		2000-07-03	MH		Created//		2001-01-05	MH		Adapted for ChatView (was part of ChatDialogItem)///--------------------------------------------------------------------------------------void	ChatView::ClearChatData(){	ASSERT("GetMacTextEdit() == NULL",GetMacTextEdit(),0);	ZGrafState		gs;	Focus();	PrepareForDrawing();	FocusForContent();	TESetSelect( 0, 32767, GetMacTextEdit() );	TEDelete( GetMacTextEdit() );//	TESetSelect( 0, isEditable? 32767 : 0, GetMacTextEdit() );	TESetSelect( 32767, 32767, GetMacTextEdit() );		RecalText(TRUE);}#pragma mark -ZView*		CreateNewChatView( ZView* aParent, Rect* aFrame, const short param ){	// for now, we just ignore the param. May change in the future...	ChatView*		cv;		FailNIL( cv = new ChatView( aParent, aFrame ));			return cv;}