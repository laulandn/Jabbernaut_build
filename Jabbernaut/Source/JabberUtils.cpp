///--------------------------------------------------------------------------------------//	File:		JabberUtils.cpp//	Project:	Jabbernaut////	Purpose:	Commonly used utility functions for Jabbernaut//	Created:	Friday, 2000-06-30//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	<Traps.h>#include	"MacZoop.h"#include	"JabberUtils.h"#include	"SoundManager.h"#include	"ProductInformation.h"///- Static Members ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Members ===NMRec		JabberUtils::msNotifyRec;bool		JabberUtils::msNotifyInstalled;#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Give this manager a chance to initate static members etc.//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	JabberUtils::Init(){	ASSERT("msNotifyRec.nmIcon != NULL",msNotifyRec.nmIcon == NULL,0);	msNotifyInstalled = false;		msNotifyRec.qLink = NULL;				// next queue entry	msNotifyRec.qType = nmType;				// queue type -- nmType = 8	msNotifyRec.nmMark = true;				// put mark in Apple menu	msNotifyRec.nmSound = NULL;				// set the sound to be played	msNotifyRec.nmStr = NULL;				// no alert text	msNotifyRec.nmResp = NULL;				// no response procedure	msNotifyRec.nmRefCon = NULL;	if( noErr == GetIconSuite( &msNotifyRec.nmIcon, kApplicationIconSuiteID, svAllSmallData ) )	{		HNoPurge( msNotifyRec.nmIcon );		HLock( msNotifyRec.nmIcon );	}	else		msNotifyRec.nmIcon = NULL;	}///--------------------------------------------------------------------------------------//	Deinit://		Give this manager a chance to dispose static members etc.//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	JabberUtils::Deinit(){	ASSERT("msNotifyRec.nmIcon == NULL",msNotifyRec.nmIcon != NULL,0);		// Just in case...	RemoveNotify();		DisposeIconSuite( msNotifyRec.nmIcon, FALSE );	msNotifyRec.nmIcon = NULL;}#pragma mark -///--------------------------------------------------------------------------------------//	DoEventNotify://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	JabberUtils::DoEventNotify( const EventNotify& inEvent ){	if( inEvent.soundOn )		SoundManager::Play( inEvent.sndResID );	if( inEvent.blinkMenu )		DoNotify();	if( inEvent.bringToFront )	{	   ProcessSerialNumber myPSN, frontPSN;	        	    GetCurrentProcess(&myPSN);	    GetFrontProcess(&frontPSN);	        	    if ((myPSN.highLongOfPSN != frontPSN.highLongOfPSN) ||			(myPSN.lowLongOfPSN != frontPSN.lowLongOfPSN))	        SetFrontProcess(&myPSN);	}}#pragma mark -///--------------------------------------------------------------------------------------//	DoNotify://		//		//	Changes://		2000-05-24	MH		Created//		2000-07-03	MH		Extracted class JabberClient///--------------------------------------------------------------------------------------void	JabberUtils::DoNotify(){	if( gApplication->InBackground() && (!msNotifyInstalled) )	{		msNotifyRec.qLink = NULL;				//next queue entry		msNotifyRec.qType = nmType;			//queue type -- nmType = 8		msNotifyRec.nmMark = true;				//put mark in Apple menu		msNotifyRec.nmSound = NULL;			//set the sound to be played		msNotifyRec.nmStr = NULL;				//no alert text		msNotifyRec.nmResp = NULL;				//no response procedure		msNotifyRec.nmRefCon = NULL;		// install notification:		FailOSErr( ::NMInstall( &msNotifyRec ) );		msNotifyInstalled = true;	}}///--------------------------------------------------------------------------------------//	RemoveNotify://		//		//	Changes://		2000-05-24	MH		Created//		2000-07-03	MH		Extracted class JabberClient///--------------------------------------------------------------------------------------void	JabberUtils::RemoveNotify(){	if( msNotifyInstalled )	{		// we're back, so delete the notification		FailOSErr( ::NMRemove( &msNotifyRec ) );		msNotifyInstalled = false;	}}#pragma mark -///--------------------------------------------------------------------------------------//	MatchString://		Matches a string to a given pattern (DOS like syntax, using * and ?)//		//	Changes://		2000-06-30	MH		Created///--------------------------------------------------------------------------------------bool	JabberUtils::MatchString( const std::string& inStr, const std::string& inPat ){// FIX ME	const char *str = inStr.c_str();	const char *pat = inPat.c_str();	const char *p = NULL;	const char *q = NULL;		for(;;)	{		switch(*pat)		{		case '*':			p = ++pat;			q = str;			break;		default:			if(*pat != *str)			{				if(p)				{					pat = p;					str = ++q;					break;				}				else					return false;			}			// fallthrough		case '?':			if(!*str)				return !*pat;			pat++;			str++;		}	}}///--------------------------------------------------------------------------------------//	MatchString://		Returns true if the string matches one of the patterns in patList//		//	Changes://		2000-10-18	MH		Created///--------------------------------------------------------------------------------------bool	JabberUtils::MatchString( const std::string& inStr, const StringList patList ){	for( StringList::const_iterator X = patList.begin(); X != patList.end(); ++X )	{		std::string	pattern(*X);				if( std::string::npos == pattern.find_first_of("/") )			pattern += "*";					if( MatchString( inStr, pattern ) )			return true;	}	return false;}///--------------------------------------------------------------------------------------//	Tokenize://		Tokenizes a given string 'text', using all chars in 'delims' as seperators. //		The result is stored in the list of strings 'tokens'//		//	Changes://		2000-08-16	MH		Created///--------------------------------------------------------------------------------------void	JabberUtils::Tokenize( const std::string& text, const std::string& delims, StringList& tokens ){	std::string::size_type	begIdx, endIdx;		// tokenize the text line	begIdx = text.find_first_not_of(delims);	while( begIdx != std::string::npos )	{		// search end of word		endIdx = text.find_first_of(delims, begIdx);				if( endIdx == std::string::npos )			endIdx = text.length();				tokens.push_back( text.substr(begIdx, endIdx-begIdx) );				begIdx = text.find_first_not_of(delims, endIdx);	}}#pragma mark -///--------------------------------------------------------------------------------------//	MatchString://		Matches a string to a given pattern (DOS like syntax, using * and ?)//		//	Changes://		2000-06-30	MH		Created///--------------------------------------------------------------------------------------std::string	JabberUtils::GetVersionString(){	Str255	pStr;	std::string	version;		if( GetVersionNumberString( 1, pStr ) == noErr )	{		char	cStr[256];		CopyPToCString( pStr, cStr );		version = cStr;	}		return version;}#pragma mark -#if __POWERPC__ && !TARGET_API_MAC_CARBONpascal OSErr PBXGetVolInfoSync(XVolumeParamPtr paramBlock){	enum	{		kXGetVolInfoSelector = 0x0012,	// Selector for XGetVolInfo		uppFSDispatchProcInfo = kRegisterBased			| REGISTER_RESULT_LOCATION(kRegisterD0)			| RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))			| REGISTER_ROUTINE_PARAMETER(1, kRegisterD0, SIZE_CODE(sizeof(long)))	// selector			| REGISTER_ROUTINE_PARAMETER(2, kRegisterD1, SIZE_CODE(sizeof(long)))	// trap word			| REGISTER_ROUTINE_PARAMETER(3, kRegisterA0, SIZE_CODE(sizeof(XVolumeParamPtr)))	};	return ( CallOSTrapUniversalProc(NGetTrapAddress(_FSDispatch, OSTrap),		uppFSDispatchProcInfo,		kXGetVolInfoSelector,		_FSDispatch,		paramBlock) );}#endif