///--------------------------------------------------------------------------------------//	File:		ColorDialogItem.cpp//	Project:	Jabbernaut////	Purpose:	This dialog item is used to allow the user to choose a color.//	Created:	Monday, 2000-07-03//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"ZDialog.h"#include	"ZGrafState.h"#include	"ColorDialogItem.h"#include	<ColorPicker.h>#define		_USE_NEW_PICKER 0#pragma mark -#pragma mark [Class Init]pascal Boolean	MyPickerFilterFunction( EventRecord *event );pascal void		MyColorChangedFunction( long userData, struct PMColor *newColor );CLASSCONSTRUCTOR( ColorDialogItem );///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------ColorDialogItem::ColorDialogItem( ZDialog* aDialog, const short item )	: inherited( aDialog, item ){	classID = CLASS_ColorDialogItem;	mColor = gBlack;}///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------ColorDialogItem::ColorDialogItem()	: inherited(){	classID = CLASS_ColorDialogItem;	mColor = gBlack;}#pragma mark -///--------------------------------------------------------------------------------------//	DrawItem://		Draw the item in the current chosen color//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	ColorDialogItem::DrawItem(){	DrawSelector( !hilited, FALSE );}///--------------------------------------------------------------------------------------//	Click://		Invert the dialog item, track the mouse and eventually call UserPickColor()//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	ColorDialogItem::Click( const Point where, const short modifiers ){	Boolean		wasIn = FALSE;	Boolean		isIn;	Point		mouse = where;	if ( enabled )	{		ZGrafState  gs;				SelfSelect();					PrepareForDrawing();		while( WaitMouseUp())		{			GetMouse( &mouse );						isIn = PtInRect( mouse, &bounds );					if ( isIn != wasIn )			{				wasIn = isIn;								DrawSelector( FALSE, wasIn );			}		}				if( isIn )		{			UserPickColor();			InvalItem();			((ZDialog*) itsBoss )->ClickItem( id );		}	}}#pragma mark -///--------------------------------------------------------------------------------------//	DrawSelector://		Draw this item with the specified color//		//	Changes://		2000-07-03	MH		Created//		2000-08-13	MH		Rewrote method to be much more flexible. In addition, the//							dialog item now looks much better.///--------------------------------------------------------------------------------------void	ColorDialogItem::DrawSelector( const Boolean dimmed, const Boolean state ){	Rect			temp;	RGBColor		saveFore, saveBack;	RGBColor		theColor = mColor;		GetForeColor( &saveFore );	GetBackColor( &saveBack );	temp = bounds;	if( !state )		RGBBackColor( &gWhite );	EraseRect( &temp );		InsetRect( &temp, 4, 4 );	if( dimmed )	{		theColor.red = theColor.red/2 + 0x8000;		theColor.blue = theColor.blue/2 + 0x8000;		theColor.green = theColor.green/2 + 0x8000;	}	RGBForeColor( &theColor );	PaintRect( &temp );		// restore the old fore/back color	RGBForeColor( &saveFore );	RGBBackColor( &saveBack );		if( state )	{		SetHiliteMode();		InvertRect (&bounds);	}	temp = bounds;	InsetRect( &temp, 2, 2 );#if APPEARANCE_MGR_AWARE		if ( gMacInfo.hasAppearanceMgr )		DrawThemeEditTextFrame( &temp, hilited? kThemeStateActive : kThemeStateInactive );	else	{#endif		DrawStdFrame( &temp );	#if APPEARANCE_MGR_AWARE	}#endif}#pragma mark -///--------------------------------------------------------------------------------------//	UserPickColor://		Let the user choose a color//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------bool	ColorDialogItem::UserPickColor(){	RGBColor	resultColor;	bool		colorChanged;#if _USE_NEW_PICKER	ColorPickerInfo			cpInfo;	// Provide start colour as RGB:	cpInfo.theColor.color.rgb = (*((CMRGBColor *) &mColor));	cpInfo.theColor.profile = 0L;	// Don't specify destination Profile:	cpInfo.dstProfile = 0L;	cpInfo.flags = kColorPickerAppIsColorSyncAware					| kColorPickerCanModifyPalette					| kColorPickerCanAnimatePalette;	// Center dialog box on the deepest color screen:	cpInfo.placeWhere = kDeepestColorScreen;	// Use default picker:	cpInfo.pickerType = 0L;	// Specify no filters & changed procs:	cpInfo.eventProc = NewUserEventProc( MyPickerFilterFunction );	cpInfo.colorProc = NewColorChangedProc( MyColorChangedFunction );	cpInfo.colorProcData = 0L;	CopyPString( "\p", cpInfo.prompt );	// Tell color picker about our edit menu:	cpInfo.mInfo.editMenuID = 130;	cpInfo.mInfo.cutItem = 3;	cpInfo.mInfo.copyItem = 4;	cpInfo.mInfo.pasteItem = 5;	cpInfo.mInfo.clearItem = 6;	cpInfo.mInfo.undoItem = 1;	// Finally bring up the dialogue box:	colorChanged = (::PickColor( &cpInfo ) == noErr) && cpInfo.newColorChosen;	if( colorChanged )		mColor = (*((RGBColor *) &cpInfo.theColor.color.rgb));#else	Point	pos = { -1, -1 };	colorChanged = ::GetColor( pos, "\p", &mColor, &resultColor );	if( colorChanged )		mColor = resultColor;		#endif	return colorChanged;}#pragma mark -pascal Boolean	MyPickerFilterFunction( EventRecord *event ){	return false;}pascal void		MyColorChangedFunction( long userData, struct PMColor *newColor ){	// Do nothing.}