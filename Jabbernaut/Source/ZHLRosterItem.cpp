///--------------------------------------------------------------------------------------//	File:		ZHLRosterItem.cpp//	Project:	Jabbernaut////	Purpose:	A ZHL (folder) tem that is used to display&store a roster item//	Created:	Thursday, 2000-05-11//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"ZGrafState.h"#include	"ZHLRosterItem.h"#include	"ZListDialogItem.h"#include	"ZTimer.h"#ifndef TOQ  #include	"AgentsManager.h"  #include	"ChatManager.h"#endif#include	"ConnectionManager.h"#include	"JabberUtils.h"#include	"PrefsManager.h"#include	"Profile.h"#include	"ReceiveManager.h"#include	"ReceiveMsgDialog.h"#include	"RosterManager.h"#include	"SendManager.h"#include	"SoundManager.h"#include	"ZHLRosterItem.h"#include	"ZHLRosterSubItem.h"#include	"Messages.h"#include	"UniqueID.h"#include	<cctype>///- Contants ---------------------------------------------------------------------------#pragma mark -#pragma mark === Contants ===enum{	kEditUserDialogID	= 1104,		kEditUserStringsID	= 1104};enum{	kEditUserApplyBtnID			= 1,	kEditUserCancelBtnID		= 2,	kEditUserJIDID				= 6,	kEditUserNameID				= 8,	kEditUserSubNoneID			= 11,	kEditUserSubToID			= 12,	kEditUserSubFromID			= 13,	kEditUserSubBothID			= 14,	kEditUserGroupListID		= 17,	kEditUserGroupAddBtnID		= 18};// FIX ME - this is also in RosterAddItemDialog.cppenum{	kAddGroupDialogID		= 1107,	kAddGroupNameID			= 4};enum{	kRosterContextMenuID	= 1004};enum{	kRosterContextMenuMessageID			= 1,	kRosterContextMenuChatID			= 2,	kRosterContextMenuEditUserID		= 4,	kRosterContextMenuDeleteUserID		= 5,	kRosterContextMenuQueryVersionID	= 7,	kRosterContextMenuQueryTimeID		= 8};///- Static Members ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Members ===MenuHandle			ZHLRosterItem::msContextualMenu	= NULL;#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Give this manager a chance to initate static members etc.//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::Init(){	ASSERT("msContextualMenu != NULL",msContextualMenu == NULL,0);	//	// Load the contextual menu (for roster items)	//#ifndef TOQ	FailNIL( msContextualMenu = GetMenu( kRosterContextMenuID ) );#endif}///--------------------------------------------------------------------------------------//	Deinit://		Give this manager a chance to dispose static members etc.//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::Deinit(){	if( msContextualMenu )	{		ReleaseResource( (Handle)msContextualMenu );		msContextualMenu = NULL;	}}#pragma mark -#pragma mark [Class Init]///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------ZHLRosterItem::ZHLRosterItem()	: ZHLFolder("\pRosterItem"){	mAskedSubscribeTo = false;	mSubscribedTo = false;	mSubscribedFrom = false;	mPresenceStatus = kOfflinePresenceStatus;		mEditDialog = NULL;		mMetaGroup = kMetaGroupOffline;		mShowMailIcon = false;		isFolder = false;}///--------------------------------------------------------------------------------------//	¥ Destructor:///--------------------------------------------------------------------------------------ZHLRosterItem::~ZHLRosterItem(){	if( mEditDialog )	{		mEditDialog->Close( kRunning );		mEditDialog = NULL;	}		// kill all our sub-items	items.DisposeAll();	// Kill all our exisiting timers	KillTimer(NULL, (long)this);}#pragma mark -///--------------------------------------------------------------------------------------//	DrawCell://		Draw the list cell.//		//	Changes://		2000-05-11	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::DrawCell( Rect& r, ZHLDialogItem *boss ){	ZGrafState	zg;	Point		pt;	short		height, relTop;	Str255		pStr;	RGBColor	textColor;	RGBColor	backColor;	#ifdef TOQ	if( CustomBackgroundColour( backColor, boss ) )#else	if( !(boss && boss->IsSelected(this)) && CustomBackgroundColour( backColor, boss ) )#endif	{		Rect		dummyRect;				RGBBackColor( &backColor );		dummyRect = r;		dummyRect.left = 1;		dummyRect.bottom++;		dummyRect.right--;		EraseRect( &dummyRect );	}		// Set up the color for the text	if( CustomForegroundColour( textColor, boss ) )		RGBForeColor( &textColor );		height = r.bottom - r.top;			// height of cell	relTop = 1 + (height * 2) / 3;		// top offset for text		// FIX ME!//	r.left += 4;	pt.h = r.left;	pt.v = r.top + 1;	if( mShowMailIcon )		RosterManager::DrawPresenceIcon( kGotMailVirtualStatus, pt  );	else		RosterManager::DrawPresenceIcon( mPresenceStatus, pt  );	r.left += 20;		MoveTo (r.left, r.top + relTop);	CopyCToPString( mText.c_str(), pStr );	#ifndef TOQ	if( items.CountItems() > 1 )	{		Str255	num;			NumToString( items.CountItems(), num );		ConcatPStrings( pStr, "\p (" );		ConcatPStrings( pStr, num );		ConcatPStrings( pStr, "\p)" );		TextFace (bold);	}#endif		DrawString( pStr );}///--------------------------------------------------------------------------------------//	DoubleClick://		Depending on the prefs, this sends a message or starts a chat//		//	Changes://		2000-05-12	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::DoubleClick(short modifiers, ZHLDialogItem *boss){#ifdef TOQ	ReceiveMsgDialog	*aRMD = ReceiveManager::GetInstance()->FindInvisibleReceiveMsgDialog( mJID );		if( aRMD && PrefsManager::GetPrefsRec().mIncomingMessagesDelayed )	{		aRMD->Select();		if( NULL == ReceiveManager::GetInstance()->FindInvisibleReceiveMsgDialog( mJID ) )			StopBlinking();	}	else		SendManager::DoNewMessage( mJID );		#else	bool	doSendMsg = PrefsManager::GetPrefsRec().mDoubleClickSendsMsg;		if( modifiers & optionKey )		doSendMsg = !doSendMsg;	if( doSendMsg )		SendManager::DoNewMessage( mJID );	else		ChatManager::DoInviteToChat( mJID );#endif}///--------------------------------------------------------------------------------------//	ContextualMenuClick://		Contextual menu handler//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::ContextualMenuClick (const Point where){#ifndef TOQ	ASSERT("msContextualMenu == NULL",msContextualMenu != NULL,0);	long		result;	// Use the normal Mac OS Menu Manager to display the menu. Note	// that we add 1 to the vertical coordinate so that we have the	// same behaviour as the CMM: i.e., the menu appears without	// any initial selection.	InsertMenu( msContextualMenu, hierMenu );	result = PopUpMenuSelect( msContextualMenu,				where.v + 1, where.h,				1 );	DeleteMenu( kRosterContextMenuID );	// idea - create new class ZContextMenu; then, add items to it	// dynamically. Also, maybe use context manager calls...	// And add a help menu item, too. This class would also 	// extract command ideas from the menu items.		// FIX ME - at least use constants for this	switch( LoWord(result) )	{	case kRosterContextMenuMessageID:		SendManager::DoNewMessage( mJID );		break;	case kRosterContextMenuChatID:		ChatManager::DoInviteToChat( mJID );		break;	case kRosterContextMenuEditUserID:		DoEditRosterItem();		break;	case kRosterContextMenuDeleteUserID:		DoRemoveRosterItem();		break;	case kRosterContextMenuQueryVersionID:		{			MacJLib::VersionMsg	*myVer;			MacJLib::JID		tempJID(mJID);			FailNIL( myVer = new MacJLib::VersionMsg() );			tempJID.setResource( mActiveResource );			myVer->setTo( tempJID.getFull() );			myVer->setType("get");			myVer->setID(GenerateUniqueID());						ConnectionManager::PostMessage( myVer );		}		break;	case kRosterContextMenuQueryTimeID:		{			MacJLib::TimeMsg	*myTime;			MacJLib::JID		tempJID(mJID);			FailNIL( myTime = new MacJLib::TimeMsg() );			tempJID.setResource( mActiveResource );			myTime->setTo( tempJID.getFull() );			myTime->setType("get");			myTime->setID(GenerateUniqueID());						ConnectionManager::PostMessage( myTime );		}		break;	}#endif}#pragma mark -const MacJLib::JID &ZHLRosterItem::getJID() const{	return mJID;}const std::string &ZHLRosterItem::getName() const{	return mName;}const MacJLib::GroupList &ZHLRosterItem::getGroupList() const{	return mGroupList;}#pragma mark -MetaGroup	ZHLRosterItem::CalcMetaGroup(){	mMetaGroup = kMetaGroupOffline;		if( mJID == Profile::GetOurJID() )	{		mMetaGroup = kMetaGroupMyResources;	}	else	{#ifndef TOQ		// Is this an agent?		ZHLAgentItem*	zhlAI;		zhlAI = AgentsManager::FindZHLAgentItem( mJID );		if( zhlAI )		{			if( !mJID.getUsername().empty() )				DebugStr("\pARGH");			mMetaGroup = kMetaGroupAgents;			mText = mName;			if( mText.empty() )				mText = zhlAI->getName();			if( mText.empty() )				mText = mJID.getFull();			Str255	pStr;			CopyCToPString( ("¥"+mText).c_str(), pStr );	// hack to make us sort to the bottom			CopyPStringTrunc(pStr, title, 31);		}		else#endif		{			if( mSubscribedTo )			{				if( (mPresenceStatus != kOfflinePresenceStatus)				 && (mPresenceStatus != kUnknownPresenceStatus) )					mMetaGroup = kMetaGroupOnline;			}			else			{				if( mAskedSubscribeTo )					mMetaGroup = kMetaGroupPending;				else if( mSubscribedFrom )					mMetaGroup = kMetaGroupStalkers;			}		}	}				return mMetaGroup;}#pragma mark -///--------------------------------------------------------------------------------------//	OnRosterItem://		handle incoming roster message for this item//		(caller has to make sure we are the right target, i.e. JID matches)//		//	Changes://		2000-05-16	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::OnRosterItem( const MacJLib::RosterItem &inItem ){	bool	wasSubscribedTo = mSubscribedTo;		std::string	subscription = inItem.getSubscription();	std::string	ask = inItem.getAsk();	mJID = inItem.getJID();	mName = inItem.getName();	mGroupList = inItem.getGroupList();	mGroupList.sort();		mSubscribedTo = mSubscribedFrom = false;	if( subscription == "both" )		mSubscribedTo = mSubscribedFrom = true;	else if( subscription == "to" )		mSubscribedTo = true;	else if( subscription == "from" )		mSubscribedFrom = true;		mAskedSubscribeTo = !mSubscribedTo && (ask == "subscribe");			//	// If we are no longer subscribed, remove all subitems	//		if( !mSubscribedTo )	{		ZHLRosterSubItem	*subItem = NULL;		long				i;				for( i = items.CountItems(); i >= 1; --i )		{			FailNIL( subItem = dynamic_cast<ZHLRosterSubItem*>(items.GetObject(i)) );			RemoveItem( subItem );		}#ifdef TOQ		mPresenceStatus = kOfflinePresenceStatus;#else		if( wasSubscribedTo )			mPresenceStatus = kUnknownPresenceStatus;#endif		isFolder = false;	}		//	// Recalc our text	//	mText = mName;#if TOQ	// In TOQ, we prefer to only show the username (but when there is no username,	// we fall back to the default behaviour)	if( mText.empty() )		mText = mJID.getUsername();#endif	if( mText.empty() )		mText = mJID.getFull();	Str255	pStr;	CopyCToPString( ("¥"+mText).c_str(), pStr );	// hack to make us sort to the bottom	CopyPStringTrunc(pStr, title, 31);		//	// Recalc our meta group	//	CalcMetaGroup();		// If we're changed, we inform out edit dialog.	// FIX ME - what if the user is just now typing into it? aargh, damn sync	// problems, I should turn everything into modal dialogs! ;-)	// (not that this would solve the problem, since the net connection is still	//  active, and the user might change the roster in another session just at the same	// time. Very unlikely, though, except if the account is shared by multiple users...)	UpdateEditDialogValues();}///--------------------------------------------------------------------------------------//	OnPresence://		handle incoming presence message for this item//		(caller has to make sure we are the right target, i.e. JID matches)//		//	Changes://		2000-05-16	MH		Created//		2000-09-13	MH		Added code for TOQ///--------------------------------------------------------------------------------------void	ZHLRosterItem::OnPresence( const MacJLib::PresenceMsg &inPresence ){	PresenceStatus		oldPresenceStatus = mPresenceStatus;	long				i = 0;	ZHLRosterSubItem	*subItem = NULL;	long				priority = LONG_MIN;		// Check if a resource is specified for this presence.	if( inPresence.getFrom().hasResource() )	{		subItem = FindSubItem( inPresence.getFrom().getResource() );				if( inPresence.getType() == "unavailable" )		{			if( subItem != NULL )			{				RemoveItem( subItem );				ForgetObject( subItem );			}		}		else		{			if( subItem == NULL )				FailNIL( subItem = CreateSubItem( inPresence.getFrom() ) );						subItem->OnPresence( inPresence );		}						//		// Find the resource with the highest priority		//		mActiveResource.clear();		mPresenceStatus = kOfflinePresenceStatus;		for( i = 1; i <= items.CountItems(); ++i )		{			FailNIL( subItem = dynamic_cast<ZHLRosterSubItem*>(items.GetObject(i)) );			if( subItem->GetPriority() > priority )			{				priority = subItem->GetPriority();				mPresenceStatus = subItem->GetPresenceStatus();				mActiveResource = subItem->GetResource();			}		}	}	else	{		// No resource was specified. Thus, assume this presence is used as		// "global" presence				mPresenceStatus = PresenceManager::GetPresenceStatus( inPresence );	}		//	// Check if our status has changed, and if yes, notify the user	//	if( oldPresenceStatus != mPresenceStatus )	{		if( ( mPresenceStatus == kOnlinePresenceStatus ) ||			( mPresenceStatus == kChatPresenceStatus ) )		{			if( oldPresenceStatus == kOfflinePresenceStatus )				JabberUtils::DoEventNotify( PrefsManager::GetPrefsRec().mEventOnline );			else				JabberUtils::DoEventNotify( PrefsManager::GetPrefsRec().mEventStatusChange );		}		else if( mPresenceStatus == kOfflinePresenceStatus )		{			JabberUtils::DoEventNotify( PrefsManager::GetPrefsRec().mEventOffline );		}			}		CalcMetaGroup();	#ifdef TOQ	// In TOQ, we never show the resources.	isFolder = false;#else	// if no subitems -> don't show us as a folder	if( (mMetaGroup == kMetaGroupAgents) || (mMetaGroup == kMetaGroupMyResources) )		isFolder = false;	else		isFolder = (0 < items.CountItems() );#endif	RosterManager::RefreshRosterItem( *this );}#pragma mark -///--------------------------------------------------------------------------------------//	DoEditRosterItem://		Opens an edit dialog for this item if none is open; then selects it.//		//	Changes://		2000-05-16	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::DoEditRosterItem(){	if( mMetaGroup == kMetaGroupMyResources )		return;		if( mEditDialog == NULL )	{		FailNIL( mEditDialog = new JabberDialog( gApplication, kEditUserDialogID ));				try		{			ListenTo( mEditDialog );			mEditDialog->InitZWindow();			mEditDialog->Place();		}		catch( ZoopError err )		{			ForgetObject( mEditDialog );			throw err;		}				UpdateEditDialogValues();	}		mEditDialog->Select();}///--------------------------------------------------------------------------------------//	DoRemoveRosterItem://		Removes this item (indirectly by sending a message; a roster push will do//		the actual work)//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::DoRemoveRosterItem(){	short	result;	Str255	jid;		if( mMetaGroup == kMetaGroupMyResources )		return;		CopyCToPString( mJID.c_str(), jid );	gWindowManager->DeactivateForDialog( -1, TRUE );	ParamText( jid, NULL, NULL, NULL );	result =  Alert( 1201, NULL );	gWindowManager->Activate();	if( result == 1 )	{		MacJLib::RosterItem	removerRosterItem;		removerRosterItem.setJID(mJID);		removerRosterItem.setSubscription("remove");				RosterManager::SendRosterItem( removerRosterItem );	}}#pragma mark -///--------------------------------------------------------------------------------------//	StartBlinking://		Start blinking our icon//		//	Changes://		2000-10-05	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::StartBlinking(){	ZTimer	*myTimer;	// Kill all our exisiting timers (just in case we were already blinking)	KillTimer(NULL, (long)this);	// Start a new timer with hald second intervals	myTimer = SetTimer(NULL, (long)this, 30);		ListenTo( myTimer );}///--------------------------------------------------------------------------------------//	StopBlinking://		Stop blinking our icon//		//	Changes://		2000-10-05	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::StopBlinking(){	// Stop the timer	KillTimer(NULL, (long)this);	if( mShowMailIcon )	{		// Make sure our normal icon is shown		mShowMailIcon = false;		// Force a redraw		gZHLMaster.RedrawIfVisible (this);	}}#pragma mark -///--------------------------------------------------------------------------------------//	UpdateEditDialogValues://		Updates the edit dialog (if present) with our values.//		//	Changes://		2000-05-17	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::UpdateEditDialogValues(){	if( mEditDialog )	{		ZListDialogItem*	myListItem;		Str255				pStr;		mEditDialog->SetValueAsString( kEditUserJIDID, mJID.getFull());		mEditDialog->SetValueAsString( kEditUserNameID, mName);				// FIX ME!!		mEditDialog->SetValue( kEditUserSubNoneID,	!mSubscribedTo && !mSubscribedFrom);		mEditDialog->SetValue( kEditUserSubToID,	 mSubscribedTo && !mSubscribedFrom);		mEditDialog->SetValue( kEditUserSubFromID,	!mSubscribedTo &&  mSubscribedFrom);		mEditDialog->SetValue( kEditUserSubBothID,	 mSubscribedTo &&  mSubscribedFrom);						FailNIL( myListItem = dynamic_cast<ZListDialogItem *>(mEditDialog->GetItemObject(kEditUserGroupListID)) );				myListItem->MLSetEmptyList();		myListItem->MLAppendCol();//		myListItem->MLSetSelectionFlags( lOnlyOne );		myListItem->MLSetSelectionFlags( lExtendDrag | lUseSense );/*    lOnlyOne                    = -128,    lExtendDrag                 = 64,    lNoDisjoint                 = 32,    lNoExtend                   = 16,    lNoRect                     = 8,    lUseSense                   = 4,    lNoNilHilite                = 2*/		GroupList		allGroups;		Cell			cell = { 0, 0 };		RosterManager::GetGroupList( allGroups );				for( MacJLib::GroupList::iterator X = allGroups.begin(); X != allGroups.end(); ++X )		{			CopyCToPString( X->c_str(), pStr );			cell.v = myListItem->MLAppendRowInAlphaOrder( pStr, true );			if( mGroupList.end() != find( mGroupList.begin(), mGroupList.end(), *X ) )//				myListItem->MLSetSelection( cell );				LSetSelect( TRUE, cell, myListItem->MLGetMacList() );		}	}}///--------------------------------------------------------------------------------------//	ReceiveMessage://		handle our edit dialog...//		//	Changes://		2000-05-16	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::ReceiveMessage( ZComrade* aSender, ZoopMessage aMsg, UntypedPtr msgData ){	if( aMsg == kMsgDialogItemClicked && (aSender == mEditDialog) )	{		switch( *(long*)msgData & 0xffff )		{		case kEditUserCancelBtnID:			{				mEditDialog->Close( kRunning );				mEditDialog = NULL;			}			break;		case kEditUserApplyBtnID:			{				Str255				pStr;				char				cStr[256];				std::string			aStr;				MacJLib::RosterItem	myRosterItem;				MacJLib::GroupList	myGroupList;				ZListDialogItem*	myListItem;				Cell				myCell = { 0, 0 };				FailNIL( myListItem = dynamic_cast<ZListDialogItem *>(mEditDialog->GetItemObject(kEditUserGroupListID)) );								mEditDialog->GetValueAsString( kEditUserNameID, aStr );				myRosterItem.setName( aStr );								//read out list				myGroupList.clear();				for( myCell.v = 0; myCell.v < myListItem->MLCountRows(); myCell.v++ )				{					if( LGetSelect( false, &myCell, myListItem->MLGetMacList()) )					{						myListItem->MLGetCell( myCell, pStr );						CopyPToCString( pStr, cStr );						myGroupList.push_back( std::string(cStr) );					}				}								myRosterItem.setJID( mJID );				myRosterItem.setGroupList( myGroupList );				RosterManager::SendRosterItem( myRosterItem );								{					bool	subTo = false;					bool	subFrom = false;					if( mEditDialog->GetValue( kEditUserSubBothID ) )						subTo = subFrom = true;					else if( mEditDialog->GetValue( kEditUserSubToID ) )						subTo = true;					else if( mEditDialog->GetValue( kEditUserSubFromID ) )						subFrom = true;										if( subTo != mSubscribedTo )					{						if( subTo )							PresenceManager::SendPresence( mJID, "subscribe" );						else							PresenceManager::SendPresence( mJID, "unsubscribe" );											}					if( subFrom != mSubscribedFrom )					{						if( !subFrom )							PresenceManager::SendPresence( mJID, "unsubscribed" );					}				}			}			break;		case kEditUserGroupListID:			{				// handle list here - BACKSPACE remove ?!?!			}			break;		case kEditUserGroupAddBtnID:			{				Str255				groupName;				ZListDialogItem*	myListItem;				Cell				myCell = { 0, 0 };				FailNIL( myListItem = dynamic_cast<ZListDialogItem *>(mEditDialog->GetItemObject(kEditUserGroupListID)) );								groupName[0] = 0;				ZDialog	d( mEditDialog, kAddGroupDialogID );				d.InitZWindow();								if( d.RunModal() )					d.GetValueAsText( kAddGroupNameID, groupName );				if( groupName[0] )				{					myCell.v = myListItem->MLAppendRowInAlphaOrder( groupName, true );					LSetSelect( TRUE, myCell, myListItem->MLGetMacList() );				}			}			break;		}	}	else if( aMsg == kMsgDialogSuccessfullyClosed && (aSender == mEditDialog) ) 		mEditDialog = NULL;	else if( aMsg == kTimerMsgTimerTripped )		DoTimer( (long)msgData );}///--------------------------------------------------------------------------------------//	DoTimer://		called repeatedly when this item is supposed to blink...//		//	Changes://		2000-10-05	MH		Created///--------------------------------------------------------------------------------------void	ZHLRosterItem::DoTimer( long timerID ){	// Toggle the mail icon	mShowMailIcon = !mShowMailIcon;	// Force a redraw	gZHLMaster.RedrawIfVisible (this);}#pragma mark -///--------------------------------------------------------------------------------------//	FindSubItem://		Find a sub item with name 'name'.//		//	Changes://		2000-07-17	MH		Created///--------------------------------------------------------------------------------------ZHLRosterSubItem*	ZHLRosterItem::FindSubItem( const std::string &name ){	ZHLRosterSubItem	*subItem;	long				i;		for( i = 1; i <= items.CountItems(); ++i )	{		FailNIL( subItem = dynamic_cast<ZHLRosterSubItem*>(items.GetObject(i)) );		if( subItem->GetResource() == name )			return subItem;	}		return NULL;}///--------------------------------------------------------------------------------------//	CreateSubItem://		Create a new sub item matching the JID 'inJID'.//		//	Changes://		2000-07-17	MH		Created///--------------------------------------------------------------------------------------ZHLRosterSubItem*	ZHLRosterItem::CreateSubItem( const MacJLib::JID &inJID ){	ZHLRosterSubItem	*subItem;	FailNIL( subItem = new ZHLRosterSubItem(this, inJID) );		AddItem( subItem );		return subItem;}#pragma mark -///--------------------------------------------------------------------------------------//	CustomBackgroundColour://		Override to make sure ZHL draws us correctly//		//	Changes://		2000-07-25	MH		Created//		2000-09-13	MH		Added code for TOQ///--------------------------------------------------------------------------------------bool	ZHLRosterItem::CustomBackgroundColour(RGBColor &color, ZHLDialogItem *boss){#ifdef TOQ	FailNILParam( boss );		bool selected = boss->IsSelected(this);		switch( mPresenceStatus )	{	case kOnlinePresenceStatus:		// Normal, Chat = "Disponivel"	case kChatPresenceStatus:		if( selected )			color = RGBColorClass(0xFF00, 0xA600, 0x6B00);		else			color = RGBColorClass(0xFF00, 0xD100, 0xB200);		break;	case kOfflinePresenceStatus:	// Disconnected = "Desconectado"		if( selected )			color = RGBColorClass(0xB200, 0xB200, 0xB200);		else			color = RGBColorClass(0xD700, 0xD700, 0xD700);		break;	default:						// NA, DND, Away = "Nao Disponivel"		if( selected )			color = RGBColorClass(0xA600, 0xC400, 0xC400);		else			color = RGBColorClass(0xD100, 0xE000, 0xE000);		break;	}#else	switch( mMetaGroup )	{	case kMetaGroupOnline:		color = PrefsManager::GetPrefsRec().mGroupOnline.itemColor;		break;	case kMetaGroupMyResources:		color = PrefsManager::GetPrefsRec().mGroupMyResources.itemColor;		break;	case kMetaGroupOffline:		color = PrefsManager::GetPrefsRec().mGroupOffline.itemColor;		break;	case kMetaGroupPending:		color = PrefsManager::GetPrefsRec().mGroupPending.itemColor;		break;	case kMetaGroupStalkers:		color = PrefsManager::GetPrefsRec().mGroupStalkers.itemColor;		break;	case kMetaGroupAgents:		color = PrefsManager::GetPrefsRec().mGroupAgents.itemColor;		break;	default:		return false;		break;	}#endif	return true;}///--------------------------------------------------------------------------------------//	CustomForegroundColour://		Text color setup//		//	Changes://		2000-08-04	MH		Created//		2000-09-13	MH		Added code for TOQ///--------------------------------------------------------------------------------------bool	ZHLRosterItem::CustomForegroundColour(RGBColor &color, ZHLDialogItem *boss){#ifdef TOQ	FailNILParam( boss );		bool selected = boss->IsSelected(this);		if( selected )		color = gWhite;	else	{		switch( mPresenceStatus )		{		case kOnlinePresenceStatus:		// Normal, Chat = "Disponivel"		case kChatPresenceStatus:			color = RGBColorClass(0xFF00, 0x6600, 0x0000);			break;		case kOfflinePresenceStatus:	// Disconnected = "Desconectado"			color = RGBColorClass(0x7B00, 0x7B00, 0x7B00);			break;		default:						// NA, DND, Away = "Nao Disponivel"			color = RGBColorClass(0x6600, 0x9900, 0x9900);			break;		}	}#else	switch( mMetaGroup )	{	case kMetaGroupOnline:		color = PrefsManager::GetPrefsRec().mGroupOnline.itemTextColor;		break;	case kMetaGroupMyResources:		color = PrefsManager::GetPrefsRec().mGroupMyResources.itemTextColor;		break;	case kMetaGroupOffline:		color = PrefsManager::GetPrefsRec().mGroupOffline.itemTextColor;		break;	case kMetaGroupPending:		color = PrefsManager::GetPrefsRec().mGroupPending.itemTextColor;		break;	case kMetaGroupStalkers:		color = PrefsManager::GetPrefsRec().mGroupStalkers.itemTextColor;		break;	case kMetaGroupAgents:		color = PrefsManager::GetPrefsRec().mGroupAgents.itemTextColor;		break;	default:		return false;		break;	}#endif	return true;}#pragma mark -///--------------------------------------------------------------------------------------//	ZHLRosterItemCompare://		Compares two ZHLRosterItem//		//	Changes://		2000-05-16	MH		Created///--------------------------------------------------------------------------------------short	ZHLRosterItemCompare( void *inItemA, void *inItemB, const long ref ){	ZHLItem*		itemA = *(ZHLItem**)inItemA;	ZHLItem*		itemB = *(ZHLItem**)inItemB;	ZHLRosterItem*	a = dynamic_cast<ZHLRosterItem *>(itemA);	ZHLRosterItem*	b = dynamic_cast<ZHLRosterItem *>(itemB);#ifndef TOQ	if(PrefsManager::GetPrefsRec().mRosterSortByStatus )#endif		if( a && b )		{			if( a->mPresenceStatus < b->mPresenceStatus )				return -1;			else if( a->mPresenceStatus > b->mPresenceStatus )				return +1;		}	return RelString(itemA->GetNameForSort(), itemB->GetNameForSort(), false, false);}