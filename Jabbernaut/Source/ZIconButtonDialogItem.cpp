/****************************************************************************************************			ZIconButtonDialogItem.cpp		-- a versatile graphical button class******			© 2000, Max Horn****************************************************************************************************/#include	"ZIconButtonDialogItem.h"#include	"ZDialog.h"#include	"ZGrafState.h"#include	"MacZoop.h"CLASSCONSTRUCTOR( ZIconButtonDialogItem );/*-------------------------------***   CONSTRUCTOR   ***--------------------------------*/ZIconButtonDialogItem::ZIconButtonDialogItem( ZDialog* aBoss, const short anID )	: ZDialogItem( aBoss, anID ){	classID = CLASS_ZIconButtonDialogItem;		itsType = kPushButton;	itsStyle = kIconButton;	isPushed = false;		normalResID = -1;	pushedResID = -1;	normalDisResID = -1;	pushedDisResID = -1;}/*-------------------------------***   CONSTRUCTOR   ***--------------------------------*/ZIconButtonDialogItem::ZIconButtonDialogItem()	: ZDialogItem(){	classID = CLASS_ZIconButtonDialogItem;		itsType = kPushButton;	itsStyle = kIconButton;	isPushed = false;		normalResID = -1;	pushedResID = -1;	normalDisResID = -1;	pushedDisResID = -1;}/*--------------------------------***   DESTRUCTOR   ***--------------------------------*/ZIconButtonDialogItem::~ZIconButtonDialogItem(){}/*-------------------------------***   INITITEM   ***-----------------------------------*//*initialise button from template resources	----------------------------------------------------------------------------------------*/void ZIconButtonDialogItem::InitItem( const short paramCount, const long params[] ){	ButtonTemplateHdl	bTmplH = NULL;		// If we have not at least one parameter, return immediatly.	if( paramCount == 0 )		return;			// The first parameter give the id of the button resource.		FailNILRes( bTmplH = (ButtonTemplateHdl)GetResource( kButtonTemplateResType, params[0] ) );			// Set up the button using the settings pointed at by bTmplH		itsType 		= (**bTmplH).btType;	itsStyle 		= (**bTmplH).btStyle;	isPushed		= false;	normalResID		= (**bTmplH).btNormalResID;	pushedResID		= (**bTmplH).btPushedResID;	normalDisResID	= (**bTmplH).btNormalDisResID;	pushedDisResID	= (**bTmplH).btPushedDisResID;			// Clean up:		ReleaseResource( (Handle)bTmplH );}/*-------------------------------***   CLICK   ***--------------------------------------*//*process mouse click in the button----------------------------------------------------------------------------------------*/void ZIconButtonDialogItem::Click( const Point aMousePt, const short modifiers ){	ZDialog*	zd = (ZDialog*) GetBoss();		// We track the button and respond to the  mouse up.		if ( TrackButton() )	{		switch ( itsType )		{			case kPushButton:				// send the command to the boss				// FIX ME				//SendCommand();				break;							case kToggleButton://				SelectButton( ( itsState == kButtonNormal ) ? kButtonPushed : kButtonNormal );				break;		}		zd->ClickItem( id );	}}/*-------------------------------***   DRAWITEM   ***-----------------------------------*//*draw the button in the current state, style, etc----------------------------------------------------------------------------------------*/void ZIconButtonDialogItem::DrawItem(){	// draws the button in the current state according to the current style, etc.		Rect		r = bounds;	short		resID;	short		transform = kTransformNone;		ZGrafState	zg;		PenNormal();	ClipRect( &bounds );			// set port to black and white	SetPortBlackWhite();			// determine the correct res ID for drawing.		if( IsEnabled() )	{		if( isPushed == false )		{			resID = normalResID;			if( resID == -1 )			{				transform = kTransformDisabled;			}		}		else		{			resID = pushedResID;			if( resID == -1 )			{				resID = normalResID;				transform = kTransformSelected;			}		}	}	else	{		if( isPushed == false )		{			resID = normalDisResID;			if( resID == -1 )			{				resID = normalResID;				transform = kTransformDisabled;			}		}		else		{			resID = pushedDisResID;			if( resID == -1 )			{				resID = pushedResID;				if( resID != -1 )					transform = kTransformDisabled;				else				{					resID = normalResID;					transform = kTransformSelectedDisabled;				}			}		}	}		if( resID == -1 )	{		EraseRect( &bounds );	}	else	{		switch( itsStyle )		{			case kIconButton:			{				// For icon button, plot icon with ID in <resID>. We use the				// icon's true rect, centred in the button.				CIconHandle	ciH;				ciH = GetCIcon( resID );								if ( ciH )				{					r = ( **ciH ).iconMask.bounds;					OffsetRect( &r, -r.left, -r.top );					OffsetRect( &r,								( bounds.right + bounds.left) / 2 - ( r.right / 2 ),								( bounds.top + bounds.bottom) / 2 - ( r.bottom / 2 ) );																		PlotCIconHandle( &r,									 atVerticalCenter + atHorizontalCenter,									 transform,									 ciH );					DisposeCIcon( ciH );				}				break;			}						// FIX ME - the code for PICTs is incomplete... we might want to remove it?!?			case kPictButton:			{				// For picture button, plot picture with ID in <resID>.				// We use the picture's true rect, centred in the button.				PicHandle	picH;				picH = GetPicture( resID );								if( picH )				{					r = ( **picH ).picFrame;					OffsetRect( &r, -r.left, -r.top );					OffsetRect( &r,								(bounds.right + bounds.left) / 2 - ( r.right / 2 ),								(bounds.top + bounds.bottom) / 2 - ( r.bottom / 2 ) );													DrawPicture( picH, &r );					ReleaseResource( (Handle)picH );				}				break;			}		}	}/*	if ( !hilited )	{		PenPat( QDGRAYPATTERN );		PenMode( patBic );		PaintRect( &bounds );	}*/}			/*---------------------------***  DOHIGHLIGHTSELECTION  ***-----------------------------*//*set button's state, if different to current one----------------------------------------------------------------------------------------*/void ZIconButtonDialogItem::DoHilightSelection( Boolean hiliteIt ){	if ( isPushed != hiliteIt )	{		isPushed = hiliteIt;				DrawItem();	}}/*-------------------------------***   TRACKBUTTON   ***--------------------------------*//*track mouse in button, highlighting as we go----------------------------------------------------------------------------------------*/Boolean ZIconButtonDialogItem::TrackButton()	{	Point	mouse;	Boolean	isIn = TRUE, wasIn = FALSE;		// assume mouse is initially in		while( WaitMouseUp() )	{		if ( isIn != wasIn )		{			DoHilightSelection( isIn );					wasIn = isIn;		}				GetMouse( &mouse );		isIn = PtInRect( mouse, &bounds );	}		// mouse released, so unhilight button		DoHilightSelection( false );		return wasIn;}