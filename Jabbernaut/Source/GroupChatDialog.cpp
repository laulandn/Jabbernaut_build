///--------------------------------------------------------------------------------------//	File:		GroupChatDialog.cpp//	Project:	Jabbernaut////	Purpose:	<default>//	Created:	Thursday, 2000-05-18///	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"ChatView.h"#include	"ChatManager.h"//#include	"GroupChatRosterView.h"#include	"GroupChatDialog.h"#include	"GroupChatManager.h"#include	"JabberUtils.h"#include	"PrefsManager.h"#include	"PresenceManager.h"#include	"SendManager.h"#include	"MemoryOps.h"#include	"Messages.h"#include	"UniqueID.h"///- Contants ---------------------------------------------------------------------------#pragma mark -#pragma mark === Contants ===enum{	kGroupChatDialogID	= 1005};enum{	// Attention: our code requires that these first four items are identical to those	// in the normal chat dialog!!	kGroupChatNicksID		= 5};#pragma mark -#pragma mark [Class Init]///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------GroupChatDialog::GroupChatDialog( ZCommander* aBoss, const short windowID, const MacJLib::JID &inJid, const std::string &inNick )	: ChatDialog( aBoss, windowID, inJid, "" ){	// We store out nick in the resource of the targetJID - this implies	// we have to strip it out when we send a message to a group, but simplifies	// some other code.	mTargetJID.setResource( inNick );/*	mNick = inNick;		// Clear the resource (just for extra safety), since we're supposed to talk	// to the _group_ which is addressed by leaving the resource empty.	mTargetJID.setResource( "" );*/}///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------GroupChatDialog::GroupChatDialog( const MacJLib::JID &inJid, const std::string &inNick )	: ChatDialog( gApplication, kGroupChatDialogID, inJid, "" ){	// We store out nick in the resource of the targetJID - this implies	// we have to strip it out when we send a message to a group, but simplifies	// some other code.	mTargetJID.setResource( inNick );/*	mNick = inNick;		// Clear the resource (just for extra safety), since we're supposed to talk	// to the _group_ which is addressed by leaving the resource empty.	mTargetJID.setResource( "" );*/}///--------------------------------------------------------------------------------------//	¥ Destructor:///--------------------------------------------------------------------------------------GroupChatDialog::~GroupChatDialog(){	// Part the group chat by sending unavailable presence	mTargetJID.setResource("");	PresenceManager::SendPresence( mTargetJID, "unavailable" );	// ATTENTION: ChatManager::RemovedChatDialog(this); is called, too!	// this shouldn't be a problem, though. Just be aware of this!	GroupChatManager::RemovedGroupChatDialog(this);}#pragma mark -///--------------------------------------------------------------------------------------//	InitZWindow://		//		//	Changes://		2000-06-19	MH		Created///--------------------------------------------------------------------------------------void	GroupChatDialog::InitZWindow(){	inherited::InitZWindow();	//	FailNIL( mListItem = dynamic_cast<GroupChatRosterView *>(GetItem(kGroupChatNicksID)) );}///--------------------------------------------------------------------------------------//	Type://		Do tab completion.//		//	Changes://		2000-08-17	MH		Created///--------------------------------------------------------------------------------------void	GroupChatDialog::Type( const char theKey, const short modifiers ){#if 0using std::string;	ASSERT("mListItem == NULL",mListItem,0);		if ( theKey == TAB_KEY && focusItem == mChatView->GetEditLineItem() )	{		// OK, try to do tab completion/*		string		msg;		string		lastword;				GetValueAsString( msg );		// Search for the last whitespace		string::size_type n = msg.find_last_of(" ");		if (n != string::npos)			lastword = msg.substr(n+1);		else			lastword = msg;*/	}	else#endif		inherited::Type( theKey, modifiers );}#pragma mark -///--------------------------------------------------------------------------------------//	OnPresence://		OnPresence updates the nick list//		//	Changes://		2000-05-22	MH		Created///--------------------------------------------------------------------------------------void	GroupChatDialog::OnPresence( const MacJLib::PresenceMsg &aMsg ){/*	ASSERT("mListItem == NULL",mListItem,0);		mListItem->OnPresence( aMsg );*/}///--------------------------------------------------------------------------------------//	OnMessage://		OnMessage adds the body of aMsg to the chat view//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	GroupChatDialog::OnMessage( const MacJLib::MessageMsg &aMsg ){//	ASSERT("mListItem == NULL",mListItem,0);		// tell the list item, so it can draw "idle" users grayed out//	mListItem->OnMessage( aMsg );	// is this is a server message?	if( !aMsg.getFrom().hasResource() )	{		mChatView->AppendChatData( MacJLib::emptyJID,									aMsg.getBody(),									PrefsManager::GetPrefsRec().mColorServer,									PrefsManager::GetPrefsRec().mTimestampsInGC,									aMsg.getTimeStamp() );	}	else	{		// Use a different color depending on who sent message...		if( aMsg.getFrom().getResource() != mTargetJID.getResource() )		{			JabberUtils::DoEventNotify( PrefsManager::GetPrefsRec().mEventGroupchatMsg );			mChatView->AppendChatData( aMsg.getFrom(),										aMsg.getBody(),										(aMsg.getType() == "groupchat" ) ? PrefsManager::GetPrefsRec().mColorDefault : PrefsManager::GetPrefsRec().mColorPrivate,										PrefsManager::GetPrefsRec().mTimestampsInGC,										aMsg.getTimeStamp() );		}		else			mChatView->AppendChatData( aMsg.getFrom(),										aMsg.getBody(),										PrefsManager::GetPrefsRec().mColorOwn,										PrefsManager::GetPrefsRec().mTimestampsInGC,										aMsg.getTimeStamp() );	}		// FIX ME		// display the channel topic somewhere...	if( !aMsg.getSubject().empty() )		SetSubject( aMsg.getSubject() );}#pragma mark -///--------------------------------------------------------------------------------------//	ChangeOwnNick://		Called if your nick has changed.//		//	Changes://		2000-06-19	MH		Created///--------------------------------------------------------------------------------------void	GroupChatDialog::ChangeOwnNick( const std::string &nick ){//	ASSERT("mListItem == NULL",mListItem,0);	//	mListItem->RemoveNick( mTargetJID.getResource() );#if !_DEBUG_//FIX ME//add handler for x:gc/*<iq from='jnaut@irc.jabber.org' type='set'>	<query xmlns='jabber:x:gc'><nick>test</nick>	</query></iq>*/#endif	mTargetJID.setResource( nick );//	mListItem->AddNick( mTargetJID.getResource() );	SetTitleToTargetJID();}///--------------------------------------------------------------------------------------//	ContainsNick://		Check whether the specified nick is contained in the nick list.//		//	Changes://		2000-07-24	MH		Created///--------------------------------------------------------------------------------------bool	GroupChatDialog::ContainsNick( const std::string &nick ){/*	ASSERT("mListItem == NULL",mListItem,0);	return mListItem->ContainsNick( nick );*/	return	false;}#pragma mark -///--------------------------------------------------------------------------------------//	SendLine://		Send out a line. Process command if required//		//	Changes://		2000-06-19	MH		Created///--------------------------------------------------------------------------------------void	GroupChatDialog::SendLine( const std::string &text ){	MacJLib::MessageMsgHeader	theMsgHeader;		// set the recipient	theMsgHeader.to = mTargetJID;	theMsgHeader.to.setResource("");		// insert the message text	theMsgHeader.body = text;	// generate an unique ID	theMsgHeader.id = GenerateUniqueID();	// set to type "groupchat"	theMsgHeader.type = "groupchat";	// make sure thread is set correctly!	theMsgHeader.thread = mThreadID;		// check if this was a command	if( text[0] == '/' )	{		StringList				tokens;		std::string				command;				// Tokenize the input		JabberUtils::Tokenize( text, " \t", tokens );				// The first token is the command		command = tokens.front();		tokens.pop_front();				if( command == "/nick" && !tokens.empty() )		{			// Nick change -> second token is the desired new nick			std::string	nick = tokens.front();						ChangeOwnNick( nick );			PresenceManager::SendPresence( mTargetJID );		}		else if( command == "/msg" && (tokens.size() > 1 ) )		{			std::string	nick = tokens.front();			std::string	body;						theMsgHeader.to.setResource(nick);			tokens.pop_front();						// FIX ME			theMsgHeader.body.clear();			for(StringList::const_iterator X = tokens.begin(); X != tokens.end(); ++X)				theMsgHeader.body += *X + " ";						body = "->" + nick + ": " + theMsgHeader.body;						// set to type "normal", i.e. empty it//			theMsgHeader.type.clear();			theMsgHeader.type = "chat";			SendManager::SendMessage( theMsgHeader );			mChatView->AppendChatData( mTargetJID,										body,										PrefsManager::GetPrefsRec().mColorPrivate,										PrefsManager::GetPrefsRec().mTimestampsInGC );		}		else if( command == "/query" && !tokens.empty()  )		{			ChatDialog*	theChatDialog;			std::string	nick = tokens.front();						theMsgHeader.to.setResource(nick);			FailNIL( theChatDialog = ChatManager::CreateChatDialog( theMsgHeader.to, GenerateUniqueID() ) );			theChatDialog->Select();		}		else if( command == "/me" )		{			// The command /me is ignored; the receiving client has to handle it			SendManager::SendMessage( theMsgHeader );		}		else if( command == "/clear" )		{			// clear the chat item			mChatView->ClearChatData();		}		else if( command == "/quit" || command == "/part" || command == "/leave" )		{			// just close this window			Close( kRunning );		}	}	else	{		// fire it up!		SendManager::SendMessage( theMsgHeader );	}}///--------------------------------------------------------------------------------------//	ChangeSubject://		Send out a new subject//		//	Changes://		2000-07-29	MH		Created///--------------------------------------------------------------------------------------void	GroupChatDialog::ChangeSubject( const std::string &subject ){	MacJLib::MessageMsgHeader	theMsgHeader;		// set the recipient	theMsgHeader.to = mTargetJID;	theMsgHeader.to.setResource("");		// insert the message text	theMsgHeader.body = "/me changed the subject to: " + subject;	theMsgHeader.subject = subject;	// generate an unique ID	theMsgHeader.id = GenerateUniqueID();	// set to type "groupchat"	theMsgHeader.type = "groupchat";	// make sure thread is set correctly!	theMsgHeader.thread = mThreadID;		// fire it up!	SendManager::SendMessage( theMsgHeader );}