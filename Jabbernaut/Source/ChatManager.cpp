///--------------------------------------------------------------------------------------//	File:		ChatManager.cpp//	Project:	Jabbernaut////	Purpose:	<default>//	Created:	Thursday, 2000-05-18//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"ChatDialog.h"#include	"ChatInviteDialog.h"#include	"ChatManager.h"#include	"ConnectionManager.h"#include	"GroupChatManager.h"#include	"PrefsManager.h"#include	"SoundManager.h"#include	"Messages.h"#include	"UniqueID.h"///- Static Members ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Members ===ZChatDialogList		*ChatManager::msChatDialogs = NULL;JThreadIDList		ChatManager::msInviteeThreads;#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Give this manager a chance to initate static members etc.//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	ChatManager::Init(){	ASSERT("msChatDialogs != NULL",msChatDialogs == NULL,0);	FailNIL( msChatDialogs = new ZChatDialogList() );}///--------------------------------------------------------------------------------------//	Deinit://		Give this manager a chance to dispose static members etc.//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	ChatManager::Deinit(){//	if( msChatDialogs )//		ForgetObject( msChatDialogs );}#pragma mark -///--------------------------------------------------------------------------------------//	DoInviteToChat://		Open a "Invite to Chat" dialog//		//	Changes://		2000-05-18	MH		Created///--------------------------------------------------------------------------------------void	ChatManager::DoInviteToChat( const MacJLib::JID &inJID ){	ChatInviteDialog	*aDialog;		FailNIL( aDialog = new ChatInviteDialog());		try	{		aDialog->InitZWindow();		aDialog->Place();	}	catch( ZoopError err )	{		ForgetObject( aDialog );				throw err;	}	aDialog->SetTargetJID( inJID );	aDialog->Select();}#pragma mark -///--------------------------------------------------------------------------------------//	DispatchMessageMsg://		Check if there's a dialog open to handle the message, otherwise create one//		//	Changes://		2000-05-09	MH		Created///--------------------------------------------------------------------------------------void	ChatManager::DispatchMessageMsg( MacJLib::MessageMsg &aMsg ){	ASSERT("msChatDialogs == NULL",msChatDialogs,0);		ChatDialog*	theChatDialog;	if( JabberUtils::MatchString( aMsg.getFrom().getFull(),									PrefsManager::GetPrefsRec().mBlockJIDList ) )		return;	theChatDialog = FindChatDialog( aMsg.getFrom(),aMsg.getThread() );		if ( ! theChatDialog )	{		// Let the GroupChatManager check if this message was for him. If yes, do nothing further.		if( GroupChatManager::MaybeDispatchMessageMsg( aMsg ) )			return;				// Check if this is a response to an invitation we offered. If no,		// treat this as an invitation adressed to us.				bool	match = false;				for( JThreadIDList::const_iterator X = msInviteeThreads.begin(); X != msInviteeThreads.end(); ++X )		{			if( *X == aMsg.getThread() )			{				// FIX ME inefficient code				match = true;				msInviteeThreads.remove( aMsg.getThread() );				break;			}		}		#if !_DEBUG_/*		if( !match )			AskForPermission();		else			FIX ME			*/#endif				FailNIL( theChatDialog = CreateChatDialog( aMsg.getFrom(),aMsg.getThread() ));		// make a sound!		if( PrefsManager::GetPrefsRec().mEventChatMsg.soundOn )			SoundManager::Play( 1002 );	}		theChatDialog->OnMessage( aMsg );#ifdef	FIX_ME	theChatDialog->CleverSelect();#else	theChatDialog->Select();#endif}///--------------------------------------------------------------------------------------//	RemovedChatDialog://		This is called whenever a ChatDialog is closed so we can remove it from our list//		//	Changes://		2000-05-09	MH		Created///--------------------------------------------------------------------------------------void	ChatManager::RemovedChatDialog( ChatDialog* dead ){	ASSERT("msChatDialogs == NULL",msChatDialogs,0);		FailNILParam( dead );		msChatDialogs->DeleteObject( dead );}///--------------------------------------------------------------------------------------//	FindChatDialog://		Searches a chat dialog matching inJID and returns it - or NULL//		//	Changes://		2000-05-22	MH		Created///--------------------------------------------------------------------------------------ChatDialog*	ChatManager::FindChatDialog( const MacJLib::JID &inJID, const std::string &inThread ){	ASSERT("msChatDialogs == NULL",msChatDialogs,0);		ChatDialog*	theChatDialog;	long		i;		for ( i = 1; i <= msChatDialogs->CountItems(); i++ )	{			theChatDialog = dynamic_cast<ChatDialog*>(msChatDialogs->GetObject( i ));		if( PrefsManager::GetPrefsRec().mChatIgnoreThread || inThread.empty() )		{			if( theChatDialog->mTargetJID.strictCompare(inJID) )				return theChatDialog;		}		else		{			if( theChatDialog->mThreadID == inThread )				return theChatDialog;		}/*		if ( theChatDialog->mThreadID == inThread )			if( theChatDialog->mTargetJID == inJID )				return theChatDialog;*/	}		return NULL;}///--------------------------------------------------------------------------------------//	CreateChatDialog://		Creates a new chat dialog (but doesn't open it).//		//	Changes://		2000-07-25	MH		Created///--------------------------------------------------------------------------------------ChatDialog*	ChatManager::CreateChatDialog( const MacJLib::JID &inJID, const std::string &inThread ){	ASSERT("msChatDialogs == NULL",msChatDialogs,0);		ChatDialog*	theChatDialog;		FailNIL( theChatDialog = new ChatDialog( inJID, inThread ));		try	{		theChatDialog->InitZWindow();		theChatDialog->Place();	}	catch( ZoopError err )	{		ForgetObject( theChatDialog );				throw err;	}	msChatDialogs->AppendItem( theChatDialog );		return theChatDialog;}#pragma mark -///--------------------------------------------------------------------------------------//	InviteToChat://		Send an invite message to someone (in fact, this is a simple <message>//		//	Changes://		2000-05-23	MH		Created///--------------------------------------------------------------------------------------void	ChatManager::InviteToChat( const MacJLib::JID& inJID, const std::string &inReason ){// FIX ME - this should check if there's already a chat with this person ?!	MacJLib::MessageMsgHeader	aMessageHeader;		aMessageHeader.to = inJID;	aMessageHeader.type = "chat";	aMessageHeader.id = GenerateUniqueID();	aMessageHeader.body = inReason;	aMessageHeader.thread = GenerateUniqueID();		// now remember this thread ID so we can use it to recognize a chat we have	// initiated (and thus don't ask the user for permission)	// FIXME: add a timeout for invitations!	msInviteeThreads.push_back( aMessageHeader.thread );		ConnectionManager::PostMessage( new MacJLib::MessageMsg(&aMessageHeader) );}