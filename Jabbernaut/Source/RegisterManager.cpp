///--------------------------------------------------------------------------------------//	File:		RegisterManager.cpp//	Project:	Jabbernaut////	Purpose:	<default>//	Created:	Monday, 2000-07-10//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"ZProgress.h"#include	"AgentsManager.h"#include	"ConnectionManager.h"#include	"ErrorManager.h"#include	"RegisterManager.h"#include	"RegistrationDialog.h"#include	"BaseClient.h"#include	"Messages.h"#include	"UniqueID.h"using	MacJLib::MsgListener;///- Macros -----------------------------------------------------------------------------#pragma mark -#pragma mark === Macros ===#define		YieldTillConditionOrTimeout(cond, p, timeoutDuration)					\					while( !(cond) )												\					{																\						long	timeoutStart = TickCount();							\						if( (timeoutStart + (timeoutDuration)*60) < TickCount() )	\							throw (ZoopError)kTimeOutErr;							\						YieldToAnyThread();											\						p.InformProgress( 1 );										\					}///- Static Members ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Members ===ZObjectList				*RegisterManager::msRegisterDialogs = NULL;RegisterQueryList		RegisterManager::msRegisterQueryIDs;RegisterQueryList		RegisterManager::msRegisterAttemptIDs;RegisterQueryList		RegisterManager::msUnregisterAttemptIDs;#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Give this manager a chance to initate static members etc.//		//	Changes://		2000-07-10	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::Init(){	ASSERT("msRegisterDialogs != NULL",msRegisterDialogs == NULL,0);	FailNIL( msRegisterDialogs = new ZObjectList() );}///--------------------------------------------------------------------------------------//	Deinit://		Give this manager a chance to dispose static members etc.//		//	Changes://		2000-07-10	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::Deinit(){	if( msRegisterDialogs )		ForgetObject( msRegisterDialogs );}#pragma mark -///--------------------------------------------------------------------------------------//	DispatchIQErrorMsg://		Check if one of our registration attempts failed//		//	Changes://		2000-08-02	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::DispatchIQErrorMsg( const MacJLib::IQErrorMsg &aMsg ){	RegisterQueryList::iterator	X;		X = msRegisterAttemptIDs.find( aMsg.getID() );	if( X != msRegisterAttemptIDs.end() )	{		msRegisterAttemptIDs.erase( X );				ErrorManager::ReportFailure( kErrorStrID, kRegisterAgentFailed, aMsg.getErrorType());	}			X = msUnregisterAttemptIDs.find( aMsg.getID() );	if( X != msUnregisterAttemptIDs.end() )	{		msUnregisterAttemptIDs.erase( X );				// FIX ME		// unregister failed -> tell user!	}}///--------------------------------------------------------------------------------------//	DispatchIQResultMsg://		Check if one of our registration attempts was succesful//		//	Changes://		2000-08-02	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::DispatchIQResultMsg( const MacJLib::IQResultMsg &aMsg ){	RegisterQueryList::iterator	X;		X = msRegisterAttemptIDs.find( aMsg.getID() );	if( X != msRegisterAttemptIDs.end() )	{		ZHLAgentItem*	zhlAI;		JID				targetJID(X->second.target);				msRegisterAttemptIDs.erase( X );				zhlAI = AgentsManager::FindZHLAgentItem( targetJID );		zhlAI->setRegistered( true );				// FIX ME		// register succesfull -> tell user?!?	}	X = msUnregisterAttemptIDs.find( aMsg.getID() );	if( X != msUnregisterAttemptIDs.end() )	{		ZHLAgentItem*	zhlAI;		JID				targetJID(X->second.target);		msUnregisterAttemptIDs.erase( X );				zhlAI = AgentsManager::FindZHLAgentItem( targetJID );		zhlAI->setRegistered( false );				// FIX ME		// unregister succesfull -> tell user?!?	}}///--------------------------------------------------------------------------------------//	DispatchRegisterMsg://		Dispatch the msg based on its type...//		//	Changes://		2000-07-10	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::DispatchRegisterMsg( const MacJLib::RegisterMsg &aMsg ){//	if( !aMsg.isRegistered() && (aMsg.getType() == "result") )	if( msRegisterQueryIDs.count( aMsg.getID() ) > 0 )	{		msRegisterQueryIDs.erase( aMsg.getID() );				if( aMsg.getType() == "result" )		{			RegistrationDialog*	theRegistrationDialog;						theRegistrationDialog = FindRegisterDialog( aMsg.getFrom() );						if( theRegistrationDialog == NULL )				theRegistrationDialog = CreateRegisterDialog( aMsg );						theRegistrationDialog->Select();		}	}}#pragma mark -class	UniqueRegisterMsgListener : MsgListener{public:	UniqueRegisterMsgListener(std::string id) : MsgListener(), mID(id), mZPD(NULL)		{			// FIX ME			// Incoming message pop up *over* our progress dialog, which is a bad thing									//			// Open a progress dialog to show the user we are doing something			//				FailNIL( mZPD = new ZProgress( gApplication, kStdProgressResID, 1, kCancelType, kIndeterminateProgress ) );						// Give it two seconds - if it's not finished then, show a progress dialog			mZPD->SetDelay( kTwoSeconds );			mZPD->SetMessage( "\pPreparing agent registrationÉ" );		}	~UniqueRegisterMsgListener()		{			ForgetObject(mZPD)		}	void	onError( IQErrorMsg &inError )		{			if( mID == inError.getID() )			{				mZPD->Hide();				ErrorManager::ReportFailure( kErrorStrID, kRegisterAgentFailed, inError.getErrorType());			}		}	void	onResult( IQResultMsg &inResult )		{			if( mID == inResult.getID() )			{				mZPD->Hide();			}		}	void	onRegister( RegisterMsg &inResult )		{			if( (mID == inResult.getID()) && (inResult.getType() == "result") )			{				RegistrationDialog*	theRegistrationDialog;								mZPD->Hide();/*				theRegistrationDialog = FindRegisterDialog( inResult.getFrom() );								if( theRegistrationDialog == NULL )					theRegistrationDialog = CreateRegisterDialog( inResult );								theRegistrationDialog->Select();*/			}		}	private:	ZProgress		*mZPD;	std::string		mID;};///--------------------------------------------------------------------------------------//	DoRegister://		Initiates a register//		//	Changes://		2000-08-02	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::DoRegister( const MacJLib::JID &agentJID ){	RegistrationDialog*	theRegistrationDialog;		theRegistrationDialog = FindRegisterDialog( agentJID );	if( theRegistrationDialog == NULL )	{		MacJLib::RegisterMsg	*anRegisterMsg;		std::string				uniqueID;		uniqueID = GenerateUniqueID();		msRegisterQueryIDs.insert( make_pair(uniqueID,					RegisterQuery(agentJID, MacJLib::GetTimeSeconds() + kRegisterTimeout)) );		FailNIL( anRegisterMsg = new MacJLib::RegisterMsg() );		anRegisterMsg->setType( "get" );		anRegisterMsg->setTo( agentJID );		anRegisterMsg->setID( uniqueID );		ConnectionManager::PostMessage( anRegisterMsg );/////////////////////////////////////////////////////////////*			try			{				YieldTillConditionOrTimeout( , *mZPD, connectTimeoutSecs );			}			catch( ZoopError err )			{				// Check if the user canceld. If yes, return immediatly.				if( err == userCanceledErr )					return;				else if( err == kTimeOutErr )					// FIX ME!!!!					ErrorManager::ReportFailure( kErrorStrID, kLoginFailedTimeoutIndex, err );			}*/////////////////////////////////////////////////////////////	}	else	{		theRegistrationDialog->Select();	}}///--------------------------------------------------------------------------------------//	DoUnregister://		Initiates a register//		//	Changes://		2000-08-02	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::DoUnregister( const MacJLib::JID &agentJID ){	MacJLib::RegisterMsg	*anRegisterMsg;	std::string				uniqueID;	uniqueID = GenerateUniqueID();	msUnregisterAttemptIDs.insert( make_pair(uniqueID,					RegisterQuery(agentJID, MacJLib::GetTimeSeconds() + kRegisterTimeout)) );	FailNIL( anRegisterMsg = new MacJLib::RegisterMsg() );	anRegisterMsg->setType( "set" );	anRegisterMsg->setTo( agentJID );	anRegisterMsg->setID( uniqueID );	anRegisterMsg->setRemove( true );	ConnectionManager::PostMessage( anRegisterMsg );		//FIX ME		//Add a timeout}#pragma mark -///--------------------------------------------------------------------------------------//	FindRegisterDialog://		Searches a register dialog matching inJID and returns it - or NULL//		//	Changes://		2000-08-15	MH		Created///--------------------------------------------------------------------------------------RegistrationDialog*	RegisterManager::FindRegisterDialog( const JID &inJID ){	ASSERT("msRegisterDialogs == NULL",msRegisterDialogs,0);		RegistrationDialog*	theRegistrationDialog;	long		i;		for ( i = 1; i <= msRegisterDialogs->CountItems(); i++ )	{			theRegistrationDialog = dynamic_cast<RegistrationDialog *>(msRegisterDialogs->GetObject( i ));		if( theRegistrationDialog->getJID() == inJID )			return theRegistrationDialog;	}		return NULL;}///--------------------------------------------------------------------------------------//	CreateRegisterDialog://		Creates a new register dialog (but doesn't open it).//		//	Changes://		2000-08-15	MH		Created///--------------------------------------------------------------------------------------RegistrationDialog*	RegisterManager::CreateRegisterDialog( const MacJLib::RegisterMsg &aMsg ){	ASSERT("msRegisterDialogs == NULL",msRegisterDialogs,0);		RegistrationDialog*	theRegistrationDialog;		FailNIL( theRegistrationDialog = new RegistrationDialog( aMsg ));		try	{		theRegistrationDialog->InitZWindow();		theRegistrationDialog->Place();	}	catch( ZoopError err )	{		ForgetObject( theRegistrationDialog );				throw err;	}	msRegisterDialogs->AppendItem( theRegistrationDialog );		return theRegistrationDialog;}///--------------------------------------------------------------------------------------//	RemovedRegisterDialog://		This is called whenever a RegistrationDialog is closed so we can remove it from our list//		//	Changes://		2000-08-15	MH		Created///--------------------------------------------------------------------------------------void	RegisterManager::RemovedRegisterDialog( RegistrationDialog* dead ){	ASSERT("msRegisterDialogs == NULL",msRegisterDialogs,0);		FailNILParam( dead );		msRegisterDialogs->DeleteObject( dead );}