///--------------------------------------------------------------------------------------//	File:		PrefsManager.cpp//	Project:	Jabbernaut////	Purpose:	This module manages the preferences and handles the prefs dialog//	Created:	Friday, 2000-05-26//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"ZFile.h"#include	"JabberUtils.h"#ifndef TOQ  #include	"PrefsDialog.h"#endif#include	"PrefsManager.h"#include	"RosterManager.h"#include	"MacJLibPrefix.h"#include	"ExpatParser.h"#include	"NodeBuildingHandler.h"#include	<Keychain.h>///- Macros -----------------------------------------------------------------------------#pragma mark -#pragma mark === Macros ===#define	StoreMetagroup(tree, lcase, ucase, s, o, meta, metaText, group, groupText, item, itemText, resource, resourceText)	do { \	tree->PathGetValue( "settings/roster/metagroups/"#lcase"/show", prefsRec.mGroup##ucase##.show, s );	\	tree->PathGetValue( "settings/roster/metagroups/"#lcase"/open", prefsRec.mGroup##ucase##.open, o );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/meta", prefsRec.mGroup##ucase##.metaColor, meta );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/metatext", prefsRec.mGroup##ucase##.metaTextColor, metaText );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/group", prefsRec.mGroup##ucase##.groupColor, group );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/grouptext", prefsRec.mGroup##ucase##.groupTextColor, groupText );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/item", prefsRec.mGroup##ucase##.itemColor, item );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/itemtext", prefsRec.mGroup##ucase##.itemTextColor, itemText );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/resource", prefsRec.mGroup##ucase##.resourceColor, resource );	\	PathGetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/resourcetext", prefsRec.mGroup##ucase##.resourceTextColor, resourceText );	\	} while(0)#define	LoadMetagroup(tree, lcase, ucase)	do { \	tree->PathSetValue( "settings/roster/metagroups/"#lcase"/show", prefsRec.mGroup##ucase##.show );	\	tree->PathSetValue( "settings/roster/metagroups/"#lcase"/open", prefsRec.mGroup##ucase##.open );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/meta", prefsRec.mGroup##ucase##.metaColor );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/metatext", prefsRec.mGroup##ucase##.metaTextColor );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/group", prefsRec.mGroup##ucase##.groupColor );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/grouptext", prefsRec.mGroup##ucase##.groupTextColor );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/item", prefsRec.mGroup##ucase##.itemColor );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/itemtext", prefsRec.mGroup##ucase##.itemTextColor );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/resource", prefsRec.mGroup##ucase##.resourceColor );	\	PathSetRGBValue( tree, "settings/roster/metagroups/"#lcase"/color/resourcetext", prefsRec.mGroup##ucase##.resourceTextColor );	\	} while(0)#define	StoreEventNotify(tree, lcase, ucase, sound, resID, blink, popToFront)	do { \	tree->PathGetValue( "settings/events/"#lcase"/sound/enabled", prefsRec.mEvent##ucase##.soundOn, sound ); \	tree->PathGetValue( "settings/events/"#lcase"/sound/resid", prefsRec.mEvent##ucase##.sndResID, resID ); \	tree->PathGetValue( "settings/events/"#lcase"/blink", prefsRec.mEvent##ucase##.blinkMenu, blink ); \	tree->PathGetValue( "settings/events/"#lcase"/bringToFront", prefsRec.mEvent##ucase##.bringToFront, popToFront ); \	} while(0)#define	LoadEventNotify(tree, lcase, ucase)	do { \	tree->PathSetValue( "settings/events/"#lcase"/sound/enabled", prefsRec.mEvent##ucase##.soundOn ); \	tree->PathSetValue( "settings/events/"#lcase"/sound/resid", prefsRec.mEvent##ucase##.sndResID ); \	tree->PathSetValue( "settings/events/"#lcase"/blink", prefsRec.mEvent##ucase##.blinkMenu ); \	tree->PathSetValue( "settings/events/"#lcase"/bringToFront", prefsRec.mEvent##ucase##.bringToFront ); \	} while(0)#ifdef TOQ  #define		PREFS_BASE_ENTITY	"toq"#else  #define		PREFS_BASE_ENTITY	"jabbernaut"#endif///- Static Members ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Members ===CElementNode*		PrefsManager::msXMLPrefsTree = NULL;PrefsDialog*		PrefsManager::msPrefsDialog = NULL;PrefsRec			PrefsManager::msPrefsRec;PrefsRec			PrefsManager::msBackupPrefsRec;bool				PrefsManager::msHasKeychain = false;ZFile*				PrefsManager::msPrefsFile = NULL;///- Prototypes -------------------------------------------------------------------------#pragma mark -#pragma mark === Prototypes ===OSStatus StorePasswordInKeychain( const std::string &username, const std::string &server, const std::string &password );OSStatus RetrievePasswordFromKeychain( const std::string &username, const std::string &server, std::string &password );#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Give this manager a chance to initate static members etc.//		//	Changes://		2000-06-23	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::Init(){	ASSERT("msPrefsDialog != NULL",msPrefsDialog == NULL,0);		//	// Determine whether the key chain is available.	//#if	TARGET_CPU_PPC && !TARGET_API_MAC_CARBON	msHasKeychain = KeychainManagerAvailable();#else	msHasKeychain = false;#endif#ifndef TOQ	//	// Create the prefs dialog	//	FailNIL( msPrefsDialog = new PrefsDialog());	try	{		msPrefsDialog->InitZWindow();		msPrefsDialog->Place();	}	catch( ZoopError err )	{		ForgetObject( msPrefsDialog );				throw err;	}#endif	//	// Activate the defaul prefs.	//	// FIX ME#ifdef TOQ	FailNIL( msPrefsFile = new ZFile( "\pTOQ.INI" ) );#else	FailNIL( msPrefsFile = new ZFile( "\pDefault Profile" ) );#endif	if( msPrefsFile->IsReal() )		ReadPrefs();	else		ResetPrefs();	}///--------------------------------------------------------------------------------------//	Deinit://		Give this manager a chance to dispose static members etc.//		//	Changes://		2000-06-23	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::Deinit(){	if( msPrefsFile )	{		WritePrefs();		ForgetObject( msPrefsFile );	}		if( msXMLPrefsTree )		ForgetObject( msXMLPrefsTree );}#pragma mark -///--------------------------------------------------------------------------------------//	DoPrefsDialog://		Open the prefs dialog//		//	Changes://		2000-05-26	MH		Created//		2000-06-23	MH		Don't spawn a new dialog each time called but instead//								use a single one!///--------------------------------------------------------------------------------------void	PrefsManager::DoPrefsDialog(){#ifndef TOQ	ASSERT("msPrefsDialog == NULL",msPrefsDialog != NULL,0);	// make the zoom rects appear from the correct spot	gMenuBar->SetZoomSourceToCommand( kCmdDoPreferences );		msPrefsDialog->Select();#endif}#pragma mark -///--------------------------------------------------------------------------------------//	Commit://		Commit the changes the user made to the prefs - this func is called when//			the user confirms the prefs dialog//		//	Changes://		2000-06-23	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::Commit(){	msBackupPrefsRec = msPrefsRec;	if( msPrefsFile )		WritePrefs();}///--------------------------------------------------------------------------------------//	Restore://		Restores the changes the user made to the prefs - this func is called when//			the user cancels the prefs dialog//		//	Changes://		2000-06-23	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::Restore(){	msPrefsRec = msBackupPrefsRec;		RosterManager::NotifyPrefChange();}#pragma mark -///--------------------------------------------------------------------------------------//	ResetPrefs://		Empties the prefs tree, and inits it with the default values//		//	Changes://		2000-06-28	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::ResetPrefs(){	// If there's already prefs tree, dispose it,	if( msXMLPrefsTree )		ForgetObject( msXMLPrefsTree );		// Allocate a fresh prefs tree	FailNIL( msXMLPrefsTree = new CElementNode( PREFS_BASE_ENTITY ) );		// now, set it up with the default values (ReadFromPrefsTree does this for us)	ReadFromPrefsTree( msXMLPrefsTree, msPrefsRec );		// inform the various program parts about the changed prefs#ifndef TOQ	if( msPrefsDialog )		msPrefsDialog->DisplayPrefsRec( msPrefsRec );#endif	RosterManager::NotifyPrefChange();	RosterManager::SortRoster();	//	// Init the backup copy	//	msBackupPrefsRec = msPrefsRec;}///--------------------------------------------------------------------------------------//	ReadPrefs://		Read the prefs from the specified file. It needs to exist and be opened...//		//	Changes://		2000-06-28	MH		Created//		2000-12-23	MH		Modified to always act upon msPrefsFile///--------------------------------------------------------------------------------------void	PrefsManager::ReadPrefs(){	ASSERT("msPrefsFile == NULL",msPrefsFile != NULL,0);		CAbstractNode*					myNode;	if( !msPrefsFile->IsReal() )		return;	if( msXMLPrefsTree )		ForgetObject( msXMLPrefsTree );	{		CNodeBuildingHandler	myHandler;		Ptr						buffer;		long					len;						msPrefsFile->Open();		len = msPrefsFile->GetLength();		FailNIL( buffer = NewPtr( len ) );		msPrefsFile->Read( buffer, &len );		msPrefsFile->Close();		{			CExpatParser			myParser( &myHandler );			myParser.StartParsing();			myParser.Parse( buffer, len );			myParser.EndParsing();		}		DisposePtr( buffer );		myNode = myHandler.DetachRootNode();	}	msXMLPrefsTree = dynamic_cast<CElementNode*>(myNode);	if( msXMLPrefsTree == NULL )		FailNIL( msXMLPrefsTree = new CElementNode( PREFS_BASE_ENTITY ) );	// now, scan the tree for prefs	ReadFromPrefsTree( msXMLPrefsTree, msPrefsRec );		// inform the various program parts about the changed prefs#ifndef TOQ	if( msPrefsDialog )		msPrefsDialog->DisplayPrefsRec( msPrefsRec );#endif	RosterManager::NotifyPrefChange();	RosterManager::SortRoster();		//	// Init the backup copy	//	msBackupPrefsRec = msPrefsRec;}///--------------------------------------------------------------------------------------//	WritePrefs://		Write the prefs to the specified file. It needs to exist and be opened...//		//	Changes://		2000-06-28	MH		Created//		2000-12-23	MH		Modified to always act upon msPrefsFile///--------------------------------------------------------------------------------------void	PrefsManager::WritePrefs(){	ASSERT("msPrefsFile == NULL",msPrefsFile != NULL,0);		std::string			dummy;	long				outLen;		// If the file does not actually exist, create it	if( !msPrefsFile->IsReal() )	{		msPrefsFile->SetType( 'TEXT' );		msPrefsFile->Create();	}		// Create the XML prefs tree if needed	if( NULL == msXMLPrefsTree )		FailNIL( msXMLPrefsTree = new CElementNode( PREFS_BASE_ENTITY, MacJLib::CAttributeMap() ) );		// Write the prefs into the XML prefs tree	WriteToPrefsTree( msXMLPrefsTree, msPrefsRec );		// Convert the XML tree to text	dummy = msXMLPrefsTree->AsString(true);	outLen = dummy.size();	// Open & clear the file	msPrefsFile->Open();	msPrefsFile->SetLength( 0 );	// Write the XML to the file	msPrefsFile->Write((char*)dummy.data(), &outLen);	// Cleanup	msPrefsFile->Close();}#pragma mark -///--------------------------------------------------------------------------------------//	ReadFromPrefsTree://		Read the prefs from the specified node tree//		//	Changes://		2000-07-20	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::ReadFromPrefsTree( const CElementNode* aTree, PrefsRec &prefsRec  ){	ASSERT("aTree == NULL",aTree != NULL,0);	if( aTree->GetName() == PREFS_BASE_ENTITY )	{		//		// Account Prefs		//				// IMPORTANT: get these prefs *before* trying to get the password!#ifndef TOQ		aTree->PathGetValue( "profile/usessl", prefsRec.mUseSSL, false );		aTree->PathGetValue( "profile/savepassword", prefsRec.mSavePassword, true );		aTree->PathGetValue( "profile/usekeychain", prefsRec.mUseKeychain, false );#endif		aTree->PathGetValue( "profile/username", prefsRec.mUsername, "" );		PathGetSecretValue( aTree, "profile/password", prefsRec.mPassword );		aTree->PathGetValue( "profile/resource", prefsRec.mResource, "" );		aTree->PathGetValue( "profile/server", prefsRec.mServer, "jabber.org" );				{		// Use a default port value of 0 - this means, auto, choose!		long	dummy;		aTree->PathGetValue( "profile/port", dummy, 0L );		prefsRec.mServerPort = dummy;		}				//		// General Prefs		//#ifdef TOQ		aTree->PathGetValue( "settings/connection/autologin", prefsRec.mAutoLogin, true );#else		aTree->PathGetValue( "settings/connection/autologin", prefsRec.mAutoLogin, false );#endif		aTree->PathGetValue( "settings/connection/autorelogin", prefsRec.mAutoRelogin, true );#ifndef TOQ		aTree->PathGetValue( "settings/connection/checkversion", prefsRec.mCheckVersion, true );				aTree->PathGetValue( "settings/timestamps/chat", prefsRec.mTimestampsInChat, true );		aTree->PathGetValue( "settings/timestamps/groupchat", prefsRec.mTimestampsInGC, true );				aTree->PathGetValue( "settings/autoaway/enabled", prefsRec.mAutoAway, true );		aTree->PathGetValue( "settings/autoaway/delay", prefsRec.mAutoAwayDelay, 5 );		aTree->PathGetValue( "settings/xautoaway/enabled", prefsRec.mExtendedAutoAway, false );		aTree->PathGetValue( "settings/xautoaway/delay", prefsRec.mExtendedAutoAwayDelay, 15 );		aTree->PathGetValue( "settings/autoaway/autoend", prefsRec.mAutoEndAuoAway, true );#endif				//		// Subscription Prefs		//#ifndef TOQ		aTree->PathGetValue( "settings/subscription/response/onroster", prefsRec.mResponseIfOnRoster, kAskOnPresenceRequest );		aTree->PathGetValue( "settings/subscription/response/notonroster", prefsRec.mResponseIfNotOnRoster, kAskOnPresenceRequest );				aTree->PathGetValue( "settings/subscription/autosubscribe/enabled", prefsRec.mAutoSubscribeBack, true );		aTree->PathGetValue( "settings/subscription/autosubscribe/defaultgroup", prefsRec.mAutoSubscribeGroup, "" );				aTree->PathGetValue( "settings/subscription/rejection/autoreply/enabled", prefsRec.mSendRejectionMsg, false );		aTree->PathGetValue( "settings/subscription/rejection/autoreply/text", prefsRec.mRejectionMsg, "" );#endif		//		// Roster Prefs		//				// meta groups#ifndef TOQ		StoreMetagroup( aTree, online, Online,							true,							true,							RGBColorClass(0x4C00, 0xB300, 0x9100),	gBlack,							RGBColorClass(0xA600, 0xD900, 0xC900),	gBlack,							gVeryLightGray,							RGBColorClass(0x3200, 0x7600, 0x5F00),							gVeryLightGray,							gBlack						);		StoreMetagroup( aTree, myresources, MyResources,							true,							true,							RGBColorClass(0x4C00, 0xB300, 0x9100),	gBlack,							RGBColorClass(0xA600, 0xD900, 0xC900),	gBlack,							gVeryLightGray,							RGBColorClass(0x3200, 0x7600, 0x5F00),							gVeryLightGray,							gBlack						);		StoreMetagroup( aTree, offline, Offline,							true,							false,							RGBColorClass(0xFF00, 0x0000, 0x0000),	gBlack,							RGBColorClass(0xFF00, 0x4C00, 0x4C00),	gBlack,							gVeryLightGray,							RGBColorClass(0xAA00, 0x0000, 0x0000),							gVeryLightGray,							gBlack						);		StoreMetagroup( aTree, pending, Pending,							true,							false,							RGBColorClass(0xFF00, 0x9500, 0x0000),	gBlack,							RGBColorClass(0xFF00, 0xCA00, 0x7F00),	gBlack,							gVeryLightGray,							RGBColorClass(0xA800, 0x6200, 0x0000),							gVeryLightGray,							gBlack						);		StoreMetagroup( aTree, stalkers, Stalkers,							true,							false,							RGBColorClass(0x9900, 0x9900, 0x9900),	gBlack,							RGBColorClass(0xBF00, 0xBF00, 0xBF00),	gBlack,							gVeryLightGray,							gBlack,							gVeryLightGray,							gBlack						);		StoreMetagroup( aTree, agents, Agents,							true,							true,							gVeryLightGray,							gBlack,							gVeryLightGray,							gBlack,							gVeryLightGray,							gBlack,							gVeryLightGray,							gBlack						);		// sorting		aTree->PathGetValue( "settings/roster/sort/bystatus", prefsRec.mRosterSortByStatus, false );				// double click behaviour		aTree->PathGetValue( "settings/roster/doubleclick/sendmsg", prefsRec.mDoubleClickSendsMsg, true );#endif		// should closing the roster quit?		aTree->PathGetValue( "settings/roster/closeQuits", prefsRec.mRosterCloseQuits, false );		//		// Privacy Prefs		//		// only show if sender is on roster		aTree->PathGetValue( "settings/privacy/onlyshowifonroster", prefsRec.mOnlyShowMsgIfOnRoster, false );				// FIX ME		aTree->PathGetValue( "settings/privacy/block", "jid", prefsRec.mBlockJIDList );		//		// Chat Prefs		//#ifndef TOQ		aTree->PathGetValue( "settings/chat/defaultnick", prefsRec.mDefaultNick, "" );		aTree->PathGetValue( "settings/chat/ignorethread", prefsRec.mChatIgnoreThread, true );#endif		//		// Groupchat Prefs		//		#ifndef TOQ		aTree->PathGetValue( "settings/groupchat/idletime", prefsRec.mGroupChatIdleTime, 7 );#endif		//		// Event Prefs		//		StoreEventNotify( aTree, online, Online, true, 1000, false, false );		StoreEventNotify( aTree, offline, Offline, false, 1001, false, false );		StoreEventNotify( aTree, statusChange, StatusChange, true, 1008, false, false );		StoreEventNotify( aTree, normalmsg, NormalMsg, true, 1002, false, false );#ifndef TOQ		StoreEventNotify( aTree, chatmsg, ChatMsg, true, 1003, false, false );		StoreEventNotify( aTree, groupchatmsg, GroupchatMsg, true, 1004, false, false );		StoreEventNotify( aTree, headline, Headline, false, 1005, false, false );#endif		StoreEventNotify( aTree, error, Error, false, 1006, false, false );		StoreEventNotify( aTree, subscribereq, SubscribeReq, false, 1007, false, false );		//		// Color Prefs		//#ifndef TOQ		PathGetRGBValue( aTree, "settings/colors/default", prefsRec.mColorDefault, gBlack );		PathGetRGBValue( aTree, "settings/colors/own", prefsRec.mColorOwn, gBlue );		PathGetRGBValue( aTree, "settings/colors/server", prefsRec.mColorServer, gGreen );		PathGetRGBValue( aTree, "settings/colors/private", prefsRec.mColorPrivate, gDarkGray );		PathGetRGBValue( aTree, "settings/colors/nicklist/ops", prefsRec.mColorOps, gRed );		PathGetRGBValue( aTree, "settings/colors/nicklist/voice", prefsRec.mColorVoice, gGreen );#endif		//		// Debug Prefs		//		aTree->PathGetValue( "settings/debug/showwindows", prefsRec.mShowDebugWindows, false );		aTree->PathGetValue( "settings/debug/timestamps", prefsRec.mShowDebugTimestamps, false );				//		// Hidden Prefs		//#ifdef TOQ		aTree->PathGetValue( "settings/messages/delayincoming", prefsRec.mIncomingMessagesDelayed, false );#else		aTree->PathGetValue( "windows/agents/visible", prefsRec.mAgentsVisible, false );		aTree->PathGetValue( "windows/history/visible", prefsRec.mHistoryVisible, true );		aTree->PathGetValue( "windows/roster/visible", prefsRec.mRosterVisible, true );#endif	}}///--------------------------------------------------------------------------------------//	WriteToPrefsTree://		Read the prefs from the specified node tree//		//	Changes://		2000-07-20	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::WriteToPrefsTree( CElementNode* aTree, const PrefsRec &prefsRec  ){	ASSERT("aTree == NULL",aTree != NULL,0);	{		//		// Account Prefs		//#ifndef TOQ		aTree->PathSetValue( "profile/usessl", prefsRec.mUseSSL );		aTree->PathSetValue( "profile/savepassword", prefsRec.mSavePassword );		aTree->PathSetValue( "profile/usekeychain", prefsRec.mUseKeychain );#endif		aTree->PathSetValue( "profile/username", prefsRec.mUsername );		PathSetSecretValue( aTree, "profile/password", prefsRec.mPassword );		aTree->PathSetValue( "profile/resource", prefsRec.mResource );		aTree->PathSetValue( "profile/server", prefsRec.mServer );		aTree->PathSetValue( "profile/port", prefsRec.mServerPort.c_str() );				//		// General Prefs		//		aTree->PathSetValue( "settings/connection/autologin", prefsRec.mAutoLogin );		aTree->PathSetValue( "settings/connection/autorelogin", prefsRec.mAutoRelogin );#ifndef TOQ		aTree->PathSetValue( "settings/connection/checkversion", prefsRec.mCheckVersion );				aTree->PathSetValue( "settings/timestamps/chat", prefsRec.mTimestampsInChat );		aTree->PathSetValue( "settings/timestamps/groupchat", prefsRec.mTimestampsInGC );				aTree->PathSetValue( "settings/autoaway/enabled", prefsRec.mAutoAway );		aTree->PathSetValue( "settings/autoaway/delay", prefsRec.mAutoAwayDelay );		aTree->PathSetValue( "settings/xautoaway/enabled", prefsRec.mExtendedAutoAway );		aTree->PathSetValue( "settings/xautoaway/delay", prefsRec.mExtendedAutoAwayDelay );		aTree->PathSetValue( "settings/autoaway/autoend", prefsRec.mAutoEndAuoAway );#endif		//		// Subscription Prefs		//#ifndef TOQ		aTree->PathSetValue( "settings/subscription/response/onroster", prefsRec.mResponseIfOnRoster );		aTree->PathSetValue( "settings/subscription/response/notonroster", prefsRec.mResponseIfNotOnRoster );				aTree->PathSetValue( "settings/subscription/autosubscribe/enabled", prefsRec.mAutoSubscribeBack );		aTree->PathSetValue( "settings/subscription/autosubscribe/defaultgroup", prefsRec.mAutoSubscribeGroup );				aTree->PathSetValue( "settings/subscription/rejection/autoreply/enabled", prefsRec.mSendRejectionMsg );		aTree->PathSetValue( "settings/subscription/rejection/autoreply/text", prefsRec.mRejectionMsg );#endif				//		// Roster Prefs		//		// meta groups#ifndef TOQ		LoadMetagroup( aTree, online, Online );		LoadMetagroup( aTree, myresources, MyResources );		LoadMetagroup( aTree, offline, Offline );		LoadMetagroup( aTree, pending, Pending );		LoadMetagroup( aTree, stalkers, Stalkers );		LoadMetagroup( aTree, agents, Agents );				// sorting		aTree->PathSetValue( "settings/roster/sort/bystatus", prefsRec.mRosterSortByStatus );				// double click behaviour		aTree->PathSetValue( "settings/roster/doubleclick/sendmsg", prefsRec.mDoubleClickSendsMsg );#endif				// should closing the roster quit?		aTree->PathSetValue( "settings/roster/closeQuits", prefsRec.mRosterCloseQuits );		//		// Privacy Prefs		//		// only show if sender is on roster		aTree->PathSetValue( "settings/privacy/onlyshowifonroster", prefsRec.mOnlyShowMsgIfOnRoster );		// FIX ME		aTree->PathSetValue( "settings/privacy/block", "jid", prefsRec.mBlockJIDList );		//		// Chat Prefs		//#ifndef TOQ		aTree->PathSetValue( "settings/chat/defaultnick", prefsRec.mDefaultNick );		aTree->PathSetValue( "settings/chat/ignorethread", prefsRec.mChatIgnoreThread );#endif		//		// Groupchat Prefs		//#ifndef TOQ		aTree->PathSetValue( "settings/groupchat/idletime", prefsRec.mGroupChatIdleTime );#endif		//		// Event Prefs		//		LoadEventNotify( aTree, online, Online );		LoadEventNotify( aTree, offline, Offline );		LoadEventNotify( aTree, statusChange, StatusChange );		LoadEventNotify( aTree, normalmsg, NormalMsg );#ifndef TOQ		LoadEventNotify( aTree, chatmsg, ChatMsg );		LoadEventNotify( aTree, groupchatmsg, GroupchatMsg );		LoadEventNotify( aTree, headline, Headline );#endif		LoadEventNotify( aTree, error, Error );		LoadEventNotify( aTree, subscribereq, SubscribeReq );		//		// Color Prefs		//#ifndef TOQ		PathSetRGBValue( aTree, "settings/colors/default", prefsRec.mColorDefault );		PathSetRGBValue( aTree, "settings/colors/own", prefsRec.mColorOwn );		PathSetRGBValue( aTree, "settings/colors/server", prefsRec.mColorServer );		PathSetRGBValue( aTree, "settings/colors/private", prefsRec.mColorPrivate );		PathSetRGBValue( aTree, "settings/colors/nicklist/ops", prefsRec.mColorOps );		PathSetRGBValue( aTree, "settings/colors/nicklist/voice", prefsRec.mColorVoice );#endif		//		// Debug Prefs		//		aTree->PathSetValue( "settings/debug/showwindows", prefsRec.mShowDebugWindows );		aTree->PathSetValue( "settings/debug/timestamps", prefsRec.mShowDebugTimestamps );				//		// Hidden Prefs		//#ifdef TOQ		aTree->PathSetValue( "settings/messages/delayincoming", prefsRec.mIncomingMessagesDelayed );#else		aTree->PathSetValue( "windows/agents/visible", prefsRec.mAgentsVisible );		aTree->PathSetValue( "windows/history/visible", prefsRec.mHistoryVisible );		aTree->PathSetValue( "windows/roster/visible", prefsRec.mRosterVisible );#endif	}}#pragma mark -///--------------------------------------------------------------------------------------//	SaveWindowPosition://		Store the posistion of a window in the profile//		//	Changes://		2000-07-30	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::SaveWindowPosition( ZWindow * aWindow, short id ){	ASSERT("msXMLPrefsTree == NULL",msXMLPrefsTree != NULL,0);	FailNILParam( aWindow );		short	x, y, width, height, screenWidth, screenHeight;	Rect	screenRect;	Rect	windowRect;	screenRect = *REGIONBOUNDINGBOX(GetGrayRgn());	screenWidth = screenRect.right - screenRect.left;	screenHeight = screenRect.bottom - screenRect.top;	aWindow->GetGlobalPosition( &x, &y );	windowRect = *WINDOWPORTRECT( aWindow->GetMacWindow());		width = windowRect.right - windowRect.left;	height = windowRect.bottom - windowRect.top;		//	// Transfrom x, y, width, height to a device-independant format	//	x = x * 1000.0 / screenWidth;	y = y * 1000.0 / screenHeight;	width = width * 1000.0 / screenWidth;	height = height * 1000.0 / screenHeight;		//	...store x, y, width, height...	std::string		path("dialogs/id");	path += NumericString(id).c_str();		msXMLPrefsTree->PathSetValue( path + "/x", (long)x );	msXMLPrefsTree->PathSetValue( path + "/y", (long)y );	msXMLPrefsTree->PathSetValue( path + "/w", (long)width );	msXMLPrefsTree->PathSetValue( path + "/h", (long)height );}///--------------------------------------------------------------------------------------//	RestoreWindowPosition://		Restore the posistion of a window from the profile//		//	Changes://		2000-07-30	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::RestoreWindowPosition( ZWindow * aWindow, short id ){	ASSERT("msXMLPrefsTree == NULL",msXMLPrefsTree != NULL,0);	FailNILParam( aWindow );		long	x, y, width, height, screenWidth, screenHeight;	Rect	screenRect;	Rect	windowRect;		screenRect = *REGIONBOUNDINGBOX(GetGrayRgn());	screenWidth = screenRect.right - screenRect.left;	screenHeight = screenRect.bottom - screenRect.top;//	...retrieve x, y, width, height...	std::string		path("dialogs/id");	path += NumericString(id).c_str();		if( !msXMLPrefsTree->PathGetValue( path + "/x", x, 0 ) )		return;	if( !msXMLPrefsTree->PathGetValue( path + "/y", y, 0 ) )		return;	if( !msXMLPrefsTree->PathGetValue( path + "/w", width, 0 ) )		return;	if( !msXMLPrefsTree->PathGetValue( path + "/h", height, 0 ) )		return;		//	// Transfrom x, y, width, height from a device-independant format	//	x = (x/1000.0) * screenWidth;	y = (y/1000.0) * screenHeight;	width = (width/1000.0) * screenWidth;	height = (height/1000.0) * screenHeight;		// all numbers are expressed in percent of the screen width/height	SetRect( &windowRect, 0, 0, width, height );	OffsetRect( &windowRect, x, y );				short	tBar = aWindow->GetTitleBarHeight();		windowRect.top -= tBar;		// modify rect according to titlebar height, and system, etc		if ( gMacInfo.systemVersion < 0x0800 )		windowRect.bottom = windowRect.top + tBar;		// if on screen, move the window. Otherwise leave it where it is:		if ( WindowOnDesktop( &windowRect ))		aWindow->PlaceAt(x, y );    	if ( aWindow->IsResizeable() )		aWindow->SetSize(width, height );}//REGIONBOUNDINGBOXbool		PrefsManager::WindowOnDesktop( Rect* wFrame ){	// return TRUE if the rect passed intersects the desktop. Called by RestoreWindowPosition	// to see if the restored position is legal on this system.	RgnHandle	utilRgn;	bool		result;		FailNIL( utilRgn = NewRgn() );		RectRgn( utilRgn, wFrame );	SectRgn( utilRgn, GetGrayRgn(), utilRgn );		result = ! EmptyRgn( utilRgn );	DisposeRgn( utilRgn );	return result;}#pragma mark -///--------------------------------------------------------------------------------------//	PathSetRGBValue://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::PathSetRGBValue( CElementNode* aTree, const std::string& basePath, const RGBColor& aColor ){	ASSERT("aTree == NULL",aTree != NULL,0);	aTree->PathSetValue( basePath+"/red", (long)(aColor.red>>8) );	aTree->PathSetValue( basePath+"/green", (long)(aColor.green>>8) );	aTree->PathSetValue( basePath+"/blue", (long)(aColor.blue>>8) );}///--------------------------------------------------------------------------------------//	PathGetRGBValue://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::PathGetRGBValue( const CElementNode* aTree, const std::string& basePath, RGBColor& aColor, const RGBColor &defaultColor ){	ASSERT("aTree == NULL",aTree != NULL,0);	long	val, def;	def = defaultColor.red >> 8;	aTree->PathGetValue( basePath+"/red", val, def );	aColor.red = val << 8;		def = defaultColor.green >> 8;	aTree->PathGetValue( basePath+"/green", val, def );	aColor.green = val << 8;		def = defaultColor.blue >> 8;	aTree->PathGetValue( basePath+"/blue", val, def );	aColor.blue = val << 8;}///--------------------------------------------------------------------------------------//	PathSetSecretValue://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::PathSetSecretValue( CElementNode* aTree, const std::string& basePath, const std::string& password ){#ifndef TOQ	ASSERT("aTree == NULL",aTree != NULL,0);	// first, empty the password in the tree	aTree->PathSetValue( basePath, "" );	if( msPrefsRec.mSavePassword )	{		if( msPrefsRec.mUseKeychain )			StorePasswordInKeychain(msPrefsRec.mUsername,									msPrefsRec.mServer,									password);		else			aTree->PathSetValue( basePath, password );	}#endif}///--------------------------------------------------------------------------------------//	PathGetSecretValue://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::PathGetSecretValue( const CElementNode* aTree, const std::string& basePath, std::string& password ){#ifndef TOQ	ASSERT("aTree == NULL",aTree != NULL,0);	if( msPrefsRec.mSavePassword )	{		aTree->PathGetValue( basePath, password, "" );		if( msPrefsRec.mUseKeychain )			RetrievePasswordFromKeychain(msPrefsRec.mUsername,											msPrefsRec.mServer,											password);	}	else		password.clear();#endif}#pragma mark -///--------------------------------------------------------------------------------------//	SyncPrefsDialog://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::SyncPrefsDialog(){#ifndef TOQ	if( msPrefsDialog )		msPrefsDialog->DisplayPrefsRec( msPrefsRec );#endif}///--------------------------------------------------------------------------------------//	StorePasswordInKeychain://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------OSStatus StorePasswordInKeychain( const std::string &username, const std::string &server, const std::string &password ){#if	TARGET_CPU_PPC && !TARGET_API_MAC_CARBON	OSStatus	status;	KCItemRef	item;	if (!PrefsManager::HasKeychain()) // is it there?		return ((OSStatus) -1);	status = kcaddinternetpassword (						server.c_str(),		// server name						"",					// security domain						username.c_str(),	// account name						5222,				// port						'JABB',				// protocol						kKCAuthTypeDefault,	// auth type						password.size(),	// length of password						password.c_str(),	// pointer to password data						&item);	return (status);#else	return ((OSStatus) -1);#endif}///--------------------------------------------------------------------------------------//	RetrievePasswordFromKeychain://		//		//	Changes://		2000-07-03	MH		Created///--------------------------------------------------------------------------------------OSStatus RetrievePasswordFromKeychain( const std::string &username, const std::string &server, std::string &password ){#if	TARGET_CPU_PPC && !TARGET_API_MAC_CARBON	OSStatus	status;	KCItemRef	item;	char		temp[256];	UInt32		size = 0;	if (!PrefsManager::HasKeychain()) // is it there?		return ((OSStatus) -1);	status = kcfindinternetpassword (						server.c_str(),		// server name						"",					// security domain						username.c_str(),	// account name						5222,				// port						'JABB',				// protocol						kKCAuthTypeDefault,	// auth type						255,				// max length of password						temp, 				// pointer to password data						&size,				// length of password						&item);	temp[size] = 0;	if( status == noErr )		password = temp;	return (status);#else	return ((OSStatus) -1);#endif}#pragma mark -///--------------------------------------------------------------------------------------//	OnLogin://		//		//	Changes://		2000-08-21	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::OnLogin(){#ifndef TOQ	if( msPrefsDialog )		msPrefsDialog->OnLogin();#endif}///--------------------------------------------------------------------------------------//	OnLogout://		//		//	Changes://		2000-08-21	MH		Created///--------------------------------------------------------------------------------------void	PrefsManager::OnLogout(){#ifndef TOQ	if( msPrefsDialog )		msPrefsDialog->OnLogout();#endif}