// ZHierarchicList -- a hierarchic listview class for MacZoop.//// Conceived and begun December'98 by brk (benk@intranet.ca)//// This code is copyright ©1998-2000 by Ben R. Kennedy, but may be freely used and// modified by Mac developers provided that credit is given to the original author.// See doc file accompanying the archive for details and revision history.#include <Fonts.h>#include "ProjectSettings.h"#include "ZHierarchicList.h"#include "ZGrafState.h"#include "PixMapUtils.h"// Uncomment this for debugging -- all ZHLs will spawn with a few default items// and folders in them. Mostly used for testing the cell selection algorithms// during development.////#define _ZHL_DEBUGenum{	TRIANGLE_WIDTH			= 16,	// width of the Appearance disclosure triangles	TRIANGLE_HEIGHT			= 16,	// height of same// stuff for using Glenn's Flag (pre-appearance triangle; see docs for credits/info)//// Resource ID's for stuff -- you can change these at will:	kOldTriangleCDEF		= 932,		// resource ID of the CDEF resource	kOldTriangleCicnClosed	= 14913,	// CICN depicting icon in closed state (16x16)	kOldTriangleCicnOpen	= 14914,	// CICN depicting icon in open state (16x16)// other constants for Glenn's Flag	kOldTriangleProc		= (kOldTriangleCDEF << 4),	// proc ID for default variation	kOldTrianglePartCode	= 11,		// part code it returns on successful hit	OLD_TRIANGLE_WIDTH		= 12,		// width (should be 12 to mimic Appearance)	OLD_TRIANGLE_HEIGHT		= 12,		// height (should be 12 to mimic Appearance)// stuff for general cell rendering	LEFT_PADDING			= 5,				// amount of whitespace on left side of cell	NEST_INDENT				= TRIANGLE_WIDTH,		// how far to indent each folder	kZHLSmallScrollbarWidth	= 11};pascal void ZHLScrollActionProc (ControlHandle, ControlPartCode);ZHLMaster gZHLMaster;	// functions use this as a common reference point//------------------------------------------------------------------------------// ZHLItem -- items (files, entries, etc) which appear in the list.//------------------------------------------------------------------------------#pragma mark ### ZHLItem ###ZHLItem::ZHLItem (ConstStr31Param p): ZComrade()	{	classID = CLASS_ZHLItem;	flags = NULL;	isFolder = false;	// configure default settings	if (p) CopyPStringTrunc (p, title, 31);	else title[0] = '\0';	ref = NULL;	}ZHLItem::~ZHLItem()  {}// DrawCell --	Draw this item's contents into its list cell.  The bounding rect//				is provided (taking into account its indention and disclosure//				triangle).  The calling method handles highlighting for selection.//void ZHLItem::DrawCell (Rect& r, ZHLDialogItem *boss)	{	short height, relTop;		// by default, simply render the item name.		height = r.bottom - r.top;			// height of cell	relTop = 1 + (height * 2) / 3;		// top offset for text	MoveTo (r.left, r.top + relTop);	DrawString (title);		return;	}// SetName --	Updates this item's name as supplied, and refreshes the listview//				on screen if this item is visible.//void ZHLItem::SetName (ConstStr31Param p)	{	CopyPStringTrunc (p, title, 31);	// tell all ZHL's to refresh if this is visible	gZHLMaster.RedrawIfVisible (this);	return;	}#pragma mark -//------------------------------------------------------------------------------// ZHLItemList -- linked list (ZObjectArray) of items in a folder.//------------------------------------------------------------------------------// Duplicate --	Makes itself an exact copy of another list.//void ZHLItemList::Duplicate (ZHLItemList& source)	{	DisposeHandle (a);	a = source.a;	HandToHand (&a);	FailMemError();	numElements = source.numElements;	blkSize = source.blkSize;	physicalBlks = source.physicalBlks;		return;	}// ZHLItemCompare --	Default method to compare two ZHLItems for sorting.//						This compares them alphabetically by name.////						User can override this functionality per folder by calling//						ZHLFolder::SetComparison() with a pointer to a//						replacement comparison function.//short ZHLItemCompare (void *itema, void *itemb, const long ref)	{	StringPtr pa = (*(ZHLItem**)itema)->GetNameForSort();	StringPtr pb = (*(ZHLItem**)itemb)->GetNameForSort();	// not case sensitive, not diacritically sensitive	return RelString (pa, pb, false, false);	}#pragma mark -//------------------------------------------------------------------------------// ZHLFolder -- folders (groups, hierarchies, etc) which can contain items.//------------------------------------------------------------------------------#pragma mark ### ZHLFolder ###ZHLFolder::ZHLFolder (ConstStr31Param p): ZHLItem (p)	{	classID = CLASS_ZHLFolder;	isFolder = true;		// actually, we are a folder	// default sorting paramaters	compareFunc = ZHLItemCompare;	sortRef = NULL;	}ZHLFolder::~ZHLFolder() {}// DisposeRecursively --	Disposes (frees the storage) of everything contained//							in this folder and its subfolders, including its subfolders.////							This does NOT send any messages.  Doing further ZHL//							operations will almost certainly crash, though, since//							ZHL objects won't know these items have gone away.////							This is best used (with care) for final cleanup only.//void ZHLFolder::DisposeRecursively()	{	long i;	ZHLItem *o;		for (i=1; i<= items.CountItems(); ++i)		{		o = (ZHLItem*) items.GetObject (i);		if (o->isFolder)			((ZHLFolder*)o)->DisposeRecursively();		delete o;		}	items.DeleteAll();	return;	}// DrawCell --	overrides ZHLItem's draw cell.  We want to be bold.//void ZHLFolder::DrawCell (Rect& r, ZHLDialogItem *boss)	{	TextFace (bold);	ZHLItem::DrawCell (r, boss);	return;	}// SetSort --	adjust the sort mode (turn on or off).  If turning on, sort the list//				first to ensure that binary searches performed by InsertSortedItem//				will function correctly.//void ZHLFolder::SetSort (SortCmpProcPtr f, long ref)	{	compareFunc = f;	sortRef = ref;	if (compareFunc)		{		items.Sort (compareFunc, sortRef);		gZHLMaster.RefreshFolderEvent (zhlFolderSorted, this, NULL);		}	return;	}// AddItem --	Adds an item to this folder.////				If 'where' is specified, the item is inserted at the given index.//				Otherwise if sort mode is on, the item is inserted alphabetically//				(or as otherwise determined by a custom compare method). Elsewise//				the item is appended at the end.//void ZHLFolder::AddItem (ZHLItem *o, long where)	{	// chuck her in reverse dere lad	if (where)		{		items.InsertItem (o, where);		}	else {		if (compareFunc)			items.InsertSortedItem (o, compareFunc, sortRef);		else items.AppendItem (o);		}	// inform the world of this event	gZHLMaster.RefreshFolderEvent (zhlItemAdded, this, o);	return;	}// RemoveItem --	Removes the item from this folder.//					Note, however, that it does not dispose of its storage.//void ZHLFolder::RemoveItem (ZHLItem *o)	{	// remove from the list -- does not free!	items.DeleteObject (o);	gZHLMaster.RefreshFolderEvent (zhlItemRemoved, this, o);	return;	}// DoubleClick --	Folder has been double-clicked. Overrides ZHLItem.//					Simply open (or close) the folder!//void ZHLFolder::DoubleClick (short modifiers, ZHLDialogItem *boss)	{	if (boss->IsOpen (this))		boss->OpenFolder (this, false);	else boss->OpenFolder (this, true);	return;	}// IsSelectable --	Check if folder is selectable. Overrides ZHLItem.//					Simply open (or close) the folder!//bool ZHLFolder::IsSelectable (ZHLDialogItem *boss)	{	return !(boss->GetModes() & zhl::selNotFolders);	}// Enumerate --	traverse the contents of this folder and its contained items/folders,//				yelling back to the boss dialog item in order so that it can compose//				a master cell list.//void ZHLFolder::Enumerate (ZHLDialogItem *boss, char nest)	{	ZHLItem *o;		for (long i=1; i<= items.CountItems(); ++i)		{		o = (ZHLItem*) items.GetObject (i);		boss->EnumerateThis (o, nest);	// register this with the boss		if (o->isFolder && boss->IsOpen ((ZHLFolder *)o))			((ZHLFolder*)o)->Enumerate (boss, nest + 1);	// get its contents too		}	return;	}#pragma mark -//------------------------------------------------------------------------------// ZHLDialogItem --	the actual list dialog item for ZAdvancedDialog.//------------------------------------------------------------------------------#pragma mark ### ZHLDialogItem ###ZHLDialogItem::ZHLDialogItem (ZDialog *dialog, const short item): ZDialogItem (dialog, item)	{	classID = CLASS_ZHLDialogItem;	leaveRoomForGrowbox = false;	smallScrollbar = false;	dynamicScrollbar = false;	theDialog = dialog;	scrollBar = NULL;	discTri = NULL;	triOpen = triClosed = NULL;	listZGW = NULL;	rootFolder = NULL;	nestLevel = NULL;	nestLevelSize = 0;	// stuff for select-by-keystroke	keyThresh = MIN (120, LMGetKeyThresh() * 2);	searchStr[0] = searchStr[15] = 0;	// using [15] as a length counter	lastKeyTime = 0;	// allocate some general purpose regions	rgn1 = rgn2 = rgn3 = NULL;	FailNIL (rgn1 = NewRgn());	FailNIL (rgn2 = NewRgn());	FailNIL (rgn3 = NewRgn());	canTakeFocus = true;		return;	};ZHLDialogItem::~ZHLDialogItem()	{	// ensure we aren't registered	gZHLMaster.allZHL.DeleteObject (this);	// clean up all our sheeeeeit	if (rgn1) DisposeRgn (rgn1);	if (rgn2) DisposeRgn (rgn2);	if (rgn3) DisposeRgn (rgn3);	if (scrollBar) DisposeControl (scrollBar);	if (discTri) DisposeControl (discTri);	if (triOpen) DisposePixMap (triOpen);	if (triClosed) DisposePixMap (triClosed);	delete listZGW;	delete[] nestLevel;	if (willDelRoot)		delete rootFolder;	}// InitItem --	initialize things based on the optional paramaters specified//				in the DITL construction.////				Currently both paramaters are ignored.//void ZHLDialogItem::InitItem (short count, const long params[])	{	Rect r, rt = {0, 0, TRIANGLE_HEIGHT, TRIANGLE_WIDTH};	short scrollProc;		leaveRoomForGrowbox = count > 0 ? params[0] : false;	smallScrollbar = count > 1 ? params[1] : false;	dynamicScrollbar = count > 2 ? params[2] : false;		// set up some standard numbers	listBounds = bounds;	// rect in which the list cells are drawn	listHeight = (listBounds.bottom - listBounds.top);	if( smallScrollbar )		listBounds.right -= kZHLSmallScrollbarWidth + 1;	else		listBounds.right -= kStdScrollbarWidth + 1;	// set up two globals (depth and colour) for use in calling appearance funcs.	// (this code taken from Ambrosia chapter 6)	GDHandle deviceHdl = LMGetMainDevice();	gZHLMaster.pixelDepth = (*(*deviceHdl)->gdPMap)->pixelSize;	if (BitTst (&(*deviceHdl)->gdFlags, gdDevType))		gZHLMaster.isColourDevice = true;		// get msgs (e.g. main screen depth changed) from the main application	ListenTo (gApplication);	// The GWorld we will keep to use as a back buffer for list contents drawing.	r = listBounds;	OffsetRect (&r, -listBounds.left, -listBounds.top);	FailNIL (listZGW = new ZGWorld (r, gZHLMaster.pixelDepth));	// and the pixmaps we will use to store images of the disclosure triangle	FailNIL (triOpen = MakePixMap (&rt, gZHLMaster.pixelDepth));	FailNIL (triClosed = MakePixMap (&rt, gZHLMaster.pixelDepth));	// build the scroll bar#if APPEARANCE_MGR_AWARE	if (gMacInfo.hasAppearanceMgr)		scrollProc = kControlScrollBarLiveProc;	else#endif		scrollProc = scrollBarProc;	r.top = listBounds.top - 1;	r.left = listBounds.right + 1;	r.bottom = listBounds.bottom + 1;	if( leaveRoomForGrowbox )		r.bottom -= kStdScrollbarWidth;	if( smallScrollbar )		r.right = r.left + kZHLSmallScrollbarWidth;	else		r.right = r.left + kStdScrollbarWidth + 1;	FailNIL (scrollBar = NewControl (theDialog->GetMacWindow(), &r, NULL,		true, 0, 0, 0, scrollProc, (long)this));	// Build an invisible disclosure triangle for repositioning and reuse,	// then make images of it in its open and closed states	// which we will use to render the triangles in the listview.	GWorldPtr saveGW;	GDHandle saveGD;	listZGW->SetPortToGW (&saveGW, &saveGD);	listZGW->Lock();	LockPixels (triClosed);	LockPixels (triOpen);	//#if APPEARANCE_MGR_AWARE	if (gMacInfo.hasAppearanceMgr)		{		// make an Appearance-compliant disclosure triangle		r.top = r.left = 0;		r.bottom = TRIANGLE_HEIGHT;		r.right = TRIANGLE_WIDTH;		FailNIL (discTri = NewControl (theDialog->GetMacWindow(), &r, NULL,			false, 0, 0, 1, kControlTriangleProc, (long)this));		// take snapshots of it in both states, using Dialog Manager to draw it		SetControlVisibility (discTri, true, false);		DrawControlInCurrentPort (discTri);		// draw the control into this GW		listZGW->CopyOut ((BitMap*)*triClosed, &rt, &rt);		SetControlValue (discTri, true);		// open it up		DrawControlInCurrentPort (discTri);		// draw the control into this GW		listZGW->CopyOut ((BitMap*)*triOpen, &rt, &rt);		SetControlVisibility (discTri, false, false);		}	else {#endif		// make an incarnation of Glenn's Flag (System 7-compatible)		r.top = r.left = 0;		r.bottom = OLD_TRIANGLE_HEIGHT;		r.right = OLD_TRIANGLE_WIDTH;		FailNIL (discTri = NewControl (theDialog->GetMacWindow(), &r, NULL,			false, 0, 0, 1, kOldTriangleProc, (long)this));		// simulate snapshots of it in both states, using pre-rolled cicns.		// (DrawControlInCurrentPort is unavailable on pre-OS8 systems)		CIconHandle cicn;		FailNIL (cicn = GetCIcon (kOldTriangleCicnClosed));		PlotCIcon (&rt, cicn);		DisposeCIcon (cicn);		CopyBits (CURRENTPORTPIXMAP, (BitMap*)*triClosed, &rt, &rt, srcCopy, NULL);		EraseRect (&rt);		FailNIL (cicn = GetCIcon (kOldTriangleCicnOpen));		PlotCIcon (&rt, cicn);		DisposeCIcon (cicn);		CopyBits (CURRENTPORTPIXMAP, (BitMap*)*triOpen, &rt, &rt, srcCopy, NULL);#if APPEARANCE_MGR_AWARE		}#endif	//	UnlockPixels (triClosed);	UnlockPixels (triOpen);	listZGW->Unlock();	SetGWorld (saveGW, saveGD);	// allocate storage for the nestLevel array	nestLevelSize = LIST_ENTRIES_INCREMENT;	// initial size	FailNIL (nestLevel = new unsigned char [nestLevelSize]);		// initialize some of our variables	lastItem = rangeFirst = rangeLast = NULL;	// nothing was previously selected	folderAnimate = true;	// if not explicitly handling, animate the triangles	drawing = true;		// make sure list is drawn into by default	// default selection mode allows multiple cells, selection-by-name, etc.	SetModes (zhl::selMultiple);		// set up default font settings for list	// (conveniently, this also forces it to initially refresh)	SetListFont (kFontIDGeneva, 9);	// create and initialize the rootfolder	ResetAndClearList();	// finally, register this ZHL with the masta tracka	gZHLMaster.allZHL.AppendItem (this);#ifdef _ZHL_DEBUG	// add some dummy crap to the list	ZHLFolder *root, *fold, *fold2;	root = GetRootFolder();	root->AddItem (fold2 = new ZHLFolder ("\proot beer"));	fold2->AddItem (new ZHLItem ("\psome file"));	fold2->AddItem (fold = new ZHLFolder ("\pfolder one"));	fold->AddItem (new ZHLItem ("\pfolder's punchbuggy"));	fold2->AddItem (new ZHLFolder ("\pempty folder"));	fold2->AddItem (new ZHLItem ("\pziggy ziggurath"));	fold2->AddItem (new ZHLFolder ("\pempty folder 2"));	fold->AddItem (new ZHLItem ("\panother item"));	fold->AddItem (new ZHLFolder ("\pfolder's folder"));#endif	return;	}// SetBounds --	Adjust the item bounds, perhaps in response to a dialog resizing.//				(march 2000, rev 3)//void ZHLDialogItem::SetBounds (Rect *newBounds)	{	// actually do the bounds setting and invalidation	ZDialogItem::SetBounds (newBounds);		// now update our own internals as necessary/*	// revise some standard numbers	listBounds = bounds;	// rect in which the list cells are drawn	listHeight = (listBounds.bottom - listBounds.top);	if( !dynamicScrollbar || (MAX (0, (rowHeight * listVisible.CountItems()) - listHeight)) )	{		if( smallScrollbar )			listBounds.right -= kZHLSmallScrollbarWidth;		else			listBounds.right -= kStdScrollbarWidth + 1;	}		// revise the back buffer	Rect r = listBounds;	OffsetRect (&r, -listBounds.left, -listBounds.top);	listZGW->SetSize (r);	if( dynamicScrollbar && !(MAX (0, (rowHeight * listVisible.CountItems()) - listHeight)) )	{		if( smallScrollbar )			r.right -= kZHLSmallScrollbarWidth;		else			r.right -= kStdScrollbarWidth + 1;	}	// revise the scroll bar	r.top = listBounds.top - 1;	r.left = listBounds.right + 1;	r.bottom = listBounds.bottom + 1;	if( leaveRoomForGrowbox )		r.bottom -= kStdScrollbarWidth;	if( smallScrollbar )		r.right = r.left + kZHLSmallScrollbarWidth;	else		r.right = r.left + kStdScrollbarWidth + 1;	SETCONTROLRECT ((ControlHandle) scrollBar, &r);	*/	// now, recalc/rerender our visuals	DrawListContents();	return;	}// ReceiveMessage --	process messages.  Nothing in particular.//void ZHLDialogItem::ReceiveMessage ( ZComrade* aSender, ZoopMessage aMsg, UntypedPtr msgData )	{	switch (aMsg)		{		case msgMainScreenDepthChanged:			// user changed screen depth (application notified us)			gZHLMaster.pixelDepth = * ((short*)msgData);			break;		default:			ZDialogItem::ReceiveMessage (aSender, aMsg, msgData);			return;		}		return;	}// Enable --	the dialog is attempting to enable us (this may or may not actually//				happen depending on the state history).  Activate the scroll bar, etc.//void ZHLDialogItem::Enable (Boolean hist)	{	ZDialogItem::Enable (hist);#if APPEARANCE_MGR_AWARE		if (gMacInfo.hasAppearanceMgr)			{			if (hilited) ActivateControl (scrollBar);			else DeactivateControl (scrollBar);			}		else#endif			HiliteControl (scrollBar, hilited ? 0 : 255);	// Refresh the screen since selection hiliting will have to change	DrawListContents();	return;	}// Disable --	the dialog is attempting to disable us. Grey out the scroll bar.//void ZHLDialogItem::Disable (Boolean hist)	{	ZDialogItem::Disable (hist);#if APPEARANCE_MGR_AWARE		if (gMacInfo.hasAppearanceMgr)			DeactivateControl (scrollBar);		else#endif			HiliteControl (scrollBar, 255);	// Refresh the screen since selection hiliting will have to change	DrawListContents();	return;	}// DoHilightSelection --	Gives us the opportunity to render selections differently//							depending on whether or not we are focused/hilited.//void ZHLDialogItem::DoHilightSelection (Boolean onoff)	{//	InvalRect (&listBounds);	// if we are supposed to do smart hiliting (an outline of the selection	// if the list is unfocused), then force a redraw.	if (listOptionFlags & zhl::optSmartHilite)		DrawListContents();	return;	}// DrawItem --	Render everything pertaining to ZHL that shows up on screen.//void ZHLDialogItem::DrawItem (void)	{	// refresh the border around everything#if APPEARANCE_MGR_AWARE	if (gMacInfo.hasAppearanceMgr)		DrawThemeListBoxFrame (&bounds, hilited ? kThemeStateActive : kThemeStateInactive);	else#endif	DrawStdFrame (&bounds);		// refresh the scroll bar	DrawOneControl (scrollBar);		// refresh the list proper -- more efficient than calling DrawListContents();	RenderToScreen();		return;		}// RenderToScreen --	copies the back buffer into the dialog window.//						Called by DrawItem() and DrawListContents().//						Assumes the dialog is focused.//void ZHLDialogItem::RenderToScreen (void)	{	ForeColor (blackColor);		// make sure fg/bg are correct for image copy!	BackColor (whiteColor);	// copy the back buffer into the actual window	Rect r;	listZGW->GetSize (&r);	LockPixels (WINDOWPIXMAP(theDialog->GetMacWindow()));	listZGW->CopyOut (PORTPIXMAP(WINDOWGRAFPTR(theDialog->GetMacWindow())), &r, &listBounds);	UnlockPixels (WINDOWPIXMAP(theDialog->GetMacWindow()));//	LockPixels ((PixMapHandle)PORTPIXMAP(theDialog->GetMacWindow()));//	listZGW->CopyOut (PORTPIXMAP(theDialog->GetMacWindow()), &r, &listBounds);//	UnlockPixels ((PixMapHandle)PORTPIXMAP(theDialog->GetMacWindow()));	}// DrawListContents --	Refreshes the listview contents (and adjusts scroll limits)//						but does not superfluously refresh the border or scroll bar.////						This is a PROTECTED routine which is used by various//						methods.  If the user has to make this kind of thing happen,//						she's either doing something wrong -- or else she can//						use RefreshListContents(), which will first re-enumerate.//void ZHLDialogItem::DrawListContents (void)	{	int i, j, scrollMax, max, scrollOfs, listWidth;	Rect r, itemRect, triRect;	ZHLItem *o;	CGrafPtr saveGW;	GDHandle saveGD;	FocusBoss();	ZGrafState preserve;	ClipRect (&bounds);		// draw in whole thing	// now update our own internals as necessary	// revise some standard numbers	listBounds = bounds;	// rect in which the list cells are drawn	listHeight = (listBounds.bottom - listBounds.top);		// calculate the scroll bar maximum	scrollMax = MAX (0, (rowHeight * listVisible.CountItems()) - listHeight);		// if the maximum is 0 (i.e. nothing to scroll) and we are set to use a dynamic scrollbar,	// then do *not* reserve space for the scrollbar	if (!(dynamicScrollbar && (scrollMax == 0)))	{		if( smallScrollbar )			listBounds.right -= kZHLSmallScrollbarWidth;		else			listBounds.right -= kStdScrollbarWidth + 1;	}					// revise the back buffer	r = listBounds;	OffsetRect (&r, -listBounds.left, -listBounds.top);	listZGW->SetSize (r);						// Show/hide/resize the scroll bar as it is fit	if (dynamicScrollbar && (scrollMax == 0))		HideControl( scrollBar );	else	{		// revise the scroll bar		r.top = listBounds.top - 1;		r.left = listBounds.right;		r.bottom = listBounds.bottom + 1;		if( leaveRoomForGrowbox )			r.bottom -= kStdScrollbarWidth;		if( smallScrollbar )			r.right = r.left + kZHLSmallScrollbarWidth;		else			r.right = r.left + kStdScrollbarWidth + 1;		SETCONTROLRECT ((ControlHandle) scrollBar, &r);			ShowControl( scrollBar );	}	// refresh scroll bar maximum	if (scrollMax != GetControlMaximum (scrollBar))	{		SetControlMaximum (scrollBar, scrollMax);		DrawOneControl (scrollBar);	}	// calc some variables to be used in rendering	scrollOfs = GetControlValue (scrollBar);	// scroll offset	firstCell = (scrollOfs / rowHeight) + 1;	// first cell of which part will be visible	drawOfs = scrollOfs % rowHeight;			// amount of first cell which is cut off in list	listWidth = listBounds.right - listBounds.left;	// constant more or less	visiCells = listHeight / rowHeight;			// number of cells visible in list	if (scrollOfs) visiCells++;		// compensate for half-cells at top and bottom	// set the offscreen GWorld for rendering	listZGW->SetPortToGW (&saveGW, &saveGD);	listZGW->Lock();	// first, erase the entire list rect	SetPlainBackgroundColour ();	r = listBounds;	OffsetRect (&r, -listBounds.left, -listBounds.top);	EraseRect (&r);	// step thru the listVisible and put em on the scrn	max = MIN (listVisible.CountItems(), firstCell + visiCells);	for (i = firstCell, j=0; i<= max; ++i, ++j)		{		itemRect.top = (j * rowHeight) - drawOfs;		itemRect.left = 0;		itemRect.bottom = itemRect.top + rowHeight;		itemRect.right = listWidth;		// draw separator line above		DrawRowSeparator (0, itemRect.top, listWidth, itemRect.top);				// get the object in question		o = (ZHLItem*) listVisible.GetObject (i);					// calc the drawing area for the cell draw function		r = itemRect;		r.left = (nestLevel[i-1] * NEST_INDENT) + LEFT_PADDING;				r.top += 1;		r.bottom -= 1;				// reset pen colour and text face just to be nice		#if APPEARANCE_MGR_AWARE			if (gMacInfo.hasAppearanceMgr)				SetThemeTextColor (kThemeListViewTextColor, gZHLMaster.pixelDepth, gZHLMaster.isColourDevice);			else		#endif				ForeColor (blackColor);		TextFace (normal);		// and ask the item to draw itself into the rect		o->DrawCell (r, this);		// display a mock disclosure triangle if a folder		if (o->isFolder)			{			RGBColor rgb;			PixMapHandle img = IsOpen ((ZHLFolder*)o) ? triOpen : triClosed;			SetTriRect (nestLevel[i-1], itemRect, &triRect);			LockPixels (img);			GetBackColor (&rgb);	// preserve current back color (sorted/unsorted)			BackColor (whiteColor);	// reqd for 'transparent' transfer mode to work			CopyBits ((BitMap*)*img, CURRENTPORTPIXMAP, &img[0]->bounds, &triRect, transparent, NULL);//			CopyBits ((BitMap*)*img, CURRENTPORTPIXMAP, &img[0]->bounds, &triRect, srcCopy, NULL);			RGBBackColor (&rgb);	// restore so highlighting etc. resumes working			UnlockPixels (img);			}		// highlight it if selected (method taken from ambrosia chapter 20)		if (IsSelected (o))			{			UInt8 hiliteVal = LMGetHiliteMode();			BitClr (&hiliteVal, pHiliteBit);			LMSetHiliteMode (hiliteVal);			if (!hilited || (!focused && listOptionFlags & zhl::optSmartHilite))				{/*					RGBForeColor (& ((GrafVars*)((CGrafPtr)theDialog->GetMacWindow())->grafVars[0])->rgbHiliteColor);				PenSize (2, 2);				Rect rr = itemRect; rr.top++;				FrameRect (&rr);				PenNormal();*/				Rect ra, rb;				ra = itemRect;				ra.top++;				RectRgn (rgn1, &ra);				rb = ra;				InsetRect (&rb, 2, 2);				RectRgn (rgn2, &rb);				DiffRgn (rgn1, rgn2, rgn3);				InvertRgn (rgn3);				}			else InvertRect (&itemRect);			}		}	// draw separator line below last item	DrawRowSeparator (0, itemRect.bottom, listWidth, itemRect.bottom);	// see if there's blank space in the list beneath the last cell	if ( ((j * rowHeight) + 1 - drawOfs) < listHeight)		{		// if scrollbar is not right at top of visible list, scroll it		if (max < firstCell + visiCells && firstCell != 1)			{			DrawListContents();	// this will set things straight...			}		// ghost out the scrollbar if it's not already ghosted		else if (GetControlMaximum (scrollBar))			{			SetControlMaximum (scrollBar, 0);			DrawOneControl (scrollBar);			}		}	listZGW->Unlock();	SetGWorld (saveGW, saveGD);		// restore the dialog window	RenderToScreen();	return;	}// RefreshListContents --	Forces the ZHL to reassemble the list of visible cells,//							and refreshes it onscreen.////							This is called by several other methods (e.g. when a//							contained folder's contents change). It's also useful//							to call after a series of operations when drawing/updating//							has been suspended with DrawingActive().//void ZHLDialogItem::RefreshListContents()	{	listVisible.DeleteAll();	rootFolder->Enumerate (this, listOptionFlags & zhl::optNoIndent ? 0 : 1);	if (drawing) DrawListContents();	return;	}#pragma mark -// ClickItem --	The user clicked somewhere in the list.  Fully process the event,//				moving the scroll bar if necessary, changing the item states as//				required and calling the item's methods to do further work if needed.//void ZHLDialogItem::Click (const Point where, const short modifiers)	{	ControlHandle ch;	ControlPartCode pc;	ZHLItem *o;	int pos, cell;	Rect r, t;	Boolean opening, f;	// first call inherited -- this will make sure we get the focus,	// and also notify the window object's ClickItem	ZDialogItem::Click (where, modifiers);		// if we're not enabled, boot it out of here	if (! hilited) return;		// see if the click landed in the scroll bar	pc = FindControl (where, theDialog->GetMacWindow(), &ch);	if (pc)		{		if (ch == scrollBar)	// handle the scroll bar			{#if APPEARANCE_MGR_AWARE			if (gMacInfo.hasAppearanceMgr)				pc = HandleControlClick (ch, where, modifiers, gZHLMaster.scrollActionUPP);			else {#endif				if (TrackControl (ch, where, pc == kControlIndicatorPart ? NULL : gZHLMaster.scrollActionUPP))					DrawListContents();#if APPEARANCE_MGR_AWARE				}#endif			}		}		// not in a control, so it musta been the list, right?	else if (where.h < listBounds.right)		{		// determine which cell		pos = where.v - listBounds.top + drawOfs;		cell = pos / rowHeight;		// zero-based				// if it was empty space that was clicked in		if (cell + 1 > listVisible.CountItems())			{			if (modifiers & (shiftKey|rightShiftKey) && listVisible.CountItems())				{				// if shift key is down, treat as if it were the last cell				o = (ZHLItem*) listVisible.GetObject (listVisible.CountItems());				ChooseItem (o, modifiers, zhl::posBottom);				}			else if (listOptionFlags & zhl::selAlways)				{				// if something's always gotta be selected, we can't do much				return;				}			else {				// otherwise deselect everything				SelectNone();				}			}		// otherwise locate the object and handle the click		else {			o = (ZHLItem*) listVisible.GetObject (cell + firstCell);			// calculate the cell rectangle			r.top = listBounds.top - drawOfs + (cell * rowHeight);			r.left = listBounds.left;			r.bottom = r.top + rowHeight;			r.right = listBounds.right;			// calculate the disclosure triangle rect based on this			SetTriRect (nestLevel[cell+firstCell-1], r, &t);			// handle disclosure triangle			if (PtInRect (where, &t) && o->isFolder)				{				// first make sure the correct backgnd colour will be used				ZGrafState zg;				SetBackgroundColour (o);				opening = ! IsOpen ((ZHLFolder*)o);				f = DoDisclosureTri (true, opening, t);				if (f == opening)					{					folderAnimate = false;	// explicitly refuse animation					OpenFolder ((ZHLFolder*)o, opening);					folderAnimate = true;	// default					}				}						// otherwise maybe select the cell			else {				f = (lastItem == o);	// ChooseItem will modify lastItem								ChooseItem (o, modifiers, zhl::posNone);				if (gApplication->GetClicks() == 2 && f)					{					// let the user handle a double-click if desired					o->DoubleClick (modifiers, this);					SendMessage (zhlItemDoubleClicked, o);					}				else {					// let the user handle a single-click if desired					o->Click (modifiers, this);					SendMessage (zhlItemClicked, o);					}				}			}		}			return;	}void ZHLDialogItem::ContextualMenuClick (const Point globalPoint){	ZHLItem *o;	int pos, cell;	Rect r, t;	Point	where = globalPoint;		FocusBoss();	GlobalToLocal( &where );	// first call inherited -- this will make sure we get the focus,	// and also notify the window object's ClickItem	ZDialogItem::Click (where, 0 );		// if we're not enabled, boot it out of here	if (! hilited)		return;		// not in a control, so it musta been the list, right?	if (where.h < listBounds.right)	{		// determine which cell		pos = where.v - listBounds.top + drawOfs;		cell = pos / rowHeight;		// zero-based				// if it was not empty space that was clicked in		if (cell + 1 <= listVisible.CountItems())		{			o = (ZHLItem*) listVisible.GetObject (cell + firstCell);			// calculate the cell rectangle			r.top = listBounds.top - drawOfs + (cell * rowHeight);			r.left = listBounds.left;			r.bottom = r.top + rowHeight;			r.right = listBounds.right;			// calculate the disclosure triangle rect based on this			SetTriRect (nestLevel[cell+firstCell-1], r, &t);			// was not in disclosure triangle			if (!o->isFolder || !PtInRect (where, &t))			{				ChooseItem (o, 0, zhl::posNone);				o->ContextualMenuClick( globalPoint );			}		}	}}// Type --	handles typing in the list.  This is based on ZListDialogItem::Type.//void ZHLDialogItem::Type (const char theKey, const short modifiers)	{	ZHLItem *currItem;	int index, n1, n2;	short posmode = zhl::posMiddle;	// only try this if the list is not empty	if (listVisible.CountItems())		{		currItem = lastItem;		// calc range stuff ahead of time. (see also ChooseItem())		// if no range defined, or if previous bounds are no longer here		if (! rangeFirst		|| ! (n1 = listVisible.FindIndex (rangeFirst))		|| ! (n2 = listVisible.FindIndex (rangeLast)))			{			n1 = n2 = listVisible.FindIndex (lastItem);			}		// handle the keypress				switch (theKey)			{			case UP_ARROW_KEY:			// up arrow, move up if possible				posmode = zhl::posBottom;								// cmdkey: go to top of list				if (modifiers & cmdKey)					currItem = (ZHLItem*) listVisible.GetObject (1);								// shift: expand range upward				// (modifiers must still be passed to ChooseItem() for this to work)				else if (modifiers & (shiftKey|rightShiftKey))					{					if (n1 > 1)						currItem = (ZHLItem*) listVisible.GetObject (--n1);					}								// plain: go to top if nothing selected				else if (! TotalSelected())					currItem = (ZHLItem*) listVisible.GetObject (1);								// else go to next				else {					index = listVisible.FindIndex (lastItem);					if (index > 1)						currItem = (ZHLItem*) listVisible.GetObject (--index);					}				break;						case DOWN_ARROW_KEY:		// down arrow, move down if possible				posmode = zhl::posTop;								// cmdkey: go to bottom of list				if (modifiers & cmdKey)					currItem = (ZHLItem*) listVisible.GetObject (listVisible.CountItems());								// shift: expand range downward				// (modifiers must still be passed to ChooseItem() for this to work)				else if (modifiers & (shiftKey|rightShiftKey))					{					if (n2 < listVisible.CountItems())						currItem = (ZHLItem*) listVisible.GetObject (++n2);					}								// plain: go to bottom if nothing selected				else if (! TotalSelected())					currItem = (ZHLItem*) listVisible.GetObject (listVisible.CountItems());				// else go to next				else {					index = listVisible.FindIndex (lastItem);					if (index < listVisible.CountItems())						currItem = (ZHLItem*) listVisible.GetObject (++index);					}				break;						case RIGHT_ARROW_KEY:			case RETURN_KEY:			// try to open a folder				if (lastItem && lastItem->isFolder)					OpenFolder ((ZHLFolder*)lastItem, true);				break;			case LEFT_ARROW_KEY:		// try to close a folder				if (lastItem && lastItem->isFolder)					OpenFolder ((ZHLFolder*)lastItem, false);				break;						case BACKSPACE_KEY:			// perhaps delete the selection								DoClear();				currItem = lastItem;	// prevent a reselection below				break;						case ENTER_KEY:				// open/activate the selection				if( listSelected.CountItems() == 1 )				{					ZHLItem *o;					for (int i = 1; i <= listSelected.CountItems(); ++i)					{						o = (ZHLItem*) listSelected.GetObject (i);						o->DoubleClick (modifiers, this);						SendMessage (zhlItemDoubleClicked, o);					}				}				break;						default:		// handle letter typing to select items in list.											if ( ((theKey >= 'a' && theKey <= 'z')				|| (theKey >= 'A' && theKey <= 'Z')				|| (theKey >= '0' && theKey <= '9'))				&& ! (listOptionFlags & zhl::selNotByName) )					{					long theTime = TickCount();					// time to start a new string yet?					if ((theTime > lastKeyTime + keyThresh) || (searchStr[0] > 12))						searchStr[0] = 0;					lastKeyTime = theTime;										// add typed chars to the search string					searchStr [++searchStr[0]] = theKey;										// find a cell that matches this one					ZHLItem *o;					Str31 p;										for (int i = listVisible.CountItems(); i > 0; --i)						{						o = (ZHLItem*) listVisible.GetObject (i);						CopyPStringTrunc (o->GetNameForSort(), p, searchStr[0]);						if (! RelString (searchStr, p, false, false))							currItem = o;						}					}				break;			}				// if we found a candidate, select the new cell		if (currItem != lastItem)			ChooseItem (currItem, modifiers & (shiftKey|rightShiftKey), posmode);		}		ZDialogItem::Type (theKey, modifiers);	return;	}#pragma mark - // UpdateMenus --	Update the menu bar.//void ZHLDialogItem::UpdateMenus (void)	{	if (listOptionFlags & zhl::selMultiple)		gMenuBar->EnableCommand (kCmdSelectAll);		ZDialogItem::UpdateMenus();	return;	}// AttachRootFolder --	Purges and resets the list, then attaches the provided//						folder to the list as the new root folder.////						Used by ResetAndClearList(), but may also be called by//						hand during your dialog's SetUp() to attach a pre-assembled//						root folder to the list (avoiding the overhead that//						would normally occur since the list would refresh on every//						AddItem()).////						The paramater autoDel specifies whether ZHL should dispose//						of this root folder as part of the cleanup process.//						Normally, since ZHL creates an empty root folder, it will//						dispose of it automatically. However if the user is employing//						this function (with a custom root folder which is likely//						used elsewhere beyond ZHL), she may wish to handle deletion//						by hand.  autoDel allows control over this (the default is//						false, causing ZHL never to attempt disposal of the folder).//void ZHLDialogItem::AttachRootFolder (ZHLFolder *f, Boolean autoDel)	{	listVisible.DeleteAll();	listSelected.DeleteAll();	listOpenFolders.DeleteAll();	lastItem = rangeFirst = rangeLast = NULL;	visiCells = firstCell = 0;	if (willDelRoot)		delete rootFolder;	// free existing if we're allowed	rootFolder = f;	willDelRoot = autoDel;	// store the new deletion mode	listOpenFolders.AppendItem (rootFolder);	RefreshListContents();	return;	}// ResetAndClearList --	Erases the whole list, refreshes the display, and//						starts fresh.  This is accomplished by simply calling//						AttachRootFolder with a new empty folder.//void ZHLDialogItem::ResetAndClearList (void)	{	ZHLFolder *rf;	FailNIL (rf = new ZHLFolder ("\proot"));	AttachRootFolder (rf, true);	// we create, so we will delete	return;	}// SetListFont --	Establish text settings for use in rendering the list cells.////					This is called automatically by InitItem to set the default//					font stuff.  The user can call it at any time.  This routine//					merely changes the font settings in the offscreen graphics port;//					the advantage is that lots of such calls during cell drawing//					are then unnecessary.////					The third paramater specifies the row height for each list cell.//					If null (default), an optimal height will be automatically//					calculated based on the font size.////					font = font ID.  size = point size.  height = row height.//void ZHLDialogItem::SetListFont (short font, short size, short height)	{	GWorldPtr saveGW;	GDHandle saveGD;	// set the font and size in our offscreen world	listZGW->SetPortToGW (&saveGW, &saveGD);	listZGW->Lock();	TextFont (font);	TextSize (size);	SetGWorld (saveGW, saveGD);		// determine the row height based on font size, if none supplied	rowHeight = height ? height : (size * 2) + 1;		// force the list to redraw with the new settings	if (drawing) DrawListContents();	return;	}// OpenFolder --	opens or closes a folder item belonging to this list.////					If opening = true, open the folder.  Else, close the folder.//					Returns true if operation succeeded, or false if the given//					folder is not in this list.//Boolean ZHLDialogItem::OpenFolder (ZHLFolder *o, Boolean opening)	{	int i;		i = listOpenFolders.FindIndex (o);	if (opening && i == 0)		// not currently open		{		listOpenFolders.AppendItem (o);		if (drawing)			{			OpenCloseAnimate (o, true);			RefreshListContents();			}		o->Open (this);		SendMessage (zhlFolderOpened, o);		}	else if (!opening && i)		// presently open		{		listOpenFolders.DeleteItem (i);		if (drawing)			{			OpenCloseAnimate (o, false);			RefreshListContents();			}		o->Close (this);		SendMessage (zhlFolderClosed, o);		}	return true;	}// IsOpen --	determines whether or not the specified folder is open.//				(If it is not even in the list, returns false anyway)//Boolean ZHLDialogItem::IsOpen (ZHLFolder *o)	{	return listOpenFolders.Contains (o);	}// IsSelected --	determines whether or not the specified item is selected.//					(If it is not even in the list, returns false anyway)//Boolean ZHLDialogItem::IsSelected (ZHLItem *o)	{	return listSelected.Contains (o);	}// TotalSelected --	returns the number of cells currently selected in the list.//long ZHLDialogItem::TotalSelected()	{	return listSelected.CountItems();	}// GetSelection --	returns the nth selected item.//ZHLItem *ZHLDialogItem::GetSelection (long n)	{	return (ZHLItem*) listSelected.GetObject (n);	}// ChooseItem --	Handle mouse clicks on a given list cell.////					Calling this method is the recommended way to select a cell as//					a result of some user operation (Click(), among other things,//					uses this).////					Although it may seem odd, it is quite possible to be handling//					a "click" on an item which is not visible -- for example,//					as a result of type-selection.////					This honours the selection modes (based on 'modifiers'), and//					also scrolls the cell into view if it's not already visible,//					according to 'position' (default is centered).//void ZHLDialogItem::ChooseItem (ZHLItem *o, short modifiers, short position)	{	Rect r;	Boolean b;	int i, j, n, visIdx;	ZHLItem *p;	// We just play with listSelected here to do the selections,	// and then send all messages at the end.  That way we avoid sending	// unnecessary duplicate messages, and can send 'selected' msgs before	// 'unselected' ones, etc.	// Take a snapshot of current selection array for use by FlushSelection()	listOldSelected.Duplicate (listSelected);	// if it's impossible to select any cells, return	if (! (listOptionFlags & (zhl::selOnlyOne | zhl::selMultiple)))		return;	// if this is the root folder, assume we are coming from DoSelectAll()	// and use an efficient means to select everything (according to sel mdoes)	else if (o == rootFolder)		{		listSelected.DeleteAll();		AddSelectRecursively (o);	// shim in here avoids adding the rootfolder itself		}		// if this item is not currently visible in the list, return	else if (! (visIdx = listVisible.FindIndex (o)))		return;	// if shift is down and multiple selection is allowed, handle that	else if (listOptionFlags & zhl::selMultiple	&& modifiers & (shiftKey|rightShiftKey))		{		// if no range defined, or if previous bounds are no longer here		if (! rangeFirst		|| ! (i = listVisible.FindIndex (rangeFirst))		|| ! (j = listVisible.FindIndex (rangeLast)))			{			// if this is the same frickin cell as last clicked, toggle it			if (o == lastItem) goto cmdkey;			// else use it as the start/end of current range			i = j = listVisible.FindIndex (lastItem);			}				i = MIN (visIdx, i);		j = MAX (visIdx, j);		// select everything within range		for (n = i; n<= j; ++n)			{			p = (ZHLItem*) listVisible.GetObject (n);			if (! listSelected.Contains (p))				AddSelectRecursively (p);			}				// and cache the range pointers		rangeFirst = (ZHLItem*) listVisible.GetObject (i);		rangeLast = p;		}	// if cmd key is down, simply toggle the selection state of this item	else if (modifiers & cmdKey)		{		cmdkey:		// if this is the last selected item (going to deselect) but something		// must always remain selected, then don't do it. Otherwise do.		if ((i = listSelected.FindIndex (o))		&& ! (listOptionFlags & zhl::selAlways && TotalSelected() <= 1))			listSelected.DeleteItem (i);				// else select only it (provided it's not a folder that's is disallowed,		// and that multiple selection is allowed if there's already one selected)		else if (o->IsSelectable (this))			{			if (listOptionFlags & zhl::selOnlyOne && TotalSelected())				goto plainkey;	// pretend it never happened						else listSelected.AppendItem (o);	// NOT recursive			}		}	// if only one cell can be selected at once, first de-select all others	else {		plainkey:		rangeFirst = rangeLast = NULL;		listSelected.DeleteAll();		// if we should select all folder contents		if (! (listOptionFlags & zhl::selNotContents))			AddSelectRecursively (o);	// recursive according to selection modes		// else select only it (provided it's not a folder that's is disallowed)		else if (o->IsSelectable (this))			listSelected.AppendItem (o);	// NOT recursive		}	// scroll the list to reveal the cell if not completely in view	b = FindItemListRect (o, &r, NULL);	if (! b || r.top < listBounds.top || r.bottom > listBounds.bottom	&& o != rootFolder && drawing)		{		switch (position)			{			case zhl::posMiddle:				SetControlValue (scrollBar, (rowHeight * visIdx) - listHeight / 2);				break;						case zhl::posTop:				SetControlValue (scrollBar, rowHeight * (visIdx-1));				break;							case zhl::posBottom:				SetControlValue (scrollBar, (rowHeight * visIdx) - listHeight);				break;													default: break;			}		}		// finally refresh the display	if (drawing) DrawListContents();	// and send out messages and call the hook methods now	FlushSelection();	lastItem = o;			return;	}// SelectItem --	selects or deselects an item belonging to this list.//					If select = true, select it.  Else, deselect it.////					If you must quietly force a change to an item's selection state,//					use this.  Otherwise, use ChooseItem() to get full processing//					(including selection logic) as if it were clicked by the user.////					Unlike ChooseItem(), this does NOT refresh the display.//					This does NOT heed any selection modes (including folder//					exclusion and recursive selection).  Avoid this if possible.//void ZHLDialogItem::SelectItem (ZHLItem *o, Boolean select)	{	int i = listSelected.FindIndex (o);	if (select && i == 0)		// not currently selected		{		listSelected.AppendItem (o);		o->Select (true, this);		SendMessage (zhlItemSelected, o);		}	else if (i)					// presently selected		{		listSelected.DeleteItem (i);		o->Select (false, this);		SendMessage (zhlItemUnselected, o);		}	return;	}// AddSelectRecursively --	Add this item to listSelected, and if it's a folder,//							iterate recursively through its contents doing the//							same (while honouring the selection modes).////							Private utility for ChooseItem() only.//void ZHLDialogItem::AddSelectRecursively (ZHLItem *o)	{	ZHLItem *p;	int i, n;	if (o->isFolder)	// special processing for folders		{		// first, add this if it can be selected		// (provided it's NOT the root folder)		if ( o->IsSelectable (this) && o != rootFolder)			listSelected.AppendItem (o);		// now loop through recursively for the contents		n = ((ZHLFolder*)o)->items.CountItems();		for (i=1; i<= n; ++i)			{			p = (ZHLItem*) ((ZHLFolder*)o)->items.GetObject (i);			if (! listSelected.Contains (p))				AddSelectRecursively (p);			}		}		// otherwise, just add it	else listSelected.AppendItem (o);		return;	}// DoSelectAll --	select everything in the list, chico.//void ZHLDialogItem::DoSelectAll (void)	{	// there are special shims in ChooseItem to make the rootfolder selection	// work as one would expect.  :D	ChooseItem (rootFolder, NULL, zhl::selNone);	return;	} // SelectNone --	unselects everything in the list.  Can be called by hand,//					but is also used by Click when necessary (empty region clicked)//void ZHLDialogItem::SelectNone (void)	{	if (TotalSelected())	// if at least one selection		{		listOldSelected.Duplicate (listSelected);	// for FlushSelection()		listSelected.DeleteAll();		lastItem = rangeFirst = rangeLast = NULL;		if (drawing) DrawListContents();		FlushSelection();							// send out the msgs		}	return;	}// FlushSelection --	called after a complex selection/deselection operation//						in which any combination of cells could have been toggled.//						Used by ChooseItem(), SelectNone(), etc.////						When this is called, listSelected must contain the "new"//						enumeration of selected cells.  listOldSelected must contain//						the "previous" enumeration; that is, the selection state//						before the operation occurred.  (It is therefore necessary//						for the client to do listOldSelected.Duplicate(listSelected);//						prior to manipulating listSelected.)////						This function compares the two lists, and sends out//						messages accordingly.  The purpose of this is to eliminate//						duplicate messages, and ensure they are delivered in a//						controlled order.//void ZHLDialogItem::FlushSelection (void)	{	int i, j;	ZHLItem *p;	Boolean change = false;		// first handle newly selected items	for (i=1; i<= listSelected.CountItems(); ++i)		{		p = (ZHLItem*) listSelected.GetObject (i);		j = listOldSelected.FindIndex (p);		if (j)			{			// item was here before and still is here			listOldSelected.DeleteItem (j);			}		else {			// not there, hence it was just added			p->Select (true, this);			SendMessage (zhlItemSelected, p);			change = true;			}		}		// now handle deselected items	for (i=1; i<= listOldSelected.CountItems(); ++i)		{		p = (ZHLItem*) listOldSelected.GetObject (i);		p->Select (false, this);		SendMessage (zhlItemUnselected, p);		change = true;		}	if (change)		SendMessage (zhlSelectCount, (void*)TotalSelected());		return;	}	// EnumerateThis --	a folder is reporting in with some contents for a refresh.//					So, chalk it up into our listVisible of potentially visible//					cells.//void ZHLDialogItem::EnumerateThis (ZHLItem *o, char nest)	{	int n;	unsigned char *p;		if ((n = listVisible.CountItems()) >= nestLevelSize)		{		// there are more visible entries than we bargained for.		// So, increase the nestLevel buffer by a fixed amount and reallocate.		nestLevelSize += LIST_ENTRIES_INCREMENT;		FailNIL (p = new unsigned char [nestLevelSize]);		BlockMoveData (nestLevel, p, n);		delete nestLevel;		nestLevel = p;		}		// assign it and append	nestLevel [n] = nest;	listVisible.AppendItem (o);	return;	}// FindItemListRect --	Determines whether the given ZHLItem is currently visible//						in the listview.  If yes, returns true and places the cell//						rectangle dimensions in r and its disclosure triangle//						dimensions in t (if both are supplied). If no, returns false.//Boolean ZHLDialogItem::FindItemListRect (ZHLItem *o, Rect *r, Rect *t)	{	int n;		n = listVisible.FindIndex (o);	if (n && n >= firstCell && n < firstCell + visiCells)		{		if (r)			{			r->top = listBounds.top - drawOfs + rowHeight * (n - firstCell);			r->bottom = r->top + rowHeight;			r->left = listBounds.left;			r->right = listBounds.right;						if (t)				SetTriRect (nestLevel[n-1], *r, t);			}		return true;		}		else return false;	}// SetTriRect --	determines, based on an input list cell rectangle and indention//					level, the rectangle for the cell's disclosure triangle control.//inline void ZHLDialogItem::SetTriRect (short nest, Rect &cellRect, Rect *triRect)	{	triRect->top = cellRect.top + (rowHeight - TRIANGLE_HEIGHT) / 2 + 3;//	triRect->left = cellRect.left + ((nest - 1) * NEST_INDENT) + LEFT_PADDING;	triRect->left = cellRect.left + 4;	triRect->bottom = triRect->top + TRIANGLE_HEIGHT;	triRect->right = triRect->left + TRIANGLE_WIDTH;	#if APPEARANCE_MGR_AWARE	if (! gMacInfo.hasAppearanceMgr)#endif		OffsetRect (triRect, -1, -1);	return;	}	// OpenCloseAnimate --	Utility used by OpenFolder() to conditionally animate//						a disclosure triangle using DoDisclosureTri().//void ZHLDialogItem::OpenCloseAnimate (ZHLFolder *o, Boolean opening)	{	Rect r, t;	// if this is visible in the list and we oughtta animate it, do so	if (folderAnimate && FindItemListRect (o, &r, &t))		{		ZGrafState preserve;		SetBackgroundColour (o);		DoDisclosureTri (false, opening, t);		}	return;	}	// DoDisclosureTri --	Handles the disclosure triangle animation for opening or//						closing a folder which is visible in the list.////						forreal = true to test validity of an actual mouse click.//						opening = true if triangle is opening, false if closing.//						t = rectangle in which to place the triangle onscreen.////						Returns the out value of opening (if not forreal this will//						be the same as initial, otherwise will depend on the mouse).//Boolean ZHLDialogItem::DoDisclosureTri (Boolean forreal, Boolean opening, Rect &t)	{	Rect r;	short pc;	Boolean within, result;	Point where = { t.left + 1, t.top + 1 };		FocusBoss();	ZGrafState preserve;		// get control into desired initial state while hiding animation from user	r.top = listBounds.bottom;	r.left = listBounds.right;	r.bottom = r.top + 1;	r.right = r.left + 1;	ClipRect (&r);	ShowControl (discTri);	// allow it to shoot its load	SetControlValue (discTri, !opening);	// force it to change state	HideControl (discTri);	// hide for move	// position and reveal our portable disclosure triangle	ClipRect (&listBounds);	MoveControl (discTri, t.left, t.top);	ShowControl (discTri);	// reveal it so it can take clicks	// now simulate as if the user clicked on it (which they did, kinda)	if (forreal)		{#if APPEARANCE_MGR_AWARE		if (gMacInfo.hasAppearanceMgr)			{			pc = HandleControlClick (discTri, where, NULL, NULL);			within = (pc == kControlTrianglePart);			}		else {#endif			pc = TrackControl (discTri, where, NULL);			within = (pc == kOldTrianglePartCode);#if APPEARANCE_MGR_AWARE			}#endif		}	if (!forreal || within)		{		// switch the setting, so we get a nice Appearance animation		SetControlValue (discTri, opening);		result = opening;		}	else result = !opening;	// hide the control for future use	ClipRect (&r);	// obscure	HideControl (discTri);	return result;	}// SetBackgroundColour --	sets the background colour of the current graphics port//							appropriate to whether the cell should be hilited or//							not (as specified by 'selected').//void ZHLDialogItem::SetBackgroundColour (ZHLItem *o)	{//OLD	if (selected && (!hilited || (!focused && listOptionFlags & zhl::optSmartHilite)))	// if selected, AND hilited, AND either	//		- focused, OR	//		- unfocused but no smart hiliting	if ((IsSelected (o) && hilited)	  && (focused || !(listOptionFlags & zhl::optSmartHilite)))		{		// pull the hilite colour from the window struct (looks messy yeah)#if TARGET_API_MAC_CARBON		RGBBackColor (&gYellow);	// FIX ME!#else		RGBBackColor (& ((GrafVars*) DIALOGGRAFPTR(theDialog->GetMacWindow())->grafVars[0])->rgbHiliteColor);#endif		}	else {		RGBColor	custom;		if( o->CustomBackgroundColour(custom, this) )			RGBBackColor( &custom );		else			SetPlainBackgroundColour();		}	return;	}// SetPlainBackgroundColour //void ZHLDialogItem::SetPlainBackgroundColour()	{#if APPEARANCE_MGR_AWARE		if (gMacInfo.hasAppearanceMgr)			SetThemeBackground (kThemeListViewBackgroundBrush, gZHLMaster.pixelDepth, gZHLMaster.isColourDevice);		else#endif			RGBBackColor (&gLightGray);	}// DrawRowSeparator --	draw the separator line between two items in the list.//						This uses standard Appearance colours, but the user might//						want to override and do something different.//void ZHLDialogItem::DrawRowSeparator (short ax, short ay, short bx, short by)	{#if APPEARANCE_MGR_AWARE	if (gMacInfo.hasAppearanceMgr)		SetThemePen (kThemeListViewSeparatorBrush, gZHLMaster.pixelDepth, gZHLMaster.isColourDevice);	else#endif		RGBForeColor (&gWhite);	MoveTo (ax, ay);	LineTo (bx, by);	return;	}#pragma mark -void ZHLDialogItem::NotifyRemoval (ZHLItem *o)	{		listVisible.DeleteObject( o );		listSelected.DeleteObject( o );		listOldSelected.DeleteObject( o );		listOpenFolders.DeleteObject( o );		if( lastItem == o )			lastItem = NULL;		if( rangeFirst == o )			rangeFirst = NULL;		if( rangeLast == o )			rangeLast = NULL;	}#pragma mark -//------------------------------------------------------------------------------// ZHLMaster -- the ZHL overlord which directs traffic.//------------------------------------------------------------------------------#pragma mark ### ZHLMaster ###ZHLMaster::ZHLMaster()	{	FailNIL (scrollActionUPP = NewControlActionUPP (ZHLScrollActionProc));	}ZHLMaster::~ZHLMaster()	{	if (scrollActionUPP)		DisposeControlActionUPP (gZHLMaster.scrollActionUPP);	}// RedrawIfVisible --	Iterate through all ZHL's, and tell them to refresh their//						display if the given item is contained and presently visible.//void ZHLMaster::RedrawIfVisible (ZHLItem *o)	{	int i, n;	ZHLDialogItem *zhl;		n = allZHL.CountItems();	for (i=1; i<= n; ++i)		{		zhl = allZHL.GetObject (i);		if (zhl->FindItemListRect (o, NULL, NULL) && zhl->drawing)			zhl->DrawListContents();		}		return;	}// RefreshFolderEvent --	Iterate through all ZHL's, telling all those which//							contain the given folder to refresh their//							internal lists and pass on the message to listeners.//void ZHLMaster::RefreshFolderEvent (long msg, ZHLFolder *o, ZHLItem *p)	{	int i, n;	ZHLDialogItem *zhl;		n = allZHL.CountItems();	for (i=1; i<= n; ++i)		{		zhl = allZHL.GetObject (i);		if (zhl->listOpenFolders.Contains (o))			{			// awkward magic to make sure the right thing is posted in the data:			// - zhlFolderSorted sends the sorted folder as data			// - zhlItemAdded/Removed send the item in question as data			if (msg == zhlFolderSorted)				zhl->SendMessage (msg, o);			else zhl->SendMessage (msg, p);						if( msg == zhlItemRemoved )				zhl->NotifyRemoval( p );			if (zhl->drawing) zhl->RefreshListContents();			}		}		return;	}	// ZHLScrollActionProc --	Handle clicks in our live-feedback scroll bar.//							This function assumes that the scroll bar in question is//							the one we want (after all, it should be).//pascal void ZHLScrollActionProc (ControlHandle ch, ControlPartCode pc)	{	short val, n;#if TARGET_API_MAC_CARBON	ZHLDialogItem *zhl = (ZHLDialogItem*)GetControlReference(ch);#else	ZHLDialogItem *zhl = ((ZHLDialogItem*)(ch[0]->contrlRfCon));#endif		if (!pc) return;	// if no part code, don't do jack		if (pc != kControlIndicatorPart)		{		switch (pc)			{			case kControlUpButtonPart:			case kControlDownButtonPart:				n = zhl->rowHeight;				break;						case kControlPageUpPart:			case kControlPageDownPart:				n = zhl->listHeight;				break;						default: break;			}		// if we're going up, it's actually the other way		if (pc == kControlUpButtonPart || pc == kControlPageUpPart)			n = -n;		// if the scroll is already at an extreme, don't bother to refresh anything		val = GetControlValue (ch);		if (val == GetControlMaximum (ch) && n > 0		|| val == GetControlMinimum (ch) && n < 0)			return;		// else move the scroll box and proceed on to render		SetControlValue (ch, val + n);		}	zhl->DrawListContents();	return;	}// the end