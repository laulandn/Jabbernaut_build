Requirements============* Metrowerks CodeWarrior Pro	Version 5 is used by me. It should work with version 6, too. I have no	version 6 right now, so I can't verify it, though.* MacZoop	http://www.maczoop.com	version 2.2f2 or later is recommended* MacJLib	http://sourceforge.net/projects/machlib/	You propably should get the latest version from CVS* GUSI 2.1 or newer	http://sourceforge.net/projects/gusi/	As of this writing, 2.1.3 is current* OpenSSL 0.9.5a	http://www.openssl.org	This is only required if you want to build for SSL support. You can	disable this by adding this line to the prefix file:	#define USE_SSL 0	The binaries are included in CVS, but you still need to get the OpenSSL	headers. A new version of OpenSSL, 0.9.6 has been released recently,	but we have not yet switched to using it.How to build it===============Jabbernaut/TOQ is currently build with Metrowerks Codewarrior Pro 5. However,feel free to try other compilers. If you're successful, please tell me,so I can change the docs.1) Get all required libs and installe them2) Opent the project file3) You now should change the Access Paths to match the locations where you   installed the various libs4) Choose the "Make..." command (or just press Cmd-M), that should build it5) Do a "Run..." (Cmd-R)In case there are any troubles, you propably forgot to update one or more ofthe Access Pathes, or use incorrect versions of the libs. If your problemspersist, feel free to contact me for assistance.Where to get the latest version===============================The Jabbernaut homepage is currently at http://jabbernaut.sourceforge.net.It will move soon to http://www.jabbernaut.com.You can get the latest source from the CVS repository. Look athttp://sourceforge.net/cvs/?group_id=6072 to find out how to access it.For more information on Jabber, see http://www.jabber.org.Understanding how it works==========================Class JabberApplication is where it all begins. Here all components(aka "Managers") are initialised. You should start here if you want tounderstand the app.The ConnectionManager handles all the data flow to/from the Jabber server.It creates a second thread which is responsible for all communication whilethe main thread does all user interaction.The connection thread creates a JabberClient object, which is derived fromMacJLib's BaseClient class. A (Base)Client is a client to a jabber server. Itparses the incoming XML stream and creates appropriate Msg objects based on thestream data. E.g. a <message>...</message> would create a MessageMsg object,<presence>...</presence> creates a PresenceMsg object, and so on. All these arethen collected in a stack.Likewise, if the app wants to send something, it creates a Msg object as needed,then hands it to the ConnectionManager, which in turn hands it to the JabberClientinstance. This will put it on a send stack.The ConnectionThread repeatedly calls Client::processOut() and Client::processIn().processOut() will iterate over the send stack, converting the objects on it to XMLand then sending them to the server. OTOH, processIn() feeds the incoming datato a special XML parser (in our case expat plus some C++ wrapper classes) which createsMsg objects from it (as we mentioned above). These objects then are dispatchedto various handlers that further process them.Managers:---------The SendManager manages all Send Message dialogs. It also delivers outgoing messagesby handing them to the ConnectionManager.The ReceiveManager likewise is called for incomming messages of type="normal", anddisplays them as appropriate in ReceiveMsgDialogs.The PresenceManager handles incoming and outgoing presence information. Currently,it does not itself store these in a DB, but hands them to the RosterManager, whichstores them as part of the roster information. However, this is under considerationand is likely to be changed in the future in order to get a cleaner implementation.The RosterManager, as the name suggests, cares for everything relevant to the Roster.It collects all incoming RosterData and uses this information to constantly updatethe internal Roster database. IT also manages the singles instance of RosterDialog,which is used to display the roster to the user.Currently, the Roster DB is one with the roster item list represantation the user sees.That is, the UI objects also function as data storage. This is functional but not very clean approach. A rewrite for this is planned for the near future to more cleanlyseperate the model from the view.The PrefsManager loads and saves the Profile/TOQ.ini file (which is using XML). Italso contains all the various prefs of the app, and other managers generally "ask"the PrefsManager if they have to determine some setting.The ErrorManager is a helper for the other parts of the app and is used to display errorand also success messages to the user. The advantage of having this as a central partof the app is that it simplifies the localisation to other languages (like Brazilianand German)The SoundManager is used to give audible feedback to the user. Right now it's not doingmuch besides playing some fixed sounds.Helper classes--------------JabberDialog: base class for most dialogs, adds some useful common methods to ZDialogJabberUtils: contains miscellaneous helping methods, like a simple string pattern matcherJabberDITemMaker: hook for our custom UI objects, including:  ZHLDialogItem: handles (hierarchical) lists like in the Roster Dialog. In TOQ,    the lists don't look hierarchical, but ZHL is still used  ColorDialogItem: a color button, which allows the user to choose a color (not in TOQ)   ZIconButtonDialogItem: an item that uses 'cicn's to draw itself (only TOQ)ZTextDebugWindow: these are used for our debug output.Other stuff-----------ProductInformation.c: contains some functions that allow the app to determine its version.Developers==========Max Horn <mailto:max@quendi.de>