///--------------------------------------------------------------------------------------//	File:		SSLConnection.cpp//	Project:	Jabbernaut////	Purpose:	<default>//	Created:	Wednesday, 2000-07-12//	Authors:	MH - Max Horn <max@quendi.de>////	Copyright:	(c) 2000-2001 Max Horn <max@quendi.de>////	This program is free software; you can redistribute it and/or modify//	it under the terms of the GNU General Public License as published by//	the Free Software Foundation; either version 2 of the License, or//	(at your option) any later version.//	//	This program is distributed in the hope that it will be useful,//	but WITHOUT ANY WARRANTY; without even the implied warranty of//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the//	GNU General Public License for more details.//	//	You should have received a copy of the GNU General Public License//	along with this program; if not, write to the Free Software//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit//	<http://www.gnu.org/copyleft/gpl.html> on the World Wide Web.///--------------------------------------------------------------------------------------///- Includes ---------------------------------------------------------------------------#pragma mark === Includes ===#include	"MacZoop.h"#include	"SSLConnection.h"#include	"Randomizer.h"// GUSI includes:#include <errno.h>#include <string.h>#include <unistd.h>#include <netdb.h>#include <arpa/inet.h>#include <sys/socket.h>#include <sys/types.h>// FIX ME#define GUSI_SOURCE#include <GusiBasics.h>#undef GUSI_SOURCEusing namespace MacJLib;	///- Globals ----------------------------------------------------------------------------#pragma mark -#pragma mark === Globals ===///- Static Globals ---------------------------------------------------------------------#pragma mark -#pragma mark === Static Globals ===///- Prototypes -------------------------------------------------------------------------#pragma mark -#pragma mark === Prototypes ===void GUSIThreadSpin(bool wait);#pragma mark -#pragma mark [Class Init]///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------SSLConnection::SSLConnection() : ClientConnection(){	mSocket		= -1;	mBytesAvail	= 0;#if	USE_SSL	mNextTimeUseSSL = false;	mUseSSL = false;		mRandomizer		= new CRandomizer;	mSSL_ctx		= NULL;	mSSL			= NULL;	//	Init SSL stuff	SSL_load_error_strings();	SSL_library_init();	mSSL_ctx = SSL_CTX_new(SSLv23_client_method());	mSSL = SSL_new(mSSL_ctx);#endif	// Install a hook that simply calls YieldToAnyThread()	GUSISetHook(GUSI_SpinHook, (GUSIHook) GUSIThreadSpin);}///--------------------------------------------------------------------------------------//	¥ Destructor:///--------------------------------------------------------------------------------------SSLConnection::~SSLConnection(){	if( mSocket >= 0 )		closeConn();	#if USE_SSL	if( mRandomizer )		ForgetObject( mRandomizer );	if( mSSL != NULL )		SSL_free(mSSL);		if( mSSL_ctx != NULL )		SSL_CTX_free(mSSL_ctx);	ERR_free_strings();	EVP_cleanup();#endif}#pragma mark -///--------------------------------------------------------------------------------------//	initializeConn://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------long	SSLConnection::initializeConn(){/*	ASSERT("mSocket >= 0",mSocket < 0,0);		mSocket = ::socket( AF_INET, SOCK_STREAM, 0 );	if( mSocket < 0 )		return errno;*/		return 0;}///--------------------------------------------------------------------------------------//	openConn://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------long	SSLConnection::openConn( const char *server, unsigned short port ){//	ASSERT("mSocket < 0",mSocket >= 0,0);	ASSERT("mSocket >= 0",mSocket < 0,0);	#if	USE_SSL	ASSERT("mSSL == NULL",mSSL != NULL,0);#endif		long				res;	struct hostent *	ent;	struct sockaddr_in	addr;	int					keep_alive = 1;		ent = ::gethostbyname(server);	if( NULL == ent )		goto BAIL;	::memcpy(&addr.sin_addr.s_addr, ent->h_addr, sizeof(struct in_addr));	addr.sin_family	= AF_INET;	addr.sin_port	= port;		mSocket = ::socket( AF_INET, SOCK_STREAM, 0 );	if( mSocket < 0 )		return errno;	res = ::connect(mSocket, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));	if(res)		goto BAIL;		res = ::setsockopt(mSocket, IPPROTO_TCP, SO_KEEPALIVE, &keep_alive, sizeof(int));	if(res)		goto BAIL;	#if	USE_SSL	mUseSSL = mNextTimeUseSSL;	if( mUseSSL )	{		SSL_set_fd(mSSL,mSocket);		res = SSL_connect(mSSL);		if( res < 0  )		{			res = ERR_get_error();			goto BAIL;		}	}#endif	return 0;BAIL:	int	theErrno = errno;	// save errno here, in case close() changes it		closeConn();		if( theErrno )		return theErrno;	else		return -1;}///--------------------------------------------------------------------------------------//	closeConn://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------long	SSLConnection::closeConn(){	if( mSocket >= 0 )	{		::close( mSocket );		mSocket = -1;	}		return errno;}#pragma mark -///--------------------------------------------------------------------------------------//	getConnectionState://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------ConnectionState	SSLConnection::getConnectionState(){	if( mSocket < 0 )		return kConnectionStateDisconnected;	else		return kConnectionStateConnected;}///--------------------------------------------------------------------------------------//	houseKeeping://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------long	SSLConnection::houseKeeping(){#if	USE_SSL	if( mRandomizer )		mRandomizer->PeriodicAction();#endif	if( mSocket >= 0 )	{		// FIX ME		// send "keep alive packets" (i.e. just a single space)		// this will help to detect if the remote end closed the connection	}		return 0;}#pragma mark -///--------------------------------------------------------------------------------------//	isDataAvail://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------bool	SSLConnection::isDataAvail(){	ASSERT("mSocket < 0",mSocket >= 0,0);		int				res;	fd_set			rdfds;	fd_set			exfds;	struct timeval	delay;	FD_ZERO(&rdfds);	FD_ZERO(&exfds);		FD_SET(mSocket, &rdfds);	FD_SET(mSocket, &exfds);		delay.tv_sec	=	1;	delay.tv_usec	=	0;		res = ::select(mSocket+1, &rdfds, NULL, &exfds, &delay);		if (res <= 0)	{		//throw res;	}	else if (res && FD_ISSET(mSocket, &exfds))	{//		printf("# select() returned an exception\n");		//throw errno;	}	else if (res && FD_ISSET(mSocket, &rdfds))	{		return true;	}	return false;}///--------------------------------------------------------------------------------------//	readBytes://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------long	SSLConnection::readBytes( char *buf, long bufSize ){	ASSERT("mSocket < 0",mSocket >= 0,0);	int	res;#if	USE_SSL	ASSERT("mSSL == NULL",mSSL != NULL,0);	if( mUseSSL )		res = ::SSL_read( mSSL, buf, bufSize );	else#endif	res = ::read( mSocket, buf, bufSize );		if( res <= 0 )		closeConn();	// we are disconnected...			return res;}///--------------------------------------------------------------------------------------//	writeBytes://		put your description here//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------long	SSLConnection::writeBytes( const char *buf, long bufSize ){	ASSERT("mSocket < 0",mSocket >= 0,0);	int	res;#if	USE_SSL	ASSERT("mSSL == NULL",mSSL != NULL,0);	if( mUseSSL )		res = ::SSL_write( mSSL, buf, bufSize );	else#endif	res = ::write( mSocket, (void*)buf, bufSize );	if( res <= 0 )		closeConn();	// we are disconnected...			return res;}#pragma mark -///--------------------------------------------------------------------------------------//	setSSLMode://		(de)activates SSL, but only if not connected!//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------void SSLConnection::setSSLMode( bool useSSL ){#if	USE_SSL	mNextTimeUseSSL = useSSL;#endif}#pragma mark -///--------------------------------------------------------------------------------------//	GUSIThreadSpin://		calls YieldToAnyThread//		//	Changes://		2000-07-12	MH		Created///--------------------------------------------------------------------------------------void GUSIThreadSpin(bool wait){	if( wait )		::YieldToAnyThread();}