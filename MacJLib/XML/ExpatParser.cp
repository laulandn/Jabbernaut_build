/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		ExpatParser.cp *  Created:	2000-04-01 *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ * *	Based on code by Jonathan Wight <JWight@bigfoot.com>. Thank you, Jonathan! */#include "MacJLibUtils.h"#include "ExpatParser.h"#include <iostream>#include "Node.h"#if USE_MACJLIB_NSstatic void My_StartElementHandler(void *userData, const char *name, const char **atts);static void My_EndElementHandler(void *userData, const char *name);static void My_CharacterDataHandler(void *userData, const char *s, int len);static void My_ProcessingInstructionHandler(void *userData, const char *target, const char *data);namespace MacJLib{#endifCExpatParser::CExpatParser(CAbstractHandler *inHandler)	:	CAbstractParser(inHandler),		mExpatParser(NULL){}CExpatParser::~CExpatParser(){}void CExpatParser::StartParsing(void){	MJ_ASSERT( "mExpatParser != NULL", mExpatParser == NULL )	mExpatParser = ::XML_ParserCreate(NULL);	::XML_SetElementHandler(mExpatParser, ::My_StartElementHandler, ::My_EndElementHandler);	::XML_SetCharacterDataHandler(mExpatParser, ::My_CharacterDataHandler);	::XML_SetProcessingInstructionHandler(mExpatParser, ::My_ProcessingInstructionHandler);	::XML_SetUserData(mExpatParser, (void *)this);}void CExpatParser::EndParsing(void){	MJ_ASSERT( "mExpatParser == NULL", mExpatParser != NULL )	bool theResult = ::XML_Parse(mExpatParser, NULL, 0L, true);	// ThrowIf_(theResult == false);	::XML_ParserFree(mExpatParser);}void CExpatParser::Parse(const char *inText, const size_t inTextLength){	MJ_ASSERT( "mExpatParser == NULL", mExpatParser != NULL )	bool theResult = ::XML_Parse(mExpatParser, inText, inTextLength, false);	// ThrowIf_(theResult == false);}#if USE_MACJLIB_NS}#endif#pragma mark -void My_StartElementHandler(void *userData, const char *name, const char **atts){	MJ_ASSERT( "userData == NULL", userData != NULL )	MacJLib::CExpatParser *theParser = (MacJLib::CExpatParser *)userData;	MacJLib::CAttributeMap theAttributeMap;	if (atts)	{		for (int N=0; atts[N] && atts[N+1]; N+=2)			theAttributeMap[atts[N]] = atts[N+1];	}	theParser->HandleStartElement(name, theAttributeMap);}void My_EndElementHandler(void *userData, const char *name){	MJ_ASSERT( "userData == NULL", userData != NULL )	MacJLib::CExpatParser *theParser = (MacJLib::CExpatParser *)userData;	theParser->HandleEndElement(name);}void My_CharacterDataHandler(void *userData, const char *s, int len){	// Assert_(userData != NULL);	MacJLib::CExpatParser *theParser = (MacJLib::CExpatParser *)userData;	theParser->HandleCharacterData(std::string(s, len));}/* target and data are '\0' terminated */void My_ProcessingInstructionHandler(void *userData, const char *target, const char *data){	#pragma unused (userData, target, data)	// Throw_(-1);}