/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		Node.cp *  Created:	2000-04-01 *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ * *	Based on code by Jonathan Wight <JWight@bigfoot.com>. Thank you, Jonathan! */#include	"Node.h"#include	<sstream>#include	<cstdlib>#if USE_MACJLIB_NSnamespace MacJLib{#endifCElementNode::CElementNode(CElementNode *parent)	:	CAbstractNode(),		mParentNode(parent){}CElementNode::CElementNode(const CElementNode &inTagNode)	:	CAbstractNode(),		mParentNode(NULL){	Assign( inTagNode );}CElementNode::CElementNode(const std::string &inName)	:	CAbstractNode(),		mName(inName),		mParentNode(NULL){}CElementNode::CElementNode(const std::string &inName, const CAttributeMap &inAttributeMap)	:	CAbstractNode(),		mName(inName),		mAttributeMap(inAttributeMap),		mParentNode(NULL){}CElementNode::CElementNode(CElementNode *parent, const std::string &inName, const CAttributeMap &inAttributeMap)	:	CAbstractNode(),		mName(inName),		mAttributeMap(inAttributeMap),		mParentNode(parent){}CElementNode::~CElementNode(){	for (CNodeList::const_iterator X = mChildNodes.begin(); X != mChildNodes.end(); ++X)		delete *X;}void CElementNode::AppendChild(CAbstractNode *inNode){	CElementNode	*elementNode = dynamic_cast<CElementNode *>(inNode);	mChildNodes.push_back(inNode);	if( elementNode )		elementNode->mParentNode = this;}void CElementNode::RemoveChild(CAbstractNode *inNode){	CElementNode	*elementNode = dynamic_cast<CElementNode *>(inNode);	mChildNodes.remove(inNode);	if( elementNode )		elementNode->mParentNode = NULL;}std::string	CElementNode::AttribVal(const std::string &key) const{	CAttributeMap::const_iterator pos;	pos = mAttributeMap.find( key );	if( pos != mAttributeMap.end() )		return pos->second;	else		return std::string("");}const CElementNode& CElementNode::Assign( const CElementNode& aNode ){	// copy the name	mName = aNode.mName;		// copy the attribute map	mAttributeMap = aNode.mAttributeMap;	// first, empty the old child list	for (CNodeList::const_iterator X = mChildNodes.begin(); X != mChildNodes.end(); ++X)		delete *X;	mChildNodes.clear();	// then, clone the child list of aNode	for (CNodeList::const_iterator X = aNode.mChildNodes.begin(); X != aNode.mChildNodes.end(); ++X)		mChildNodes.push_back((*X)->Clone());		return *this;}/*std::string CElementNode::AsUnescapedString() const{	std::string	fullStr;		fullStr = "<" + mName;		fullStr += AttributeString();	if( mChildNodes.empty() )		fullStr += "/>";	else		fullStr += ">" + ContentUnescapedString() + "</" + mName + ">";	return fullStr;}*/std::string CElementNode::AsString( bool escaped ) const{	std::string	fullStr("<");		if( escaped )		fullStr += EscapeXML( mName );	else		fullStr += mName;			fullStr += AttributeString();	if( mChildNodes.empty() )		fullStr += "/>";	else	{		fullStr += ">";		for (CNodeList::const_iterator X = mChildNodes.begin(); X != mChildNodes.end(); ++X)			fullStr += (*X)->AsString( escaped );		fullStr +=  "</";		if( escaped )			fullStr += EscapeXML( mName );		else			fullStr += mName;		fullStr +=  ">";	}	return fullStr;}std::string CElementNode::AttributeString() const{	std::string	attribStr;		for (CAttributeMap::const_iterator X = mAttributeMap.begin(); X != mAttributeMap.end(); ++X)		attribStr += " " + X->first + "=\"" + X->second + "\"";	return attribStr;}/*std::string CElementNode::ContentUnescapedString() const{	std::string	subTagStr;		for (CNodeList::const_iterator X = mChildNodes.begin(); X != mChildNodes.end(); ++X)		subTagStr += (*X)->AsUnescapedString();	return subTagStr;}std::string CElementNode::ContentEscapedString() const{	std::string	subTagStr;		for (CNodeList::const_iterator X = mChildNodes.begin(); X != mChildNodes.end(); ++X)		subTagStr += (*X)->AsString();	return subTagStr;}*/CElementNode*	CElementNode::Clone() const{	return new CElementNode(*this);}#pragma mark -CElementNode*	CElementNode::PathFindNode( const std::string &path, bool createIfMissing ){	CElementNode					*curNode, *nextNode;	std::string::size_type		begIdx, endIdx;	const std::string			delims("/");	std::string					key;		// We are the iteration root.	curNode = this;		// Tokenize the text line	begIdx = path.find_first_not_of(delims);	while( curNode && (begIdx != std::string::npos) )	{		// Search end of word		endIdx = path.find_first_of(delims, begIdx);		if( endIdx == std::string::npos )			endIdx = path.length();				// Extract the key		key = path.substr(begIdx, endIdx-begIdx);		nextNode = NULL;		for (CNodeList::const_iterator X = curNode->ChildNodes().begin(); X != curNode->ChildNodes().end(); ++X)		{			nextNode = dynamic_cast<CElementNode*>(*X);			if( nextNode )			{				if( key == nextNode->mName )					break;			}			nextNode = NULL;		}		if( createIfMissing && (nextNode == NULL) )		{			nextNode = new CElementNode( key, CAttributeMap() );			curNode->AppendChild( nextNode );		}		curNode = nextNode;				begIdx = path.find_first_not_of(delims, endIdx);	}		return curNode;}const CElementNode*	CElementNode::PathFindNode( const std::string &path ) const{	const CElementNode				*curNode, *nextNode;	std::string::size_type		begIdx, endIdx;	const std::string			delims("/");	std::string					key;		long test;		test = mChildNodes.size();	if ( test == 0 )		key = "damn";		// We are the iteration root.	curNode = this;		// Tokenize the text line	begIdx = path.find_first_not_of(delims);	while( curNode && (begIdx != std::string::npos) )	{		// Search end of word		endIdx = path.find_first_of(delims, begIdx);		if( endIdx == std::string::npos )			endIdx = path.length();				// Extract the key		key = path.substr(begIdx, endIdx-begIdx);		nextNode = NULL;		for (CNodeList::const_iterator X = curNode->ChildNodes().begin(); X != curNode->ChildNodes().end(); ++X)		{			nextNode = dynamic_cast<CElementNode*>(*X);			if( nextNode )			{				if( key == nextNode->mName )					break;			}			nextNode = NULL;		}		curNode = nextNode;				begIdx = path.find_first_not_of(delims, endIdx);	}		return curNode;}void	CElementNode::PathGetNodeList( const std::string &path, CNodeList &nodeList ) const{	const CElementNode			*curNode, *nextNode;	std::string::size_type		begIdx, endIdx;	const std::string			delims("/");	std::string					key;	bool						endNodeReached = false;		// First, empty the give node list	nodeList.clear();		// We are the iteration root.	curNode = this;		// Tokenize the text line	begIdx = path.find_first_not_of(delims);	while( curNode && (begIdx != std::string::npos) )	{		// Search end of word		endIdx = path.find_first_of(delims, begIdx);				if( endIdx == std::string::npos )		{			endNodeReached = true;			endIdx = path.length();		}				// Extract the key		key = path.substr(begIdx, endIdx-begIdx);		nextNode = NULL;		for (CNodeList::const_iterator X = curNode->ChildNodes().begin(); X != curNode->ChildNodes().end(); ++X)		{			nextNode = dynamic_cast<CElementNode*>(*X);			if( nextNode )			{				if( key == nextNode->mName )				{					if ( endNodeReached )						nodeList.push_back( (CAbstractNode*)nextNode );					else						break;				}			}			nextNode = NULL;		}		curNode = nextNode;				begIdx = path.find_first_not_of(delims, endIdx);	}}#pragma mark -void	CElementNode::PathGetValue( const std::string &path, const std::string &key, StringList &result ) const{	CElementNode	*curNode;	CNodeList		nodeList;		PathGetNodeList( path + "/" + key, nodeList );		result.clear();	for (CNodeList::const_iterator X = nodeList.begin(); X != nodeList.end(); ++X)	{		curNode = dynamic_cast<CElementNode*>(*X);		if( curNode && curNode->IsLeaf() )			result.push_back( curNode->GetLeafData() );	}}void	CElementNode::PathSetValue( const std::string &path, const std::string &key, const StringList &data ){	CElementNode	*elementNode = NULL;	CElementNode	*newNode = NULL;	elementNode = PathFindNode( path, true );	if( elementNode )	{		// first, empty the old child list		for (CNodeList::const_iterator X = elementNode->mChildNodes.begin(); X != elementNode->mChildNodes.end(); ++X)			delete *X;		elementNode->mChildNodes.clear();		// then, add a single char data child		for (StringList::const_iterator X = data.begin(); X != data.end(); ++X)		{			newNode = new CElementNode(key);			newNode->AppendChild(new CTextNode(*X));			elementNode->AppendChild( newNode );		}	}}#pragma mark -bool	CElementNode::PathGetValue( const std::string &path, std::string &result, const std::string &defaultValue ) const{	const CElementNode	*elementNode = NULL;		elementNode = PathFindNode( path );	if( elementNode && elementNode->IsLeaf() )	{		result = MacJLib::Trim(elementNode->GetLeafData());		return true;	}	else	{		result = defaultValue;		return false;	}}bool	CElementNode::PathGetValue( const std::string &path, bool &result, bool defaultValue ) const{	const CElementNode	*elementNode = NULL;		elementNode = PathFindNode( path );	if( elementNode && elementNode->IsLeaf() )	{		result = (MacJLib::Trim(elementNode->GetLeafData()) == "true");		return true;	}	else	{		result = defaultValue;		return false;	}}bool	CElementNode::PathGetValue( const std::string &path, long &result, long defaultValue ) const{	const CElementNode	*elementNode = NULL;		elementNode = PathFindNode( path );	if( elementNode && elementNode->IsLeaf() )	{		result = std::atol( elementNode->GetLeafData().c_str() );		return true;	}	else	{		result = defaultValue;		return false;	}}#pragma mark -void		CElementNode::PathSetValue( const std::string &path, const std::string &data ){	CElementNode					*curNode;	curNode = PathFindNode( path, true );	if( curNode )	{		// first, empty the old child list		for (CNodeList::const_iterator X = curNode->mChildNodes.begin(); X != curNode->mChildNodes.end(); ++X)			delete *X;		curNode->mChildNodes.clear();		// then, add a single char data child		curNode->AppendChild( new CTextNode(data) );	}}void		CElementNode::PathSetValue( const std::string &path, bool data ){	const static std::string	true_str("true");	const static std::string	false_str("false");	if( data )		PathSetValue( path, true_str );	else		PathSetValue( path, false_str );}void		CElementNode::PathSetValue( const std::string &path, long data ){	std::ostringstream	os;	os << data;	PathSetValue( path, os.str() );}#pragma mark -bool			CElementNode::IsLeaf() const{	for (CNodeList::const_iterator X = mChildNodes.begin(); X != mChildNodes.end(); ++X)		if( typeid(**X) != typeid(CTextNode) )			return false;			return true;}std::string		CElementNode::GetLeafData() const{	CTextNode		*textNode = NULL;	std::string		leafData;		for (CNodeList::const_iterator X = mChildNodes.begin(); X != mChildNodes.end(); ++X)	{		textNode = dynamic_cast<CTextNode*>(*X);		if( textNode )			leafData += textNode->GetData();		else			return std::string();	}		return leafData;}void			CElementNode::SetLeafData( const std::string& data ){	// FIX ME	// IMPLEMENT ME}#pragma mark -CTextNode::CTextNode(const std::string &inData)	:	CAbstractNode(),		mData(inData){}CTextNode::~CTextNode(){}const CTextNode& CTextNode::Assign( const CTextNode& aNode ){	mData = aNode.mData;		return *this;}std::string CTextNode::AsString( bool escaped ) const{	if( escaped )		return EscapeXML( mData );	else		return mData;}CTextNode*	CTextNode::Clone() const{	return new CTextNode(mData);}#if USE_MACJLIB_NS}#endif