/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		Node.h *  Created:	2000-04-01 *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ * *	Based on code by Jonathan Wight <JWight@bigfoot.com>. Thank you, Jonathan! */#pragma once#include	"MacJLibUtils.h"#include	<list>#include	<map>#include	<string>#define CNODE_BACKWARD_COMPATIBILITY	0	#if USE_MACJLIB_NSnamespace MacJLib{#endif	class CAbstractNode;	class CElementNode;	class CTextNode;	class CAttributeNode;	typedef std::map <std::string, std::string> CAttributeMap;	typedef CElementNode *(*NodeCreatorFuncP)(const std::string &inName, const CAttributeMap &inAttributeMap);	typedef std::list <CAbstractNode *> CNodeList;	class CAbstractNode	{		public:			CAbstractNode()				{}			virtual ~CAbstractNode()				{}						virtual std::string				AsString( bool escaped ) const = 0;			virtual CAbstractNode*			Clone() const = 0;#if CNODE_BACKWARD_COMPATIBILITY			// FOR BACKWARD COMPATIBILITY://			virtual std::string				AsUnescapedString() const = 0;//			virtual std::string				AsEscapedString() const = 0;#endif	};	class CElementNode : public CAbstractNode	{		public:			CElementNode(CElementNode *parent = NULL);			CElementNode(const CElementNode &inTagNode);//			CElementNode(const CElementNode *parent, const CElementNode &inTagNode);			CElementNode(const std::string &inName);			CElementNode(const std::string &inName, const CAttributeMap &inAttributeMap);			CElementNode(CElementNode *parent, const std::string &inName, const CAttributeMap &inAttributeMap);			virtual ~CElementNode();			const std::string&		GetName(void) const				{ return mName; }			const void				SetName(std::string& name)				{ mName = name; }			const CAttributeMap&	AttributeMap(void) const				{ return mAttributeMap; }			const CNodeList&		ChildNodes(void) const				{ return mChildNodes; }			virtual void			AppendChild(CAbstractNode *inNode);			virtual void			RemoveChild(CAbstractNode *inNode);			std::string				AttribVal(const std::string &key) const;			const CElementNode&	operator=( const CElementNode& aNode )				{ return Assign(aNode); }			virtual std::string		AsString( bool escaped ) const;			virtual CElementNode*	Clone() const;						CElementNode*			PathFindNode( const std::string &path, bool createIfMissing = false );			const CElementNode*		PathFindNode( const std::string &path ) const;			void					PathGetNodeList( const std::string &path, CNodeList &nodeList ) const;			void					PathGetValue( const std::string &path, const std::string &key, StringList &result ) const;			void					PathSetValue( const std::string &path, const std::string &key, const StringList &data );			bool					PathGetValue( const std::string &path, std::string &result, const std::string &defaultValue ) const;			bool					PathGetValue( const std::string &path, bool &result, bool defaultValue) const;			bool					PathGetValue( const std::string &path, long &result, long defaultValue) const;			void					PathSetValue( const std::string &path, const std::string &data );			void					PathSetValue( const std::string &path, bool data );			void					PathSetValue( const std::string &path, long data );						bool					IsLeaf() const;			std::string				GetLeafData() const;			void					SetLeafData( const std::string& data );		protected:			const CElementNode&		Assign( const CElementNode& aNode );//			virtual std::string		AsEscapedString() const;//			virtual std::string		AsUnescapedString() const;			virtual std::string		AttributeString() const;//			virtual std::string		ContentUnescapedString() const;//			virtual std::string		ContentEscapedString() const;		protected:			std::string					mName;			CAttributeMap				mAttributeMap;			CNodeList					mChildNodes;			CElementNode				*mParentNode;	};	class CTextNode : public CAbstractNode	{		public:			CTextNode(const std::string &inData);			virtual ~CTextNode();					const std::string			&GetData(void) const				{ return mData; }			void						SetData(const std::string &inData)	{ mData = inData; }			void						SetData(const char *inData, std::size_t inSize)												{ mData.assign( inData, inSize ); }			const CTextNode&			operator=( const CTextNode& aNode )	{ return Assign(aNode); }			virtual std::string			AsString( bool escaped ) const;			virtual CTextNode*			Clone() const;				protected:			const CTextNode&			Assign( const CTextNode& aNode );//			virtual std::string			AsUnescapedString() const;		protected:			std::string				mData;	};		class CPath	{		public:			CPath();			CPath(const std::string &path);											protected:			struct Constrain			{			};			struct PathStep			{				enum				{					kAncestor,					kAncestorOrSelf,					kAttribute,					kChild,					kDescendant,					kDescendantOrSelf,					kFollowing,					kFollowingSibling,					kNameSpace,					kParent,					kPreceding,					kPrecedingSibling,					kSelf				}						axis;				std::string				name;				long					count;				std::list<Constrain>	ConstraintList;			};			std::list<PathStep>		mPath;	};	#if CNODE_BACKWARD_COMPATIBILITY	// FOR BACKWARD COMPATIBILITY:	typedef CElementNode	CTagNode;	typedef CAbstractNode	CNode;	typedef CTextNode		CCharDataNode;#endif#if USE_MACJLIB_NS}#endif