/****************************   URandomLib   *********************************This is a Macintosh/Motorola implementation of the Ultra pseudo-randomnumber generator.References --	Creator:	Prof. George Marsaglia and Co-workers				Dept. of Statistics				Florida State University					Code by:	Dr. Michael P. McLaughlin				MITRE Corporation				MS W337				1820 Dolley Madison Blvd.				McLean, VA  22102								E-mail: mpmcl@mitre.org					Please acknowledge the work of others by leaving this header intact.	      ---------------  Things to watch out for  ---------------	sizeof(double) is compiler-option dependent and is here unspecified.	Longs and floats are 4 bytes.	Shorts are 2 bytes.		Functions returning bytes are pre-cast to short.		Registers not saved:		68K:	D0-D2, A0-A1		PPC:	r3-r10*****************************************************************************/#include <stdio.h>#include <OSUtils.h>#include <math.h>#include "URandomLib.h"unsigned long	Ultra_FSR[37],				// final random numbers					Ultra_SWB[37],				// subtract-with-borrow output					Ultra_brw,					// either borrow(68K) or ~borrow(PPC)					Ultra_seed1;short				Ultra_byt;					// # bytes left in FSR[37]char				*Ultra_ptr;					// running pointer to FSR[37]URandomLib::URandomLib(){	Initialize();}/*	Refill() is the core of URandomLib (see Marsaglia and Zaman, 1991,	"A New Class of Random Number Generators", Annals of Applied Probability,	vol. 1(3), 426-480). It refills Ultra_SWB[37] via a subtract-with-borrow	PRNG then superimposes a multiplicative congruential PRNG to produce	Ultra_FSR[37] which supplies all of the Ultra-random bytes. */#if defined(powerc)asm void URandomLib::Refill(){		lwz		r3,Ultra_brw		// fetch global addresses from TOC		lwz		r6,Ultra_SWB		lwz		r4,0(r3)				// ~borrow		la			r7,48(r6)			// &Ultra_SWB[12]		sub		r5,r5,r5				// clear entire word		mr			r8,r5					// counter		li			r5,1		sraw		r4,r4,r5				// restore XER|CA		li			r8,24		mtctr		r8		la			r4,-4(r6)UR1:	lwzu		r9,4(r7)		lwz		r10,4(r4)		subfe		r9,r10,r9			// r9 -= r10		stwu		r9,4(r4)		bdnz+		UR1		mr			r7,r6					// &Ultra_SWB		li			r8,13		mtctr		r8		la			r7,-4(r6)UR2:	lwzu		r9,4(r7)		lwz		r10,4(r4)		subfe		r9,r10,r9			// r9 -= r10		stwu		r9,4(r4)		bdnz+		UR2		lwz		r4,0(r3)				// ~borrow again		addme		r4,r5					// r5 = 1		neg		r4,r4		stw		r4,0(r3)				// new ~borrow		la			r6,-4(r6)			// &SWB[-1]		lwz		r7,Ultra_FSR		lwz		r5,Ultra_ptr		lwz		r4,Ultra_seed1		stw		r7,0(r5)				// reset running pointer to FSR		la			r7,-4(r7)			// overlay congruential PRNG		lis		r10,1					// r10 = 69069		addi		r10,r10,3533		lwz		r5,0(r4)				// Ultra_seed1		li			r8,37		mtctr		r8UR3:	lwzu		r9,4(r6)				// SWB		mullw		r5,r5,r10			// Ultra_seed1 *= 69069		xor		r9,r9,r5		stwu		r9,4(r7)						bdnz+		UR3		stw		r5,0(r4)				// save Ultra_seed1 for next time		lwz		r7,Ultra_byt		li			r5,148				// 4*37 bytes		sth		r5,0(r7)				// reinitialize		blr}#elseasm void URandomLib::Refill(){		machine	68020		MOVE.L	A2,-(SP)				// not scratch		LEA		Ultra_SWB,A2		// &Ultra_SWB[0]		LEA		52(A2),A1			// &Ultra_SWB[13]		MOVEQ		#0,D0					// restore extend bit		SUB.L		Ultra_brw,D0		MOVEQ		#23,D2				// 24 of theseUR1:	MOVE.L	(A1)+,D0		MOVE.L	(A2),D1		SUBX.L	D1,D0		MOVE.L	D0,(A2)+		DBRA		D2,UR1		LEA		Ultra_SWB,A1		MOVEQ		#12,D2				// 13 of theseUR2:	MOVE.L	(A1)+,D0		MOVE.L	(A2),D1		SUBX.L	D1,D0					// subtract-with-borrow		MOVE.L	D0,(A2)+		DBRA		D2,UR2		MOVEQ		#0,D0		MOVE.L	D0,D1		ADDX		D1,D0					// get borrow bit		MOVE.L	D0,Ultra_brw		//    and save it		LEA		Ultra_SWB,A1		LEA		Ultra_FSR,A2		MOVE.L	A2,Ultra_ptr		// reinitialize running pointer		MOVE.L	Ultra_seed1,D0		MOVE.L	#69069,D1			// overlay congruential PRNG		MOVEQ		#36,D2				// 37 of theseUR3:	MOVE.L	(A1)+,(A2)		MULU.L	D1,D0		EOR.L		D0,(A2)+		DBRA		D2,UR3		MOVE.L	D0,Ultra_seed1		// save global for next time		MOVE		#148,Ultra_byt		// 4*37 bytes left		MOVE.L	(SP)+,A2				// restore A2		RTS}#endif/*	ULong32() returns a four-byte integer, ~U[-2147483648, 2147483647]. It may,	of course, be cast to unsigned long. */long URandomLib::ULong32(){	register long	result;		if (Ultra_byt < 4) Refill();	result = *((long *) Ultra_ptr);	Ultra_ptr += 4; Ultra_byt -= 4;	return result;}/*	ULong31() returns a four-byte integer, ~U[0, 2147483647]. */long URandomLib::ULong31(){	register long	result;		if (Ultra_byt < 4) Refill();	result = *((long *) Ultra_ptr);	Ultra_ptr += 4; Ultra_byt -= 4;	return result & 0x7FFFFFFF;}/*	UShort16() returns a two-byte integer, ~U[-32768, 32767]. */short URandomLib::UShort16(){	register short	result;		if (Ultra_byt < 2) Refill();	result = *((short *) Ultra_ptr);	Ultra_ptr += 2; Ultra_byt -= 2;	return result;}/*	UShort15() returns a two-byte integer, ~U[0, 32767]. */short URandomLib::UShort15(){	register short	result;		if (Ultra_byt < 2) Refill();	result = *((short *) Ultra_ptr);	Ultra_ptr += 2; Ultra_byt -= 2;	return result & 0x7FFF;}/*	UShort8() returns a two-byte integer, ~U[-128, 127]. It gets a random	byte and casts it to short. This operation extends the sign bit.	Consequently, you may NOT cast this function to unsigned short/long (see 	UShort8u() below). */short URandomLib::UShort8(){	register short	result;		if (Ultra_byt < 1) Refill();	result = (short) *Ultra_ptr;	Ultra_ptr += 1; Ultra_byt -= 1;	return result;}/*	UShort8u() returns a two-byte integer, ~U[0, 255]. It proceeds as in	UShort8() but clears the high byte instead of extending the sign bit. */short URandomLib::UShort8u(){	register short	result;		if (Ultra_byt < 1) Refill();	result = (short) *Ultra_ptr;	Ultra_ptr += 1; Ultra_byt -= 1;	return result & 0xFF;}/*	UShort7() returns a two-byte integer, ~U[0, 127]. */short URandomLib::UShort7(){	register short	result;		if (Ultra_byt < 1) Refill();	result = (short) (*Ultra_ptr & 0x7F);	Ultra_ptr += 1; Ultra_byt -= 1;	return result;}/*	UBoolean() returns true or false.	It calls ULong32() and returns the bits one at a time. */Boolean URandomLib::UBoolean(){	register Boolean	result;		if (Ultra_bit <= 0) {		Ultra_bits = ULong32();		Ultra_bit = 32;	}	result = (Ultra_bits < 0) ? true : false;	Ultra_bits += Ultra_bits;						// shift left by one	--Ultra_bit;	return result;}/*	Uniform_0_1() returns a four-byte float, ~U(0, 1), with >= 25 bits of precision.	This precision is achieved by continually testing the leading byte, b, of the 	mantissa. If b == 0, it is replaced with a new random byte and the decimal point 	readjusted. This simultaneously ensures that Uniform_0_1() never returns zero. */float URandomLib::Uniform_0_1(){	register double	fac = Ultra_2n31;	register long		along;	register short		extra;		along = ULong31();	if (along >= 0x01000000) return (float)(fac*along);	for (extra=0;!extra;) {							// will not be an infinite loop		 extra = UShort7();		 fac *= Ultra_2n7;	}	along |= (((long)extra) << 24);	return (float)(fac*along);}/*	Uniform_m1_1() returns a four-byte float, ~U(-1, 1), with the same features as	described above for Uniform_0_1(). */float URandomLib::Uniform_m1_1(){	register double	fac = Ultra_2n31;	register long		along, limit = 0x01000000;	register short		extra;		if ((along = ULong32()) >= limit)		return (float)(fac*along);	else if (-along >= limit)		return (float)(fac*along);	for (extra=0;!extra;) {		 extra = UShort7();		 fac *= Ultra_2n7;	}	if (along >= 0) {		along |= (((long)extra) << 24);		return (float)(fac*along);	}	along = -along;	along |= (((long)extra) << 24);	return (float)(-fac*along);}/*	DUniform_0_1() and DUniform_m1_1() return double-precision U[0,1) and U(-1,1). 	In both cases, zero IS a remote possibility. These functions are intended for	those occasions when seven significant figures are not enough. If you need	TYPE double, but not double PRECISION, then it is much faster to use	Uniform_0_1() or Uniform_m1_1() and cast -- implicitly or explicitly. */double URandomLib::DUniform_0_1(){	return ULong31()*Ultra_2n31 + ((unsigned long) ULong32())*Ultra_2n63;}double URandomLib::DUniform_m1_1(){	return ULong32()*Ultra_2n31 + ((unsigned long) ULong32())*Ultra_2n63;}/*	Normal() returns a four-byte float, ~Normal(mu, sigma), where mu and sigma are the	mean and standard deviation, resp., of the parent population. The normal variates	returned are exact, not approximate. Normal() uses Uniform_m1_1() so there is no	possibility of a result exactly equal to mu. Note that mu and sigma must also be	floats, not doubles. */float URandomLib::Normal(float mu, float sigma){	register double	fac, rsq, v1, v2;	if ((v1 = Ultra_gauss) != 0.0) {		// Is there one left?		Ultra_gauss = 0.0;		return (float)(sigma*v1 + mu);	}	do {		v1 = Uniform_m1_1();		v2 = Uniform_m1_1();		rsq = v1*v1 + v2*v2;	} while (rsq >= 1.0);	fac = sqrt(-2.0*log(rsq)/rsq);	Ultra_gauss = fac*v2;					// Save the first N(0,1) as double	return (float)(sigma*fac*v1 + mu);	// and return the second.}/*	Expo() returns a four-byte float, ~Exponential(lambda). The parameter, lambda, 	is both the mean and standard deviation of the parent population. It must be a	float greater than zero. */float URandomLib::Expo(float lambda){	return (float)(-lambda*log(Uniform_0_1()));}/*	SaveStart() and RecallStart() save and restore, resp., the complete state of 	URandomLib. Call SaveStart() at the point where it may be necessary to recall 	a sequence of random numbers exactly. To recover the sequence later, call 	RecallStart(). To terminate a program and still recover a random sequence, save 	Ultra_Remember to a file and read it back upon restart. */Boolean URandomLib::SaveStart(char *pathname){	Ultra_Remember.gauss = Ultra_gauss;	Ultra_Remember.bits = Ultra_bits;	Ultra_Remember.seed1 = Ultra_seed1;	Ultra_Remember.seed2 = Ultra_seed2;	Ultra_Remember.brw = Ultra_brw;	Ultra_Remember.byt = Ultra_byt;	Ultra_Remember.bit = Ultra_bit;	Ultra_Remember.ptr = Ultra_ptr;	for (int i = 0;i < 37;i++) {		Ultra_Remember.FSR[i] = Ultra_FSR[i];		Ultra_Remember.SWB[i] = Ultra_SWB[i];	}		if (pathname != nil) {		FILE	*outfile;		if ((outfile = fopen(pathname, "w")) != nil) {			fwrite((void *) &Ultra_Remember, sizeof(Ultra_Remember), 1L, outfile);			fclose(outfile);		}		else return false;	}	return true;}Boolean URandomLib::RecallStart(char *pathname){	if (pathname != nil) {		FILE	*infile;		if ((infile = fopen(pathname, "r")) != nil) {			fread((void *) &Ultra_Remember, sizeof(Ultra_Remember), 1L, infile);			fclose(infile);		}		else return false;	}	Ultra_gauss = Ultra_Remember.gauss;	Ultra_bits = Ultra_Remember.bits;	Ultra_seed1 = Ultra_Remember.seed1;	Ultra_seed2 = Ultra_Remember.seed2;	Ultra_brw = Ultra_Remember.brw;	Ultra_byt = Ultra_Remember.byt;	Ultra_bit = Ultra_Remember.bit;	Ultra_ptr = Ultra_Remember.ptr;	for (int i = 0;i < 37;i++) {		Ultra_FSR[i] = Ultra_Remember.FSR[i];		Ultra_SWB[i] = Ultra_Remember.SWB[i];	}	return true;}/*	Initialize() computes a few global constants, initializes others, and fills	in the initial Ultra_SWB array using the supplied seeds. It terminates by	calling SaveStart() so that you may recover the whole sequence of random 	numbers by calling RecallStart(). */void URandomLib::Initialize(unsigned long seed1, unsigned long seed2){#if defined(powerc)#define	ULTRABRW	0xFFFFFFFF#else#define	ULTRABRW	0x00000000#endif	unsigned long	tempbits, ul, upper, lower;		if ((seed1 == 0) || (seed2 == 0)) {	// random initialization		::GetDateTime(&seed1);		upper = (seed1 & 0xFFFF0000) >> 16;		lower = seed1 & 0xFFFF;		seed2 = upper*lower;					// might overflow	}	Ultra_seed1 = seed1; Ultra_seed2 = seed2; 	for (int i = 0;i < 37;i++) {		tempbits = 0;		for (int j = 32;j > 0;j--) {			Ultra_seed1 *= 69069;			Ultra_seed2 ^= (Ultra_seed2 >> 15);			Ultra_seed2 ^= (Ultra_seed2 << 17);			ul = Ultra_seed1 ^ Ultra_seed2;			tempbits = (tempbits >> 1) | (0x80000000 & ul);		}		Ultra_SWB[i] = tempbits;	}	Ultra_2n31 = ((2.0/65536)/65536);	Ultra_2n63 = 0.5*Ultra_2n31*Ultra_2n31;	Ultra_2n7 = 1.0/128;	Ultra_gauss = 0.0;	Ultra_byt = Ultra_bit = 0;	Ultra_brw = ULTRABRW;					// no borrow yet	SaveStart();}