/*Copyright (C) 2000  Chris BehmThis library is free software; you can redistribute it and/ormodify it under the terms of the GNU Lesser General PublicLicense as published by the Free Software Foundation; eitherversion 2.1 of the License, or (at your option) any later version.This library is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNULesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with this library; if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USAContact Chris Behm at cjbehm@mail.comThe GNU LGPL is also readable at http://www.gnu.org/copyleft/lesser.html**** NOTICE ****This OpenTransport class is most definitely NOT of release quality NOR isit part of MacJLib. It is provided here as an example of the creating a connection subclass.**** NOTICE *****/#pragma once#include "ClientConnection.h"#include <OpenTransport.h>#include <OpenTptInternet.h>#include <cstring>#include <stdio.h>namespace MacJLib {enum ExtraErrors{	kConnectionNoErr = 0,	kConnectionNotClosedYet,	kConnectionRefusedOrBroken};enum OT_States{	ms_undef	= -1,	ms_creating,	ms_created,	ms_binding,	ms_bound,	ms_opening,	ms_open,	ms_connected,	ms_unbinding,	ms_unbound,	ms_closingDis,			//disorderly close	ms_closing,	//ms_closeFinishData,		//orderly close, finish reading data then send disconnect	ms_closed};typedef struct{	void		*mBuffer;	long		bufSize;	long		bytesUsed;	EndpointRef	ep;	long		OTState;	char		wegotdata;	char		*mHostAddress;	bool		wasCanceled;	bool		taskInProgress;	OSErr		err;}OTTInfo;class OTClientConnection : public ClientConnection{	private:		OTConfiguration *mBaseCFG;		OTTInfo			mOtInfo;		OTNotifyUPP		mNotifierCallback;		//std::string		mHostAddress;	//name & port	protected:	public:		OTClientConnection();		~OTClientConnection();		virtual ConnectionState getConnectionState();		virtual long houseKeeping();				virtual long initializeConn();		virtual long openConn( const char *server, unsigned short port );		virtual long closeConn();		//virtual Boolean connected();		virtual bool isDataAvail();		virtual long readBytes( char *buf, long maxSize );		virtual long writeBytes( const char *buf, long bufSize );		virtual long resizeBuffer( long newSize );		virtual long getBufferSize();				virtual char *errorToCStr( long errNo );};}