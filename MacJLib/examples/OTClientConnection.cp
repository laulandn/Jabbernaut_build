/*Copyright (C) 2000  Chris BehmThis library is free software; you can redistribute it and/ormodify it under the terms of the GNU Lesser General PublicLicense as published by the Free Software Foundation; eitherversion 2.1 of the License, or (at your option) any later version.This library is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNULesser General Public License for more details.You should have received a copy of the GNU Lesser General PublicLicense along with this library; if not, write to the Free SoftwareFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USAContact Chris Behm at cjbehm@mail.comThe GNU LGPL is also readable at http://www.gnu.org/copyleft/lesser.html**** NOTICE ****This OpenTransport class is most definitely NOT of release quality NOR isit part of MacJLib. It is provided here as an example of the creating a connection subclass.**** NOTICE *****/#include "OTClientConnection.h"#include "MacJLibUtils.h"#include <string.h>using namespace MacJLib;static pascal void OTNotifierProc(void* contextPtr, OTEventCode code, OTResult result, void* cookie);static pascal void OTNotifierProc(void* contextPtr, OTEventCode code, OTResult result, void* cookie){#pragma unused( result )	OTTInfo		*t;	long		bAvail;	UInt32		flags;	DNSAddress	hostAdd;	TCall		sndCall;	TDiscon		disco;		t = (OTTInfo*)contextPtr;	switch( code )	{		case T_DATA:			t->wegotdata = true;			bAvail = t->bufSize - t->bytesUsed;			if( bAvail > 0 )			{				OTResult	res;				void		*bufPtr;				bufPtr = ((Ptr)t->mBuffer) + t->bytesUsed;				while( true )				{					res = OTRcv(t->ep, bufPtr, bAvail, &flags);					if( res > 0 )					{						t->bytesUsed += (long)res;						bAvail -= (long)res;						bufPtr = ((Ptr)bufPtr) + (long)res;												if( bAvail <= 0 )							break;					}					else						break;				}			}			break;		case T_BINDCOMPLETE:			//t->OTState = ms_bound;			t->taskInProgress = false;			if( !t->wasCanceled )			{				OTMemzero(&sndCall,sizeof(TCall));				sndCall.addr.buf 	= (UInt8 *) &hostAdd;				sndCall.addr.len 	= OTInitDNSAddress(&hostAdd, t->mHostAddress);				sndCall.opt.buf 	= NULL;		// no connection options				sndCall.opt.len 	= 0;				sndCall.udata.buf 	= NULL;		// no connection data				sndCall.udata.len 	= 0;				sndCall.sequence 	= 0;		// ignored by OTConnect								t->err = OTConnect( t->ep,&sndCall, NULL );				if( t->err == kOTNoDataErr )					t->err = noErr;				if( !t->err )				{					t->taskInProgress = true;					t->OTState = ms_opening;				}			}						break;		/*case T_UNBINDCOMPLETE:			t->OTState = ms_unbound;			break;*/		case T_OPENCOMPLETE:			t->ep = (EndpointRef)cookie;			//t->OTState = ms_created;						t->taskInProgress = false;			if( !t->wasCanceled )			{				t->err = OTSetBlocking( t->ep );				if( !t->err )				{					t->err = OTBind( t->ep, NULL, NULL );					if( !t->err )						t->taskInProgress = true;					t->OTState = ms_binding;				}			}			break;		case T_CONNECT:			t->OTState = ms_open;						t->taskInProgress = false;			if( !t->wasCanceled )			{				t->err = OTRcvConnect( t->ep, NULL );				if( !t->err )					t->OTState = ms_connected;			}								break;		case T_DISCONNECT:			t->OTState = ms_closingDis;						t->taskInProgress = false;			if( !(t->err = OTRcvDisconnect( t->ep, &disco )) )				t->taskInProgress = true;			break;		case T_ORDREL:			t->OTState = ms_closing;						t->taskInProgress = false;			if( !t->wasCanceled )			{				t->err = OTRcvOrderlyDisconnect(t->ep);				if( !t->err)				{					t->err = OTSndOrderlyDisconnect(t->ep);										if( !t->err )					{						t->taskInProgress = true;						t->OTState = ms_closed;					}				}				else					t->taskInProgress = true;			}			//t->OTState = ms_closed;			break;		case T_DISCONNECTCOMPLETE:			//t->OTState = ms_closed;			t->taskInProgress = false;			t->err = OTUnbind(t->ep);			if( !t->err )			{				t->OTState = ms_unbinding;				t->taskInProgress = true;			}			break;		default:			break;	}}OTClientConnection::OTClientConnection() : ClientConnection(){	mBaseCFG = NULL;	mOtInfo.mBuffer = NULL;	mOtInfo.ep = NULL;	mOtInfo.bytesUsed = 0;	mOtInfo.OTState = ms_undef;	mOtInfo.err = noErr;	mOtInfo.wegotdata = false;	mOtInfo.mHostAddress = NULL;	mOtInfo.wasCanceled = false;	mOtInfo.taskInProgress = false;		mNotifierCallback = NewOTNotifyUPP( OTNotifierProc );		#if TARGET_API_MAC_CARBON	FailOnOSErr( InitOpenTransportInContext( kInitOTForApplicationMask, NULL ) );#else	FailOnOSErr( InitOpenTransport() );#endif}OTClientConnection::~OTClientConnection(){	if( mOtInfo.ep )		OTCloseProvider( mOtInfo.ep );	if( mOtInfo.mBuffer )		OTFreeMem( mOtInfo.mBuffer );	if( mOtInfo.mHostAddress )		DisposePtr( mOtInfo.mHostAddress );		mOtInfo.mBuffer = NULL;	mOtInfo.ep = NULL;	mOtInfo.mHostAddress = NULL;		if( mNotifierCallback )		DisposeOTNotifyUPP( mNotifierCallback );#if TARGET_API_MAC_CARBON	CloseOpenTransportInContext( NULL );#else	CloseOpenTransport();#endif}long OTClientConnection::houseKeeping(){	/*	 * NOTE: this ALWAYS returns the last error that OT gave	 * If you "take care of" an error, make sure to set mOtInfo.err = noErr	*/		if( mOtInfo.wasCanceled && !mOtInfo.taskInProgress )	{		mOtInfo.taskInProgress = false;		//we were connecting and it was canceled, clean up		switch( mOtInfo.OTState )		{			case ms_creating:				//the endpoint is created, but that's it				mOtInfo.err = OTCloseProvider( mOtInfo.ep );				mOtInfo.ep = NULL;				mOtInfo.OTState = ms_undef;				break;			case ms_binding:				//we were created after open was called so the ep is bound now				mOtInfo.err = OTUnbind( mOtInfo.ep );				if( !mOtInfo.err )				{					mOtInfo.OTState = ms_unbinding;					mOtInfo.taskInProgress = true;				}				break;			case ms_open:				mOtInfo.err = closeConn();				break;		}	}		switch( mOtInfo.err )	{		case -3155:			mOtInfo.err = OTCloseProvider( mOtInfo.ep );			mOtInfo.wasCanceled = false;			mOtInfo.taskInProgress = false;			mOtInfo.OTState = ms_undef;			break;		default:			break;	}		switch( mOtInfo.OTState )	{		case ms_undef:			break;		case ms_closingDis:			mExtraErrorInfo = kConnectionRefusedOrBroken;		case ms_closed:			OTSetSynchronous( mOtInfo.ep );			mOtInfo.err = OTUnbind( mOtInfo.ep );			mOtInfo.OTState = ms_unbound;			break;		case ms_unbound:			if( mOtInfo.ep )			{				mOtInfo.err = OTCloseProvider( mOtInfo.ep );				mOtInfo.ep = NULL;			}			mOtInfo.OTState = ms_undef;			break;		default:			break;	}		return mOtInfo.err;}long OTClientConnection::initializeConn(){// we assume OT has been inited here!	mOtInfo.bufSize = 8192;		// FIX ME#if TARGET_API_MAC_CARBON	mOtInfo.mBuffer = OTAllocMemInContext( mOtInfo.bufSize, NULL );#else	mOtInfo.mBuffer = OTAllocMem( mOtInfo.bufSize );#endif	mBaseCFG = OTCreateConfiguration(kTCPName);	return noError;}long OTClientConnection::openConn( const char *iserver, unsigned short iport ){	OSStatus	err = noErr;	char		to[1024];	int			l;		if( mOtInfo.OTState == ms_undef )	{		mExtraErrorInfo = kConnectionNoErr;		sprintf(to,"%s:%i",iserver,iport);		l = strlen(to);		if( mOtInfo.mHostAddress )			DisposePtr( mOtInfo.mHostAddress );		mOtInfo.mHostAddress = NewPtr( l + 1 );		if( mOtInfo.mHostAddress )		{			strcpy( mOtInfo.mHostAddress, to );			if( mBaseCFG )#if TARGET_API_MAC_CARBON				err = OTAsyncOpenEndpointInContext( OTCloneConfiguration(mBaseCFG), 0UL, NULL, mNotifierCallback, &mOtInfo, NULL );#else				err = OTAsyncOpenEndpoint( OTCloneConfiguration(mBaseCFG), 0UL, NULL, mNotifierCallback, &mOtInfo );#endif			else				err = -1;		}		else			err = MemError();				if( !err )		{			mOtInfo.OTState	= ms_creating;			mOtInfo.wasCanceled = false;			mOtInfo.taskInProgress = true;		}	}	else		mExtraErrorInfo = kConnectionNotClosedYet;		return err;}long OTClientConnection::closeConn(){	if( mOtInfo.OTState < ms_connected )		mOtInfo.wasCanceled = true;		if( mOtInfo.OTState < ms_unbinding && mOtInfo.OTState > ms_undef )	{		mOtInfo.err = OTSndOrderlyDisconnect(mOtInfo.ep);		if( mOtInfo.err )		{			if( !(mOtInfo.err = OTSndDisconnect( mOtInfo.ep, NULL)) )				mOtInfo.taskInProgress = true;		}		else			mOtInfo.taskInProgress = true;	}	return mOtInfo.err;}ConnectionState OTClientConnection::getConnectionState(){	ConnectionState x;	if( mOtInfo.OTState == ms_undef )		x = kConnectionStateDisconnected;	else if( mOtInfo.OTState < ms_connected )		x = kConnectionStateConnecting;	else if( mOtInfo.OTState == ms_connected )		x = kConnectionStateConnected;	else if( mOtInfo.OTState )		x = kConnectionStateDisconnecting;		return x;}bool OTClientConnection::isDataAvail(){	return mOtInfo.bytesUsed;}long OTClientConnection::readBytes( char *buf, long maxSize ){	if( buf && (maxSize > 0) && mOtInfo.mBuffer && (mOtInfo.bytesUsed > 0) )	{		//"Lock" the buffer while we're copying out the data		if( ::OTEnterNotifier( mOtInfo.ep ) )		{			if( maxSize > mOtInfo.bytesUsed )				maxSize = mOtInfo.bytesUsed;					OTMemcpy( buf, mOtInfo.mBuffer, maxSize );			mOtInfo.bytesUsed -= maxSize;			if( mOtInfo.bytesUsed > 0 )			{				OTMemmove( mOtInfo.mBuffer, ((Ptr)mOtInfo.mBuffer) + maxSize, mOtInfo.bytesUsed );			}			else			{//				mOtInfo.bytesUsed = 0;				mOtInfo.wegotdata = false;			}			::OTLeaveNotifier( mOtInfo.ep );		}		else			maxSize = 0;	}	else		maxSize = 0;		return maxSize;}long OTClientConnection::writeBytes( const char *buf, long bufSize ){	if( mOtInfo.OTState == ms_connected && mOtInfo.ep && buf && bufSize > 0 )		return OTSnd( mOtInfo.ep, (void *)buf, bufSize, NULL );	else		return 0;}long OTClientConnection::resizeBuffer( long newSize ){	void *t;		//Don't allow modifications to the buffer while we're swapping it out	//some considerations, this doesn't copy the old buffer in any way shape or form	//so it might be a good idea to make sure there's no data waiting	if( ::OTEnterNotifier( mOtInfo.ep ) )	{#if TARGET_API_MAC_CARBON		t = OTAllocMemInContext( newSize, NULL );#else		t = OTAllocMem( newSize );#endif		if( t )		{			if( mOtInfo.mBuffer )				OTFreeMem( mOtInfo.mBuffer );						mOtInfo.mBuffer = t;			mOtInfo.bufSize = newSize;		}		::OTLeaveNotifier( mOtInfo.ep );	}		return mOtInfo.bufSize;}long OTClientConnection::getBufferSize(){	return mOtInfo.bufSize;}		char *OTClientConnection::errorToCStr( long errNo ){	char *errDesc = NULL;		switch( errNo )	{		case kConnectionNotClosedYet:			errDesc = NewPtr(41);			if( errDesc )				sprintf(errDesc,"The previous connection is still closing");			break;		case kConnectionRefusedOrBroken:			errDesc = NewPtr( 43 );			if( errDesc )				sprintf(errDesc,"The connection was terminated unexpectedly");			break;		case kConnectionNoErr:		default:			break;	}		return errDesc;}