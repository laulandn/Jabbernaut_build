/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		ExpatStream.cp *  Created:	2000-06-26 *  Authors:	CB - Chris Behm <cbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"ExpatStream.h"#include	"ExpatParser.h"#include	"MacJLibUtils.h"#include	"ParseableNode.h"#if USE_MACJLIB_NSnamespace MacJLib {#endifExpatStream::ExpatStream() : JXMLStream(), CNodeBuildingHandler(){ 	mParser = NULL; 	mStreamOpen = false; 	#if USE_AUTOMATIC_UTF8	FailOnNIL( mUTF8ToMacConverter = new UTFConverter() );	mUTF8ToMacConverter->Init(false);#endif} ExpatStream::~ExpatStream(){	if( mParser )	{		if( mStreamOpen )			mParser->EndParsing();		delete mParser;	}		while( !mWaitQ.empty() )	{		delete mWaitQ.front();		mWaitQ.pop();	}#if USE_AUTOMATIC_UTF8	if( mUTF8ToMacConverter )	{		delete mUTF8ToMacConverter;		mUTF8ToMacConverter = NULL;	}#endif}void ExpatStream::OpenStream(){	if( mParser )		delete mParser;		mParser = new CExpatParser( this );	if( mParser )	{		mParser->StartParsing();		mStreamOpen = true;	}}void ExpatStream::CloseStream(){	if( mParser && mStreamOpen ) 		mParser->EndParsing();		mStreamOpen = false;}void ExpatStream::ParseStream( const char* inStream, std::size_t inLength ){	if( mParser && mStreamOpen )		mParser->Parse( inStream, inLength );}void ExpatStream::ParseStream( const std::string& inStream ){	if( mParser && mStreamOpen )		mParser->Parse( inStream.c_str(), inStream.size() );}ParseableNode* ExpatStream::GetNextMessage(){	if( !mWaitQ.empty() )	{		ParseableNode		*topMsg = mWaitQ.front();		mWaitQ.pop();		return topMsg;	}		return NULL;}void ExpatStream::NodeHandlerWrapper( CAbstractNode& inNode ){	ParseableNode*	theMsg = NULL;	#if USE_AUTOMATIC_UTF8	mUTF8ToMacConverter->Convert( &inNode );#endif		theMsg = ParseNode( (CElementNode&)inNode );	if( theMsg )		mWaitQ.push( theMsg );}void ExpatStream::HandleStartElement(const std::string &inName, const CAttributeMap &inAttributeMap){	bool	getSessionID;		getSessionID = (mRootNode == NULL);		CNodeBuildingHandler::HandleStartElement( inName, inAttributeMap );	if (mRootNode && getSessionID)	{		//the root node should be the <stream:stream ... node right?		mSessionID = mRootNode->AttribVal("id");	}}void ExpatStream::HandleEndElement( const std::string &inName ){	#pragma unused (inName)	CAbstractNode	*topNode;	FailOnNIL(topNode = mNodeStack.top());	mNodeStack.pop();		// Check if the node is a child of the root node...	if( mNodeStack.size() == 1 )	{		CElementNode	*tagNode;		// Try to parse the node...		tagNode = dynamic_cast<CElementNode*>(topNode);		if( tagNode )			NodeHandlerWrapper( *tagNode );			//ParseNodes( *tagNode );		// ...and then get rid of it		tagNode = dynamic_cast<CElementNode*>(mRootNode);		if( tagNode )			tagNode->RemoveChild( topNode );		delete topNode;	}	else if( mNodeStack.size() == 0 )	{		//this will only be true when the root tag is closed so delete the root here		if( mRootNode )		{			delete mRootNode;			mRootNode = NULL;		}	}}#if USE_MACJLIB_NS}#endif