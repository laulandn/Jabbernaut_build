/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		SearchItem.cp *  Created:	2000-11-06 *	Authors:	MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"SearchItem.h"#include	"MemoryOps.h"#include	<string.h>#if USE_MACJLIB_NSnamespace MacJLib {#endifSearchItem::SearchItem(){}SearchItem::SearchItem( const CElementNode& inTagNode ){	CElementNode	*curNode;	std::string tmp;		mJID = inTagNode.AttribVal( "jid" );		for( CNodeList::const_iterator X = inTagNode.ChildNodes().begin();X != inTagNode.ChildNodes().end();++X)	{		curNode = dynamic_cast<CElementNode *>(*X);		if( curNode )		{			if( curNode->GetName() == "first" )				TagToString( *curNode, mFirst );			else if( curNode->GetName() == "last" )				TagToString( *curNode, mLast );			else if( curNode->GetName() == "nick" )				TagToString( *curNode, mNick );			else if( curNode->GetName() == "email" )				TagToString( *curNode, mEmail );		}	}}SearchItem::~SearchItem(){}#pragma mark -const JID &SearchItem::getJID() const{	return mJID;}void SearchItem::setJID( const JID &inJID ){	mJID = inJID;}const std::string &SearchItem::getFirst() const{	return mFirst;}void SearchItem::setFirst( const std::string &inFirst ){	mFirst = inFirst;}const std::string &SearchItem::getLast() const{	return mLast;}void SearchItem::setLast( const std::string &inLast ){	mLast = inLast;}const std::string &SearchItem::getNick() const{	return mNick;}void SearchItem::setNick( const std::string &inNick ){	mNick = inNick;}const std::string &SearchItem::getEmail() const{	return mEmail;}void SearchItem::setEmail( const std::string &inEmail ){	mEmail = inEmail;}#pragma mark -void SearchItem::appendXML( Ptr xmlStr ) const{	if( xmlStr )	{		strcat(xmlStr,"<item");		attrib_strcat(xmlStr,"jid",mJID.getFull());		strcat(xmlStr,">");		tag_strcat(xmlStr,"first",mFirst);		tag_strcat(xmlStr,"last",mLast);		tag_strcat(xmlStr,"nick",mNick);		tag_strcat(xmlStr,"email",mEmail);		strcat(xmlStr,"</item>");	}}Ptr SearchItem::toXML() const{	Ptr		xmlStr;	long	len;		len = size() + 1;		xmlStr = AllocMemClear( len );	if( xmlStr )	{		appendXML( xmlStr );		ConvertCRs( xmlStr, false );	}		return xmlStr;}long SearchItem::size() const{	long	len = 5;//	<item		attrib_strlen("jid",mJID.getFull());	len += 1;		//	>	len += tag_strlen("first",mFirst);	len += tag_strlen("last",mLast);	len += tag_strlen("nick",mNick);	len += tag_strlen("email",mEmail);	len += 7;		//	</item>	return len;}#if USE_MACJLIB_NS}#endif