/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		BaseMsg.cp *  Created:	2000-??-?? *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"BaseMsg.h"#include	"MacJLibUtils.h"#include	<string.h>#if USE_MACJLIB_NSnamespace MacJLib {#endifBaseMsg::BaseMsg() : ParseableNode(), mRefCon( 0 ){	mTimestamp = GetTimeSeconds() - TimeZoneOffsetInSeconds();}BaseMsg::BaseMsg( const BaseMsg& pMsgObj ) : ParseableNode(), mRefCon( 0 ){	mTo = pMsgObj.mTo;	mFrom = pMsgObj.mFrom;	mID = pMsgObj.mID;	mType = pMsgObj.mType;	mErrorType = pMsgObj.mErrorType;	mErrorMessage = pMsgObj.mErrorMessage;	mTimestamp = pMsgObj.mTimestamp;}BaseMsg::BaseMsg( const BaseMsgHeader *pMOHdr ) : ParseableNode(), mRefCon( 0 ){	MJ_ASSERT( "pMOHdr==NULL", pMOHdr!=NULL )	mTo = pMOHdr->to;	mFrom = pMOHdr->from;	mID = pMOHdr->id;	mType = pMOHdr->type;	mTimestamp = GetTimeSeconds() - TimeZoneOffsetInSeconds();}BaseMsg::BaseMsg( const CElementNode& pNode ) : ParseableNode( pNode ), mRefCon( 0 ){	mTo = AttribVal("to");	mFrom = AttribVal("from");	mID = AttribVal("id");	mType = AttribVal("type");	mTimestamp = GetTimeSeconds() - TimeZoneOffsetInSeconds();}BaseMsg::~BaseMsg(){	for (AttachmentList::const_iterator X = mAttachments.begin(); X != mAttachments.end(); ++X)		delete *X;}#pragma mark -void	BaseMsg::stdAttribsAppend( Ptr xmlStr ) const{	if( !mTo.empty() )	{		strcat(xmlStr, " to=\"");		strcatEscaped(xmlStr, mTo.c_str());		strcat(xmlStr, "\"");	}	if( !mFrom.empty() )	{		strcat(xmlStr, " from=\"");		strcatEscaped(xmlStr, mFrom.c_str());		strcat(xmlStr, "\"");	}	if( !mID.empty() )	{		strcat(xmlStr," id=\"");		strcatEscaped(xmlStr,mID.c_str());		strcat(xmlStr,"\"");	}	if( !mType.empty() )	{		strcat(xmlStr, " type=\"");		strcatEscaped(xmlStr, mType.c_str());		strcat(xmlStr, "\"");	}}long	BaseMsg::stdAttribsSize() const{	long len = 0;			if( !mTo.empty() )		len += 6 + strlenEscaped(mTo.c_str());			// to=""	if( !mFrom.empty() )		len += 8 + strlenEscaped(mFrom.c_str());		// from=""	if( !mID.empty() )		len += 6 + strlenEscaped(mID.c_str());			// id=""	if( !mType.empty() )		len += 8 + strlenEscaped(mType.c_str());		// type=""	return len;}#pragma mark -long BaseMsg::getRefCon() const{	return mRefCon;}void BaseMsg::setRefCon(long refcon){	mRefCon = refcon;}#pragma mark -void BaseMsg::setFrom( const JID &iFrom ){	mFrom = iFrom;}const JID &BaseMsg::getFrom() const{	return mFrom;}void BaseMsg::setTo( const JID &iTo ){	mTo = iTo;}const JID &BaseMsg::getTo() const{	return mTo;}void BaseMsg::setID( const std::string &iID ){	mID = iID;}const std::string &BaseMsg::getID() const{	return mID;}void BaseMsg::setType( const std::string &iType ){	mType = iType;}const std::string &BaseMsg::getType() const{	return mType;}const long BaseMsg::getErrorType() const{	return mErrorType;}const std::string &BaseMsg::getErrorMessage() const{	return mErrorMessage;}#pragma mark -std::time_t BaseMsg::getTimeStamp() const{	return mTimestamp;}void BaseMsg::setTimeStamp( std::time_t t ){	mTimestamp = t;}#pragma mark -void BaseMsg::visitNode( const CElementNode& aNode ){	if( aNode.GetName() == "error" )	{		mErrorType = aNode.AttribVal("code").c_str();		TagToString( aNode, mErrorMessage );	}	else if( aNode.GetName() == "x" && aNode.AttribVal("xmlns") == "jabber:x:delay" )	{		mTimestamp = UTCToSeconds( aNode.AttribVal("stamp") );	}}#if USE_MACJLIB_NS}#endif