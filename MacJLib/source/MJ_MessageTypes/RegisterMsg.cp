/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		RegisterMsg.cp *  Created:	2000-04-01 *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"RegisterMsg.h"#include	"MemoryOps.h"#include	<string.h>#if USE_MACJLIB_NSnamespace MacJLib {#endifconst std::string RegisterMsg::msXMLNS("jabber:iq:register");RegisterMsg::RegisterMsg() : BaseIQMsg(){	mType = "get";	mRegistered = false;	mRemove = false;	for( short i = 0; i < kReqSize; ++i )		mRequiredFlagField[i] = false;}RegisterMsg::RegisterMsg( const CElementNode& iq ) : BaseIQMsg( iq ){	mRegistered = false;	mRemove = false;	for( short i = 0; i < kReqSize; ++i )		mRequiredFlagField[i] = false;}RegisterMsg::RegisterMsg( const RegisterMsg& pRgMsg ) : BaseIQMsg( pRgMsg ){	mInstructions = pRgMsg.mInstructions;	mKey = pRgMsg.mKey;	mRegistered = pRgMsg.mRegistered;	mRemove = pRgMsg.mRemove;	for( short i = 0; i < kReqSize; ++i )		mElementsField[i] = pRgMsg.mElementsField[i];	for( short i = 0; i < kReqSize; ++i )		mRequiredFlagField[i] = pRgMsg.mRequiredFlagField[i];}RegisterMsg::RegisterMsg( const RegisterMsgHeader *pRgHdr ) : BaseIQMsg( pRgHdr ){	MJ_ASSERT( "pRgHdr==NULL", pRgHdr!=NULL )	mInstructions = pRgHdr->instructions;	mRegistered = false;	mRemove = false;	for( short i = 0; i < kReqSize; ++i )		mRequiredFlagField[i] = false;	mElementsField[kReqUsername] = pRgHdr->username;	mElementsField[kReqNick] = pRgHdr->nick;	mElementsField[kReqPassword] = pRgHdr->password;	mElementsField[kReqName] = pRgHdr->name;	mElementsField[kReqFirst] = pRgHdr->first;	mElementsField[kReqLast] = pRgHdr->last;	mElementsField[kReqEmail] = pRgHdr->email;	mElementsField[kReqAddress] = pRgHdr->address;	mElementsField[kReqCity] = pRgHdr->city;	mElementsField[kReqState] = pRgHdr->state;	mElementsField[kReqZip] = pRgHdr->zip;	mElementsField[kReqPhone] = pRgHdr->phone;	mElementsField[kReqUrl] = pRgHdr->url;	mElementsField[kReqDate] = pRgHdr->date;	mElementsField[kReqMisc] = pRgHdr->misc;	mElementsField[kReqText] = pRgHdr->text;	mKey = pRgHdr->key;}RegisterMsg::~RegisterMsg(){}#pragma mark -RegisterMsg *RegisterMsg::makeReply() const{	RegisterMsg *replyMsg = new RegisterMsg( *this );	if( replyMsg )	{		//this is a reply so swap 'to' and 'from'		replyMsg->setTo( mFrom );				// ...but 'from' should stay empty, the server will do the Right Thing (tm) automatically		replyMsg->setFrom( "" );	}		return replyMsg;}#pragma mark -Ptr RegisterMsg::toXML() const{	Ptr		xmlStr;	long	len;		len = size() + 1;		xmlStr = AllocMemClear( len );	if( xmlStr )	{		strcat(xmlStr,"<iq");		stdAttribsAppend( xmlStr );		strcat(xmlStr,"><query xmlns=\"");		strcat(xmlStr,msXMLNS.c_str());		strcat(xmlStr,"\">");				if( mRemove )			strcat(xmlStr, "<remove/>");		else		{			tag_strcat( xmlStr, "username", mElementsField[kReqUsername] );			tag_strcat( xmlStr, "nick", mElementsField[kReqNick] );			tag_strcat( xmlStr, "password", mElementsField[kReqPassword] );			tag_strcat( xmlStr, "name", mElementsField[kReqName] );			tag_strcat( xmlStr, "first", mElementsField[kReqFirst] );			tag_strcat( xmlStr, "last", mElementsField[kReqLast] );			tag_strcat( xmlStr, "email", mElementsField[kReqEmail] );			tag_strcat( xmlStr, "address", mElementsField[kReqAddress] );			tag_strcat( xmlStr, "city", mElementsField[kReqCity] );			tag_strcat( xmlStr, "state", mElementsField[kReqState] );			tag_strcat( xmlStr, "zip", mElementsField[kReqZip] );			tag_strcat( xmlStr, "phone", mElementsField[kReqPhone] );			tag_strcat( xmlStr, "url", mElementsField[kReqUrl] );			tag_strcat( xmlStr, "date", mElementsField[kReqDate] );			tag_strcat( xmlStr, "misc", mElementsField[kReqMisc] );			tag_strcat( xmlStr, "text", mElementsField[kReqText] );		}				tag_strcat( xmlStr, "key", mKey );		strcat(xmlStr, "</query></iq>");		ConvertCRs( xmlStr, false );	}		return xmlStr;}long RegisterMsg::size() const{	long len = 3;			//"<iq"	len += stdAttribsSize();	len += 17;				//><query xmlns="">	len += msXMLNS.size();	len += 13;				//</query></iq>	if( mRemove )		len +=  9;			//<remove/>	else	{		len += tag_strlen( "username", mElementsField[kReqUsername] );		len += tag_strlen( "nick", mElementsField[kReqNick] );		len += tag_strlen( "password", mElementsField[kReqPassword] );		len += tag_strlen( "name", mElementsField[kReqName] );		len += tag_strlen( "first", mElementsField[kReqFirst] );		len += tag_strlen( "last", mElementsField[kReqLast] );		len += tag_strlen( "email", mElementsField[kReqEmail] );		len += tag_strlen( "address", mElementsField[kReqAddress] );		len += tag_strlen( "city", mElementsField[kReqCity] );		len += tag_strlen( "state", mElementsField[kReqState] );		len += tag_strlen( "zip", mElementsField[kReqZip] );		len += tag_strlen( "phone", mElementsField[kReqPhone] );		len += tag_strlen( "url", mElementsField[kReqUrl] );		len += tag_strlen( "date", mElementsField[kReqDate] );		len += tag_strlen( "misc", mElementsField[kReqMisc] );		len += tag_strlen( "text", mElementsField[kReqText] );	}	len += tag_strlen( "key", mKey );				return len;}void RegisterMsg::getRequiredFlags( bool inReqFields[kReqSize] ) const{		for( short i = 0; i < kReqSize; ++i )		inReqFields[i] = mRequiredFlagField[i];}void RegisterMsg::getElements( std::string elementsField[kReqSize] ) const{		for( short i = 0; i < kReqSize; ++i )		elementsField[i] = mElementsField[i];}void RegisterMsg::setElements( const std::string elementsField[kReqSize] ){		for( short i = 0; i < kReqSize; ++i )		mElementsField[i] = elementsField[i];}#pragma mark -const std::string &RegisterMsg::getInstructions() const{	return mInstructions;}const std::string &RegisterMsg::getUsername() const{	return mElementsField[kReqUsername];}const std::string &RegisterMsg::getNick() const{	return mElementsField[kReqNick];}const std::string &RegisterMsg::getPassword() const{	return mElementsField[kReqPassword];}const std::string &RegisterMsg::getName() const{	return mElementsField[kReqName];}const std::string &RegisterMsg::getFirst() const{	return mElementsField[kReqFirst];}const std::string &RegisterMsg::getLast() const{	return mElementsField[kReqLast];}const std::string &RegisterMsg::getEmail() const{	return mElementsField[kReqEmail];}const std::string &RegisterMsg::getAddress() const{	return mElementsField[kReqAddress];}const std::string &RegisterMsg::getCity() const{	return mElementsField[kReqCity];}const std::string &RegisterMsg::getState() const{	return mElementsField[kReqState];}const std::string &RegisterMsg::getZip() const{	return mElementsField[kReqZip];}const std::string &RegisterMsg::getPhone() const{	return mElementsField[kReqPhone];}const std::string &RegisterMsg::getURL() const{	return mElementsField[kReqUrl];}const std::string &RegisterMsg::getDate() const{	return mElementsField[kReqDate];}const std::string &RegisterMsg::getMisc() const{	return mElementsField[kReqMisc];}const std::string &RegisterMsg::getText() const{	return mElementsField[kReqText];}const std::string &RegisterMsg::getKey() const{	return mKey;}bool RegisterMsg::isRegistered() const{	return mRegistered;}void RegisterMsg::setRemove( bool remove ){	mRemove = remove;}#pragma mark -void RegisterMsg::visitQueryNode( const CElementNode& aNode ){	if( aNode.GetName() == "instructions" )		TagToString( aNode, mInstructions );	else if( aNode.GetName() == "key" )		TagToString( aNode, mKey );	else if( aNode.GetName() == "registered" )		mRegistered = true;	else if( aNode.GetName() == "remove" )		mRemove = true;	else if( aNode.GetName() == "username" )	{		mRequiredFlagField[kReqUsername] = true;		TagToString( aNode, mElementsField[kReqUsername] );	}	else if( aNode.GetName() == "nick" )	{		mRequiredFlagField[kReqNick] = true;		TagToString( aNode, mElementsField[kReqNick] );	}	else if( aNode.GetName() == "password" )	{		mRequiredFlagField[kReqPassword] = true;		TagToString( aNode, mElementsField[kReqPassword] );	}	else if( aNode.GetName() == "name" )	{		mRequiredFlagField[kReqName] = true;		TagToString( aNode, mElementsField[kReqName] );	}	else if( aNode.GetName() == "first" )	{		mRequiredFlagField[kReqFirst] = true;		TagToString( aNode, mElementsField[kReqFirst] );	}	else if( aNode.GetName() == "last" )	{		mRequiredFlagField[kReqLast] = true;		TagToString( aNode, mElementsField[kReqLast] );	}	else if( aNode.GetName() == "email" )	{		mRequiredFlagField[kReqEmail] = true;		TagToString( aNode, mElementsField[kReqEmail] );	}	else if( aNode.GetName() == "address" )	{		mRequiredFlagField[kReqAddress] = true;		TagToString( aNode, mElementsField[kReqAddress] );	}	else if( aNode.GetName() == "city" )	{		mRequiredFlagField[kReqCity] = true;		TagToString( aNode, mElementsField[kReqCity] );	}	else if( aNode.GetName() == "state" )	{		mRequiredFlagField[kReqState] = true;		TagToString( aNode, mElementsField[kReqState] );	}	else if( aNode.GetName() == "zip" )	{		mRequiredFlagField[kReqZip] = true;		TagToString( aNode, mElementsField[kReqZip] );	}	else if( aNode.GetName() == "phone" )	{		mRequiredFlagField[kReqPhone] = true;		TagToString( aNode, mElementsField[kReqPhone] );	}	else if( aNode.GetName() == "url" )	{		mRequiredFlagField[kReqUrl] = true;		TagToString( aNode, mElementsField[kReqUrl] );	}	else if( aNode.GetName() == "date" )	{		mRequiredFlagField[kReqDate] = true;		TagToString( aNode, mElementsField[kReqDate] );	}	else if( aNode.GetName() == "misc" )	{		mRequiredFlagField[kReqMisc] = true;		TagToString( aNode, mElementsField[kReqMisc] );	}	else if( aNode.GetName() == "text" )	{		mRequiredFlagField[kReqText] = true;		TagToString( aNode, mElementsField[kReqText] );	}	else		BaseIQMsg::visitQueryNode( aNode );}#if USE_MACJLIB_NS}#endif