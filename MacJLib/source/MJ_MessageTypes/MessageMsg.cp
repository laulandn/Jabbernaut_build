/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		MessageMsg.cp *  Created:	2000-??-?? *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"MessageMsg.h"#include	"MemoryOps.h"#include	<string.h>#include	<cstdlib>#if USE_MACJLIB_NSnamespace MacJLib {#endifMessageMsg::MessageMsg() : BaseMsg(){}MessageMsg::MessageMsg( const MessageMsg& pMsg ) : BaseMsg( pMsg ){	mBody = pMsg.mBody;	mSubject = pMsg.mSubject;	mThread = pMsg.mThread;}MessageMsg::MessageMsg( const MessageMsgHeader *pTMsgHdr ) : BaseMsg( pTMsgHdr ){	MJ_ASSERT( "pTMsgHdr==NULL", pTMsgHdr!=NULL )	mBody = pTMsgHdr->body;	mSubject = pTMsgHdr->subject;	mThread = pTMsgHdr->thread;}MessageMsg::MessageMsg( const CElementNode& iNode ) : BaseMsg( iNode ){	// The following is there to make the live of client authors easier	if( mType.empty() )		mType = "normal";}MessageMsg::~MessageMsg(){}#pragma mark -MessageMsg *MessageMsg::makeReply() const{	MessageMsg *replyMsg = new MessageMsg( *this );	if( replyMsg )	{		//this is a reply so swap 'to' and 'from'		replyMsg->setTo( mFrom );				// ...but 'from' should stay empty, the server will do the Right Thing (tm) automatically		replyMsg->setFrom( "" );	}		return replyMsg;}#pragma mark -Ptr MessageMsg::toXML() const{	Ptr		xmlStr;	long	len;	len = size() + 1;	xmlStr = AllocMemClear( len );	if( xmlStr )	{		strcat(xmlStr,"<message");		stdAttribsAppend( xmlStr );		strcat(xmlStr,">");				tag_strcat( xmlStr, "body", mBody );		tag_strcat( xmlStr, "subject", mSubject );		tag_strcat( xmlStr, "thread", mThread );		strcat(xmlStr, "</message>");		ConvertCRs( xmlStr, false );	}			return xmlStr;}long MessageMsg::size() const{	long len = 8;						//<message			len += stdAttribsSize();		len++;								//>	len += tag_strlen( "body", mBody );	len += tag_strlen( "subject", mSubject );	len += tag_strlen( "thread", mThread );		len += 10;							//</message>		//this function returns the size of the actual data, which doesn't include the null	//byte, done on purpose		return len;}#pragma mark -void MessageMsg::setBody( const std::string &iBody ){	mBody = iBody;}const std::string &MessageMsg::getBody() const{	return mBody;}void MessageMsg::setSubject( const std::string &iSubject ){	mSubject = iSubject;}const std::string &MessageMsg::getSubject() const{	return mSubject;}void MessageMsg::setThread( const std::string &iThread ){	mThread = iThread;}const std::string &MessageMsg::getThread() const{	return mThread;}#pragma mark -void MessageMsg::visitNode( const CElementNode& aNode ){	if( aNode.GetName() == "body" )		TagToString( aNode, mBody );	else if( aNode.GetName() == "subject" )		TagToString( aNode, mSubject );	else if( aNode.GetName() == "thread" )		TagToString( aNode, mThread );	else		BaseMsg::visitNode( aNode );}#if USE_MACJLIB_NS}#endif