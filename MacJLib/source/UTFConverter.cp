/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		UTFConverter.cp *  Created:	2000-05-07 *  Authors:	MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"UTFConverter.h"#include	"MacJLibUtils.h"#include	"ConvertUTF.h"#include	<TextEncodingConverter.h>#if USE_MACJLIB_NSusing namespace MacJLib;#endif///- Constants --------------------------------------------------------------------------#pragma mark -#pragma mark === Constants ===	// default size for the output bufer is 16K. It should always be at least 32 bytes!#define kOutputBufferSize	(1024*16)const UTF16 MacToUTF16Table[] ={	// The chars from 0x00 till 0x7F (i.e. ASCII)	0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,	0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,	0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,	0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,	0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,	0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,	0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,	0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,	// Mapping for the chars from 0x80 till 0xFF	0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,	0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,	0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,	0x221E,0x00B1,0x2266,0x2265,0x00A5,0x00B5,0x2202,0x03A3,0x03A0,0x03C0,0x222B,0x00AA,0x00BA,0x2126,0x00E6,0x00F8,	0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,0x00BB,0x2026,0x00A0,0x00C1,0x00C3,0x00D5,0x0152,0x0153,	0x00AD,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,0x00FF,0x0178,0x2215,0x00A4,0x2039,0x203A,0xFB01,0xFB02,	0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,	0xE000,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x0302,0x0303,0x0304,0x0306,0x0307,0x030A,0x0327,0x030B,0x0328,0x030C};UTF16 UTF16ToMacTable[0xFFFD + 1];///--------------------------------------------------------------------------------------//	¥ Constructor:///--------------------------------------------------------------------------------------UTFConverter::UTFConverter(){#if USE_MAC_ROUTINES	mConverter = NULL;	FailOnNIL( mOutputBuffer = ::NewPtrClear( kOutputBufferSize ) );#endif}///--------------------------------------------------------------------------------------//	¥ Destructor:///--------------------------------------------------------------------------------------UTFConverter::~UTFConverter(){#if USE_MAC_ROUTINES  #if USE_NATIVE_UTF8 && __POWERPC__	if( mConverter )		(void)TECDisposeConverter( mConverter );  #endif	if( mOutputBuffer )		::DisposePtr(mOutputBuffer);#endif}#pragma mark -///--------------------------------------------------------------------------------------//	Init://		Allocate the converter from TEC//		//	Changes://		2000-05-07	MH		Created///--------------------------------------------------------------------------------------MacJLibError	UTFConverter::Init( bool toUnicode ){	mToUnicode = toUnicode;	#if USE_MAC_ROUTINES && USE_NATIVE_UTF8 && __POWERPC__	MJ_ASSERT( "mConverter!=NULL", mConverter==NULL )		OSStatus			err;	TextEncoding		macEncoding;	TextEncoding		UTF8Encoding;		err = UpgradeScriptInfoToTextEncoding(smSystemScript,								kTextLanguageDontCare,								kTextRegionDontCare,								NULL,								&macEncoding);	if( err != noErr )		return (MacJLibError)err;		UTF8Encoding = CreateTextEncoding(						kTextEncodingUnicodeDefault,						kTextEncodingDefaultVariant,						kUnicodeUTF8Format );		if( toUnicode )		err = TECCreateConverter(&mConverter, macEncoding, UTF8Encoding);	else		err = TECCreateConverter(&mConverter, UTF8Encoding, macEncoding);	return (MacJLibError)err;#else	//	// Build conversion table UTF16 -> mac encoding	//	UTF16	i;		for( i = 0x80; i <= 0xFFFD; ++i )		UTF16ToMacTable[i] = 0x2E;		for( i = 0; i <= 0xFF; ++i )		UTF16ToMacTable[MacToUTF16Table[i]] = i;		return noError;#endif}#pragma mark -///--------------------------------------------------------------------------------------//	Reset://		Reset the converter object so we can use it on another data stream.//		//	Changes://		2000-05-08	MH		Created///--------------------------------------------------------------------------------------void		UTFConverter::Reset(){#if USE_MAC_ROUTINES && USE_NATIVE_UTF8 && __POWERPC__	MJ_ASSERT( "mConverter==NULL", mConverter!=NULL )	// ClearConverterContext should be called only when a stream was closed...	// since we receive data in chunks, we must not clean the context all the time	// in case a UTF-8 two byte 'package' was split in the middle...	TECClearConverterContextInfo(mConverter);#endif}#pragma mark -///--------------------------------------------------------------------------------------//	Convert://		Convert data in a given area of memory and returns a pointer to the//		translated data (note: you need to call DisposePtr() on this pointer!//		//	Changes://		2000-06-08	MH		Created///--------------------------------------------------------------------------------------Ptr		UTFConverter::Convert( const char * inputBuffer, size_t &dataSize ){	MJ_ASSERT( "inputBuffer==NULL", inputBuffer!=NULL )		Handle	aHandle;	Ptr		aPtr;		FailOnNIL( aHandle = InternalConvert( (unsigned char *)inputBuffer, dataSize ) );	dataSize = GetHandleSize( aHandle );	FailOnNIL( aPtr = AllocMem( dataSize ) );	BlockMoveData( *aHandle, aPtr, dataSize );	DisposeHandle( aHandle );	return aPtr;}///--------------------------------------------------------------------------------------//	Convert://		Convert a std::string and places the result in another string.//		//	Changes://		2000-06-08	MH		Created///--------------------------------------------------------------------------------------void		UTFConverter::Convert( const std::string &inStr, std::string &outStr ){	Handle	aHandle;	size_t	dataSize;		FailOnNIL( aHandle = InternalConvert( (unsigned char *)inStr.data(), inStr.size() ) );	dataSize = GetHandleSize( aHandle );	HLock( aHandle );	outStr.assign(*aHandle, dataSize);	// <-- FIX IT HERE	HUnlock( aHandle );	DisposeHandle( aHandle );}		///--------------------------------------------------------------------------------------//	Convert://		Convert a std::string in-place.//		//	Changes://		2000-06-08	MH		Created///--------------------------------------------------------------------------------------void		UTFConverter::Convert( std::string &aStr ){	Convert( aStr, aStr );}///--------------------------------------------------------------------------------------//	Convert://		Convert a CAbstractNode or even a complete CElementNode tree (inplace).//		//	Changes://		2000-06-08	MH		Created///--------------------------------------------------------------------------------------void		UTFConverter::Convert( CAbstractNode *inNode ){	MJ_ASSERT( "inNode==NULL", inNode!=NULL )		CElementNode	*elementNode;	CTextNode		*textNode;		elementNode = dynamic_cast<CElementNode*>(inNode);	textNode = dynamic_cast<CTextNode*>(inNode);	if( elementNode )	{		for( CNodeList::const_iterator X = elementNode->ChildNodes().begin();X != elementNode->ChildNodes().end();++X)			Convert( *X );		// we use recursion for simplicity	}	else if( textNode )	{		Handle	aHandle;		size_t	dataSize;				FailOnNIL( aHandle = InternalConvert( (unsigned char *)textNode->GetData().data(),												textNode->GetData().size() ) );		dataSize = GetHandleSize( aHandle );		HLock( aHandle );		textNode->SetData(*aHandle, dataSize);		HUnlock( aHandle );		DisposeHandle( aHandle );	}}#pragma mark -///--------------------------------------------------------------------------------------//	InternalConvert://		Convert a given piece of memory as specified in Init()//		//	Changes://		2000-05-07	MH		Created///--------------------------------------------------------------------------------------Handle		UTFConverter::InternalConvert( const unsigned char * inputBuffer, size_t inputLength ){	MJ_ASSERT( "inputBuffer==NULL", inputBuffer!=NULL )	Handle		outputHandle = NULL;#if USE_MAC_ROUTINES && USE_NATIVE_UTF8 && __POWERPC__	MJ_ASSERT( "mConverter==NULL", mConverter!=NULL )	OSStatus	convertStatus;	size_t		actualInputLength, actualOutputLength;		FailOnNIL( outputHandle = NewHandle( 0 ) );	do	{		convertStatus = TECConvertText( mConverter, (TextPtr)inputBuffer, inputLength, &actualInputLength,									    (TextPtr)mOutputBuffer, kOutputBufferSize, &actualOutputLength );		// Advance the counters		inputBuffer += actualInputLength;		inputLength -= actualInputLength;				FailOnErr( PtrAndHand( mOutputBuffer, outputHandle, actualOutputLength ) );	} while( convertStatus == kTECUsedFallbacksStatus );		do	{		convertStatus = TECFlushText( mConverter, (TextPtr)mOutputBuffer, kOutputBufferSize, &actualOutputLength);									FailOnErr( PtrAndHand( mOutputBuffer, outputHandle, actualOutputLength ) );	}	while( convertStatus == kTECNeedFlushStatus );#else	UTF16				*UTF16_Ptr, *UTF16_Ptr_mod, *UTF16_Ptr_end;	UTF8				*UTF8_Ptr, *UTF8_Ptr_mod, *UTF8_Ptr_end;	size_t				i, outputLength;	ConversionResult	result;	FailOnNIL( UTF16_Ptr_mod = UTF16_Ptr = (UTF16*)NewPtr( inputLength * sizeof(UTF16) ) );	UTF16_Ptr_end = (UTF16*)((Ptr)UTF16_Ptr + ::GetPtrSize((Ptr)UTF16_Ptr));	if( mToUnicode )	{		// FIX ME - instead of allocating a large output buffer, use mOutputBuffer!		// The worst-case memory wise is triple memory usage for UTF8...		// This should never happen, but then...				FailOnNIL( UTF8_Ptr_mod = UTF8_Ptr = (UTF8*)NewPtr( inputLength *  3 ) );		UTF8_Ptr_end = UTF8_Ptr + ::GetPtrSize((Ptr)UTF8_Ptr);				for( i = 0; i < inputLength; i++ )			UTF16_Ptr[i] = MacToUTF16Table[inputBuffer[i]];				result = 		ConvertUTF16toUTF8( &UTF16_Ptr_mod, UTF16_Ptr_end,							&UTF8_Ptr_mod, UTF8_Ptr_end );				outputLength = UTF8_Ptr_mod - UTF8_Ptr;		FailOnNIL( outputHandle = NewHandle( outputLength ) );		BlockMoveData( UTF8_Ptr, *outputHandle, outputLength );		DisposePtr((Ptr)UTF8_Ptr);	}	else	{		FailOnNIL( UTF8_Ptr = UTF8_Ptr_mod = (UTF8*)inputBuffer );		UTF8_Ptr_end = UTF8_Ptr_mod + inputLength;				result = 		ConvertUTF8toUTF16( &UTF8_Ptr_mod, UTF8_Ptr_end,							&UTF16_Ptr_mod, UTF16_Ptr_end );				outputLength = ((Ptr)UTF16_Ptr_mod - (Ptr)UTF16_Ptr) / 2;		FailOnNIL( outputHandle = NewHandle( outputLength ) );		HLock( outputHandle );		for( i = 0; i < outputLength; i++ )			(*outputHandle)[i] = UTF16ToMacTable[UTF16_Ptr[i]];		HUnlock( outputHandle );	}		DisposePtr((Ptr)UTF16_Ptr);#endif	return	outputHandle;}/*mac char for unknow Unicode: 0x2Econst UCS4 kReplacementCharacter =	0x0000FFFDUL;Unicode values	Unicode-Bits		UTF-8-Bytes as Bits 0x0000-0x007F 	0000 0000 0XXXXXXX	0XXXXXXX 0x0080-0x07FF 	0000 0XXX XXXXXXXX	110XXXXX 10XXXXXX 0x0800-0xFFFF	XXXX XXXX XXXXXXXX	1110XXXX 10XXXXXX 10XXXXXXX Mapping for the chars from 0x80 till 0xFF  // 0      1      2      3      4      5      6      7      8      9      A      B      C      D      E     F  0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,  0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,  0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,  0x221E,0x00B1,0x2266,0x2265,0x00A5,0x00B5,0x2202,0x03A3,0x03A0,0x03C0,0x222B,0x00AA,0x00BA,0x2126,0x00E6,0x00F8,  0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,0x00BB,0x2026,0x00A0,0x00C1,0x00C3,0x00D5,0x0152,0x0153,  0x00AD,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,0x00FF,0x0178,0x2215,0x00A4,0x2039,0x203A,0xFB01,0xFB02,  0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,  0xE000,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x0302,0x0303,0x0304,0x0306,0x0307,0x030A,0x0327,0x030B,0x0328,0x030C*/