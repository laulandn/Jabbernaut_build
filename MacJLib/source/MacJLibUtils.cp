/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		MacJLibUtils.cp *  Created:	2000-08-05 *  Authors:	MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"MacJLibUtils.h"#include	<stdio.h>#if USE_MACJLIB_NSnamespace MacJLib {#endifstd::time_t		GetTimeSeconds(){#if USE_MAC_ROUTINES	unsigned long x;	::GetDateTime(&x);	return x;#else	return time( NULL );#endif}std::string		SecondsToUTC( std::time_t secs ){#if USE_MAC_ROUTINES	DateTimeRec	dtr;	char		utcStr[18];	SecondsToDate( secs, &dtr );	sprintf(utcStr, "%04d%02d%02dT%02d:%02d:%02d", dtr.year, dtr.month, dtr.day, dtr.hour, dtr.minute, dtr.second );		return std::string(utcStr);#endif}std::time_t		UTCToSeconds( const std::string utc ){#if USE_MAC_ROUTINES	DateTimeRec		dtr;	unsigned long	secs;	long			year;	long			month;	long			day;	long			hour;	long			minute;	long			second;	if( utc.size() != 17 )		return 0;		if( utc[8] != 'T' || utc[11] != ':' ||  utc[14] != ':' )		return 0;	//20000710T18:54:57	sscanf( utc.c_str(), "%4d%2d%2dT%2d:%2d:%2d", &year, &month, &day, &hour, &minute, &second );	dtr.year = year;	dtr.month = month;	dtr.day = day;	dtr.hour = hour;	dtr.minute = minute;	dtr.second = second;	DateToSeconds( &dtr, &secs );		return secs;#endif}int	TimeZoneOffsetInSeconds(){#if USE_MAC_ROUTINES	MachineLocation	theLocation;	long			gmt;	ReadLocation( &theLocation );	gmt = theLocation.u.gmtDelta;	gmt &= 0x00FFFFFF;			// mask off dlsDelta	if (gmt & 0x00800000)		// if sign bit of gmtDelta is set		gmt |= 0xFF000000;		// then turn on high char if long		return gmt;#endif}#pragma mark -void ConvertCRs( char *cBuffer, bool cr ){	MJ_ASSERT( "cBuffer==NULL", cBuffer!=NULL )		char searchChar	= cr ? '\n' : '\r';	char repChar	= cr ? '\r' : '\n';		while( *cBuffer )	{		if(*cBuffer == searchChar)			*cBuffer = repChar;		cBuffer++;	}}void ConvertCRs( std::string &aStr, bool cr ){	char searchChar	= cr ? '\n' : '\r';	char repChar	= cr ? '\r' : '\n';	#if 0	for( std::string::iterator X = aStr.begin(); X != aStr.end(); ++X )		if( *X == searchChar )			*X = repChar;#else	size_t theStringSize = aStr.size();	for( size_t i = 0; i < theStringSize; i++ )		if( aStr[i] == searchChar )			aStr[i] = repChar;#endif}void			Trim( std::string & str ){	std::string	whitespace(" \t\r\n");	std::string::size_type	b, e;		b = str.find_first_not_of(whitespace);	if( b != std::string::npos )	{		e = str.find_last_not_of(whitespace);		str = str.substr(b, e - b + 1);	}	else		str = std::string();}std::string		Trim( const std::string & str ){	std::string	whitespace(" \t\r\n");	std::string::size_type	b, e;		b = str.find_first_not_of(whitespace);	if( b != std::string::npos )	{		e = str.find_last_not_of(whitespace);		return str.substr(b, e - b + 1);	}	else		return std::string();}void			EscapeXML( std::string & str ){	str = EscapeXML( const_cast<const std::string &>(str) );}std::string		EscapeXML( const std::string & str ){	std::string	escapedXML;	for(std::string::const_iterator X = str.begin(); X != str.end(); ++X )	{		switch( *X )		{		case '&':			escapedXML += "&amp;";			break;		case '\'':			escapedXML += "&apos;";			break;		case '\"':			escapedXML += "&quot;";			break;		case '<':			escapedXML += "&lt;";			break;		case '>':			escapedXML += "&gt;";			break;		default:			escapedXML += *X;		}	}	return escapedXML;}#pragma mark -void	MJ_AssertError( long lineNo, char* srcFile, char* reason ){#if MACJLIB_DEBUG	char		dStr[1024] = "ASSERT: %s in file %s, line %d"; 	Str255		pStr;		sprintf( dStr, reason, srcFile, lineNo );		CopyCStringToPascal( dStr, pStr );			DebugStr( pStr );	#endif}#if USE_MACJLIB_NS}#endif