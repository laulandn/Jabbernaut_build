/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		BaseClient.cp *  Created:	2000-04-01 *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"BaseClient.h"#include	"MacJLibUtils.h"#include	"JXMLStream.h"#include	"TagHandler.h"#if USE_AUTOMATIC_UTF8  #include	"UTFConverter.h"#endif#include	<string.h>#include	<typeinfo>#if USE_MACJLIB_NSnamespace MacJLib {#endifClient::Client( ClientConnection *inLink, JXMLStream* inStream ){	mXMLStream = inStream;	mLastConnState = kConnectionStateDisconnected;	mLink = inLink;	mXMLStreamOutBegin = NULL;	mSaidHello = false;		if( mXMLStream )	{		//register our default handlers				mXMLStream->AddTagHandler( new MessageTagHandler() );		mXMLStream->AddTagHandler( new PresenceTagHandler() );				mXMLStream->AddTagHandler( new IQErrorTagHandler() );		mXMLStream->AddTagHandler( new IQResultTagHandler() );		mXMLStream->AddTagHandler( new AgentsTagHandler() );		mXMLStream->AddTagHandler( new GroupchatTagHandler() );		mXMLStream->AddTagHandler( new RegisterTagHandler() );		mXMLStream->AddTagHandler( new RosterTagHandler() );		mXMLStream->AddTagHandler( new SearchTagHandler() );		mXMLStream->AddTagHandler( new TimeTagHandler() );		mXMLStream->AddTagHandler( new VersionTagHandler() );		// Finally, add a "catch-all" handler		mXMLStream->AddTagHandler( new RawTagHandler() );	}#if USE_AUTOMATIC_UTF8	FailOnNIL( mMacToUTF8Converter = new UTFConverter() );	FailOnErr( mMacToUTF8Converter->Init(true) );#endif}Client::~Client(){	while( !mOutgoingMessages.empty() )	{		delete mOutgoingMessages.front();		mOutgoingMessages.pop();	}		if( mXMLStream )		delete mXMLStream;		if( mLink )		delete mLink;		if( mXMLStreamOutBegin )		FreeMem( mXMLStreamOutBegin );	#if USE_AUTOMATIC_UTF8	if( mMacToUTF8Converter )		delete mMacToUTF8Converter;#endif	for( MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X)		delete *X;	for( StateListenerList::iterator X = mStateListeners.begin(); X != mStateListeners.end(); ++X)		delete *X;	for( DataListenerList::iterator X = mDataListeners.begin(); X != mDataListeners.end(); ++X)		delete *X;}#pragma mark -void Client::queueMessage( BaseMsg *inMessage ){	MJ_ASSERT( "inMessage == NULL", inMessage != NULL )	// Queue a message to be sent	mOutgoingMessages.push( inMessage );}MacJLibError Client::connect( const std::string &inServerName,unsigned short inPort ){	MJ_ASSERT( "mLink == NULL", mLink != NULL )	//Set server and port, initialize the connection and try to connect	//returns whatever error initializeConn() or openConn() return	MacJLibError theError = noError;		mServer = inServerName;	mPort = inPort;		theError = mLink->initializeConn();	if( !theError )	{		//This begins a connection attempt		theError = mLink->openConn( inServerName.c_str(), inPort );	}		return theError;}MacJLibError Client::preConnected(){	MJ_ASSERT( "mLink == NULL", mLink != NULL )	/* This routine is called internally and sends the handshake to the	 * Jabber Server. It will return a memory error if it couldn't allocate	 * storage for the hello string, whatever error writebytes sends or noError	*/	MacJLibError	theError = noError;	std::string		theInitString;		// Create the hello string	theInitString =		"<?xml version=\"1.0\"?><stream:stream to=\"" +		mServer +		"\" xmlns=\"jabber:client\" xmlns:stream=\"http://etherx.jabber.org/streams\">";			// Send hello string	notifyDataOut( theInitString.data(), theInitString.size() );	theError = mLink->writeBytes( theInitString.data(), theInitString.size() );		if( theError > 0 )	{		mSaidHello = true;		// the bytes were sent, send the notifyConnect event and start the XML parser				notifyConnect();				if( mXMLStream )			mXMLStream->OpenStream();				theError = noError;	}	else	{		//most likely if writeBytes failed then we will be disconnected		//by the server, but perhaps we should do something?	}		return theError;}MacJLibError Client::disconnect(){	MJ_ASSERT( "mLink == NULL", mLink != NULL )	MacJLibError	theError = noError;	const char		theCloseTag[16+1]	= "</stream:stream>";	if( mLink->getConnectionState() == kConnectionStateConnected )	{		//If we're connected send the closing string to the server		notifyDataOut( theCloseTag, 16 );		theError = mLink->writeBytes( theCloseTag, 16 );		if( theError > 0 )			theError = noError;	}	if( mLink->getConnectionState() != kConnectionStateDisconnected )		(void)mLink->closeConn();		// we ignore any errors from mLink at this stage		closeOutParser();		return theError;}void Client::closeOutParser(){	if( mXMLStream && mXMLStream->IsOpen() )	{		//If the parser existed, delete it		mXMLStream->ParseStream("</stream:stream>",16);		mXMLStream->CloseStream();	}}#pragma mark -MacJLibError Client::processIn(){	MJ_ASSERT( "mLink == NULL", mLink != NULL )	/*	 * Purpose:		give the Client object time to process incoming data	 * 	 * Output:		nothing	 * 	*/	long			theBytesRead;	MacJLibError	theError = noError;	ConnectionState theTempLinkState;		if( mLink == NULL )		return theError;		theTempLinkState = mLink->getConnectionState();	theError = mLink->houseKeeping();		switch( theTempLinkState )	{		case kConnectionStateDisconnected:			if( mLastConnState != kConnectionStateDisconnected )			{				notifyDisconnect();				closeOutParser();			}			mSaidHello = false;			break;		case kConnectionStateDisconnecting:			break;		case kConnectionStateConnected:			if( mLastConnState != kConnectionStateConnected )			{				theError = preConnected();			}						if( mLink->isDataAvail() )			{				/*				Send incoming data to the XML parser				Fire the onData event				*/								theBytesRead = mLink->readBytes( mReadBuffer, kBufferSize - 1 );				if( theBytesRead > 0 )				{					MJ_ASSERT( "theBytesRead > kBufferSize", theBytesRead < kBufferSize )					mReadBuffer[theBytesRead] = 0;					notifyDataIn( mReadBuffer, theBytesRead );					if( mXMLStream )						mXMLStream->ParseStream( mReadBuffer, theBytesRead );				}				else				{					theError = theBytesRead;					goto bail;				}			}						/* Get the next message that's been created by the parser  */			if( mXMLStream )			{				ParseableNode *theTopMessage = mXMLStream->GetNextMessage();				while( theTopMessage )				{					notifyMsgListeners( theTopMessage  );/*					if( typeid(*theTopMessage) == typeid(IQErrorMsg) )						onError( *(IQErrorMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(MessageMsg) )						onMessage( *(MessageMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(RosterMsg) )						onRoster( *(RosterMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(PresenceMsg) )						onPresence( *(PresenceMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(IQResultMsg) )						onResult( *(IQResultMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(RegisterMsg) )						onRegister( *(RegisterMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(VersionMsg) )						onVersion( *(VersionMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(TimeMsg) )						onTime( *(TimeMsg*)theTopMessage );										else if( typeid(*theTopMessage) == typeid(AgentsMsg) )						onAgents( *(AgentsMsg*)theTopMessage );										else						onUnknownMsg( *theTopMessage );*/										delete theTopMessage;					theTopMessage = mXMLStream->GetNextMessage();				}			}			break;		case kConnectionStateConnecting:			break;	}bail:	mLastConnState = theTempLinkState;		return theError;}MacJLibError Client::processOut(){	MJ_ASSERT( "mLink == NULL", mLink != NULL )	/*	 * Purpose:		give the Client object time to "do its stuff"	 * 	 * Output:		nothing	 * 	*/	MacJLibError	theError = noError;	static std::time_t keepAlive_timer = TickCount();	if( !mLink || !mSaidHello )		return theError;		switch( mLink->getConnectionState() )	{		case kConnectionStateConnected:						long	theBytesSent = 0;						while( (theError == noError)				&& (theBytesSent < kBufferSize)				&& !mOutgoingMessages.empty() )			{				/*				If there is no data waiting to be sent then try to get another message				from the outbound queue				*/				if( mXMLStreamOutBegin == NULL )				{					BaseMsg		*theTopMessage = mOutgoingMessages.front();					size_t		theDataSize;					mOutgoingMessages.pop();					FailOnNIL( mXMLStreamOutBegin = theTopMessage->toXML() );					theDataSize = theTopMessage->size();				#if USE_AUTOMATIC_UTF8					Ptr		UTF8_Ptr;					FailOnNIL( UTF8_Ptr = mMacToUTF8Converter->Convert(mXMLStreamOutBegin, theDataSize ) );					FreeMem( mXMLStreamOutBegin );					mXMLStreamOutBegin = UTF8_Ptr;				#endif					mXMLStreamOutPos = mXMLStreamOutBegin + 0L;					mXMLStreamOutEnd = mXMLStreamOutBegin + theDataSize;					delete theTopMessage;				}				/*				If there is data to send, send it				*/				if( mXMLStreamOutBegin )				{					MJ_ASSERT( "mXMLStreamOutBegin > mXMLStreamOutPos", mXMLStreamOutBegin <= mXMLStreamOutPos )					MJ_ASSERT( "mXMLStreamOutPos > mXMLStreamOutEnd", mXMLStreamOutPos <= mXMLStreamOutEnd )					MJ_ASSERT( "mLink == NULL", mLink != NULL )					if( mXMLStreamOutPos < mXMLStreamOutEnd )					{						long		theBytesToSend;						int			theResult;						theBytesToSend = mXMLStreamOutEnd - mXMLStreamOutPos;						notifyDataOut( mXMLStreamOutPos, theBytesToSend );						theResult = mLink->writeBytes( mXMLStreamOutPos, theBytesToSend );						keepAlive_timer = TickCount();						if( theResult < 0 )						{							theError = theResult;							break;						}						else						{							theBytesSent += theResult;							mXMLStreamOutPos += theResult;														if( mXMLStreamOutPos >= mXMLStreamOutEnd )							{								//done								FreeMem( mXMLStreamOutBegin );								mXMLStreamOutBegin = mXMLStreamOutEnd = mXMLStreamOutPos = NULL;							}						}					}					else					{						FreeMem( mXMLStreamOutBegin );						mXMLStreamOutBegin = mXMLStreamOutEnd = mXMLStreamOutPos = NULL;					}				}			}			if( mXMLStreamOutBegin == NULL )			{				// Keep alive tickle				if( keepAlive_timer + 60 < TickCount() ) // send keep alive every second				{					//notifyDataOut( " ", 1 );					mLink->writeBytes( " ", 1 );					keepAlive_timer = TickCount();				}			}			break;		case kConnectionStateConnecting:			break;		case kConnectionStateDisconnecting:			break;		case kConnectionStateDisconnected:			mSaidHello = false;			break;	}	return theError;}#pragma mark -ConnectionState Client::getConnectionState(){	MJ_ASSERT( "mLink == NULL", mLink != NULL )	return mLink->getConnectionState();}const std::string& Client::getSessionID() const{	if( mXMLStream )		return mXMLStream->GetSessionID();	else		return "";}void Client::getServer( char *outServerName ) const{	strcpy( outServerName, mServer.c_str() );}long Client::getPort() const{	return mPort;}#pragma mark -void	Client::addMsgListener( MsgListener *listener ){	mMsgListeners.push_back( listener );}void	Client::removeMsgListener( MsgListener *listener ){	mMsgListeners.remove( listener );}void	Client::addStateListener( StateListener *listener ){	mStateListeners.push_back( listener );}void	Client::removeStateListener( StateListener *listener ){	mStateListeners.remove( listener );}void	Client::addDataListener( DataListener *listener ){	mDataListeners.push_back( listener );}void	Client::removeDataListener( DataListener *listener ){	mDataListeners.remove( listener );}#pragma mark -// Notify listeners about connectvoid	Client::notifyConnect(){	for( MacJLib::StateListenerList::iterator X = mStateListeners.begin(); X != mStateListeners.end(); ++X )		(*X)->onConnect();}// Notify listeners about disconnectvoid	Client::notifyDisconnect(){	for( MacJLib::StateListenerList::iterator X = mStateListeners.begin(); X != mStateListeners.end(); ++X )		(*X)->onDisconnect();}void	Client::notifyMsgListeners( ParseableNode *inUnknown ){	if( typeid(*inUnknown) == typeid(IQErrorMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onError( *(IQErrorMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(MessageMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onMessage( *(MessageMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(RosterMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onRoster( *(RosterMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(PresenceMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onPresence( *(PresenceMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(IQResultMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onResult( *(IQResultMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(RegisterMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onRegister( *(RegisterMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(VersionMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onVersion( *(VersionMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(TimeMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onTime( *(TimeMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(AgentsMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onAgents( *(AgentsMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(SearchMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onSearch( *(SearchMsg*)inUnknown );	}	else if( typeid(*inUnknown) == typeid(GroupchatMsg) )	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onGroupchat( *(GroupchatMsg*)inUnknown );	}	else	{		for( MacJLib::MsgListenerList::iterator X = mMsgListeners.begin(); X != mMsgListeners.end(); ++X )			(*X)->onUnknownMsg( *inUnknown );	}}// Notify listeners about incoming datavoid	Client::notifyDataIn( const char *data, std::size_t len ){	for( MacJLib::DataListenerList::iterator X = mDataListeners.begin(); X != mDataListeners.end(); ++X )		(*X)->onDataIn( data, len );}// Notify listeners about outgoing datavoid	Client::notifyDataOut( const char *data, std::size_t len ){	for( MacJLib::DataListenerList::iterator X = mDataListeners.begin(); X != mDataListeners.end(); ++X )		(*X)->onDataOut( data, len );}#if USE_MACJLIB_NS}#endif