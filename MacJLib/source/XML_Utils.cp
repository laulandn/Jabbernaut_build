/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		XML_Utils.cp *  Created:	2000-04-01 *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"XML_Utils.h"#include	"MacJLibUtils.h"#include	<string.h>#if USE_MACJLIB_NSnamespace MacJLib {#endifvoid TagToString( const CElementNode &elementNode, std::string &destStr ){	if( elementNode.IsLeaf() )		destStr = elementNode.GetLeafData();	ConvertCRs( destStr, true );}#pragma mark -// strcpyEscaped//	This function appends a str to another and escapes some XML chars on the way.//	Take care that enough space is allocated!void	strcpyEscaped( char *destStr, const char *srcStr ){	MJ_ASSERT( "destStr==NULL", destStr!=NULL )	MJ_ASSERT( "srcStr==NULL", srcStr!=NULL )	while( *srcStr )	{		switch( *srcStr )		{		case '&':			MoveMem( "&amp;", destStr, 5 );			destStr += 5;			break;		case '\'':			MoveMem( "&apos;", destStr, 6 );			destStr += 6;			break;		case '\"':			MoveMem( "&quot;", destStr, 6 );			destStr += 6;			break;		case '<':			MoveMem( "&lt;", destStr, 4 );			destStr += 4;			break;		case '>':			MoveMem( "&gt;", destStr, 4 );			destStr += 4;			break;		default:			*(destStr++) = *srcStr;		}		srcStr++;	}	*destStr = '\0';}// strcatEscaped//	This function appends a str to another and escapes some XML chars on the way.//	You previously have to take care that enough space is allocated!void	strcatEscaped( char *destStr, const char *aStr ){	MJ_ASSERT( "destStr==NULL", destStr!=NULL )	MJ_ASSERT( "aStr==NULL", aStr!=NULL )	destStr += strlen(destStr);		strcpyEscaped( destStr, aStr );}size_t	strlenEscaped( const char *aStr ){	MJ_ASSERT( "aStr==NULL", aStr!=NULL )	size_t	len = 0;	while( *aStr )	{		switch( *aStr )		{		case '&':			len += 5;	//&amp;			break;		case '\'':			len += 6;	//&apos;			break;		case '\"':			len += 6;	//&quot;			break;		case '<':			len += 4;	//&lt;			break;		case '>':			len += 4;	//&gt;			break;		default:			len++;		}		aStr++;	}	return len;}#pragma mark -void	tag_strcat( char *destStr, const char *tagName, const std::string& tagData ){	MJ_ASSERT( "destStr==NULL", destStr!=NULL )	MJ_ASSERT( "tagName==NULL", tagName!=NULL )	if( !tagData.empty() )	{		strcat(destStr, "<");		strcatEscaped(destStr, tagName);		strcat(destStr, ">");		strcatEscaped(destStr, tagData.c_str());		strcat(destStr, "</");		strcatEscaped(destStr, tagName);		strcat(destStr, ">");	}}long	tag_strlen( const char *tagName, const std::string& tagData ){	MJ_ASSERT( "tagName==NULL", tagName!=NULL )	if( !tagData.empty() )		return	5 +				2*strlenEscaped(tagName) + 				strlenEscaped(tagData.c_str());	else		return 0;}void	attrib_strcat( char *destStr, const char *attribName, const std::string& attribData ){	MJ_ASSERT( "destStr==NULL", destStr!=NULL )	MJ_ASSERT( "attribName==NULL", attribName!=NULL )	if( !attribData.empty() )	{		strcat(destStr, " ");		strcatEscaped(destStr, attribName);		strcat(destStr, "=\"");		strcatEscaped(destStr, attribData.c_str());		strcat(destStr, "\"");	}}long	attrib_strlen( const char *attribName, const std::string& attribData ){	MJ_ASSERT( "attribName==NULL", attribName!=NULL )	if( !attribData.empty() )		return	4 +				strlenEscaped(attribName) + 				strlenEscaped(attribData.c_str());	else		return 0;}#if USE_MACJLIB_NS}#endif