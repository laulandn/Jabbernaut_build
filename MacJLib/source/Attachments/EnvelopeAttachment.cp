/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		EnvelopeAttachment.cp *  Created:	2000-09-20 *  Authors:	MH - Max Horn <max@quendi.de> *				CB - Chris Behm <cjbehm@mail.com> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#include	"EnvelopeAttachment.h"#include	"XML_Utils.h"#if USE_MACJLIB_NSnamespace MacJLib {#endifconst std::string EnvelopeAttachment::msXMLNS("jabber:x:envelope");#pragma mark -void EnvelopeAttachment::setToJID( const JID &inToJID ){	mToJID = inToJID;}const JID &EnvelopeAttachment::getToJID() const{	return mToJID;}void EnvelopeAttachment::setTo( const std::string &inTo ){	mTo = inTo;}const std::string &EnvelopeAttachment::getTo() const{	return mTo;}void EnvelopeAttachment::setFromJID( const JID &inFromJID ){	mFromJID = inFromJID;}const JID &EnvelopeAttachment::getFromJID() const{	return mFromJID;}void EnvelopeAttachment::setFrom( const std::string &inFrom ){	mFrom = inFrom;}const std::string &EnvelopeAttachment::getFrom() const{	return mFrom;}void EnvelopeAttachment::setCCJID( const JID &inCCJID ){	mCCJID = inCCJID;}const JID &EnvelopeAttachment::getCCJID() const{	return mCCJID;}void EnvelopeAttachment::setCC( const std::string &inCC ){	mCC = inCC;}const std::string &EnvelopeAttachment::getCC() const{	return mCC;}void EnvelopeAttachment::setForwardedByJID( const JID &inForwardedByJID ){	mForwardedByJID = inForwardedByJID;}const JID &EnvelopeAttachment::getForwardedByJID() const{	return mForwardedByJID;}void EnvelopeAttachment::setForwardedBy( const std::string &inForwardedBy ){	mForwardedBy = inForwardedBy;}const std::string &EnvelopeAttachment::getForwardedBy() const{	return mForwardedBy;}void EnvelopeAttachment::setReplyToJID( const JID &inReplyToJID ){	mReplyToJID = inReplyToJID;}const JID &EnvelopeAttachment::getReplyToJID() const{	return mReplyToJID;}void EnvelopeAttachment::setReplyTo( const std::string &inReplyTo ){	mReplyTo = inReplyTo;}const std::string &EnvelopeAttachment::getReplyTo() const{	return mReplyTo;}#pragma mark -void EnvelopeAttachment::visitNode( const CElementNode& aNode ){	if( aNode.GetName() == "to" )	{		mToJID = aNode.AttribVal("to");		TagToString( aNode, mTo );	}	else if( aNode.GetName() == "from" )	{		mFromJID = aNode.AttribVal("from");		TagToString( aNode, mFrom );	}	else if( aNode.GetName() == "cc" )	{		mCCJID = aNode.AttribVal("cc");		TagToString( aNode, mCC );	}	else if( aNode.GetName() == "forwardedby" )	{		mForwardedByJID = aNode.AttribVal("forwardedby");		TagToString( aNode, mForwardedBy );	}	else if( aNode.GetName() == "replyto" )	{		mReplyToJID = aNode.AttribVal("replyto");		TagToString( aNode, mReplyTo );	}	else		MsgAttachment::visitNode( aNode );}#if USE_MACJLIB_NS}#endif