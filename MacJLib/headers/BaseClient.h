/* *  This library is free software; you can redistribute it and/or *  modify it under the terms of the GNU Lesser General Public *  License as published by the Free Software Foundation; either *  version 2.1 of the License, or (at your option) any later version. * *  This library is distributed in the hope that it will be useful, *  but WITHOUT ANY WARRANTY; without even the implied warranty of *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *  Lesser General Public License for more details. * *  You should have received a copy of the GNU Lesser General Public *  License along with this library; if not, write to the Free Software *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA * *  Project:	MacJLib *  File:		BaseClient.h *  Created:	2000-04-01 *  Authors:	CB - Chris Behm <cjbehm@mail.com> *				MH - Max Horn <max@quendi.de> * *  Copyright:	(C) 2000 The MacJLib Team http://macjlib.sourceforge.net/ */#pragma once#include	"MacJLibPrefix.h"#include	"ClientConnection.h"#include	"MacJLibUtils.h"#include	"Messages.h"#include	"MessageQueue.h"#if USE_MACJLIB_NSnamespace MacJLib {#endif#pragma mark class MsgListenerclass MsgListener{public:	virtual ~MsgListener()	{}	// Listener interface to watch for certain messages.	virtual void		onError( IQErrorMsg &inError ) {}	virtual void		onResult( IQResultMsg &inResult ) {}	virtual void		onMessage( MessageMsg &inMessage ) {}	virtual void		onRoster( RosterMsg &inRoster ) {}	virtual void		onPresence( PresenceMsg &inPresence ) {}	virtual void		onRegister( RegisterMsg &inRegister ) {}	virtual void		onVersion( VersionMsg &inVersion ) {}	virtual void		onTime( TimeMsg &inTime ) {}	virtual void		onAgents( AgentsMsg &inAgentsMsg ) {}	virtual void		onSearch( SearchMsg &inSearchMsg ) {}	virtual void		onGroupchat( GroupchatMsg &inGroupchatMsg ) {}	virtual void		onUnknownMsg( ParseableNode &inUnknown ) {}};// Adapter class for MsgListener.// Purpose: BaseClient's destrutor deletes all MsgListener objects passed to it.// However, in some cases you want to keep your MsgListener (e.g. BaseCelient passes// itself as MsgListener; and you might want to use a single listener with multiple// clients etc.). Solution: MsgListenerAdapter. It acts as a proxy to a MsgListener// object you pass to it in the constructor. #pragma mark class MsgListenerAdapterclass MsgListenerAdapter : public MsgListener{public:	MsgListenerAdapter( MsgListener *aListener )		: mTarget( aListener )	{}	virtual void		onError( IQErrorMsg &msg )			{ mTarget->onError( msg ); }	virtual void		onResult( IQResultMsg &msg )		{ mTarget->onResult( msg ); }	virtual void		onMessage( MessageMsg &msg )		{ mTarget->onMessage( msg ); }	virtual void		onRoster( RosterMsg &msg )			{ mTarget->onRoster( msg ); }	virtual void		onPresence( PresenceMsg &msg )		{ mTarget->onPresence( msg ); }	virtual void		onRegister( RegisterMsg &msg )		{ mTarget->onRegister( msg ); }	virtual void		onVersion( VersionMsg &msg )		{ mTarget->onVersion( msg ); }	virtual void		onTime( TimeMsg &msg )				{ mTarget->onTime( msg ); }	virtual void		onAgents( AgentsMsg &msg )			{ mTarget->onAgents( msg ); }	virtual void		onSearch( SearchMsg &msg )			{ mTarget->onSearch( msg ); }	virtual void		onGroupchat( GroupchatMsg &msg )	{ mTarget->onGroupchat( msg ); }	virtual void		onUnknownMsg( ParseableNode &msg )	{ mTarget->onUnknownMsg( msg ); }private:	MsgListener	* const mTarget;};typedef std::list<MsgListener*>			MsgListenerList;#pragma mark -#pragma mark class StateListenerclass StateListener{public:	virtual ~StateListener()	{}	// Listener interface to watch for (dis)connect events.	virtual void		onConnect() {}	virtual void		onDisconnect() {}};#pragma mark class StateListenerAdapterclass StateListenerAdapter : public StateListener{public:	StateListenerAdapter( StateListener *aListener )		: mTarget( aListener )	{}	virtual void		onConnect()		{ mTarget->onConnect(); }	virtual void		onDisconnect()	{ mTarget->onDisconnect(); }private:	StateListener	* const mTarget;};typedef std::list<StateListener*>	StateListenerList;#pragma mark -#pragma mark class DataListenerclass DataListener{public:	virtual ~DataListener()	{}	// Hooks to watch the data as it is sent in and out.	virtual void		onDataIn( const char *inData, std::size_t inLen )	{}	virtual void		onDataOut( const char *inData, std::size_t inLen )	{}};#pragma mark class DataListenerAdapterclass DataListenerAdapter : public DataListener{public:	DataListenerAdapter( DataListener *aListener )		: mTarget( aListener )	{}	virtual void		onDataIn( const char *inData, std::size_t inLen )	{ mTarget->onDataIn( inData, inLen ); }	virtual void		onDataOut( const char *inData, std::size_t inLen )	{ mTarget->onDataOut( inData, inLen ); }private:	DataListener	* const mTarget;};typedef std::list<DataListener*>		DataListenerList;class	JXMLStream;#if USE_AUTOMATIC_UTF8	class	UTFConverter;#endifclass Client{	public:		Client( ClientConnection *inLink, JXMLStream* inStream );		virtual ~Client();				// Call these two functions as frequently as possible, like in your idle loop.		MacJLibError		processIn();		MacJLibError		processOut();				// Call these two functions to connect/disconnect to/from the sever.		MacJLibError		connect( const std::string &inServerName, unsigned short inPort );		MacJLibError		disconnect();		void				queueMessage( BaseMsg *inMessage );				// Some query functions.		ConnectionState		getConnectionState();		const std::string&	getSessionID() const;		void				getServer( char *outServerName ) const;		long				getPort() const;				// Listener add/remove methods		void				addMsgListener( MsgListener *listener );		void				removeMsgListener( MsgListener *listener );				void				addStateListener( StateListener *listener );		void				removeStateListener( StateListener *listener );				void				addDataListener( DataListener *listener );		void				removeDataListener( DataListener *listener );			protected:				virtual void		notifyConnect();		virtual void		notifyDisconnect();		virtual void		notifyMsgListeners( ParseableNode *inUnknown );		virtual void		notifyDataIn( const char *inData, std::size_t inLen );		virtual void		notifyDataOut( const char *inData, std::size_t inLen );	// Private Functions	private:		// preConnected is for internal use only. It is called just before the connection		// if finally established.		MacJLibError		preConnected();		// Correctly closes down the XML parser and handler.		void				closeOutParser();	// Private Data	private:		// Queue of outbound messages		MessageQueue		mOutgoingMessages;				// Network connection		ClientConnection	*mLink;				// JXMLStream - much like clientconnection, hides implementation		JXMLStream			*mXMLStream;		#if USE_AUTOMATIC_UTF8		// Converter to UTF-8		UTFConverter		*mMacToUTF8Converter;#endif				// These three member variables keep track of the data that's being sent.		// mXMLStreamOutPos points to where in the data stream we are		// for sending.		Ptr					mXMLStreamOutBegin;		Ptr					mXMLStreamOutEnd;		Ptr					mXMLStreamOutPos;				// internal data.		short				mPort;		std::string			mServer;		int					mLastConnState;		bool				mSaidHello;				// internal read buffer		static const long	kBufferSize = 16384;		char				mReadBuffer[kBufferSize];				MsgListenerList		mMsgListeners;		StateListenerList	mStateListeners;		DataListenerList	mDataListeners;};class BaseClient : public Client, MsgListener, StateListener, DataListener{		BaseClient( ClientConnection *inLink, JXMLStream* inStream )			: Client( inLink, inStream )			{				addMsgListener( new MsgListenerAdapter(this) );				addStateListener( new StateListenerAdapter(this) );				addDataListener( new DataListenerAdapter(this) );			}};#if USE_MACJLIB_NS}#endif