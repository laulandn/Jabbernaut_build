=head1 OverviewThis section discusses the routines common to all, or almost allcommunication domains. These routines return C<-1> if an error occurred,and set the variable C<errno> to an error code. On success, the routines return C<0>or some positive value.Here's a list of all error codes and their typical explanations. The most importantof them are repeated for the individual calls.=over 4=item C<EACCES>Permission denied: An attempt was made to access a file in a way forbidden by itsfile access permissions, e.g., to C<open()> a locked file for writing.=item C<EADDRINUSE>Address already in use: C<bind()> was called with an address already in use by another socket.=item C<EADDRNOTAVAIL>Can't assign requested address: C<bind()> was called with an address which this socket can't assume, e.g., a TCP/IP address whose C<in_addr> specifies a different host.=item C<EAFNOSUPPORT>Address family not supported: You haven't linked with this socket family or havespecified a nonexisting family, e.g., AF_CHAOS.=item C<EALREADY>Operation already in progress, e.g., C<connect()> was called twice in a row for a nonblocking socket.=item C<EBADF>Bad file descriptor: The file descriptor you specified is not open.=item C<EBUSY>Request for a system resource already in incompatible use, e.g., attempt to deletean open file.=item C<ECONNREFUSED>Connection refused, e.g. you specified an unused port for a C<connect()>=item C<EEXIST>File exists, and you tried to open it with C<O_EXCL>.=item C<EHOSTDOWN>Remote host is down.=item C<EHOSTUNREACH>No route to host.=item C<EINPROGRESS>Operation now in progress. This is *not* an error, but returned from nonblocking operations, e.g., nonblocking C<connect()>.=item C<EINTR>Interrupted system call: The user pressed Command-. or C<alarm()> timed out.=item C<EINVAL>Invalid argument or various other error conditions.=item C<EIO>Input/output error.=item C<EISCONN>Socket is already connected.=item C<EISDIR>Is a directory, e.g. you tried to C<open()> a directory.=item C<EMFILE>Too many open files.=item C<EMSGSIZE>Message too long, e.g. for an UDP C<send()>.=item C<ENAMETOOLONG>File name too long.=item C<ENETDOWN>Network is down, e.g., Appletalk is turned off in the chooser.=item C<ENFILE>Too many open files in system.=item C<ENOBUFS>No buffer space available.=item C<ENOENT>No such file or directory.=item C<ENOEXEC>Severe error with the PowerPC standard library.=item C<ENOMEM>Cannot allocate memory.=item C<ENOSPC>No space left on device.=item C<ENOTCONN>Socket is not connected, e.g., neither C<connect()> nor C<accept()> has been called successfully for it.=item C<ENOTDIR>Not a directory.=item C<ENOTEMPTY>Directory not empty, e.g., attempt to delete nonempty directory.=item C<ENXIO>Device not configured, e.g., MacTCP control panel misconfigured.=item C<EOPNOTSUPP>Operation not supported on socket, e.g., C<sendto()> on a stream socket.=item C<EPFNOSUPPORT>Protocol family not supported, i.e., attempted use of ADSP on a machine that has AppleTalk but not ADSP.=item C<EPROTONOSUPPORT>Protocol not supported, e.g., you called C<getprotobyname()> with neither "tcp" nor"udp" specified.=item C<ERANGE>Result too large, e.g., C<getcwd()> called with insufficient buffer.=item C<EROFS>Read-only file system.=item C<ESHUTDOWN>Can't send after socket shutdown.=item C<ESOCKTNOSUPPORT>Socket type not supported, e.g., datagram PPC toolbox sockets.=item C<ESPIPE>Illegal seek, e.g., C<lseek()> called for a TCP socket.=item C<EWOULDBLOCK>Nonblocking operation would block.=item C<EXDEV>Cross-device link, e.g. C<FSpSmartMove()> attempted to move file to a different volume.=back=head2 Creating and destroying socketsA socket is created with C<socket()> and destroyed with C<close()>. In some situations,it's useful to create a pair of connected sockets with C<socketpair()> or C<pipe()>. Youcan gradually shut down data transfer with C<shutdown()>.=over 4=item C<int socket(int af, int type, int protocol)> creates an endpoint for communicationand returns a descriptor. C<af> specifies the communication domain to be used. Validvalues are:=over 4=item C<AF_UNIX>=item C<AF_LOCAL>Communication internal to a single Mac.=item C<AF_INET>TCP/IP, using C<MacTCP> or C<Open Transport> depending on your configuration.=item C<AF_APPLETALK>Appletalk, using the ADSP and DDP protocols (not implemented yet in GUSI 2).=item C<AF_PPC>The Program-to-Program Communication Toolbox.=backC<type> specifies the semantics of the communication. The following two types areavailable:=over 4=item C<SOCK_STREAM>A two way, reliable, connection based byte stream.=item C<SOCK_DGRAM>Connectionless, unreliable messages of a fixed maximum length.=backC<protocol> would be used to specify an alternate protocol to be used with a socket.In C<GUSI>, however, this parameter is always ignored.Error codes:=over 4=item C<EINVAL>The C<af> you specified doesn't exist.=item C<EMFILE>The descriptor table is full.=back=item C<void close(int fd)> removes the access path associated with the descriptor, andcloses the file or socket if the last access path referring to it was removed.=item C<shutdown(int how)>if C<how> is C<SHUT_RD>(0), shut down the socket for reading, for C<SHUT_WR>(1), shut downfor writing, and for C<SHUT_RDWR>, shut down for both reading and writing.=item C<int socketpair(int domain, int type, int protocol, int fds[2])>creates, in C<fds[0]> and C<fds[1]>, an unnamed pair if indistinguishable socketsin the indicated domain (currently only C<AF_LOCAL> is accepted).=item C<int pipe(int fds[2])>is a shorthand notion for     socketpair(AF_LOCAL, SOCK_STREAM, 0, fds)    but fds[0] will be read-only and fds[1] will be write only.=back=head2 Establishing connections between socketsBefore you can transmit data on a stream socket, it must be connected to a peer socket. Connection establishment is asymmetrical: The server socket registers its address with C<bind()>, calls C<listen()> to indicate its willingness to accept connections and accepts them by calling C<accept()>. The client socket, after possibly having registered its address with C<bind()> (This is not necessary for all socket families as some will automatically assign an address) callsC<connect()> to establish a connection with a server.It is possible, but not required, to call C<connect()> for datagram sockets.=over 4=item C<int bind(int s, const struct sockaddr *name, socklen_t namelen)> binds a socket to its address. The format of the address is different for every socket family. Error codes:=over 4=item C<EAFNOSUPPORT>C<name> specifies an illegal address family for this socket.=item C<EADDRINUSE>There is already another socket with this address.=back=item C<int listen(int s, int qlen)> turns a socket into a listener. C<qlen> determines how many clients can concurrently wait for a connection.=item C<int accept(int s, struct sockaddr *addr, socklen_t *addrlen)> accepts a connection for a socket I<on a new socket> and returns the descriptor of the new socket. If C<addr> is not C<NULL>, the address of the connecting socketwill be assigned to it.You can find out if a connection is pending by calling C<select()> to find out ifthe socket is ready for I<reading>.Error codes:=over 4=item C<ENOTCONN>You did not call C<listen()> for this socket.=item C<EWOULDBLOCK>The socket is nonblocking and no socket is trying to connect.=back=item C<int connect(int s, const struct sockaddr *addr, socklen_t addrlen)> tries to connect to the socket whose address is in C<addr>. If the socket is nonblocking and the connection cannot be made immediately, C<connect()> returns C<EINPROGRESS>. You can find out if the connection has been established by calling C<select()> to find out if the socket is ready for I<writing>.Error codes:=over 4=item C<EAFNOSUPPORT>C<name> specifies an illegal address family for this socket.=item C<EISCONN>The socket is already connected.=item C<EADDRNOAVAIL>There is no socket with the given address.=item C<ECONNREFUSED>The socket refused the connection.=item C<EINPROGRESS>The socket is nonblocking and the connection is being established.=back=back=head2 Transmitting data between socketsYou can write data to a socket using C<write()>, C<writev()>, C<send()>, C<sendto()>, or C<sendmsg()>. You can read data from a socket using C<read()>, C<readv()>, C<recv()>, C<recvfrom()>, or C<recvmsg()>.=over 4=item C<int read(int s, void *buffer, size_t buflen)> reads up to C<buflen> bytes from the socket. C<read()> for sockets differs from C<read()> for files mainly in that it may read fewer than the requested number of bytes without waiting for the rest to arrive.Error codes:=over 4=item C<EWOULDBLOCK>The socket is nonblocking and there is no data immediately available.=back=item C<int readv(int s, const struct iovec *iov, int count)> performs the same action, but scatters the input data into the C<count> buffers of the C<iov>Êarray, always filling one buffer completely before proceeding to the next. C<iovec> is defined as follows:    struct iovec {      void *  iov_base;  /* Address of this buffer */      size_t  iov_len;   /* Length of the buffer */    };=item C<int recv(int s, void *buffer, size_t buflen, int flags)> is identical to C<read()>, except for the C<flags> parameter. If the C<MSG_OOB> flag is set for a stream socket that supports out-of-band data, C<recv()> reads out-of-band data.=item C<int recvfrom(int s, void *buffer, size_t buflen, int flags, struct sockaddr *from, socklen_t *fromlen)>is the equivalent of C<recv()> for unconnected datagram sockets. If C<from> is notC<NULL>, it will be set to the address of the sender of the message.=item C<int recvmsg(int s, struct msghdr *msg, int flags)> is the most general routine, combining the possibilities of C<readv()> and C<recvfrom()>. C<msghdr> is defined as follows:    struct msghdr {      caddr_t  msg_name;            /* Like from in recvfrom() */      int      msg_namelen;         /* Like fromlen in recvfrom() */      struct   iovec *msg_iov;      /* Scatter/gather array */      int      msg_iovlen;          /* Number of elements in msg_iov */      caddr_t  msg_accrights;       /* Access rights sent/received. Not used in GUSI */      int      msg_accrightslen;    };=item C<int write(int s, void *buffer, size_t buflen)> writes up to C<buflen> bytes to the socket. As opposed to C<read()>, C<write()> for nonblocking sockets always blocks until all bytes are written or an error occurs.Error codes:=over 4=item C<EWOULDBLOCK>The socket is nonblocking and data can't be immediately written.=back=item C<int writev(int s, const struct iovec *iov, int count)> performs the same action, but gathers the output data from the C<count> buffers ofthe C<iov>Êarray, always sending one buffer completely before proceeding to thenext.=item C<int send(int s, void *buffer, size_t buflen, int flags)> is identical to C<write()>, except for the C<flags> parameter. If the C<MSG_OOB> flag is set for a stream socket that supports out-of-band data, C<send()> sends an out-of-band message.=item C<int sendto(int s, void *buffer, size_t buflen, int flags, struct sockaddr *to, socklen_t tolen)>is the equivalent of C<send()> for unconnected datagram sockets. The message willbe sent to the socket whose address is given in C<to>.=item C<int sendmsg(int s, const struct msghdr *msg, int flags)> combines the possibilities of C<writev()> and C<sendto()>.=back=head2 I/O multiplexing=over 4=item C<int select(int width, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)>examines the I/O descriptors specified by the bit masks C<readfs>, C<writefs>, and C<exceptfs> to see if they are ready for reading, writing, or have an exception pending. C<width> is the number of significant bits in the bit mask. C<select()> replaces the bit masks with masks of those descriptors which are ready and returns the total number of ready descriptors. C<timeout>, if not C<NULL>, specifies the maximum time to wait for a descriptor to become ready. If C<timeout> is C<NULL>, C<select()> waits indefinitely. To do a poll, pass a pointer to a zero C<timeval> value in C<timeout>. Any of C<readfds>, C<writefds>, or C<exceptfds> may be given as C<NULL> if no descriptors are of interest.Error codes:=over 4=item C<EBADF>One of the bit masks specified an invalid descriptor.=backThe descriptor bit masks can be manipulated with the following macros:    FD_ZERO(fds);    /* Clear all bits in *fds */    FD_SET(n, fds);  /* Set bit n in *fds */    FD_CLR(n, fds);  /* Clear bit n in *fds */    FD_ISSET(n, fds);   /* Return 1 if bit n in *fds is set, else 0 */=back=head2 Getting and changing properties of socketsYou can obtain the address of a socket and the socket it is connected to by callingC<getsockname()> and C<getpeername()> respectively. You can query and manipulate other properties of a socket by calling C<ioctl()>, C<fcntl()>, C<getsockopt()>, and C<setsockopt()>. You can create additional descriptors for a socket by calling C<dup()> or C<dup2()>.=over 4=item C<int getsockname(int s, struct sockaddr *name, socklen_t *namelen)> returns in C<*name> the address the socket is bound to. C<*namelen> should be set to the maximum length of C<name> and will be set by C<getsockname()> to the actual length of the name.=item C<int getpeername(int s, struct sockaddr *name, socklen_t *namelen)> returns in C<*name> the address of the socket that this socket is connected to. C<*namelen> should be set to the maximum length of C<name> and will be set by C<getpeername()> to the actual length of the name.=item C<int ioctl(int d, unsigned int request, ...)> performs various operations on the socket, depending on the C<request>. The following codes are valid for all socket families:=over 4=item C<ioctl(d, FIONBIO, int * argp)>Make the socket blocking if the C<int> pointed to by argp is C<0>, elsemake it nonblocking.=item C<ioctl(d, FIONREAD, int * argp)>Set C<*argp> to the number of bytes waiting to be read.=backError codes:=over 4=item C<EOPNOTSUPP>The operation you requested with C<request> is not supported by thissocket family.=back=item C<int fcntl(int s, unsigned int cmd, int arg)> provides additional control over a socket. The following values of C<cmd> are defined for all socket families:=over 4=item C<F_DUPFD>Return a new descriptor greater than or equal to C<arg> which refers to the same socket.=item C<F_GETFL>Return descriptor status flags.=item C<F_SETFL>Set descriptor status flags to C<arg>.=backThe only status flag implemented is C<O_NONBLOCK> (Also known under its older name C<FNDELAY>)which is true if the socket is nonblocking.Error codes:=over 4=item C<EOPNOTSUPP>The operation you requested with C<cmd> is not supported by thissocket family.=back=item C<int getsockopt(int s, int level, int optname, void *optval, int * optlen)>=item C<int setsockopt(int s, int level, int optname, void *optval, int optlen)>are used to get and set options associated with a socket. The following options areimplemented (many of them only for OpenTransport sockets, though):=over 4 =item Level C<SOL_SOCKET>:=over 4=item C<SO_BROADCAST>permit sending of broadcast datagrams.=item C<SO_DONTROUTE>bypass routing table lookup.=item C<SO_ERROR>get pending asynchronous error.=item C<SO_KEEPALIVE> periodically test if connection is still alive.=item C<SO_LINGER>linger on C<close()> if there is data to send.=item C<SO_RCVBUF>manipulates the size of the buffer used for reading data.=item C<SO_SNDBUF>manipulates the size of the buffer used for writing data.=item C<SO_RCVLOWAT>receive low-water mark.=item C<SO_SNDLOWAT>send low-water mark.=item C<SO_REUSEADDR>=item C<SO_REUSEPORT>allow local address reuse.=back=item Level C<IPPROTO_IP>:=over 4=item C<IP_TOS> type-of-service and precedence.=item C<IP_TTL>time-to-live.=item C<IP_MULTICAST_IF>specify outgoing interface.=item C<IP_MULTICAST_TTL>specify outgoing time-to-live.=item C<IP_MULTICAST_LOOP>specify loopback.=item C<IP_ADD_MEMBERSHIP>join a multicast group.=item C<IP_DROP_MEMBERSHIP>leave a multicast group.=back=item Level C<IPPROTO_TCP>:=over 4=item C<TCP_KEEPALIVE>seconds between keepalive probes.=item C<TCP_MAXSEG>TCP maximum segment size.=item C<TCP_NODELAY>disable Nagle algorithm.=back=backC<optval> is a pointer to an unsigned integer in both cases.=item C<int dup(int fd)> returns a new descriptor referring to the same socket as C<fd>.The old and new descriptors are indistinguishible. The new descriptor will alwaysbe the smallest free descriptor.=item C<int dup2(int oldfd, int newfd)> closes C<newfd> if it was open and makes it a duplicate of C<oldfd>. The old and new descriptors are indistinguishible.