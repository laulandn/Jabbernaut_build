=head1 Socket Family Specific Interfaces=head2 Internet socketsThese are the real thing for real programmers. Out-of-band data only works for sending. Both stream (TCP) and datagram (UDP) sockets are supported. Internetsockets are also suited for interapplication communication on a single machine, provided it runs MacTCP or Open Transport.Internet socket addresses have the following format:    struct in_addr {      u_long s_addr;    };    struct sockaddr_in {       u_short  sin_family;       /* Always C<AF_INET> */       u_short  sin_port;         /* Port number */       struct   in_addr sin_addr; /* Host ID */       char     sin_zero[8];    };There are many routines to convert between numeric and symbolic addresses.=over 4=item *Hosts are represented by the following structure:    struct hostent {      char *h_name;        /* Official name of the host              */      char **h_aliases;    /* A zero terminated array of alternate names for the host     */      int  h_addrtype;     /* Always AF_INET                       */      int  h_length;       /* The length, in bytes, of the address   */      char **h_addr_list;  /* A zero terminated array of network addresses for the host   */    };=over 4=item C<struct hostent * gethostbyname(char *name)> returns an entry for the host with the given C<name> or C<NULL> if a host with this name can't be found.=item C<struct hostent * gethostbyaddr(const char *addrP, int, int)> returns an entry for the host with the given address or C<NULL> if a host with this name can't be found. C<addrP> in fact has to be a C<struct in_addr *>. The last two parameters are ignored.=item C<char * inet_ntoa(struct in_addr inaddr)> converts an internet address into the usual numeric string representation (e.g., C<0x8184023C> is converted to C<"129.132.2.60">)=item C<in_addr_t inet_addr(char *address)> =item C<int inet_aton(const char * addr, struct in_addr * ina)>convert a numeric string into an internet address (If C<x> is a valid address, C<inet_addr(inet_ntoa(x)) == x>).=item C<int gethostname(char *machname, long buflen)> gets our name into C<buffer>.=back=item *Services are represented by the following data structure:    struct  servent {      char  *s_name;       /* official service name */      char  **s_aliases;   /* alias list  */      int   s_port;        /* port number */      char  *s_proto;      /* protocol to use ("tcp" or "udp") */    };=over 4=item C<void setservent(int stayopen)> rewinds the file of services. If C<stayopen> is set, the file will remain open until C<endservent()> is called, else it will be closed after the next call toC<getservbyname()> or C<getservbyport()>.=item C<void endservent()> closes the file of services.=item C<struct servent * getservent()> returns the next service from the file of services, opening the file first ifnecessary. If the file is not found (C</etc/services> in the preferences folder), a small built-in list is consulted. If there are no more services, C<getservent()> returns C<NULL>.=item C<struct servent * getservbyname(const char * name, const char * proto)> finds a named service by calling C<getservent()> until the protocol matchesC<proto> and either the name or one of the aliases matches C<name>.=item C<struct servent * getservbyport(int port, const char * proto)> finds aservice by calling C<getservent()> until the protocol matches C<proto> and theport matches C<port>.=back=item *Protocols are represented by the following data structure:    struct  protoent {      char  *p_name;       /* official protocol name */      char  **p_aliases;   /* alias list (always NULL for GUSI)*/      int   p_proto;       /* protocol number */    };=over 4=item C<struct protoent * getprotobyname(char * name)> finds a named protocol. This call is rather unexciting.=item C<struct protoent * getprotobynumber(int number)> does the reverse lookup. This call is even less exciting.=backFor OpenTransport TCP/IP sockets, there are a number of C<ioctl> calls toobtain information about the available interfaces.=over 4=item C<SIOCGIFCONF>stores the list of interfaces in the C<struct ifconf> pointed to by the thirdparameter. Note that an entry is created for each alias address.=item C<SIOCGIFADDR>Return the address of the interface named by the C<struct ifreq> pointed to by the third parameter in that structure.=item C<SIOCGIFFLAGS>Return the flags for the interface named by the C<struct ifreq> pointed to by the third parameter in that structure.=item C<SIOCGIFBRDADDR>Return the broadcast address of the interface named by the C<struct ifreq> pointed to by the third parameter in that structure.=item C<SIOCGIFNETMASK>Return the subnet mask of the interface named by the C<struct ifreq> pointed to by the third parameter in that structure.=back=head2 PPC socketsThese provide authenticated stream sockets without out-of-band data. PPC socketsshould work between all networked Macintoshes running System 7 or later, andbetween applications on a single Macintosh running System 7 or later.PPC socket addresses have the following format:    struct sockaddr_ppc {      short             family;     /* Always AF_PPC                     */      LocationNameRec   location;   /* Check your trusty Inside Macintosh  */      PPCPortRec        port;    };In addition, the following behavior in PPC sockets differs from the standard:=over 4=item *C<connect()> will block even if the socket is nonblocking. In practice, however,delays are likely to be quite short, as it never has to block on a higher levelprotocol and the PPC ToolBox will automatically establish the connection.=back