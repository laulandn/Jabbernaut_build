=head1 Threading supportOne of the major features new to C<GUSI> 2 is a fairly complete implementation ofthe POSIX threads API on top of the MacOS thread manager. This section discussesthe thread API, but is not intended to be a comprehensive reference on POSIX threadsin general. Refer to the literature list for good books.=head2 Principles of thread supportC<GUSI> threads are based on cooperative MacOS threads. This means that threadswill never get preempted executing a compute-bound loop. The only conditions underwhich they get preempted are=over 4=item *When they explicitly request a thread switch by calling C<sched_yield()>.=item *When they call any C<GUSI> library routine that does not complete immediately.=backIn practice, the second condition makes GUSI threading appear quite natural, suchthat, especially in code like network servers, explicit yields are rarely necessary.Each thread gets some independent context, including its own stack and its own copies of the C<errno> and C<h_errno> variables. However, all threads share otherresources, including memory, MacOS toolbox elements, and file descriptors.=head2 Thread Data TypesAll thread related data types are opaque. They have no structure known to the publicand are only manipulated through procedure calls.=over 4=item C<pthread_t>A thread identifier.=item C<pthread_attr_t>An object collecting attributes specified at the creation of a thread.=item C<pthread_key_t>An identifier for a piece of thread specific data.=item C<pthread_once_t>A flag registering whether a I<once routine> has already executed or not.=item C<pthread_mutex_t>A mutual exclusion variable.=item C<pthread_mutexattr_t>Creation attributes for a C<pthread_mutex_t>.=item C<pthread_cond_t>A condition variable.=item C<pthread_condattr_t>Creation attributes for a C<pthread_cond_t>.=back=head2 Manipulating Threads=over 4=item C<int pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(*proc)(void *), void *arg)>Create a new thread and make C<th> a reference to it. C<attr> (which can be C<NULL>) specifies creation attributes, C<proc> specifies the code to execute in the thread,and C<arg> is an initial argument to be passed to the code.=item C<pthread_t pthread_self()>Returns the currently executing thread.=item C<int pthread_equal(pthread_t t1, pthread_t t2)>Compares two threads for identity.=item C<int sched_yield()>Yields the CPU to the next eligible thread.=item C<int pthread_join(pthread_t th, void **value)>Wait for the thread to die and return its result if C<value> is not C<NULL>.=item C<int pthread_detach(pthread_t th)>Declare that we will never call C<pthread_join()> for this thread and that it simplyshould go away when done.=item C<int pthread_exit(void *value)>Terminate the current thread, giving the specified return value.=item C<int pthread_attr_init(pthread_attr_t * attr)>Initialize a thread attribute object with the default settings. =item C<int pthread_attr_destroy(pthread_attr_t * attr)>Delete a thread attribute object.=item C<int pthread_attr_setdetachstate(pthread_attr_t * attr, int state)>=item C<int pthread_attr_getdetachstate(pthread_attr_t * attr, int * state)>If C<state> is C<PTHREADS_CREATE_JOINABLE> (the default), C<pthread_join()> should eventually called on the thread. If C<state> is C<PTHREADS_CREATE_DETACHED>, the threadis created detached.=item C<int pthread_attr_setstacksize(pthread_attr_t * attr, size_t size)>=item C<int pthread_attr_getstacksize(pthread_attr_t * attr, size_t * size)>Manipulates the size of the stack allocated for the thread (20K default). Be sure tochoose this size carefully and generously, as stack overflows will lead to nasty crashes.=back=head2 Manipulating Thread Specific DataThread specific data makes it possible to have variables whose value differs from threadto thread. Each piece of thread specific data is identified by a key which has to be allocated once at the beginning of the program.=over 4=item C<int pthread_key_create(pthread_key_t * key, void (*destructor)(void *))>Creates a new key for thread specific data. All existing and new threads initially havea C<NULL> value for this key until C<pthread_setspecific()> is called. When a threadwith a non-C<NULL> value for the key ends, C<destructor> is called with that value asits argument.=item C<int pthread_key_delete(pthread_key_t key)>Deletes a key, but does I<not> call any destructors for it.=item C<int pthread_setspecific(pthread_key_t key, void * value)>=item C<void * pthread_getspecific(pthread_key_t key)>Manipulates the value associated for C<key> in the current thread.=back=head2 Synchronizing ThreadsTwo mechanisms are available to coordinate threads: Mutual exclusion and the more complex condition variables. Furthermore, the I<once> mechanism is available for initialization.=over 4=item C<int pthread_mutex_init(pthread_mutex_t * mutex, const pthread_mutexattr_t * attr)>Initialize a mutex variable dynamically. Alternatively, you can initialize it staticallywith the declaration:	pthread_mutex_t	mut = PTHREAD_MUTEX_INITIALIZER;=item C<int pthread_mutex_destroy(pthread_mutex_t * mutex)>Destroy a mutex.=item C<int pthread_mutex_lock(pthread_mutex_t * mutex)>Lock the mutex. Until this thread calls C<pthread_mutex_unlock>, no other thread will be able to lock this mutex. If the mutex was already locked, block until it becomes available.=item C<int pthread_mutex_trylock(pthread_mutex_t * mutex)>If the mutex is unlocked, lock it. If it is locked, return C<EBUSY>.=item C<int pthread_mutex_unlock(pthread_mutex_t * mutex)>Unlock the mutex and if any other threads were blocking for it, lock it for the first of them.=item C<int pthread_mutexattr_init(pthread_mutexattr_t * attr)>Create a default mutex attribute object. Currently, none of the attributes may be changed.=item C<int pthread_mutexattr_destroy(pthread_mutexattr_t * attr)>Destroy a mutex attribute object.=item C<int pthread_cond_init(pthread_cond_t * cond, const pthread_condattr_t * attr)>Initialize a condition variable. Static initialization is available as	pthread_cond_t cond = PTHREAD_COND_INITIALIZER;=item C<int pthread_cond_destroy(pthread_cond_t * cond)>Destroy a condition variable.=item C<int pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex)>Temporarily unlocks C<mutex> (which must have been locked), wait for an event on thecondition variable, and lock C<mutex> again.=item C<int pthread_cond_timedwait(pthread_cond_t * cond, pthread_mutex_t * mutex, const struct timespec * abstime)>Like C<pthread_cond_wait()>, but only waits for a condition until the absolute time specified by C<abstime>.=item C<int pthread_cond_signal(pthread_cond_t * cond)>Sends an event to the first thread waiting on the condition variable.=item C<int pthread_cond_broadcast(pthread_cond_t * cond)>Sends an event to all threads waiting on the condition variable.=item C<int pthread_condattr_init(pthread_condattr_t * attr)>Create a default condition attribute object. Currently, none of the attributes may be changed.=item C<int pthread_condattr_destroy(pthread_condattr_t * attr)>Destroy a condition attribute object.=item C<int pthread_once(pthread_once_t * once_block, void (*proc)(void))>If the specified C<once_block> hasn't executed yet, execute it. C<once_block> musthave been statially initialized as	pthread_once_t once = PTHREAD_ONCE_INIT;=back