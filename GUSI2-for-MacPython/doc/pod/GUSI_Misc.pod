=head1 Miscellaneous APIs=head2 Timing routinesSince the Metrowerks Standard Library defines C<time_t> from an epoch of 1970,GUSI 2 reimplements C<time()>, C<mktime()>, C<gmtime()>, and C<localtime()> toensure the traditional MacOS behavior.GUSI also implements the following timing-related UNIX 98 APIs:=over 4=item C<u_int sleep(u_int seconds)>Tries to sleep for the specified number of seconds and returns the remainingnumber of seconds if interrupted for any reason.=item C<void usleep(u_int usecs)>Tries to sleep for the specified number of microseconds.=item C<gettimeofday(struct timeval * tv, struct timezone * tz)>Returns time in the same base as C<time()>, but with a higher resolution(theoretically microseconds). If C<tz> is  not C<NULL>, also returnsthe current time zone and DST flag.=back=head2 Signal manipulation routinesGUSI makes some attempt to provide a reasonable emulation of UNIX 98 signal handlingbehavior, specifically:=over 4=item *Most of the signal handling API is supported.=item *GUSI will generate C<SIGALRM> when the C<alarm()> timer runs out, C<SIGPIPE> when writing toa closed socket, and C<SIGINT> when the interrupt key (C<Cmd-.>) is pressed.=item * In a significant departure from UNIX 98 behavior, signals are not delivered asynchronously, but are checked only when a thread is about to yield control by calling a blocking systemcall or C<sched_yield()>.=backAll signal functionality is defined in the F<signal.h> header. The central data structuresfor signal handling are the signal handling function type and the C<sigaction> structure:    typedef void (*__sig_handler)(int);    struct	sigaction {       __sig_handler sa_handler;  /* signal handler */       sigset_t      sa_mask;     /* signal mask to apply */       int           sa_flags;    /* see signal options below */    };When a signal is raised, the following happens:=over 4=item *The signals specified in C<sa_mask> are blocked. Furthermore, the siganl currentlyraised is also blocked unless C<SA_RESETHAND> or C<SA_NODEFER> are set in C<sa_flags>.=item *The signal handler specified in C<sa_handler> is executed, and if C<SA_RESETHAND> is setin C<sa_flags>, the signal handler is reset to C<SIG_DFL> just before executing thehandler.=item * If a "slow" system call, i.e., a call that can take an indefinite time to complete, suchas a read call on a socket, is executing, that call is interrupted unless C<SA_RESTART>is set in C<sa_flags>.=backThe following functions are supported:=over 4=item C<int	sigaddset(sigset_t * set, int signo)>Adds a signal to a signal set.=item C<int	sigdelset(sigset_t * set, int signo)>Deletes a signal from a signal set.=item C<int	sigemptyset(sigset_t * set)>Sets a signal set to the empty set.=item C<int	sigfillset(sigset_t * set)>Sets a signal set to the set containing all signals.=item C<int	sigismember(const sigset_t * set, int signo)>Tests if a signal is a member of the set.=item C<int	sigaction(int signo, const struct sigaction * act, struct sigaction * oact)>Gets and/or sets handling behavior for a signal. If C<act> is not C<NULL>, sets the newbehavior. If C<oact> is not C<NULL>, returns the previous behavior. =item C<__sig_handler signal(int signo, __sig_handler handler)>The historical interface to signal handling, equivalent to C<sigaction> with an empty C<sa_mask> and C<SA_RESETHAND> set.=item C<int raise(int signo)>Sends a signal to a process. It will be delivered to the first thread that hasn't blocked it.=item C<int	sigpending(sigset_t * set)>Returns the set of signals pending in the process or the calling thread that are blocked fromdelivery.=item C<int	sigprocmask(int how, const sigset_t * set, sigset_t * oset)>Manipulates the mask of signals to be blocked from delivery in the process. If C<set> isnot C<NULL>, the mask is changed depending on the C<how> parameter:=over 4=item C<SIG_BLOCK> The mask is set to the union of its current value and C<set>.=item C<SIG_SETMASK>The mask is set to C<set>.=item C<SIG_UNBLOCK>The mask is set to the intersection of its current value and the complement of C<set>.=backIf C<oset> is not null, it is set to the previous value of the process mask. In a multithreaded program, the behavior of C<sigprocmask> is undefined in UNIX 98. GUSIdefines this case to do the same as C<pthread_sigmask>.=item C<int	sigsuspend(const sigset_t * set)>Temporarily replace the signal mask by C<set> and then suspend execution until a signal is delivered.=item C<int sigwait(const sigset_t * set, int * signo)>Waits for a signal in C<set> to become pending, then clears it and returns its number in C<signo>. All signals in C<set> have to be blocked in the calling thread.=item C<int pthread_kill(pthread_t thread, int signo)>Sends a signal to a specific thread (waking it up if it was asleep).=item C<int pthread_sigmask(int how, const sigset_t * set, sigset_t * oset)>Manipulates the signal mask for a thread similar to the way that C<sigprocset> manipulates signal masks in the singlethreaded case.=item C<void abort()>Raises C<SIGABRT> and quits the process.=item C<unsigned int alarm(unsigned int delay)>If C<delay> is not C<0>, arranges to have C<SIGALRM> generated after the number of secondsspecified. Returns the number of seconds that would have remained in the previous callto C<alarm>.=item C<useconds_t ualarm(useconds_t delay, useconds_t interval)>Similar to C<alarm>, but manipulates times specified in microseconds. If C<interval> isnot C<0>, generates regular instances of C<SIGALRM> spaced at C<interval> microseconds.=back=head2 BSD memory routinesIf you    #include <compat.h>the following routines will be available as macros:=over 4=item C<void bzero(void * from, int len)> zeroes C<len> bytes, starting at C<from>.=item C<void bfill(void * from, int len, int x)> fills C<len> bytes, starting at C<from>, with C<x>.=item C<void bcopy(void * from, void * to, int len)> copies C<len> bytes from C<from> to C<to>.=item C<int bcmp(void * s1, void * s2, int len)> compares C<len> bytes at C<s1> against C<len> bytes at C<s2>, returning zero if the two areas are equal, nonzero otherwise.=back=head2 HooksYou can override some of GUSI's behaviour by providing hooks to GUSI. Note that theseoften get called from deep within GUSI, so be sure you understand what is requiredof a hook before overriding it.GUSI hooks can be accessed with the following routines:    typedef void (*GUSIHook)(void);    void GUSISetHook(GUSIHookCode code, GUSIHook hook);    GUSIHook GUSIGetHook(GUSIHookCode code);Currently, three types of hooks are defined. =over 4=item C<GUSI_SpinHook>This hook is called when the main thread in the GUSI application wants to yield control. To provide your own hook, call	GUSISetHook(GUSI_SpinHook, (GUSIHook) my_spin_hook);where C<my_spin_hook> is defined as	void my_spin_hook(bool wait)where C<wait> is C<false> if the thread has more work to do immediately and just wants to yield control as a courtesy, and C<true> if the thread is blocked foran indefinite time. Specifying a C<GUSI_SpinHook> disables the C<GUSI_EventHook>handling described below unless you call C<GUSIHandleNextEvent(bool wait)>.=item C<GUSI_EventHook>If no C<GUSI_SpinHook> is specified, C<GUSI> calls C<WaitNextEvent()> accordingto rules established by calling C<GUSIEventHook+eventCode> as follows:=over 4=item AppleEvents are always enabled and processed, unless you call	GUSISetHook(GUSI_EventHook+kHighLevelEvent, (GUSIHook) -1);=item Mouse down events are enabled unless you call	GUSISetHook(GUSI_EventHook+mouseDown, (GUSIHook) -1);only system clicks are processed unless you call	GUSISetHook(GUSI_EventHook+mouseDown, (GUSIHook) my_mousedown_handler);where C<my_mousedown_handler> is declared as	void my_mousedown_handler(EventRecord * ev)	and should handle both system and application clicks.=item All other events are disabled unless you specify handlers for them.=back=item C<GUSI_ExecHook>This hook is used by GUSI to decide whether a fileor folder is to be considered "executable" or not. The default hook considersall folders and all applications (i.e., files of type C<'APPL'> and C<'appe'> tobe executable. To provide your own hook, call    GUSISetHook(GUSI_ExecHook, (GUSIHook) my_exec_hook);where C<my_exec_hook> is defined as    Boolean my_exec_hook(const GUSIFileRef & ref);=back=head2 ResourcesB<The information in this section is likely to change in the near future>.On startup, C<GUSI> looks for a I<preference> resource with type C<'GUZI'> (the C<'Z'> actually must be a capital Sigma) and ID C<GUSIRsrcID>, which is currently defined as follows:   #ifndef GUSI_PREF_VERSION   #define GUSI_PREF_VERSION '0102'   #endif   type 'GUZI' {      literal longint   text  =  'TEXT';  /* Type for creat'ed files             */      literal longint   mpw   =  'MPS ';  /* Creator for creat'ed files          */      byte     noAutoSpin, autoSpin;      /* Automatically spin cursor ?         */   #if GUSI_PREF_VERSION >= '0110'      boolean  useChdir, dontUseChdir;    /* Use chdir() ?                    */      boolean  approxStat, accurateStat;  /* statbuf.st_nlink = # of subdirectories ? */      boolean  noTCPDaemon, isTCPDaemon;  /* Inetd client ?                   */      boolean  noUDPDaemon, isUDPDaemon;   #if GUSI_PREF_VERSION >= '0150'      boolean  noConsole, hasConsole;     /* Are we providing our own dev:console ? */   #if GUSI_PREF_VERSION >= '0180'      boolean   autoInitGraf, noAutoInitGraf;   /* Automatically do InitGraf ? */      boolean   exclusiveOpen, sharedOpen;  /* Shared open() ?                          */      boolean   noSigPipe, sigPipe;         /* raise SIGPIPE on write to closed PIPE */   #else      fill      bit[3];   #endif   #else      fill      bit[4];   #endif      literal longint = GUSI_PREF_VERSION;   #if GUSI_PREF_VERSION >= '0120'      integer = @t$$@>Countof(SuffixArray);      wide array SuffixArray {            literal longint;              /* Suffix of file */            literal longint;              /* Type for file */            literal longint;              /* Creator for file */      };   #endif   #endif   };To keep backwards compatible, the preference version is included, and you are free touse whatever version of the preferences you want by defining C<GUSI_PREF_VERSION>.The first two fields define the file type and creator, respectively, to be used for files created by C<GUSI>. The type and creator of existing files will neverbe changed unless explicitely requested with fsetfileinfo(). The default is tocreate text files (type `TEXT') owned by the C<MPW Shell> (creator `MPS '). If yourequest a preference version of 1.2.0 and higher, you are also allowed to specifya list of suffixes that are given different types. An example of such a list would be:    { 'SYM ', 'MPSY', 'sade'  }The C<autoSpin> value, if nonzero, makes C<GUSI> call the spin routine for everycall to C<read()>, C<write()>, C<send()>, or C<recv()>. This is useful for making an I/O bound program MultiFinder friendly without having to insert explicit callsto C<SpinCursor()>. If you don't specify a preference resource, C<autoSpin> is assumedto be C<1>. You may specify arbitrary values greater than one to make your programeven friendlier; note, however, that this will hurt performance.The C<useChdir> flag tells C<GUSI> whether you change directories with the toolbox calls C<PBSetVol()> or C<PBHSetVol()> or with the C<GUSI> call C<chdir()>.The current directory will start with the directory your application resides in or the current C<MPW> directory, if you're running an C<MPW> tool.If C<useChdir> is specified, the current directory will only change with C<chdir()> calls. If C<dontUseChdir> is specified, the current directory will change with toolbox calls, until you call C<chdir()> the first time. This behaviour is moreconsistent with the standard C<MPW> library, but has IMHO no other redeemingvalue. If you don't specify a preference resource, C<useChdir> is assumed.If C<approxStat> is specified, C<stat()> and C<lstat()> for directories return inC<st_nlink> the number of I<items> in the directory C<+ 2>. If C<accurateStat> isspecified, they return the number of I<subdirectories> in the directory. Thelatter has probably the best chances of being compatible with some Unix software,but the former is often a sufficient upper bound, is much faster, and most programsdon't care about this value anyway. If you don't specify a preference resource, C<approxStat> is assumed.The C<isTCPDaemon> and C<isUDPDaemon> flags turn C<GUSI> programs into clientsfor David Petersons C<inetd>, as discussed below. If you don't specify a preferenceresource, C<noTCPDaemon> and C<noUDPDaemon> are assumed.The C<hasConsole> flag should be set if you are overriding the default "dev:console",as discussed below.C<GUSI> by default spins the cursor to indicate progress, and this will crashunless QuickDraw is initialized. While previous versions of GUSI requiredexplicit Toolbox initialization, versions 1.8.0 and later will detect thatQuickDraw is uninitialized and call InitGraf before spinning. To disablethat behavior, set the C<noAutoInitGraf> flag.By default, C<GUSI> opens files with I<exclusive> read/write permissions. Ifyou are sure you can deal with the consequences, you can request I<shared>permissions by specifying the C<sharedOpen> flag.If a C<GUSI> client attempts to read from a socket that was closed from the otherside, an error code will be returned. As of version 1.8.0, you can specify theC<sigPipe> flag to request that a C<SIGPIPE> signal be raised additionally.