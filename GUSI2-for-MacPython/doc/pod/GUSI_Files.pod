=head1 File system callsFiles are unlike sockets in many respects: They can be rewound and re-read severaltimes. C<write()> calls can directly influence the results of subsequent C<read()>calls. There are also many calls which are specific to files.=head2 Differences to generic behavior=over 4=item *The following calls make no sense for files and return an error of C<EOPNOTSUPP>:    socket()    bind()    listen()    accept()    connect()    getsockname()    getpeername()=item *The following calls I<will> work, but might be frowned upon by your friends(besides, UNIX systems generally wouldn't like them):    recv()    recvfrom()    recvmsg()    send()    sendto()    sendmsg()=back=head2 Routines specific to the file systemIn this section, you'll meet lots of good old friends. Some of these routines alsoexist in the standard compiler libraries, but the C<GUSI> versions have a few differences:=over 4=item *File names are relative to the directory specified by chdir().=item *You can define special treatment for some file names (See below under "Adding your own file families").=back=over 4=item C<int stat(const char * path, struct stat * buf)> returns information about a file. C<struct stat> is defined as follows:    struct stat   {      dev_t    st_dev;     /* Volume reference number of file  */      ino_t    st_ino;     /* File or directory ID             */      u_short  st_mode;    /* Type and permission of file      */      short    st_nlink;   /* Always 1             */      short    st_uid;     /* Set to 0             */      short    st_gid;     /* Set to 0             */      dev_t    st_rdev;    /* Set to 0             */      off_t    st_size;      time_t   st_atime;   /* Set to st_mtime    */      time_t   st_mtime;      time_t   st_ctime;      long     st_blksize;      long     st_blocks;    };C<st_mode> is composed of a file type and of file permissions. The file typemay be one of the following:=over 4=item C<S_IFREG>A regular file.=item C<S_IFDIR>A directory.=item C<S_IFLNK>A finder alias file.=item C<S_IFCHR>A console file.=item C<S_IFSOCK>A file representing a UNIX domain socket.=backPermissions consist of an octal digit repeated three times. The three bitsin the digit have the following meaning:=over 4=item C<4>File can be read.=item C<2>File can be written.=item C<1>File can be executed, i.e., its type is `APPL' or 'appe'. The definition of executabilitycan be customized with the C<GUSI_ExecHook> discussed in the advanced section.=back=item C<int lstat(const char * path, struct stat * buf)> works just like C<stat()>, but if C<path>is a symbolic link, C<lstat()> will return information about the link and not aboutthe file it points to.=item C<int fstat(int fd, struct stat * buf)> is the equivalent of C<stat()> for descriptors representing open files. While it is legal to call C<fstat()> for sockets, theinformation returned is not really interesting. The file type in C<st_mode> will be C<S_IFSOCK> for sockets.=item C<int chmod(const char * filename, mode_t mode)> changes the mode returned by C<stat()>. Currently,the only thing you can do with C<chmod()> is to turn the write permission off and on. Thisis translated to setting and clearing the file lock bit.=ittem C<int utime(const char * file, const struct utimbuf * tim)> changes the modification timeof a file. C<struct utimbuf> is defined as:    struct utimbuf {      time_t actime;       /* Access time */      time_t modtime;      /* Modification time */    };C<actime> is ignored, as the Macintosh doesn't store access times. The modificationof C<file> is set to C<modtime>.=item C<int isatty(int fd)> returns C<1> if C<fd> represents a terminal (i.e. is connectedto C<"Dev:Stdin"> and the like), C<0> otherwise.=item C<long lseek(int, long, int)> changes the read/write position in an open file, and will return C<ESPIPE> if called for a socket. If C<lseek()> sets the position beyond EOF, the gap will befilled with 0 bytes if a C<write()> is subsequently called at the position.=item C<int remove(const char *filename)> removes the named file. If C<filename> is a symbolic link, the link will be removed and not the file.=item C<int unlink(const char *filename)> is identical to C<remove()>. =item C<int rename(const char *oldname, const char *newname)> renames and/or moves a file. C<oldname> and C<newname> must specify the same volume, but they may specify different folders.=item C<int open(const char*, int flags, ...)> opens a named file. The C<flags> consistof one of the following modes:=over 4=item C<O_RDONLY>Open for reading only.=item C<O_WRONLY>Open for writing only.=item C<O_RDWR>Open for reading and writing.=backOptionally combined with one or more of:=over 4=item C<O_APPEND>The file pointer is set to the end of the file before each write.=item C<O_RSRC>Open resource fork.=item C<O_CREAT>If the file does not exist, it is created.=item C<O_EXCL>In combination with C<O_CREAT>, return an error if file already exists.=item C<O_TRUNC>If the file exists, its length is truncated to 0; the mode is unchanged.=item C<O_ALIAS>If the named file is a symbolic link, open the link, not the file it pointsto (This is most likely an incredibly bad idea).=back=item C<int creat(const char * name)> is identical to C<open(name, O_WRONLY+O_TRUNC+O_CREAT)>. If the file didn't existbefore, C<GUSI> determines its file type and creator of the according to rulesoutlined in the section "Resources" below.=item C<int faccess(const char *filename, unsigned int cmd, long *arg)> works the same as the corresponding C<MPW> routine, but respects calls toC<chdir()> for partial filenames.=item C<void fgetfileinfo(char *filename, unsigned long *newcreator, unsigned long *newtype)>returns the file type and creator of a file.=item C<void fsetfileinfo(char *filename, unsigned long newcreator, unsigned long newtype)>sets the file type and creator of a file to the given values.=item C<int symlink(const char* linkto, const char* linkname)> creates a file named C<linkname> that contains an alias resource pointing to C<linkto>. The created file should be indistinguishible from an alias file createdby the System 7 Finder. Note that aliases bear only superficial resemblances toC<UNIX> symbolic links, especially once you start renaming files.=item C<int readlink(const char* path, char* buf, int bufsiz)> returns in C<buf> the name of the file that C<path> points to.=item C<int truncate(const char * path, off_t length)> causes a file to have a size equal to C<length> bytes, shortening it or extendingit with zero bytes as necessary.=item C<int ftruncate(int fd, off_t length)> does the same thing with an open file.=item C<int access(const char * path, int mode)> tests if you have the specified access  rights to a file. C<mode> may be eitherC<F_OK>, in which case the file is tested for existence, or a combination of thefollowing:=over 4=item C<R_OK>Tests if file is readable.=item C<W_OK>Tests if file is writeable.=item C<X_OK>Tests if file is executable. As with C<stat()>, the definition of executabilitymay be customized.=backC<access()> returns 0 if the specified access rights exist, otherwise it sets C<errno> and returns -1.=item C<int mkdir(const char * path, ...)> creates a new directory.=item C<int rmdir(const char * path)> deletes an empty directory.=item C<int chdir(const char * path)> makes all future partial pathnames relative to thisdirectory.=item C<char * getcwd(const char * buf, int size)> returns a pointer to the current directory pathname. If C<buf> is C<NULL>, C<size> bytes will be allocated using C<malloc()>.Error codes:=over 4=item C<ENAMETOOLONG>The pathname of the current directory is greater than C<size>.=item C<ENOMEM>C<buf> was C<NULL> and C<malloc()> failed.=back=backA number of calls facilitate scanning directories. Directory entries are represented by following structure:    struct dirent {      ino_t    d_ino;      			/* file number of entry */    #define MAXNAMLEN   255      char  d_name[MAXNAMLEN + 1];  /* name must be no longer than this */    };=over 4=item C<DIR * opendir(const char * dirname)> opens a directory stream and returns a pointer or C<NULL> if the call failed.=item C<struct dirent * readdir(DIR * dirp)> returns the next entry from the directory or C<NULL> if all entries have been processed.=item C<long telldir(const DIR * dirp)> returns the position in the directory.=item C<void seekdir(DIR * dirp, long loc)> changes the position.=item C<void rewinddir(DIR * dirp)> restarts a scan at the beginning.=item C<int closedir(DIR * dirp)> closes the directory stream.=back